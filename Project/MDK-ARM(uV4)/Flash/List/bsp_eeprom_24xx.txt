; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_eeprom_24xx.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_eeprom_24xx.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_eeprom_24xx.crf ..\..\User\bsp\src\bsp_eeprom_24xx.c]
                          THUMB

                          AREA ||i.ee_CheckOk||, CODE, READONLY, ALIGN=1

                  ee_CheckOk PROC
;;;31     */
;;;32     uint8_t ee_CheckOk(void)
000000  b510              PUSH     {r4,lr}
;;;33     {
;;;34     	if (i2c_CheckDevice(EE_DEV_ADDR) == 0)
000002  20a0              MOVS     r0,#0xa0
000004  f7fffffe          BL       i2c_CheckDevice
000008  b118              CBZ      r0,|L1.18|
;;;35     	{
;;;36     		return 1;
;;;37     	}
;;;38     	else
;;;39     	{
;;;40     		/* 失败后，切记发送I2C总线停止信号 */
;;;41     		i2c_Stop();
00000a  f7fffffe          BL       i2c_Stop
;;;42     		return 0;
00000e  2000              MOVS     r0,#0
;;;43     	}
;;;44     }
000010  bd10              POP      {r4,pc}
                  |L1.18|
000012  2001              MOVS     r0,#1                 ;36
000014  bd10              POP      {r4,pc}
;;;45     
                          ENDP


                          AREA ||i.ee_ReadBytes||, CODE, READONLY, ALIGN=2

                  ee_ReadBytes PROC
;;;56     */
;;;57     uint8_t ee_ReadBytes(uint8_t *_pReadBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;58     {
000004  4615              MOV      r5,r2
000006  460c              MOV      r4,r1
000008  4606              MOV      r6,r0
;;;59     	uint16_t i;
;;;60     
;;;61     	/* 采用串行EEPROM随即读取指令序列，连续读取若干字节 */
;;;62     
;;;63     	/* 第1步：发起I2C总线启动信号 */
;;;64     	i2c_Start();
00000a  f7fffffe          BL       i2c_Start
;;;65     
;;;66     	/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;67     	i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
00000e  20a0              MOVS     r0,#0xa0
000010  f7fffffe          BL       i2c_SendByte
;;;68     
;;;69     	/* 第3步：发送ACK */
;;;70     	if (i2c_WaitAck() != 0)
000014  f7fffffe          BL       i2c_WaitAck
000018  b998              CBNZ     r0,|L2.66|
;;;71     	{
;;;72     		goto cmd_fail;	/* EEPROM器件无应答 */
;;;73     	}
;;;74     
;;;75     	/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;76     	if (EE_ADDR_BYTES == 1)
;;;77     	{
;;;78     		i2c_SendByte((uint8_t)_usAddress);
;;;79     		if (i2c_WaitAck() != 0)
;;;80     		{
;;;81     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;82     		}
;;;83     	}
;;;84     	else
;;;85     	{
;;;86     		i2c_SendByte(_usAddress >> 8);
00001a  0a20              LSRS     r0,r4,#8
00001c  f7fffffe          BL       i2c_SendByte
;;;87     		if (i2c_WaitAck() != 0)
000020  f7fffffe          BL       i2c_WaitAck
000024  b968              CBNZ     r0,|L2.66|
;;;88     		{
;;;89     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;90     		}
;;;91     
;;;92     		i2c_SendByte(_usAddress);
000026  b2e0              UXTB     r0,r4
000028  f7fffffe          BL       i2c_SendByte
;;;93     		if (i2c_WaitAck() != 0)
00002c  f7fffffe          BL       i2c_WaitAck
000030  b938              CBNZ     r0,|L2.66|
;;;94     		{
;;;95     			goto cmd_fail;	/* EEPROM器件无应答 */
;;;96     		}
;;;97     	}
;;;98     
;;;99     	/* 第6步：重新启动I2C总线。下面开始读取数据 */
;;;100    	i2c_Start();
000032  f7fffffe          BL       i2c_Start
;;;101    
;;;102    	/* 第7步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;103    	i2c_SendByte(EE_DEV_ADDR | I2C_RD);	/* 此处是读指令 */
000036  20a1              MOVS     r0,#0xa1
000038  f7fffffe          BL       i2c_SendByte
;;;104    
;;;105    	/* 第8步：发送ACK */
;;;106    	if (i2c_WaitAck() != 0)
00003c  f7fffffe          BL       i2c_WaitAck
000040  b120              CBZ      r0,|L2.76|
                  |L2.66|
;;;107    	{
;;;108    		goto cmd_fail;	/* EEPROM器件无应答 */
;;;109    	}
;;;110    
;;;111    	/* 第9步：循环读取数据 */
;;;112    	for (i = 0; i < _usSize; i++)
;;;113    	{
;;;114    		_pReadBuf[i] = i2c_ReadByte();	/* 读1个字节 */
;;;115    
;;;116    		/* 每读完1个字节后，需要发送Ack， 最后一个字节不需要Ack，发Nack */
;;;117    		if (i != _usSize - 1)
;;;118    		{
;;;119    			i2c_Ack();	/* 中间字节读完后，CPU产生ACK信号(驱动SDA = 0) */
;;;120    		}
;;;121    		else
;;;122    		{
;;;123    			i2c_NAck();	/* 最后1个字节读完后，CPU产生NACK信号(驱动SDA = 1) */
;;;124    		}
;;;125    	}
;;;126    	/* 发送I2C总线停止信号 */
;;;127    	i2c_Stop();
;;;128    	return 1;	/* 执行成功 */
;;;129    
;;;130    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;131    	/* 发送I2C总线停止信号 */
;;;132    	i2c_Stop();
000042  f7fffffe          BL       i2c_Stop
;;;133    	return 0;
000046  2000              MOVS     r0,#0
                  |L2.72|
;;;134    }
000048  e8bd81f0          POP      {r4-r8,pc}
                  |L2.76|
00004c  2400              MOVS     r4,#0                 ;112
00004e  1e6f              SUBS     r7,r5,#1              ;117
000050  e00c              B        |L2.108|
000052  bf00              NOP                            ;114
                  |L2.84|
000054  f7fffffe          BL       i2c_ReadByte
000058  5530              STRB     r0,[r6,r4]            ;114
00005a  42bc              CMP      r4,r7                 ;117
00005c  d002              BEQ      |L2.100|
00005e  f7fffffe          BL       i2c_Ack
000062  e001              B        |L2.104|
                  |L2.100|
000064  f7fffffe          BL       i2c_NAck
                  |L2.104|
000068  1c64              ADDS     r4,r4,#1              ;123
00006a  b2a4              UXTH     r4,r4                 ;112
                  |L2.108|
00006c  42ac              CMP      r4,r5                 ;112
00006e  d3f1              BCC      |L2.84|
000070  f7fffffe          BL       i2c_Stop
000074  2001              MOVS     r0,#1                 ;128
000076  e7e7              B        |L2.72|
;;;135    
                          ENDP


                          AREA ||i.ee_WriteBytes||, CODE, READONLY, ALIGN=2

                  ee_WriteBytes PROC
;;;145    */
;;;146    uint8_t ee_WriteBytes(uint8_t *_pWriteBuf, uint16_t _usAddress, uint16_t _usSize)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;147    {
000004  4617              MOV      r7,r2
000006  4681              MOV      r9,r0
;;;148    	uint16_t i,m;
;;;149    	uint16_t usAddr;
;;;150    
;;;151    	/*
;;;152    		写串行EEPROM不像读操作可以连续读取很多字节，每次写操作只能在同一个page。
;;;153    		对于24xx02，page size = 8
;;;154    		简单的处理方法为：按字节写操作模式，每写1个字节，都发送地址
;;;155    		为了提高连续写的效率: 本函数采用page wirte操作。
;;;156    	*/
;;;157    
;;;158    	usAddr = _usAddress;
000008  460c              MOV      r4,r1
;;;159    	for (i = 0; i < _usSize; i++)
00000a  2500              MOVS     r5,#0
;;;160    	{
;;;161    		/* 当发送第1个字节或是页面首地址时，需要重新发起启动信号和地址 */
;;;162    		if ((i == 0) || (usAddr & (EE_PAGE_SIZE - 1)) == 0)
;;;163    		{
;;;164    			/*　第０步：发停止信号，启动内部写操作　*/
;;;165    			i2c_Stop();
;;;166    
;;;167    			/* 通过检查器件应答的方式，判断内部写操作是否完成, 一般小于 10ms
;;;168    				CLK频率为200KHz时，查询次数为30次左右
;;;169    			*/
;;;170    			for (m = 0; m < 1000; m++)
00000c  f44f787a          MOV      r8,#0x3e8
000010  e030              B        |L3.116|
                  |L3.18|
000012  b10d              CBZ      r5,|L3.24|
000014  06a0              LSLS     r0,r4,#26             ;162
000016  d11d              BNE      |L3.84|
                  |L3.24|
000018  f7fffffe          BL       i2c_Stop
00001c  f05f0600          MOVS.W   r6,#0
                  |L3.32|
;;;171    			{
;;;172    				/* 第1步：发起I2C总线启动信号 */
;;;173    				i2c_Start();
000020  f7fffffe          BL       i2c_Start
;;;174    
;;;175    				/* 第2步：发起控制字节，高7bit是地址，bit0是读写控制位，0表示写，1表示读 */
;;;176    				i2c_SendByte(EE_DEV_ADDR | I2C_WR);	/* 此处是写指令 */
000024  20a0              MOVS     r0,#0xa0
000026  f7fffffe          BL       i2c_SendByte
;;;177    
;;;178    				/* 第3步：发送一个时钟，判断器件是否正确应答 */
;;;179    				if (i2c_WaitAck() == 0)
00002a  f7fffffe          BL       i2c_WaitAck
00002e  b118              CBZ      r0,|L3.56|
000030  1c76              ADDS     r6,r6,#1
000032  b2b6              UXTH     r6,r6                 ;170
000034  4546              CMP      r6,r8                 ;170
000036  d3f3              BCC      |L3.32|
                  |L3.56|
;;;180    				{
;;;181    					break;
;;;182    				}
;;;183    			}
;;;184    			if (m  == 1000)
000038  4546              CMP      r6,r8
00003a  d012              BEQ      |L3.98|
;;;185    			{
;;;186    				goto cmd_fail;	/* EEPROM器件写超时 */
;;;187    			}
;;;188    
;;;189    			/* 第4步：发送字节地址，24C02只有256字节，因此1个字节就够了，如果是24C04以上，那么此处需要连发多个地址 */
;;;190    			if (EE_ADDR_BYTES == 1)
;;;191    			{
;;;192    				i2c_SendByte((uint8_t)usAddr);
;;;193    				if (i2c_WaitAck() != 0)
;;;194    				{
;;;195    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;196    				}
;;;197    			}
;;;198    			else
;;;199    			{
;;;200    				i2c_SendByte(usAddr >> 8);
00003c  0a20              LSRS     r0,r4,#8
00003e  f7fffffe          BL       i2c_SendByte
;;;201    				if (i2c_WaitAck() != 0)
000042  f7fffffe          BL       i2c_WaitAck
000046  b960              CBNZ     r0,|L3.98|
;;;202    				{
;;;203    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;204    				}
;;;205    
;;;206    				i2c_SendByte(usAddr);
000048  b2e0              UXTB     r0,r4
00004a  f7fffffe          BL       i2c_SendByte
;;;207    				if (i2c_WaitAck() != 0)
00004e  f7fffffe          BL       i2c_WaitAck
000052  b930              CBNZ     r0,|L3.98|
                  |L3.84|
;;;208    				{
;;;209    					goto cmd_fail;	/* EEPROM器件无应答 */
;;;210    				}
;;;211    			}
;;;212    		}
;;;213    
;;;214    		/* 第6步：开始写入数据 */
;;;215    		i2c_SendByte(_pWriteBuf[i]);
000054  f8190005          LDRB     r0,[r9,r5]
000058  f7fffffe          BL       i2c_SendByte
;;;216    
;;;217    		/* 第7步：发送ACK */
;;;218    		if (i2c_WaitAck() != 0)
00005c  f7fffffe          BL       i2c_WaitAck
000060  b120              CBZ      r0,|L3.108|
                  |L3.98|
;;;219    		{
;;;220    			goto cmd_fail;	/* EEPROM器件无应答 */
;;;221    		}
;;;222    
;;;223    		usAddr++;	/* 地址增1 */
;;;224    	}
;;;225    
;;;226    	/* 命令执行成功，发送I2C总线停止信号 */
;;;227    	i2c_Stop();
;;;228    	return 1;
;;;229    
;;;230    cmd_fail: /* 命令执行失败后，切记发送停止信号，避免影响I2C总线上其他设备 */
;;;231    	/* 发送I2C总线停止信号 */
;;;232    	i2c_Stop();
000062  f7fffffe          BL       i2c_Stop
;;;233    	return 0;
000066  2000              MOVS     r0,#0
                  |L3.104|
;;;234    }
000068  e8bd87f0          POP      {r4-r10,pc}
                  |L3.108|
00006c  1c64              ADDS     r4,r4,#1
00006e  1c6d              ADDS     r5,r5,#1              ;223
000070  b2a4              UXTH     r4,r4                 ;223
000072  b2ad              UXTH     r5,r5                 ;159
                  |L3.116|
000074  42bd              CMP      r5,r7                 ;159
000076  d3cc              BCC      |L3.18|
000078  f7fffffe          BL       i2c_Stop
00007c  2001              MOVS     r0,#1                 ;228
00007e  e7f3              B        |L3.104|
;;;235    
                          ENDP


;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_eeprom_24xx.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH|
#line 128
|__asm___17_bsp_eeprom_24xx_c_4eb00f1b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
