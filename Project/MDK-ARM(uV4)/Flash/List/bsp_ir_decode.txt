; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ir_decode.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ir_decode.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_ir_decode.crf ..\..\User\bsp\src\bsp_ir_decode.c]
                          THUMB

                          AREA ||i.IRD_DecodeNec||, CODE, READONLY, ALIGN=2

                  IRD_DecodeNec PROC
;;;125    */
;;;126    void IRD_DecodeNec(uint16_t _width)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;127    {
;;;128    	static uint16_t s_LowWidth;
;;;129    	static uint8_t s_Byte;
;;;130    	static uint8_t s_Bit;
;;;131    	uint16_t TotalWitdh;
;;;132    	
;;;133    	/* NEC 格式 （5段）
;;;134    		1、引导码  9ms低 + 4.5ms高
;;;135    		2、低8位地址码  0=1.125ms  1=2.25ms    bit0先传
;;;136    		3、高8位地址码  0=1.125ms  1=2.25ms
;;;137    		4、8位数据      0=1.125ms  1=2.25ms
;;;138    		5、8为数码反码  0=1.125ms  1=2.25ms
;;;139    	*/
;;;140    
;;;141    loop1:	
;;;142    	//bsp_LedToggle(1);		//for DEBUG 观测是否能够给在两个边沿触发捕获中断
;;;143    	switch (g_tIR.Status)
000004  4c3f              LDR      r4,|L1.260|
000006  2702              MOVS     r7,#2
;;;144    	{
;;;145    		case 0:			/* 929 等待引导码低信号  7ms - 11ms */
;;;146    			if ((_width > 700) && (_width < 1100))
;;;147    			{
;;;148    				g_tIR.Status = 1;
;;;149    				s_Byte = 0;
000008  493f              LDR      r1,|L1.264|
;;;150    				s_Bit = 0;
;;;151    			}
;;;152    			else
;;;153    			{
;;;154    				static uint8_t sss = 0;
;;;155    				
;;;156    				if (sss == 0)
;;;157    				{
;;;158    					sss = 1;
;;;159    				}
;;;160    				else if (sss == 1)
;;;161    				{
;;;162    					sss = 2;
;;;163    				}				
;;;164    			}
;;;165    			break;
;;;166    
;;;167    		case 1:			/* 413 判断引导码高信号  3ms - 6ms */
;;;168    			if ((_width > 313) && (_width < 600))	/* 引导码 4.5ms */
;;;169    			{
;;;170    				g_tIR.Status = 2;
;;;171    			}
;;;172    			else if ((_width > 150) && (_width < 250))	/* 2.25ms */
;;;173    			{
;;;174    				#ifdef IR_REPEAT_SEND_EN				
;;;175    					if (g_tIR.RepeatCount >= IR_REPEAT_FILTER)
;;;176    					{
;;;177    						bsp_PutKey(g_tIR.RxBuf[2] + IR_KEY_STRAT);	/* 连发码 */
00000a  7962              LDRB     r2,[r4,#5]
00000c  2500              MOVS     r5,#0                 ;149
00000e  4613              MOV      r3,r2
;;;178    					}
;;;179    					else
;;;180    					{
;;;181    						g_tIR.RepeatCount++;
;;;182    					}
;;;183    				#endif
;;;184    				g_tIR.Status = 0;	/* 复位解码状态 */
;;;185    			}
;;;186    			else
;;;187    			{
;;;188    				/* 异常脉宽 */
;;;189    				g_tIR.Status = 0;	/* 复位解码状态 */
;;;190    			}
;;;191    			break;
;;;192    		
;;;193    		case 2:			/* 低电平期间 0.56ms */
;;;194    			if ((_width > 10) && (_width < 100))
000010  f1a0060b          SUB      r6,r0,#0xb
000014  f1120280          ADDS.W   r2,r2,#0x80           ;149
                  |L1.24|
000018  f894c002          LDRB     r12,[r4,#2]           ;143  ; g_tIR
00001c  f1bc0f00          CMP      r12,#0                ;143
000020  d02d              BEQ      |L1.126|
000022  f1bc0f01          CMP      r12,#1                ;143
000026  d03d              BEQ      |L1.164|
000028  f1bc0f02          CMP      r12,#2                ;143
00002c  d04c              BEQ      |L1.200|
00002e  f1bc0f03          CMP      r12,#3                ;143
000032  d12d              BNE      |L1.144|
;;;195    			{		
;;;196    				g_tIR.Status = 3;
;;;197    				s_LowWidth = _width;	/* 保存低电平宽度 */
;;;198    			}
;;;199    			else	/* 异常脉宽 */
;;;200    			{
;;;201    				/* 异常脉宽 */
;;;202    				g_tIR.Status = 0;	/* 复位解码器状态 */	
;;;203    				goto loop1;		/* 继续判断同步信号 */
;;;204    			}
;;;205    			break;
;;;206    
;;;207    		case 3:			/* 85+25, 64+157 开始连续解码32bit */						
;;;208    			TotalWitdh = s_LowWidth + _width;
000034  f8b1c004          LDRH     r12,[r1,#4]  ; s_LowWidth
000038  4484              ADD      r12,r12,r0
00003a  fa1ff88c          UXTH     r8,r12
;;;209    			/* 0的宽度为1.125ms，1的宽度为2.25ms */				
;;;210    			s_Byte >>= 1;
00003e  f891c000          LDRB     r12,[r1,#0]  ; s_Byte
000042  ea4f0c5c          LSR      r12,r12,#1
000046  f881c000          STRB     r12,[r1,#0]
;;;211    			if ((TotalWitdh > 92) && (TotalWitdh < 132))
00004a  f1a80c5d          SUB      r12,r8,#0x5d
00004e  f1bc0f27          CMP      r12,#0x27
000052  d307              BCC      |L1.100|
;;;212    			{
;;;213    				;					/* bit = 0 */
;;;214    			}
;;;215    			else if ((TotalWitdh > 205) && (TotalWitdh < 245))
000054  f1a80cce          SUB      r12,r8,#0xce
000058  f1bc0f27          CMP      r12,#0x27
00005c  d23a              BCS      |L1.212|
;;;216    			{
;;;217    				s_Byte += 0x80;		/* bit = 1 */
00005e  7808              LDRB     r0,[r1,#0]  ; s_Byte
000060  3080              ADDS     r0,r0,#0x80
000062  7008              STRB     r0,[r1,#0]
                  |L1.100|
;;;218    			}	
;;;219    			else
;;;220    			{
;;;221    				/* 异常脉宽 */
;;;222    				g_tIR.Status = 0;	/* 复位解码器状态 */	
;;;223    				goto loop1;		/* 继续判断同步信号 */
;;;224    			}
;;;225    			
;;;226    			s_Bit++;
000064  7848              LDRB     r0,[r1,#1]  ; s_Bit
000066  1c40              ADDS     r0,r0,#1
000068  b2c0              UXTB     r0,r0
00006a  7048              STRB     r0,[r1,#1]
;;;227    			if (s_Bit == 8)	/* 收齐8位 */
00006c  2808              CMP      r0,#8
00006e  d033              BEQ      |L1.216|
;;;228    			{
;;;229    				g_tIR.RxBuf[0] = s_Byte;
;;;230    				s_Byte = 0;
;;;231    			}
;;;232    			else if (s_Bit == 16)	/* 收齐16位 */
000070  2810              CMP      r0,#0x10
000072  d034              BEQ      |L1.222|
;;;233    			{
;;;234    				g_tIR.RxBuf[1] = s_Byte;
;;;235    				s_Byte = 0;
;;;236    			}
;;;237    			else if (s_Bit == 24)	/* 收齐24位 */
000074  2818              CMP      r0,#0x18
000076  d035              BEQ      |L1.228|
;;;238    			{
;;;239    				g_tIR.RxBuf[2] = s_Byte;
;;;240    				s_Byte = 0;
;;;241    			}
;;;242    			else if (s_Bit == 32)	/* 收齐32位 */
000078  2820              CMP      r0,#0x20
00007a  d038              BEQ      |L1.238|
00007c  e035              B        |L1.234|
                  |L1.126|
00007e  2201              MOVS     r2,#1                 ;143
000080  f2a020bd          SUB      r0,r0,#0x2bd          ;143
000084  f5b07fc7          CMP      r0,#0x18e             ;146
000088  d804              BHI      |L1.148|
00008a  70a2              STRB     r2,[r4,#2]            ;148
00008c  700d              STRB     r5,[r1,#0]            ;149
00008e  704d              STRB     r5,[r1,#1]            ;150
                  |L1.144|
;;;243    			{
;;;244    				g_tIR.RxBuf[3] = s_Byte;
;;;245    								
;;;246    				if (g_tIR.RxBuf[2] + g_tIR.RxBuf[3] == 255)	/* 检查校验 */
;;;247    				{
;;;248    					bsp_PutKey(g_tIR.RxBuf[2] + IR_KEY_STRAT);	/* 将键值放入KEY FIFO */
;;;249    					
;;;250    					g_tIR.RepeatCount = 0;	/* 重发计数器 */										
;;;251    				}
;;;252    				
;;;253    				g_tIR.Status = 0;	/* 等待下一组编码 */
;;;254    				break;
;;;255    			}
;;;256    			g_tIR.Status = 2;	/* 继续下一个bit */
;;;257    			break;						
;;;258    	}
;;;259    }
000090  e8bd81f0          POP      {r4-r8,pc}
                  |L1.148|
000094  7888              LDRB     r0,[r1,#2]            ;156  ; sss
000096  b118              CBZ      r0,|L1.160|
000098  2801              CMP      r0,#1                 ;160
00009a  d1f9              BNE      |L1.144|
00009c  708f              STRB     r7,[r1,#2]            ;162
00009e  e7f7              B        |L1.144|
                  |L1.160|
0000a0  708a              STRB     r2,[r1,#2]            ;158
0000a2  e7f5              B        |L1.144|
                  |L1.164|
0000a4  f5a0719d          SUB      r1,r0,#0x13a          ;168
0000a8  f5b17f8f          CMP      r1,#0x11e             ;168
0000ac  d31d              BCC      |L1.234|
0000ae  3897              SUBS     r0,r0,#0x97           ;168
0000b0  2863              CMP      r0,#0x63              ;172
0000b2  d225              BCS      |L1.256|
0000b4  79e0              LDRB     r0,[r4,#7]            ;175  ; g_tIR
0000b6  280a              CMP      r0,#0xa               ;175
0000b8  d303              BCC      |L1.194|
0000ba  b2d0              UXTB     r0,r2                 ;177
0000bc  f7fffffe          BL       bsp_PutKey
0000c0  e01e              B        |L1.256|
                  |L1.194|
0000c2  1c40              ADDS     r0,r0,#1              ;177
0000c4  71e0              STRB     r0,[r4,#7]            ;181
0000c6  e01b              B        |L1.256|
                  |L1.200|
0000c8  2e59              CMP      r6,#0x59              ;194
0000ca  d203              BCS      |L1.212|
0000cc  2203              MOVS     r2,#3                 ;196
0000ce  70a2              STRB     r2,[r4,#2]            ;196
0000d0  8088              STRH     r0,[r1,#4]            ;197
0000d2  e7dd              B        |L1.144|
                  |L1.212|
0000d4  70a5              STRB     r5,[r4,#2]            ;222
0000d6  e79f              B        |L1.24|
                  |L1.216|
0000d8  7808              LDRB     r0,[r1,#0]            ;229  ; s_Byte
0000da  70e0              STRB     r0,[r4,#3]            ;229
0000dc  e004              B        |L1.232|
                  |L1.222|
0000de  7808              LDRB     r0,[r1,#0]            ;234  ; s_Byte
0000e0  7120              STRB     r0,[r4,#4]            ;234
0000e2  e001              B        |L1.232|
                  |L1.228|
0000e4  7808              LDRB     r0,[r1,#0]            ;239  ; s_Byte
0000e6  7160              STRB     r0,[r4,#5]            ;239
                  |L1.232|
0000e8  700d              STRB     r5,[r1,#0]            ;240
                  |L1.234|
0000ea  70a7              STRB     r7,[r4,#2]            ;256
0000ec  e7d0              B        |L1.144|
                  |L1.238|
0000ee  7808              LDRB     r0,[r1,#0]            ;244  ; s_Byte
0000f0  71a0              STRB     r0,[r4,#6]            ;244
0000f2  4418              ADD      r0,r0,r3              ;246
0000f4  28ff              CMP      r0,#0xff              ;246
0000f6  d103              BNE      |L1.256|
0000f8  b2d0              UXTB     r0,r2                 ;248
0000fa  f7fffffe          BL       bsp_PutKey
0000fe  71e5              STRB     r5,[r4,#7]            ;250
                  |L1.256|
000100  70a5              STRB     r5,[r4,#2]            ;253
000102  e7c5              B        |L1.144|
;;;260    
                          ENDP

                  |L1.260|
                          DCD      ||.bss||
                  |L1.264|
                          DCD      ||.data||

                          AREA ||i.IRD_StartWork||, CODE, READONLY, ALIGN=2

                  IRD_StartWork PROC
;;;40     */
;;;41     void IRD_StartWork(void)
000000  b570              PUSH     {r4-r6,lr}
;;;42     {
000002  b088              SUB      sp,sp,#0x20
;;;43     	GPIO_InitTypeDef GPIO_InitStructure;
;;;44     	NVIC_InitTypeDef NVIC_InitStructure;
;;;45     
;;;46     	/* TIM3 clock enable */
;;;47     	RCC_APB1PeriphClockCmd(RCC_APB1Periph_TIM3, ENABLE);
000004  2101              MOVS     r1,#1
000006  2002              MOVS     r0,#2
000008  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;48     
;;;49     	/* GPIOB clock enable */
;;;50     	RCC_APB2PeriphClockCmd(RCC_IRD, ENABLE);
00000c  2101              MOVS     r1,#1
00000e  2008              MOVS     r0,#8
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;51     
;;;52     	/* TIM3 chennel3 configuration : PB.0 */
;;;53     	/* 配置为输入引脚 */
;;;54     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000014  2003              MOVS     r0,#3
000016  f88d001e          STRB     r0,[sp,#0x1e]
;;;55     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	/* 输入模式 */
00001a  2004              MOVS     r0,#4
00001c  f88d001f          STRB     r0,[sp,#0x1f]
;;;56     	GPIO_InitStructure.GPIO_Pin = PIN_IRD;
000020  2501              MOVS     r5,#1
000022  f8ad501c          STRH     r5,[sp,#0x1c]
;;;57     	GPIO_Init(PORT_IRD, &GPIO_InitStructure);	
000026  a907              ADD      r1,sp,#0x1c
000028  4823              LDR      r0,|L2.184|
00002a  f7fffffe          BL       GPIO_Init
;;;58     	
;;;59     	/* Enable the TIM3 global Interrupt */
;;;60     	NVIC_InitStructure.NVIC_IRQChannel = TIM3_IRQn;
00002e  201d              MOVS     r0,#0x1d
000030  f88d0018          STRB     r0,[sp,#0x18]
;;;61     	NVIC_InitStructure.NVIC_IRQChannelPreemptionPriority = 0;
000034  2400              MOVS     r4,#0
000036  f88d4019          STRB     r4,[sp,#0x19]
;;;62     	NVIC_InitStructure.NVIC_IRQChannelSubPriority = 1;
00003a  f88d501a          STRB     r5,[sp,#0x1a]
;;;63     	NVIC_InitStructure.NVIC_IRQChannelCmd = ENABLE;
00003e  f88d501b          STRB     r5,[sp,#0x1b]
;;;64     	NVIC_Init(&NVIC_InitStructure);
000042  a806              ADD      r0,sp,#0x18
000044  f7fffffe          BL       NVIC_Init
;;;65     
;;;66     	/* 配置定时器, 启用TIM3_CH3捕获中断，和 TIM3溢出中断 */
;;;67     	{
;;;68     		TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;69     		TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;70     		uint16_t PrescalerValue;
;;;71     		
;;;72     		/* 设置分频为, 捕获计数器值的单位正好是 10us, 方便脉宽比较。 */
;;;73     		PrescalerValue = 72000000/100000 - 1;
000048  f24020cf          MOV      r0,#0x2cf
;;;74     		/* Time base configuration */
;;;75     		TIM_TimeBaseStructure.TIM_Period = 65535;
00004c  f64f71ff          MOV      r1,#0xffff
000050  f8ad1004          STRH     r1,[sp,#4]
;;;76     		TIM_TimeBaseStructure.TIM_Prescaler = PrescalerValue;
000054  f8ad0000          STRH     r0,[sp,#0]
;;;77     		TIM_TimeBaseStructure.TIM_ClockDivision = 0;
;;;78     		TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;
;;;79     		TIM_TimeBaseStructure.TIM_RepetitionCounter = 0x0000;
;;;80     		TIM_TimeBaseInit(TIM3, &TIM_TimeBaseStructure);
000058  4e18              LDR      r6,|L2.188|
00005a  f8ad4006          STRH     r4,[sp,#6]            ;77
00005e  f8ad4002          STRH     r4,[sp,#2]            ;78
000062  f88d4008          STRB     r4,[sp,#8]            ;79
000066  4669              MOV      r1,sp
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       TIM_TimeBaseInit
;;;81       
;;;82     		TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;
00006e  2008              MOVS     r0,#8
000070  f8ad000c          STRH     r0,[sp,#0xc]
;;;83     		TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	// 对于TIM3，TIM_ICPolarity_BothEdge不起作用
000074  2002              MOVS     r0,#2
000076  f8ad000e          STRH     r0,[sp,#0xe]
;;;84     		TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
00007a  f8ad5010          STRH     r5,[sp,#0x10]
;;;85     		TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
00007e  f8ad4012          STRH     r4,[sp,#0x12]
;;;86     		TIM_ICInitStructure.TIM_ICFilter = 0x0;	
000082  f8ad4014          STRH     r4,[sp,#0x14]
;;;87     		TIM_ICInit(TIM3, &TIM_ICInitStructure);
000086  a903              ADD      r1,sp,#0xc
000088  4630              MOV      r0,r6
00008a  f7fffffe          BL       TIM_ICInit
;;;88     		
;;;89     		/* TIM enable counter */
;;;90     		TIM_Cmd(TIM3, ENABLE);
00008e  2101              MOVS     r1,#1
000090  4630              MOV      r0,r6
000092  f7fffffe          BL       TIM_Cmd
;;;91     
;;;92     		/* Enable the CC3 Interrupt Request */
;;;93     		TIM_ITConfig(TIM3, TIM_IT_CC3, ENABLE);
000096  2201              MOVS     r2,#1
000098  2108              MOVS     r1,#8
00009a  4630              MOV      r0,r6
00009c  f7fffffe          BL       TIM_ITConfig
;;;94     		
;;;95     		TIM_ITConfig(TIM3, TIM_IT_Update, ENABLE);	/* 溢出中断使能，用于超时同步处理 */
0000a0  2201              MOVS     r2,#1
0000a2  4611              MOV      r1,r2
0000a4  4630              MOV      r0,r6
0000a6  f7fffffe          BL       TIM_ITConfig
;;;96     	}
;;;97     	
;;;98     	g_tIR.LastCapture = 0;	
0000aa  4805              LDR      r0,|L2.192|
0000ac  8004              STRH     r4,[r0,#0]
;;;99     	g_tIR.Status = 0;
0000ae  7084              STRB     r4,[r0,#2]
;;;100    	g_tIR.WaitFallEdge = 1;	/* 0 表示等待上升沿，1表示等待下降沿，用于切换输入捕获极性 */
0000b0  7205              STRB     r5,[r0,#8]
;;;101    }
0000b2  b008              ADD      sp,sp,#0x20
0000b4  bd70              POP      {r4-r6,pc}
;;;102    
                          ENDP

0000b6  0000              DCW      0x0000
                  |L2.184|
                          DCD      0x40010c00
                  |L2.188|
                          DCD      0x40000400
                  |L2.192|
                          DCD      ||.bss||

                          AREA ||i.IRD_StopWork||, CODE, READONLY, ALIGN=2

                  IRD_StopWork PROC
;;;110    */
;;;111    void IRD_StopWork(void)
000000  b510              PUSH     {r4,lr}
;;;112    {
;;;113    	TIM_Cmd(TIM3, DISABLE);
000002  4c06              LDR      r4,|L3.28|
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       TIM_Cmd
;;;114    	
;;;115    	TIM_ITConfig(TIM3, TIM_IT_CC3, DISABLE);	
00000c  4620              MOV      r0,r4
00000e  2200              MOVS     r2,#0
000010  e8bd4010          POP      {r4,lr}
000014  2108              MOVS     r1,#8
000016  f7ffbffe          B.W      TIM_ITConfig
;;;116    }
;;;117    
                          ENDP

00001a  0000              DCW      0x0000
                  |L3.28|
                          DCD      0x40000400

                          AREA ||i.TIM3_IRQHandler||, CODE, READONLY, ALIGN=2

                  TIM3_IRQHandler PROC
;;;268    */
;;;269    void TIM3_IRQHandler(void)
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;270    {
;;;271    	uint16_t NowCapture;
;;;272    	uint16_t Width;
;;;273    	
;;;274    	/* 溢出中断 */
;;;275    	if (TIM_GetITStatus(TIM3, TIM_IT_Update))
000004  4f36              LDR      r7,|L4.224|
000006  2101              MOVS     r1,#1
000008  4638              MOV      r0,r7
00000a  f7fffffe          BL       TIM_GetITStatus
00000e  2601              MOVS     r6,#1
;;;276    	{
;;;277    		TIM_ClearITPendingBit(TIM3, TIM_IT_Update);;
;;;278    		
;;;279            /* TIM3 计数器源频率10us, 655360us = 0.655ms; */
;;;280            if (g_tIR.TimeOut < 2)
000010  4c34              LDR      r4,|L4.228|
000012  f04f0902          MOV      r9,#2
;;;281            {
;;;282                if (++g_tIR.TimeOut == 2)
;;;283                {
;;;284                    /* 强制设置为下降沿触发 */
;;;285    				{
;;;286    					TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;287    					
;;;288    					TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;
000016  f04f0808          MOV      r8,#8
00001a  2500              MOVS     r5,#0
00001c  b1d8              CBZ      r0,|L4.86|
00001e  2101              MOVS     r1,#1                 ;277
000020  4638              MOV      r0,r7                 ;277
000022  f7fffffe          BL       TIM_ClearITPendingBit
000026  8960              LDRH     r0,[r4,#0xa]          ;280  ; g_tIR
000028  2802              CMP      r0,#2                 ;280
00002a  d214              BCS      |L4.86|
00002c  1c40              ADDS     r0,r0,#1              ;280
00002e  b280              UXTH     r0,r0                 ;282
000030  8160              STRH     r0,[r4,#0xa]          ;282
000032  2802              CMP      r0,#2                 ;282
000034  d10f              BNE      |L4.86|
000036  f8ad8000          STRH     r8,[sp,#0]
;;;289    					TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	/* 等待下降沿 */
;;;290    					TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
00003a  f8ad6004          STRH     r6,[sp,#4]
00003e  f8ad9002          STRH     r9,[sp,#2]            ;289
;;;291    					TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
000042  f8ad5006          STRH     r5,[sp,#6]
;;;292    					TIM_ICInitStructure.TIM_ICFilter = 0x0;	
000046  f8ad5008          STRH     r5,[sp,#8]
;;;293    					TIM_ICInit(TIM3, &TIM_ICInitStructure);	
00004a  4669              MOV      r1,sp
00004c  4638              MOV      r0,r7
00004e  f7fffffe          BL       TIM_ICInit
;;;294    					
;;;295    					g_tIR.WaitFallEdge = 1;
000052  7226              STRB     r6,[r4,#8]
;;;296    				}
;;;297        
;;;298                    g_tIR.Status = 0;	/* 等待下一组编码 */
000054  70a5              STRB     r5,[r4,#2]
                  |L4.86|
;;;299                }
;;;300            }
;;;301    	}
;;;302    	
;;;303    	/* 输入通道3捕获中断 */
;;;304    	if (TIM_GetITStatus(TIM3, TIM_IT_CC3))
000056  2108              MOVS     r1,#8
000058  4638              MOV      r0,r7
00005a  f7fffffe          BL       TIM_GetITStatus
00005e  2800              CMP      r0,#0
000060  d03c              BEQ      |L4.220|
;;;305    	{
;;;306    		TIM_ClearITPendingBit(TIM3, TIM_IT_CC3);
000062  46ba              MOV      r10,r7
000064  2108              MOVS     r1,#8
000066  4650              MOV      r0,r10
000068  f7fffffe          BL       TIM_ClearITPendingBit
;;;307    
;;;308    		g_tIR.TimeOut = 0;  /* 清零超时计数器 */
00006c  8165              STRH     r5,[r4,#0xa]
;;;309    		
;;;310    		NowCapture = TIM_GetCapture3(TIM3);	/* 读取捕获的计数器值，计数器值从0-65535循环计数 */
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       TIM_GetCapture3
000074  4607              MOV      r7,r0
;;;311    
;;;312    		/* 	切换捕获的极性 */
;;;313    		if (g_tIR.WaitFallEdge == 0)
000076  7a20              LDRB     r0,[r4,#8]  ; g_tIR
;;;314    		{
;;;315    			TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;316    			
;;;317    			TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;
;;;318    			TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Falling;	/* 等待下降沿 */
;;;319    			TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
;;;320    			TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
;;;321    			TIM_ICInitStructure.TIM_ICFilter = 0x0;	
;;;322    			TIM_ICInit(TIM3, &TIM_ICInitStructure);	
;;;323    			
;;;324    			g_tIR.WaitFallEdge = 1;
;;;325    		}			
;;;326    		else
;;;327    		{
;;;328    			TIM_ICInitTypeDef  TIM_ICInitStructure;
;;;329    			
;;;330    			TIM_ICInitStructure.TIM_Channel = TIM_Channel_3;
000078  f8ad8000          STRH     r8,[sp,#0]
00007c  b188              CBZ      r0,|L4.162|
;;;331    			TIM_ICInitStructure.TIM_ICPolarity = TIM_ICPolarity_Rising;		/* 等待上升沿 */
;;;332    			TIM_ICInitStructure.TIM_ICSelection = TIM_ICSelection_DirectTI;
00007e  f8ad6004          STRH     r6,[sp,#4]
000082  f8ad5002          STRH     r5,[sp,#2]            ;331
;;;333    			TIM_ICInitStructure.TIM_ICPrescaler = TIM_ICPSC_DIV1;			/* 每次跳变都产生1次捕获事件 */
000086  f8ad5006          STRH     r5,[sp,#6]
;;;334    			TIM_ICInitStructure.TIM_ICFilter = 0x0;	
00008a  f8ad5008          STRH     r5,[sp,#8]
;;;335    			TIM_ICInit(TIM3, &TIM_ICInitStructure);	
00008e  4669              MOV      r1,sp
000090  4650              MOV      r0,r10
000092  f7fffffe          BL       TIM_ICInit
;;;336    			
;;;337    			g_tIR.WaitFallEdge = 0;
000096  7225              STRB     r5,[r4,#8]
                  |L4.152|
;;;338    		}
;;;339    		
;;;340    		if (NowCapture >= g_tIR.LastCapture)
000098  8820              LDRH     r0,[r4,#0]  ; g_tIR
00009a  42b8              CMP      r0,r7
00009c  d80f              BHI      |L4.190|
;;;341    		{
;;;342    			Width = NowCapture - g_tIR.LastCapture;
00009e  1a39              SUBS     r1,r7,r0
0000a0  e011              B        |L4.198|
                  |L4.162|
0000a2  f8ad6004          STRH     r6,[sp,#4]            ;319
0000a6  f8ad9002          STRH     r9,[sp,#2]            ;318
0000aa  f8ad5006          STRH     r5,[sp,#6]            ;320
0000ae  f8ad5008          STRH     r5,[sp,#8]            ;321
0000b2  4669              MOV      r1,sp                 ;322
0000b4  4650              MOV      r0,r10                ;322
0000b6  f7fffffe          BL       TIM_ICInit
0000ba  7226              STRB     r6,[r4,#8]            ;324
0000bc  e7ec              B        |L4.152|
                  |L4.190|
;;;343    		}
;;;344    		else if (NowCapture < g_tIR.LastCapture)	/* 计数器抵达最大并翻转 */
;;;345    		{
;;;346    			Width = ((0xFFFF - g_tIR.LastCapture) + NowCapture);
0000be  f64f71ff          MOV      r1,#0xffff
0000c2  1a09              SUBS     r1,r1,r0
0000c4  4439              ADD      r1,r1,r7
                  |L4.198|
;;;347    		}			
;;;348    		
;;;349    		if ((g_tIR.Status == 0) && (g_tIR.LastCapture == 0))
0000c6  78a2              LDRB     r2,[r4,#2]  ; g_tIR
0000c8  b289              UXTH     r1,r1                 ;346
0000ca  b902              CBNZ     r2,|L4.206|
0000cc  b128              CBZ      r0,|L4.218|
                  |L4.206|
;;;350    		{
;;;351    			g_tIR.LastCapture = NowCapture;
;;;352    			return;
;;;353    		}
;;;354    				
;;;355    		g_tIR.LastCapture = NowCapture;	/* 保存当前计数器，用于下次计算差值 */
0000ce  8027              STRH     r7,[r4,#0]
;;;356    		
;;;357    		IRD_DecodeNec(Width);		/* 解码 */		
0000d0  4608              MOV      r0,r1
0000d2  e8bd4ffe          POP      {r1-r11,lr}
0000d6  f7ffbffe          B.W      IRD_DecodeNec
                  |L4.218|
0000da  8027              STRH     r7,[r4,#0]            ;351
                  |L4.220|
;;;358    	}
;;;359    }
0000dc  e8bd8ffe          POP      {r1-r11,pc}
;;;360    
                          ENDP

                  |L4.224|
                          DCD      0x40000400
                  |L4.228|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_tIR
                          %        12

                          AREA ||.data||, DATA, ALIGN=1

                  s_Byte
000000  00                DCB      0x00
                  s_Bit
000001  00                DCB      0x00
                  ||sss||
000002  0000              DCB      0x00,0x00
                  s_LowWidth
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_ir_decode.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_ir_decode_c_1d26f915____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_ir_decode_c_1d26f915____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_ir_decode_c_1d26f915____REVSH|
#line 128
|__asm___15_bsp_ir_decode_c_1d26f915____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
