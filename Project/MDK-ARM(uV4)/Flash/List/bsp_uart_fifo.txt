; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_uart_fifo.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_uart_fifo.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_uart_fifo.crf ..\..\User\bsp\src\bsp_uart_fifo.c]
                          THUMB

                          AREA ||i.ComToUSARTx||, CODE, READONLY, ALIGN=2

                  ComToUSARTx PROC
;;;147    */
;;;148    USART_TypeDef *ComToUSARTx(COM_PORT_E _ucPort)
000000  b128              CBZ      r0,|L1.14|
;;;149    {
;;;150    	if (_ucPort == COM1)
;;;151    	{
;;;152    		#if UART1_FIFO_EN == 1
;;;153    			return USART1;
;;;154    		#else
;;;155    			return 0;
;;;156    		#endif
;;;157    	}
;;;158    	else if (_ucPort == COM2)
000002  2801              CMP      r0,#1
000004  d005              BEQ      |L1.18|
;;;159    	{
;;;160    		#if UART2_FIFO_EN == 1
;;;161    			return USART2;
;;;162    		#else
;;;163    			return;
;;;164    		#endif
;;;165    	}
;;;166    	else if (_ucPort == COM3)
000006  2802              CMP      r0,#2
000008  d005              BEQ      |L1.22|
;;;167    	{
;;;168    		#if UART3_FIFO_EN == 1
;;;169    			return USART3;
;;;170    		#else
;;;171    			return 0;
;;;172    		#endif
;;;173    	}
;;;174    	else if (_ucPort == COM4)
;;;175    	{
;;;176    		#if UART4_FIFO_EN == 1
;;;177    			return USART4;
;;;178    		#else
;;;179    			return 0;
;;;180    		#endif
;;;181    	}
;;;182    	else if (_ucPort == COM5)
;;;183    	{
;;;184    		#if UART5_FIFO_EN == 1
;;;185    			return USART5;
;;;186    		#else
;;;187    			return 0;
;;;188    		#endif
;;;189    	}
;;;190    	else
;;;191    	{
;;;192    		/* 不做任何处理 */
;;;193    		return 0;
00000a  2000              MOVS     r0,#0
;;;194    	}
;;;195    }
00000c  4770              BX       lr
                  |L1.14|
00000e  4803              LDR      r0,|L1.28|
000010  4770              BX       lr
                  |L1.18|
000012  4803              LDR      r0,|L1.32|
000014  4770              BX       lr
                  |L1.22|
000016  4803              LDR      r0,|L1.36|
000018  4770              BX       lr
;;;196    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40013800
                  |L1.32|
                          DCD      0x40004400
                  |L1.36|
                          DCD      0x40004800

                          AREA ||i.ComToUart||, CODE, READONLY, ALIGN=2

                  ComToUart PROC
;;;90     */
;;;91     UART_T *ComToUart(COM_PORT_E _ucPort)
000000  b128              CBZ      r0,|L2.14|
;;;92     {
;;;93     	if (_ucPort == COM1)
;;;94     	{
;;;95     		#if UART1_FIFO_EN == 1
;;;96     			return &g_tUart1;
;;;97     		#else
;;;98     			return 0;
;;;99     		#endif
;;;100    	}
;;;101    	else if (_ucPort == COM2)
000002  2801              CMP      r0,#1
000004  d005              BEQ      |L2.18|
;;;102    	{
;;;103    		#if UART2_FIFO_EN == 1
;;;104    			return &g_tUart2;
;;;105    		#else
;;;106    			return;
;;;107    		#endif
;;;108    	}
;;;109    	else if (_ucPort == COM3)
000006  2802              CMP      r0,#2
000008  d005              BEQ      |L2.22|
;;;110    	{
;;;111    		#if UART3_FIFO_EN == 1
;;;112    			return &g_tUart3;
;;;113    		#else
;;;114    			return 0;
;;;115    		#endif
;;;116    	}
;;;117    	else if (_ucPort == COM4)
;;;118    	{
;;;119    		#if UART4_FIFO_EN == 1
;;;120    			return &g_tUart4;
;;;121    		#else
;;;122    			return 0;
;;;123    		#endif
;;;124    	}
;;;125    	else if (_ucPort == COM5)
;;;126    	{
;;;127    		#if UART5_FIFO_EN == 1
;;;128    			return &g_tUart5;
;;;129    		#else
;;;130    			return 0;
;;;131    		#endif
;;;132    	}
;;;133    	else
;;;134    	{
;;;135    		/* 不做任何处理 */
;;;136    		return 0;
00000a  2000              MOVS     r0,#0
;;;137    	}
;;;138    }
00000c  4770              BX       lr
                  |L2.14|
00000e  4803              LDR      r0,|L2.28|
000010  4770              BX       lr
                  |L2.18|
000012  4803              LDR      r0,|L2.32|
000014  4770              BX       lr
                  |L2.22|
000016  4803              LDR      r0,|L2.36|
000018  4770              BX       lr
;;;139    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      ||.bss||
                  |L2.32|
                          DCD      ||.bss||+0x828
                  |L2.36|
                          DCD      ||.bss||+0x1050

                          AREA ||i.InitHardUart||, CODE, READONLY, ALIGN=2

                  InitHardUart PROC
;;;604    */
;;;605    static void InitHardUart(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;606    {
000004  b085              SUB      sp,sp,#0x14
;;;607    	GPIO_InitTypeDef GPIO_InitStructure;
;;;608    	USART_InitTypeDef USART_InitStructure;
;;;609    
;;;610    #if UART1_FIFO_EN == 1		/* 串口1 TX = PA9   RX = PA10 或 TX = PB6   RX = PB7*/
;;;611    
;;;612    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;613    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000006  2101              MOVS     r1,#1
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;614    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_USART1, ENABLE);
00000e  2101              MOVS     r1,#1
000010  0388              LSLS     r0,r1,#14
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;615    
;;;616    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;617    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9;
000016  f44f7000          MOV      r0,#0x200
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;618    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2718              MOVS     r7,#0x18
000020  f88d7003          STRB     r7,[sp,#3]
;;;619    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2603              MOVS     r6,#3
000026  f88d6002          STRB     r6,[sp,#2]
;;;620    	GPIO_Init(GPIOA, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  4862              LDR      r0,|L3.440|
00002e  f7fffffe          BL       GPIO_Init
;;;621    
;;;622    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;623    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;624    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;625    	*/
;;;626    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000032  f44f6a80          MOV      r10,#0x400
000036  f8ada000          STRH     r10,[sp,#0]
;;;627    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00003a  2504              MOVS     r5,#4
00003c  f88d5003          STRB     r5,[sp,#3]
;;;628    	GPIO_Init(GPIOA, &GPIO_InitStructure);
000040  4669              MOV      r1,sp
000042  485d              LDR      r0,|L3.440|
000044  f7fffffe          BL       GPIO_Init
;;;629    	
;;;630    	/* 第4步： 配置串口硬件参数 */
;;;631    	USART_InitStructure.USART_BaudRate = UART1_BAUD;	/* 波特率 */
;;;632    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000048  2400              MOVS     r4,#0
;;;633    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;634    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;635    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;636    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;637    	USART_Init(USART1, &USART_InitStructure);
00004a  f8dfb170          LDR      r11,|L3.444|
00004e  f44f39e1          MOV      r9,#0x1c200           ;631
000052  f8ad4008          STRH     r4,[sp,#8]            ;632
000056  f8ad400c          STRH     r4,[sp,#0xc]          ;634
00005a  f04f080c          MOV      r8,#0xc               ;636
00005e  f8cd9004          STR      r9,[sp,#4]            ;632
000062  f8ad400a          STRH     r4,[sp,#0xa]          ;633
000066  f8ad4010          STRH     r4,[sp,#0x10]         ;635
00006a  f8ad800e          STRH     r8,[sp,#0xe]          ;636
00006e  a901              ADD      r1,sp,#4
000070  4658              MOV      r0,r11
000072  f7fffffe          BL       USART_Init
;;;638    
;;;639    	USART_ITConfig(USART1, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000076  2201              MOVS     r2,#1
000078  f2405125          MOV      r1,#0x525
00007c  4658              MOV      r0,r11
00007e  f7fffffe          BL       USART_ITConfig
;;;640    	/*
;;;641    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;642    		注意: 不要在此处打开发送中断
;;;643    		发送中断使能在SendUart()函数打开
;;;644    	*/
;;;645    	USART_Cmd(USART1, ENABLE);		/* 使能串口 */
000082  2101              MOVS     r1,#1
000084  4658              MOV      r0,r11
000086  f7fffffe          BL       USART_Cmd
;;;646    
;;;647    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;648    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;649    	USART_ClearFlag(USART1, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
00008a  2140              MOVS     r1,#0x40
00008c  4658              MOV      r0,r11
00008e  f7fffffe          BL       USART_ClearFlag
;;;650    #endif
;;;651    
;;;652    #if UART2_FIFO_EN == 1		/* 串口2 TX = PA2， RX = PA3  */
;;;653    	/* 第1步：打开GPIO和USART部件的时钟 */
;;;654    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_AFIO, ENABLE);
000092  2101              MOVS     r1,#1
000094  2005              MOVS     r0,#5
000096  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;655    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART2, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  0448              LSLS     r0,r1,#17
00009e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;656    
;;;657    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;658    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
0000a2  f8ad5000          STRH     r5,[sp,#0]
;;;659    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
0000a6  f88d7003          STRB     r7,[sp,#3]
;;;660    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
0000aa  f88d6002          STRB     r6,[sp,#2]
;;;661    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000ae  4669              MOV      r1,sp
0000b0  4841              LDR      r0,|L3.440|
0000b2  f7fffffe          BL       GPIO_Init
;;;662    
;;;663    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;664    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;665    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;666    	*/
;;;667    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3;
0000b6  2008              MOVS     r0,#8
0000b8  f8ad0000          STRH     r0,[sp,#0]
;;;668    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
0000bc  f88d5003          STRB     r5,[sp,#3]
;;;669    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000c0  4669              MOV      r1,sp
0000c2  483d              LDR      r0,|L3.440|
0000c4  f7fffffe          BL       GPIO_Init
;;;670    	/*  第3步已经做了，因此这步可以不做
;;;671    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;672    	*/
;;;673    	GPIO_Init(GPIOA, &GPIO_InitStructure);
0000c8  4669              MOV      r1,sp
0000ca  483b              LDR      r0,|L3.440|
0000cc  f7fffffe          BL       GPIO_Init
;;;674    
;;;675    	/* 第4步： 配置串口硬件参数 */
;;;676    	USART_InitStructure.USART_BaudRate = UART2_BAUD;	/* 波特率 */
;;;677    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
0000d0  f8cd9004          STR      r9,[sp,#4]
;;;678    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;679    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;680    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;681    	USART_InitStructure.USART_Mode = USART_Mode_Tx | USART_Mode_Rx;		/* 仅选择接收模式 */
;;;682    	USART_Init(USART2, &USART_InitStructure);
0000d4  f8df90e8          LDR      r9,|L3.448|
0000d8  f8ad4008          STRH     r4,[sp,#8]            ;677
0000dc  f8ad400c          STRH     r4,[sp,#0xc]          ;679
0000e0  f8ad400a          STRH     r4,[sp,#0xa]          ;678
0000e4  f8ad4010          STRH     r4,[sp,#0x10]         ;680
0000e8  f8ad800e          STRH     r8,[sp,#0xe]          ;681
0000ec  a901              ADD      r1,sp,#4
0000ee  4648              MOV      r0,r9
0000f0  f7fffffe          BL       USART_Init
;;;683    
;;;684    	USART_ITConfig(USART2, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
0000f4  2201              MOVS     r2,#1
0000f6  f2405125          MOV      r1,#0x525
0000fa  4648              MOV      r0,r9
0000fc  f7fffffe          BL       USART_ITConfig
;;;685    	/*
;;;686    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;687    		注意: 不要在此处打开发送中断
;;;688    		发送中断使能在SendUart()函数打开
;;;689    	*/
;;;690    	USART_Cmd(USART2, ENABLE);		/* 使能串口 */
000100  2101              MOVS     r1,#1
000102  4648              MOV      r0,r9
000104  f7fffffe          BL       USART_Cmd
;;;691    
;;;692    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;693    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;694    	USART_ClearFlag(USART2, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
000108  2140              MOVS     r1,#0x40
00010a  4648              MOV      r0,r9
00010c  f7fffffe          BL       USART_ClearFlag
;;;695    #endif
;;;696    
;;;697    #if UART3_FIFO_EN == 1			/* 串口3 TX = PB10   RX = PB11 */
;;;698    
;;;699    	/* 配置 PB2为推挽输出，用于切换 RS485芯片的收发状态 */
;;;700    	{
;;;701    		RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);
000110  2101              MOVS     r1,#1
000112  2008              MOVS     r0,#8
000114  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;702    
;;;703    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
000118  2010              MOVS     r0,#0x10
00011a  f88d0003          STRB     r0,[sp,#3]
;;;704    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;705    		GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
;;;706    		GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00011e  f8df90a4          LDR      r9,|L3.452|
000122  f88d6002          STRB     r6,[sp,#2]            ;704
000126  f8ad5000          STRH     r5,[sp,#0]            ;705
00012a  4669              MOV      r1,sp
00012c  4648              MOV      r0,r9
00012e  f7fffffe          BL       GPIO_Init
;;;707    	}
;;;708    
;;;709    	/* 第1步： 开启GPIO和UART时钟 */
;;;710    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB | RCC_APB2Periph_AFIO, ENABLE);
000132  2101              MOVS     r1,#1
000134  2009              MOVS     r0,#9
000136  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;711    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_USART3, ENABLE);
00013a  2101              MOVS     r1,#1
00013c  0488              LSLS     r0,r1,#18
00013e  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;712    
;;;713    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;714    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
000142  f8ada000          STRH     r10,[sp,#0]
;;;715    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000146  f88d7003          STRB     r7,[sp,#3]
;;;716    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00014a  f88d6002          STRB     r6,[sp,#2]
;;;717    	GPIO_Init(GPIOB, &GPIO_InitStructure);
00014e  4669              MOV      r1,sp
000150  4648              MOV      r0,r9
000152  f7fffffe          BL       GPIO_Init
;;;718    
;;;719    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;720    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;721    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;722    	*/
;;;723    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000156  0268              LSLS     r0,r5,#9
000158  f8ad0000          STRH     r0,[sp,#0]
;;;724    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00015c  f88d5003          STRB     r5,[sp,#3]
;;;725    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000160  4669              MOV      r1,sp
000162  4648              MOV      r0,r9
000164  f7fffffe          BL       GPIO_Init
;;;726    	/*  第3步已经做了，因此这步可以不做
;;;727    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;728    	*/
;;;729    	GPIO_Init(GPIOB, &GPIO_InitStructure);
000168  4669              MOV      r1,sp
00016a  4648              MOV      r0,r9
00016c  f7fffffe          BL       GPIO_Init
;;;730    
;;;731    	/* 第4步： 配置串口硬件参数 */
;;;732    	USART_InitStructure.USART_BaudRate = UART3_BAUD;	/* 波特率 */
;;;733    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
000170  f8ad4008          STRH     r4,[sp,#8]
;;;734    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000174  f8ad400a          STRH     r4,[sp,#0xa]
;;;735    	USART_InitStructure.USART_Parity = USART_Parity_No ;
000178  f8ad400c          STRH     r4,[sp,#0xc]
;;;736    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00017c  f8ad4010          STRH     r4,[sp,#0x10]
000180  f44f5016          MOV      r0,#0x2580            ;732
;;;737    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;738    	USART_Init(USART3, &USART_InitStructure);
000184  4c10              LDR      r4,|L3.456|
000186  9001              STR      r0,[sp,#4]            ;733
000188  f8ad800e          STRH     r8,[sp,#0xe]          ;737
00018c  a901              ADD      r1,sp,#4
00018e  4620              MOV      r0,r4
000190  f7fffffe          BL       USART_Init
;;;739    
;;;740    	USART_ITConfig(USART3, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
000194  2201              MOVS     r2,#1
000196  f2405125          MOV      r1,#0x525
00019a  4620              MOV      r0,r4
00019c  f7fffffe          BL       USART_ITConfig
;;;741    	/*
;;;742    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;743    		注意: 不要在此处打开发送中断
;;;744    		发送中断使能在SendUart()函数打开
;;;745    	*/
;;;746    	USART_Cmd(USART3, ENABLE);		/* 使能串口 */
0001a0  2101              MOVS     r1,#1
0001a2  4620              MOV      r0,r4
0001a4  f7fffffe          BL       USART_Cmd
;;;747    
;;;748    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;749    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;750    	USART_ClearFlag(USART3, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
0001a8  2140              MOVS     r1,#0x40
0001aa  4620              MOV      r0,r4
0001ac  f7fffffe          BL       USART_ClearFlag
;;;751    #endif
;;;752    
;;;753    #if UART4_FIFO_EN == 1			/* 串口4 TX = PC10   RX = PC11 */
;;;754    	/* 第1步： 开启GPIO和UART时钟 */
;;;755    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_AFIO, ENABLE);
;;;756    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART4, ENABLE);
;;;757    
;;;758    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;759    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_10;
;;;760    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;761    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;762    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;763    
;;;764    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;765    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;766    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;767    	*/
;;;768    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
;;;769    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;770    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;771    
;;;772    	/* 第4步： 配置串口硬件参数 */
;;;773    	USART_InitStructure.USART_BaudRate = UART4_BAUD;	/* 波特率 */
;;;774    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;775    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;776    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;777    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;778    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;779    	USART_Init(UART4, &USART_InitStructure);
;;;780    
;;;781    	USART_ITConfig(UART4, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;782    	/*
;;;783    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;784    		注意: 不要在此处打开发送中断
;;;785    		发送中断使能在SendUart()函数打开
;;;786    	*/
;;;787    	USART_Cmd(UART4, ENABLE);		/* 使能串口 */
;;;788    
;;;789    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;790    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;791    	USART_ClearFlag(UART4, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;792    #endif
;;;793    
;;;794    #if UART5_FIFO_EN == 1			/* 串口5 TX = PC12   RX = PD2 */
;;;795    	/* 第1步： 开启GPIO和UART时钟 */
;;;796    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC | RCC_APB2Periph_GPIOD | RCC_APB2Periph_AFIO, ENABLE);
;;;797    	RCC_APB1PeriphClockCmd(RCC_APB1Periph_UART5, ENABLE);
;;;798    
;;;799    	/* 第2步：将USART Tx的GPIO配置为推挽复用模式 */
;;;800    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
;;;801    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
;;;802    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;803    	GPIO_Init(GPIOC, &GPIO_InitStructure);
;;;804    
;;;805    	/* 第3步：将USART Rx的GPIO配置为浮空输入模式
;;;806    		由于CPU复位后，GPIO缺省都是浮空输入模式，因此下面这个步骤不是必须的
;;;807    		但是，我还是建议加上便于阅读，并且防止其它地方修改了这个口线的设置参数
;;;808    	*/
;;;809    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
;;;810    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
;;;811    	GPIO_Init(GPIOD, &GPIO_InitStructure);
;;;812    
;;;813    
;;;814    	/* 第4步： 配置串口硬件参数 */
;;;815    	USART_InitStructure.USART_BaudRate = UART5_BAUD;	/* 波特率 */
;;;816    	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
;;;817    	USART_InitStructure.USART_StopBits = USART_StopBits_1;
;;;818    	USART_InitStructure.USART_Parity = USART_Parity_No ;
;;;819    	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
;;;820    	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
;;;821    	USART_Init(UART5, &USART_InitStructure);
;;;822    
;;;823    	USART_ITConfig(UART5, USART_IT_RXNE, ENABLE);	/* 使能接收中断 */
;;;824    	/*
;;;825    		USART_ITConfig(USART1, USART_IT_TXE, ENABLE);
;;;826    		注意: 不要在此处打开发送中断
;;;827    		发送中断使能在SendUart()函数打开
;;;828    	*/
;;;829    	USART_Cmd(UART5, ENABLE);		/* 使能串口 */
;;;830    
;;;831    	/* CPU的小缺陷：串口配置好，如果直接Send，则第1个字节发送不出去
;;;832    		如下语句解决第1个字节无法正确发送出去的问题 */
;;;833    	USART_ClearFlag(UART5, USART_FLAG_TC);     /* 清发送完成标志，Transmission Complete flag */
;;;834    #endif
;;;835    }
0001b0  b005              ADD      sp,sp,#0x14
0001b2  e8bd8ff0          POP      {r4-r11,pc}
;;;836    
                          ENDP

0001b6  0000              DCW      0x0000
                  |L3.440|
                          DCD      0x40010800
                  |L3.444|
                          DCD      0x40013800
                  |L3.448|
                          DCD      0x40004400
                  |L3.452|
                          DCD      0x40010c00
                  |L3.456|
                          DCD      0x40004800

                          AREA ||i.RS485_InitTXE||, CODE, READONLY, ALIGN=2

                  RS485_InitTXE PROC
;;;406    */
;;;407    void RS485_InitTXE(void)
000000  b508              PUSH     {r3,lr}
;;;408    {
;;;409    	GPIO_InitTypeDef GPIO_InitStructure;
;;;410    
;;;411    	RCC_APB2PeriphClockCmd(RCC_RS485_TXEN, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;412    
;;;413    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;414    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
;;;415    	GPIO_InitStructure.GPIO_Pin = PIN_RS485_TXEN;
000016  2004              MOVS     r0,#4
000018  f8ad0000          STRH     r0,[sp,#0]
;;;416    	GPIO_Init(PORT_RS485_TXEN, &GPIO_InitStructure);
00001c  4669              MOV      r1,sp
00001e  4802              LDR      r0,|L4.40|
000020  f7fffffe          BL       GPIO_Init
;;;417    }
000024  bd08              POP      {r3,pc}
;;;418    
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      0x40010c00

                          AREA ||i.RS485_ReciveNew||, CODE, READONLY, ALIGN=1

                  RS485_ReciveNew PROC
;;;495    extern void MODBUS_ReciveNew(uint8_t _byte);
;;;496    void RS485_ReciveNew(uint8_t _byte)
000000  f7ffbffe          B.W      MODBUS_ReciveNew
;;;497    {
;;;498    	MODBUS_ReciveNew(_byte);
;;;499    }
;;;500    
                          ENDP


                          AREA ||i.RS485_SendBefor||, CODE, READONLY, ALIGN=2

                  RS485_SendBefor PROC
;;;440    */
;;;441    void RS485_SendBefor(void)
000000  4901              LDR      r1,|L6.8|
;;;442    {
;;;443    	RS485_TX_EN();	/* 切换RS485收发芯片为发送模式 */
000002  2004              MOVS     r0,#4
000004  6008              STR      r0,[r1,#0]
;;;444    }
000006  4770              BX       lr
;;;445    
                          ENDP

                  |L6.8|
                          DCD      0x40010c10

                          AREA ||i.RS485_SendBuf||, CODE, READONLY, ALIGN=1

                  RS485_SendBuf PROC
;;;468    */
;;;469    void RS485_SendBuf(uint8_t *_ucaBuf, uint16_t _usLen)
000000  460a              MOV      r2,r1
;;;470    {
;;;471    	comSendBuf(COM3, _ucaBuf, _usLen);
000002  4601              MOV      r1,r0
000004  2002              MOVS     r0,#2
000006  f7ffbffe          B.W      comSendBuf
;;;472    }
;;;473    
                          ENDP


                          AREA ||i.RS485_SendOver||, CODE, READONLY, ALIGN=2

                  RS485_SendOver PROC
;;;454    */
;;;455    void RS485_SendOver(void)
000000  4901              LDR      r1,|L8.8|
;;;456    {
;;;457    	RS485_RX_EN();	/* 切换RS485收发芯片为接收模式 */
000002  2004              MOVS     r0,#4
000004  6008              STR      r0,[r1,#0]
;;;458    }
000006  4770              BX       lr
;;;459    
                          ENDP

                  |L8.8|
                          DCD      0x40010c14

                          AREA ||i.RS485_SendStr||, CODE, READONLY, ALIGN=1

                  RS485_SendStr PROC
;;;481    */
;;;482    void RS485_SendStr(char *_pBuf)
000000  b510              PUSH     {r4,lr}
;;;483    {
000002  4604              MOV      r4,r0
;;;484    	RS485_SendBuf((uint8_t *)_pBuf, strlen(_pBuf));
000004  f7fffffe          BL       strlen
000008  b281              UXTH     r1,r0
00000a  4620              MOV      r0,r4
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      RS485_SendBuf
;;;485    }
;;;486    
                          ENDP


                          AREA ||i.RS485_SetBaud||, CODE, READONLY, ALIGN=1

                  RS485_SetBaud PROC
;;;426    */
;;;427    void RS485_SetBaud(uint32_t _baud)
000000  4601              MOV      r1,r0
;;;428    {
;;;429    	comSetBaud(COM3, _baud);
000002  2002              MOVS     r0,#2
000004  f7ffbffe          B.W      comSetBaud
;;;430    }
;;;431    
                          ENDP


                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;1109   #if UART1_FIFO_EN == 1
;;;1110   void USART1_IRQHandler(void)
000000  4801              LDR      r0,|L11.8|
;;;1111   {
;;;1112   	UartIRQ(&g_tUart1);
000002  f7ffbffe          B.W      UartIRQ
;;;1113   }
;;;1114   #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L11.8|
                          DCD      ||.bss||

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;1116   #if UART2_FIFO_EN == 1
;;;1117   void USART2_IRQHandler(void)
000000  4801              LDR      r0,|L12.8|
;;;1118   {
;;;1119   	UartIRQ(&g_tUart2);
000002  f7ffbffe          B.W      UartIRQ
;;;1120   }
;;;1121   #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||.bss||+0x828

                          AREA ||i.USART3_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART3_IRQHandler PROC
;;;1123   #if UART3_FIFO_EN == 1
;;;1124   void USART3_IRQHandler(void)
000000  4801              LDR      r0,|L13.8|
;;;1125   {
;;;1126   	UartIRQ(&g_tUart3);
000002  f7ffbffe          B.W      UartIRQ
;;;1127   }
;;;1128   #endif
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      ||.bss||+0x1050

                          AREA ||i.USART_SetBaudRate||, CODE, READONLY, ALIGN=2

                  USART_SetBaudRate PROC
;;;338    */
;;;339    void USART_SetBaudRate(USART_TypeDef* USARTx, uint32_t BaudRate)
000000  b530              PUSH     {r4,r5,lr}
;;;340    {
000002  b085              SUB      sp,sp,#0x14
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;341    	uint32_t tmpreg = 0x00, apbclock = 0x00;
;;;342    	uint32_t integerdivider = 0x00;
;;;343    	uint32_t fractionaldivider = 0x00;
;;;344    	uint32_t usartxbase = 0;
;;;345    	RCC_ClocksTypeDef RCC_ClocksStatus;
;;;346    	
;;;347    	/* Check the parameters */
;;;348    	assert_param(IS_USART_ALL_PERIPH(USARTx));
;;;349    	assert_param(IS_USART_BAUDRATE(BaudRate));  
;;;350    
;;;351    	usartxbase = (uint32_t)USARTx;
;;;352    
;;;353    	/*---------------------------- USART BRR Configuration -----------------------*/
;;;354    	/* Configure the USART Baud Rate -------------------------------------------*/
;;;355    	RCC_GetClocksFreq(&RCC_ClocksStatus);
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       RCC_GetClocksFreq
;;;356    	if (usartxbase == USART1_BASE)
00000e  4819              LDR      r0,|L14.116|
000010  4284              CMP      r4,r0
000012  d101              BNE      |L14.24|
;;;357    	{
;;;358    		apbclock = RCC_ClocksStatus.PCLK2_Frequency;
000014  9803              LDR      r0,[sp,#0xc]
000016  e000              B        |L14.26|
                  |L14.24|
;;;359    	}
;;;360    	else
;;;361    	{
;;;362    		apbclock = RCC_ClocksStatus.PCLK1_Frequency;
000018  9802              LDR      r0,[sp,#8]
                  |L14.26|
;;;363    	}
;;;364    
;;;365    	/* Determine the integer part */
;;;366    	//if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
;;;367    	if ((USARTx->CR1 & 0x8000) != 0)	 /* USART OVER8 mode Enable Mask */
00001a  89a1              LDRH     r1,[r4,#0xc]
00001c  0409              LSLS     r1,r1,#16
;;;368    	{
;;;369    		/* Integer part computing in case Oversampling mode is 8 Samples */
;;;370    		integerdivider = ((25 * apbclock) / (2 * BaudRate));    
;;;371    	}
;;;372    	else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;373    	{
;;;374    		/* Integer part computing in case Oversampling mode is 16 Samples */
;;;375    		integerdivider = ((25 * apbclock) / (4 * BaudRate));    
00001e  eb0001c0          ADD      r1,r0,r0,LSL #3
000022  eb011000          ADD      r0,r1,r0,LSL #4
000026  d501              BPL      |L14.44|
000028  0069              LSLS     r1,r5,#1              ;370
00002a  e000              B        |L14.46|
                  |L14.44|
00002c  00a9              LSLS     r1,r5,#2              ;370
                  |L14.46|
00002e  fbb0f0f1          UDIV     r0,r0,r1
;;;376    	}
;;;377    	tmpreg = (integerdivider / 100) << 4;
000032  2264              MOVS     r2,#0x64
000034  fbb0f1f2          UDIV     r1,r0,r2
000038  0109              LSLS     r1,r1,#4
;;;378    
;;;379    	/* Determine the fractional part */
;;;380    	fractionaldivider = integerdivider - (100 * (tmpreg >> 4));
00003a  090b              LSRS     r3,r1,#4
00003c  f06f0518          MVN      r5,#0x18
000040  436b              MULS     r3,r5,r3
000042  eb000083          ADD      r0,r0,r3,LSL #2
;;;381    
;;;382    	/* Implement the fractional part in the register */
;;;383    	//if ((USARTx->CR1 & CR1_OVER8_Set) != 0)
;;;384    	if ((USARTx->CR1 & 0x8000) != 0)
000046  89a3              LDRH     r3,[r4,#0xc]
000048  041d              LSLS     r5,r3,#16
;;;385    	{
;;;386    		tmpreg |= ((((fractionaldivider * 8) + 50) / 100)) & ((uint8_t)0x07);
00004a  f04f0332          MOV      r3,#0x32
00004e  d506              BPL      |L14.94|
000050  eb0300c0          ADD      r0,r3,r0,LSL #3
000054  fbb0f0f2          UDIV     r0,r0,r2
000058  f0000007          AND      r0,r0,#7
00005c  e005              B        |L14.106|
                  |L14.94|
;;;387    	}
;;;388    	else /* if ((USARTx->CR1 & CR1_OVER8_Set) == 0) */
;;;389    	{
;;;390    		tmpreg |= ((((fractionaldivider * 16) + 50) / 100)) & ((uint8_t)0x0F);
00005e  eb031000          ADD      r0,r3,r0,LSL #4
000062  fbb0f0f2          UDIV     r0,r0,r2
000066  f000000f          AND      r0,r0,#0xf
                  |L14.106|
00006a  4308              ORRS     r0,r0,r1
;;;391    	}
;;;392    
;;;393    	/* Write to USART BRR */
;;;394    	USARTx->BRR = (uint16_t)tmpreg;
00006c  8120              STRH     r0,[r4,#8]
;;;395    }
00006e  b005              ADD      sp,sp,#0x14
000070  bd30              POP      {r4,r5,pc}
;;;396    
                          ENDP

000072  0000              DCW      0x0000
                  |L14.116|
                          DCD      0x40013800

                          AREA ||i.UartIRQ||, CODE, READONLY, ALIGN=1

                  UartIRQ PROC
;;;1016   */
;;;1017   static void UartIRQ(UART_T *_pUart)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1018   {
000004  4604              MOV      r4,r0
;;;1019   	/* 处理接收中断  */
;;;1020   	if (USART_GetITStatus(_pUart->uart, USART_IT_RXNE) != RESET)
000006  6800              LDR      r0,[r0,#0]
000008  f2405125          MOV      r1,#0x525
00000c  f7fffffe          BL       USART_GetITStatus
000010  2500              MOVS     r5,#0
000012  b1b8              CBZ      r0,|L15.68|
;;;1021   	{
;;;1022   		/* 从串口接收数据寄存器读取数据存放到接收FIFO */
;;;1023   		uint8_t ch;
;;;1024   
;;;1025   		ch = USART_ReceiveData(_pUart->uart);
000014  6820              LDR      r0,[r4,#0]
000016  f7fffffe          BL       USART_ReceiveData
;;;1026   		_pUart->pRxBuf[_pUart->usRxWrite] = ch;
00001a  8ae2              LDRH     r2,[r4,#0x16]
00001c  68a1              LDR      r1,[r4,#8]
00001e  b2c0              UXTB     r0,r0                 ;1025
000020  5488              STRB     r0,[r1,r2]
;;;1027   		if (++_pUart->usRxWrite >= _pUart->usRxBufSize)
000022  8ae1              LDRH     r1,[r4,#0x16]
000024  1c49              ADDS     r1,r1,#1
000026  b28a              UXTH     r2,r1
000028  82e2              STRH     r2,[r4,#0x16]
00002a  89e1              LDRH     r1,[r4,#0xe]
00002c  428a              CMP      r2,r1
00002e  d300              BCC      |L15.50|
;;;1028   		{
;;;1029   			_pUart->usRxWrite = 0;
000030  82e5              STRH     r5,[r4,#0x16]
                  |L15.50|
;;;1030   		}
;;;1031   		if (_pUart->usRxCount < _pUart->usRxBufSize)
000032  8b62              LDRH     r2,[r4,#0x1a]
000034  428a              CMP      r2,r1
000036  d202              BCS      |L15.62|
;;;1032   		{
;;;1033   			_pUart->usRxCount++;
000038  8b61              LDRH     r1,[r4,#0x1a]
00003a  1c49              ADDS     r1,r1,#1
00003c  8361              STRH     r1,[r4,#0x1a]
                  |L15.62|
;;;1034   		}
;;;1035   
;;;1036   		/* 回调函数,通知应用程序收到新数据,一般是发送1个消息或者设置一个标记 */
;;;1037   		//if (_pUart->usRxWrite == _pUart->usRxRead)
;;;1038   		//if (_pUart->usRxCount == 1)
;;;1039   		{
;;;1040   			if (_pUart->ReciveNew)
00003e  6a61              LDR      r1,[r4,#0x24]
000040  b101              CBZ      r1,|L15.68|
;;;1041   			{
;;;1042   				_pUart->ReciveNew(ch);
000042  4788              BLX      r1
                  |L15.68|
;;;1043   			}
;;;1044   		}
;;;1045   	}
;;;1046   
;;;1047   	/* 处理发送缓冲区空中断 */
;;;1048   	if (USART_GetITStatus(_pUart->uart, USART_IT_TXE) != RESET)
000044  f2407727          MOV      r7,#0x727
000048  4639              MOV      r1,r7
00004a  6820              LDR      r0,[r4,#0]
00004c  f7fffffe          BL       USART_GetITStatus
;;;1049   	{
;;;1050   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1051   		if (_pUart->usTxCount == 0)
;;;1052   		{
;;;1053   			/* 发送缓冲区的数据已取完时， 禁止发送缓冲区空中断 （注意：此时最后1个数据还未真正发送完毕）*/
;;;1054   			USART_ITConfig(_pUart->uart, USART_IT_TXE, DISABLE);
;;;1055   
;;;1056   			/* 使能数据发送完毕中断 */
;;;1057   			USART_ITConfig(_pUart->uart, USART_IT_TC, ENABLE);
000050  f2406626          MOV      r6,#0x626
000054  b190              CBZ      r0,|L15.124|
000056  8aa0              LDRH     r0,[r4,#0x14]         ;1051
000058  b9c0              CBNZ     r0,|L15.140|
00005a  2200              MOVS     r2,#0                 ;1054
00005c  4639              MOV      r1,r7                 ;1054
00005e  6820              LDR      r0,[r4,#0]            ;1054
000060  f7fffffe          BL       USART_ITConfig
000064  4631              MOV      r1,r6
000066  6820              LDR      r0,[r4,#0]
000068  e8bd41f0          POP      {r4-r8,lr}
00006c  2201              MOVS     r2,#1
00006e  f7ffbffe          B.W      USART_ITConfig
                  |L15.114|
;;;1058   		}
;;;1059   		else
;;;1060   		{
;;;1061   			/* 从发送FIFO取1个字节写入串口发送数据寄存器 */
;;;1062   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;1063   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
;;;1064   			{
;;;1065   				_pUart->usTxRead = 0;
;;;1066   			}
;;;1067   			_pUart->usTxCount--;
000072  8aa0              LDRH     r0,[r4,#0x14]
000074  1e40              SUBS     r0,r0,#1
000076  82a0              STRH     r0,[r4,#0x14]
                  |L15.120|
;;;1068   		}
;;;1069   
;;;1070   	}
;;;1071   	/* 数据bit位全部发送完毕的中断 */
;;;1072   	else if (USART_GetITStatus(_pUart->uart, USART_IT_TC) != RESET)
;;;1073   	{
;;;1074   		//if (_pUart->usTxRead == _pUart->usTxWrite)
;;;1075   		if (_pUart->usTxCount == 0)
;;;1076   		{
;;;1077   			/* 如果发送FIFO的数据全部发送完毕，禁止数据发送完毕中断 */
;;;1078   			USART_ITConfig(_pUart->uart, USART_IT_TC, DISABLE);
;;;1079   
;;;1080   			/* 回调函数, 一般用来处理RS485通信，将RS485芯片设置为接收模式，避免抢占总线 */
;;;1081   			if (_pUart->SendOver)
;;;1082   			{
;;;1083   				_pUart->SendOver();
;;;1084   			}
;;;1085   		}
;;;1086   		else
;;;1087   		{
;;;1088   			/* 正常情况下，不会进入此分支 */
;;;1089   
;;;1090   			/* 如果发送FIFO的数据还未完毕，则从发送FIFO取1个数据写入发送数据寄存器 */
;;;1091   			USART_SendData(_pUart->uart, _pUart->pTxBuf[_pUart->usTxRead]);
;;;1092   			if (++_pUart->usTxRead >= _pUart->usTxBufSize)
;;;1093   			{
;;;1094   				_pUart->usTxRead = 0;
;;;1095   			}
;;;1096   			_pUart->usTxCount--;
;;;1097   		}
;;;1098   	}
;;;1099   }
000078  e8bd81f0          POP      {r4-r8,pc}
                  |L15.124|
00007c  4631              MOV      r1,r6                 ;1072
00007e  6820              LDR      r0,[r4,#0]            ;1072
000080  f7fffffe          BL       USART_GetITStatus
000084  2800              CMP      r0,#0                 ;1072
000086  d0f7              BEQ      |L15.120|
000088  8aa0              LDRH     r0,[r4,#0x14]         ;1075
00008a  b170              CBZ      r0,|L15.170|
                  |L15.140|
00008c  8a61              LDRH     r1,[r4,#0x12]         ;1091
00008e  6860              LDR      r0,[r4,#4]            ;1091
000090  5c41              LDRB     r1,[r0,r1]            ;1091
000092  6820              LDR      r0,[r4,#0]            ;1091
000094  f7fffffe          BL       USART_SendData
000098  8a60              LDRH     r0,[r4,#0x12]         ;1092
00009a  1c40              ADDS     r0,r0,#1              ;1092
00009c  b280              UXTH     r0,r0                 ;1092
00009e  8260              STRH     r0,[r4,#0x12]         ;1092
0000a0  89a1              LDRH     r1,[r4,#0xc]          ;1092
0000a2  4288              CMP      r0,r1                 ;1092
0000a4  d3e5              BCC      |L15.114|
0000a6  8265              STRH     r5,[r4,#0x12]         ;1094
0000a8  e7e3              B        |L15.114|
                  |L15.170|
0000aa  2200              MOVS     r2,#0                 ;1078
0000ac  4631              MOV      r1,r6                 ;1078
0000ae  6820              LDR      r0,[r4,#0]            ;1078
0000b0  f7fffffe          BL       USART_ITConfig
0000b4  6a20              LDR      r0,[r4,#0x20]         ;1081
0000b6  2800              CMP      r0,#0                 ;1081
0000b8  d0de              BEQ      |L15.120|
0000ba  e8bd41f0          POP      {r4-r8,lr}            ;1083
0000be  4700              BX       r0                    ;1083
;;;1100   
                          ENDP


                          AREA ||i.UartVarInit||, CODE, READONLY, ALIGN=2

                  UartVarInit PROC
;;;508    */
;;;509    static void UartVarInit(void)
000000  4923              LDR      r1,|L16.144|
;;;510    {
;;;511    #if UART1_FIFO_EN == 1
;;;512    	g_tUart1.uart = USART1;						/* STM32 串口设备 */
000002  4822              LDR      r0,|L16.140|
;;;513    	g_tUart1.pTxBuf = g_TxBuf1;					/* 发送缓冲区指针 */
;;;514    	g_tUart1.pRxBuf = g_RxBuf1;					/* 接收缓冲区指针 */
;;;515    	g_tUart1.usTxBufSize = UART1_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000004  f44f6280          MOV      r2,#0x400
000008  6008              STR      r0,[r1,#0]            ;513  ; g_tUart1
00000a  f1010028          ADD      r0,r1,#0x28           ;513
00000e  6048              STR      r0,[r1,#4]            ;514  ; g_tUart1
000010  f5006080          ADD      r0,r0,#0x400          ;514
000014  6088              STR      r0,[r1,#8]  ; g_tUart1
000016  818a              STRH     r2,[r1,#0xc]
;;;516    	g_tUart1.usRxBufSize = UART1_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000018  81ca              STRH     r2,[r1,#0xe]
;;;517    	g_tUart1.usTxWrite = 0;						/* 发送FIFO写索引 */
00001a  2000              MOVS     r0,#0
00001c  8208              STRH     r0,[r1,#0x10]
;;;518    	g_tUart1.usTxRead = 0;						/* 发送FIFO读索引 */
00001e  8248              STRH     r0,[r1,#0x12]
;;;519    	g_tUart1.usRxWrite = 0;						/* 接收FIFO写索引 */
000020  82c8              STRH     r0,[r1,#0x16]
;;;520    	g_tUart1.usRxRead = 0;						/* 接收FIFO读索引 */
000022  8308              STRH     r0,[r1,#0x18]
;;;521    	g_tUart1.usRxCount = 0;						/* 接收到的新数据个数 */
000024  8348              STRH     r0,[r1,#0x1a]
;;;522    	g_tUart1.usTxCount = 0;						/* 待发送的数据个数 */
000026  8288              STRH     r0,[r1,#0x14]
;;;523    	g_tUart1.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;524    	g_tUart1.SendOver = 0;						/* 发送完毕后的回调函数 */
000028  61c8              STR      r0,[r1,#0x1c]  ; g_tUart1
;;;525    	g_tUart1.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
00002a  6208              STR      r0,[r1,#0x20]  ; g_tUart1
;;;526    #endif
;;;527    
;;;528    #if UART2_FIFO_EN == 1
;;;529    	g_tUart2.uart = USART2;						/* STM32 串口设备 */
00002c  6248              STR      r0,[r1,#0x24]  ; g_tUart1
00002e  f6010128          ADD      r1,r1,#0x828
000032  4b18              LDR      r3,|L16.148|
;;;530    	g_tUart2.pTxBuf = g_TxBuf2;					/* 发送缓冲区指针 */
000034  600b              STR      r3,[r1,#0]  ; g_tUart2
000036  f1010328          ADD      r3,r1,#0x28
;;;531    	g_tUart2.pRxBuf = g_RxBuf2;					/* 接收缓冲区指针 */
00003a  604b              STR      r3,[r1,#4]  ; g_tUart2
00003c  f5016385          ADD      r3,r1,#0x428
;;;532    	g_tUart2.usTxBufSize = UART2_TX_BUF_SIZE;	/* 发送缓冲区大小 */
000040  608b              STR      r3,[r1,#8]  ; g_tUart2
000042  818a              STRH     r2,[r1,#0xc]
;;;533    	g_tUart2.usRxBufSize = UART2_RX_BUF_SIZE;	/* 接收缓冲区大小 */
000044  81ca              STRH     r2,[r1,#0xe]
;;;534    	g_tUart2.usTxWrite = 0;						/* 发送FIFO写索引 */
000046  8208              STRH     r0,[r1,#0x10]
;;;535    	g_tUart2.usTxRead = 0;						/* 发送FIFO读索引 */
000048  8248              STRH     r0,[r1,#0x12]
;;;536    	g_tUart2.usRxWrite = 0;						/* 接收FIFO写索引 */
00004a  82c8              STRH     r0,[r1,#0x16]
;;;537    	g_tUart2.usRxRead = 0;						/* 接收FIFO读索引 */
00004c  8308              STRH     r0,[r1,#0x18]
;;;538    	g_tUart2.usRxCount = 0;						/* 接收到的新数据个数 */
00004e  8348              STRH     r0,[r1,#0x1a]
;;;539    	g_tUart2.usTxCount = 0;						/* 待发送的数据个数 */
000050  8288              STRH     r0,[r1,#0x14]
;;;540    	g_tUart2.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;541    	g_tUart2.SendOver = 0;						/* 发送完毕后的回调函数 */
000052  61c8              STR      r0,[r1,#0x1c]  ; g_tUart2
;;;542    	g_tUart2.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
000054  6208              STR      r0,[r1,#0x20]  ; g_tUart2
;;;543    #endif
;;;544    
;;;545    #if UART3_FIFO_EN == 1
;;;546    	g_tUart3.uart = USART3;						/* STM32 串口设备 */
000056  6248              STR      r0,[r1,#0x24]  ; g_tUart2
000058  f6010128          ADD      r1,r1,#0x828
00005c  4b0e              LDR      r3,|L16.152|
;;;547    	g_tUart3.pTxBuf = g_TxBuf3;					/* 发送缓冲区指针 */
00005e  600b              STR      r3,[r1,#0]  ; g_tUart3
000060  f1010328          ADD      r3,r1,#0x28
;;;548    	g_tUart3.pRxBuf = g_RxBuf3;					/* 接收缓冲区指针 */
000064  604b              STR      r3,[r1,#4]  ; g_tUart3
000066  f5016385          ADD      r3,r1,#0x428
;;;549    	g_tUart3.usTxBufSize = UART3_TX_BUF_SIZE;	/* 发送缓冲区大小 */
00006a  608b              STR      r3,[r1,#8]  ; g_tUart3
00006c  818a              STRH     r2,[r1,#0xc]
;;;550    	g_tUart3.usRxBufSize = UART3_RX_BUF_SIZE;	/* 接收缓冲区大小 */
00006e  81ca              STRH     r2,[r1,#0xe]
;;;551    	g_tUart3.usTxWrite = 0;						/* 发送FIFO写索引 */
000070  8208              STRH     r0,[r1,#0x10]
;;;552    	g_tUart3.usTxRead = 0;						/* 发送FIFO读索引 */
000072  8248              STRH     r0,[r1,#0x12]
;;;553    	g_tUart3.usRxWrite = 0;						/* 接收FIFO写索引 */
000074  82c8              STRH     r0,[r1,#0x16]
;;;554    	g_tUart3.usRxRead = 0;						/* 接收FIFO读索引 */
000076  8308              STRH     r0,[r1,#0x18]
;;;555    	g_tUart3.usRxCount = 0;						/* 接收到的新数据个数 */
000078  8348              STRH     r0,[r1,#0x1a]
;;;556    	g_tUart3.usTxCount = 0;						/* 待发送的数据个数 */
00007a  8288              STRH     r0,[r1,#0x14]
;;;557    	g_tUart3.SendBefor = RS485_SendBefor;		/* 发送数据前的回调函数 */
00007c  4807              LDR      r0,|L16.156|
;;;558    	g_tUart3.SendOver = RS485_SendOver;			/* 发送完毕后的回调函数 */
00007e  61c8              STR      r0,[r1,#0x1c]  ; g_tUart3
000080  4807              LDR      r0,|L16.160|
;;;559    	g_tUart3.ReciveNew = RS485_ReciveNew;		/* 接收到新数据后的回调函数 */
000082  6208              STR      r0,[r1,#0x20]  ; g_tUart3
000084  4807              LDR      r0,|L16.164|
000086  6248              STR      r0,[r1,#0x24]  ; g_tUart3
;;;560    #endif
;;;561    
;;;562    #if UART4_FIFO_EN == 1
;;;563    	g_tUart4.uart = UART4;						/* STM32 串口设备 */
;;;564    	g_tUart4.pTxBuf = g_TxBuf4;					/* 发送缓冲区指针 */
;;;565    	g_tUart4.pRxBuf = g_RxBuf4;					/* 接收缓冲区指针 */
;;;566    	g_tUart4.usTxBufSize = UART4_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;567    	g_tUart4.usRxBufSize = UART4_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;568    	g_tUart4.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;569    	g_tUart4.usTxRead = 0;						/* 发送FIFO读索引 */
;;;570    	g_tUart4.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;571    	g_tUart4.usRxRead = 0;						/* 接收FIFO读索引 */
;;;572    	g_tUart4.usRxCount = 0;						/* 接收到的新数据个数 */
;;;573    	g_tUart4.usTxCount = 0;						/* 待发送的数据个数 */
;;;574    	g_tUart4.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;575    	g_tUart4.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;576    	g_tUart4.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;577    #endif
;;;578    
;;;579    #if UART5_FIFO_EN == 1
;;;580    	g_tUart5.uart = UART5;						/* STM32 串口设备 */
;;;581    	g_tUart5.pTxBuf = g_TxBuf5;					/* 发送缓冲区指针 */
;;;582    	g_tUart5.pRxBuf = g_RxBuf5;					/* 接收缓冲区指针 */
;;;583    	g_tUart5.usTxBufSize = UART5_TX_BUF_SIZE;	/* 发送缓冲区大小 */
;;;584    	g_tUart5.usRxBufSize = UART5_RX_BUF_SIZE;	/* 接收缓冲区大小 */
;;;585    	g_tUart5.usTxWrite = 0;						/* 发送FIFO写索引 */
;;;586    	g_tUart5.usTxRead = 0;						/* 发送FIFO读索引 */
;;;587    	g_tUart5.usRxWrite = 0;						/* 接收FIFO写索引 */
;;;588    	g_tUart5.usRxRead = 0;						/* 接收FIFO读索引 */
;;;589    	g_tUart5.usRxCount = 0;						/* 接收到的新数据个数 */
;;;590    	g_tUart5.usTxCount = 0;						/* 待发送的数据个数 */
;;;591    	g_tUart5.SendBefor = 0;						/* 发送数据前的回调函数 */
;;;592    	g_tUart5.SendOver = 0;						/* 发送完毕后的回调函数 */
;;;593    	g_tUart5.ReciveNew = 0;						/* 接收到新数据后的回调函数 */
;;;594    #endif
;;;595    }
000088  4770              BX       lr
;;;596    
                          ENDP

00008a  0000              DCW      0x0000
                  |L16.140|
                          DCD      0x40013800
                  |L16.144|
                          DCD      ||.bss||
                  |L16.148|
                          DCD      0x40004400
                  |L16.152|
                          DCD      0x40004800
                  |L16.156|
                          DCD      RS485_SendBefor
                  |L16.160|
                          DCD      RS485_SendOver
                  |L16.164|
                          DCD      RS485_ReciveNew

                          AREA ||i.bsp_InitUart||, CODE, READONLY, ALIGN=1

                  bsp_InitUart PROC
;;;71     */
;;;72     void bsp_InitUart(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;73     {
;;;74     	UartVarInit();		/* 必须先初始化全局变量,再配置硬件 */
000002  f7fffffe          BL       UartVarInit
;;;75     
;;;76     	InitHardUart();		/* 配置串口的硬件参数(波特率等) */
000006  f7fffffe          BL       InitHardUart
;;;77     
;;;78     	RS485_InitTXE();	/* 配置RS485芯片的发送使能硬件，配置为推挽输出 */
00000a  f7fffffe          BL       RS485_InitTXE
00000e  2025              MOVS     r0,#0x25
000010  f88d0000          STRB     r0,[sp,#0]
000014  2404              MOVS     r4,#4
000016  f88d4001          STRB     r4,[sp,#1]
00001a  2500              MOVS     r5,#0
00001c  f88d5002          STRB     r5,[sp,#2]
000020  2601              MOVS     r6,#1
000022  f88d6003          STRB     r6,[sp,#3]
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       NVIC_Init
00002c  2026              MOVS     r0,#0x26
00002e  f88d0000          STRB     r0,[sp,#0]
000032  f88d4001          STRB     r4,[sp,#1]
000036  f88d5002          STRB     r5,[sp,#2]
00003a  f88d6003          STRB     r6,[sp,#3]
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       NVIC_Init
000044  2027              MOVS     r0,#0x27
000046  f88d0000          STRB     r0,[sp,#0]
00004a  f88d4001          STRB     r4,[sp,#1]
00004e  f88d5002          STRB     r5,[sp,#2]
000052  f88d6003          STRB     r6,[sp,#3]
000056  4668              MOV      r0,sp
000058  f7fffffe          BL       NVIC_Init
;;;79     
;;;80     	ConfigUartNVIC();	/* 配置串口中断 */
;;;81     }
00005c  bdf8              POP      {r3-r7,pc}
;;;82     
                          ENDP


                          AREA ||i.comClearRxFifo||, CODE, READONLY, ALIGN=1

                  comClearRxFifo PROC
;;;291    */
;;;292    void comClearRxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;293    {
;;;294    	UART_T *pUart;
;;;295    
;;;296    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;297    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L18.18|
;;;298    	{
;;;299    		return;
;;;300    	}
;;;301    
;;;302    	pUart->usRxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  82c1              STRH     r1,[r0,#0x16]
;;;303    	pUart->usRxRead = 0;
00000e  8301              STRH     r1,[r0,#0x18]
;;;304    	pUart->usRxCount = 0;
000010  8341              STRH     r1,[r0,#0x1a]
                  |L18.18|
;;;305    }
000012  bd00              POP      {pc}
;;;306    
                          ENDP


                          AREA ||i.comClearTxFifo||, CODE, READONLY, ALIGN=1

                  comClearTxFifo PROC
;;;268    */
;;;269    void comClearTxFifo(COM_PORT_E _ucPort)
000000  b500              PUSH     {lr}
;;;270    {
;;;271    	UART_T *pUart;
;;;272    
;;;273    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;274    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L19.18|
;;;275    	{
;;;276    		return;
;;;277    	}
;;;278    
;;;279    	pUart->usTxWrite = 0;
00000a  2100              MOVS     r1,#0
00000c  8201              STRH     r1,[r0,#0x10]
;;;280    	pUart->usTxRead = 0;
00000e  8241              STRH     r1,[r0,#0x12]
;;;281    	pUart->usTxCount = 0;
000010  8281              STRH     r1,[r0,#0x14]
                  |L19.18|
;;;282    }
000012  bd00              POP      {pc}
;;;283    
                          ENDP


                          AREA ||i.comGetChar||, CODE, READONLY, ALIGN=1

                  comGetChar PROC
;;;247    */
;;;248    uint8_t comGetChar(COM_PORT_E _ucPort, uint8_t *_pByte)
000000  b510              PUSH     {r4,lr}
;;;249    {
;;;250    	UART_T *pUart;
;;;251    
;;;252    	pUart = ComToUart(_ucPort);
000002  f7fffffe          BL       ComToUart
;;;253    	if (pUart == 0)
000006  2800              CMP      r0,#0
000008  d01f              BEQ      |L20.74|
;;;254    	{
;;;255    		return 0;
;;;256    	}
;;;257    
;;;258    	return UartGetChar(pUart, _pByte);
00000a  4602              MOV      r2,r0
00000c  2001              MOVS     r0,#1
00000e  f3808810          MSR      PRIMASK,r0
000012  8b53              LDRH     r3,[r2,#0x1a]
000014  2000              MOVS     r0,#0
000016  f3808810          MSR      PRIMASK,r0
00001a  2b00              CMP      r3,#0
00001c  d015              BEQ      |L20.74|
00001e  8b14              LDRH     r4,[r2,#0x18]
000020  6893              LDR      r3,[r2,#8]
000022  5d1b              LDRB     r3,[r3,r4]
000024  700b              STRB     r3,[r1,#0]
000026  2101              MOVS     r1,#1
000028  f3818810          MSR      PRIMASK,r1
00002c  8b11              LDRH     r1,[r2,#0x18]
00002e  1c49              ADDS     r1,r1,#1
000030  b289              UXTH     r1,r1
000032  8311              STRH     r1,[r2,#0x18]
000034  89d3              LDRH     r3,[r2,#0xe]
000036  4299              CMP      r1,r3
000038  d300              BCC      |L20.60|
00003a  8310              STRH     r0,[r2,#0x18]
                  |L20.60|
00003c  8b50              LDRH     r0,[r2,#0x1a]
00003e  1e40              SUBS     r0,r0,#1
000040  8350              STRH     r0,[r2,#0x1a]
000042  2000              MOVS     r0,#0
000044  f3808810          MSR      PRIMASK,r0
000048  2001              MOVS     r0,#1
                  |L20.74|
;;;259    }
00004a  bd10              POP      {r4,pc}
;;;260    
                          ENDP


                          AREA ||i.comSendBuf||, CODE, READONLY, ALIGN=1

                  comSendBuf PROC
;;;206    */
;;;207    void comSendBuf(COM_PORT_E _ucPort, uint8_t *_ucaBuf, uint16_t _usLen)
000000  b5f8              PUSH     {r3-r7,lr}
;;;208    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
;;;209    	UART_T *pUart;
;;;210    
;;;211    	pUart = ComToUart(_ucPort);
000006  f7fffffe          BL       ComToUart
00000a  0004              MOVS     r4,r0
;;;212    	if (pUart == 0)
00000c  d034              BEQ      |L21.120|
;;;213    	{
;;;214    		return;
;;;215    	}
;;;216    
;;;217    	if (pUart->SendBefor != 0)
00000e  69e0              LDR      r0,[r4,#0x1c]
000010  b100              CBZ      r0,|L21.20|
;;;218    	{
;;;219    		pUart->SendBefor();		/* 如果是RS485通信，可以在这个函数中将RS485设置为发送模式 */
000012  4780              BLX      r0
                  |L21.20|
000014  2000              MOVS     r0,#0
;;;220    	}
;;;221    
;;;222    	UartSend(pUart, _ucaBuf, _usLen);
000016  e025              B        |L21.100|
                  |L21.24|
000018  89a1              LDRH     r1,[r4,#0xc]
                  |L21.26|
00001a  2201              MOVS     r2,#1
00001c  f3828810          MSR      PRIMASK,r2
000020  8aa2              LDRH     r2,[r4,#0x14]
000022  f8ad2000          STRH     r2,[sp,#0]
000026  2200              MOVS     r2,#0
000028  f3828810          MSR      PRIMASK,r2
00002c  f8bd2000          LDRH     r2,[sp,#0]
000030  4291              CMP      r1,r2
000032  d9f2              BLS      |L21.26|
000034  5c31              LDRB     r1,[r6,r0]
000036  8a23              LDRH     r3,[r4,#0x10]
000038  6862              LDR      r2,[r4,#4]
00003a  54d1              STRB     r1,[r2,r3]
00003c  2101              MOVS     r1,#1
00003e  f3818810          MSR      PRIMASK,r1
000042  8a21              LDRH     r1,[r4,#0x10]
000044  1c49              ADDS     r1,r1,#1
000046  b289              UXTH     r1,r1
000048  8221              STRH     r1,[r4,#0x10]
00004a  89a2              LDRH     r2,[r4,#0xc]
00004c  4291              CMP      r1,r2
00004e  d301              BCC      |L21.84|
000050  2100              MOVS     r1,#0
000052  8221              STRH     r1,[r4,#0x10]
                  |L21.84|
000054  8aa1              LDRH     r1,[r4,#0x14]
000056  1c49              ADDS     r1,r1,#1
000058  82a1              STRH     r1,[r4,#0x14]
00005a  2100              MOVS     r1,#0
00005c  f3818810          MSR      PRIMASK,r1
000060  1c40              ADDS     r0,r0,#1
000062  b280              UXTH     r0,r0
                  |L21.100|
000064  42a8              CMP      r0,r5
000066  d3d7              BCC      |L21.24|
000068  6820              LDR      r0,[r4,#0]
00006a  e8bd40f8          POP      {r3-r7,lr}
00006e  2201              MOVS     r2,#1
000070  f2407127          MOV      r1,#0x727
000074  f7ffbffe          B.W      USART_ITConfig
                  |L21.120|
;;;223    }
000078  bdf8              POP      {r3-r7,pc}
;;;224    
                          ENDP


                          AREA ||i.comSendChar||, CODE, READONLY, ALIGN=1

                  comSendChar PROC
;;;233    */
;;;234    void comSendChar(COM_PORT_E _ucPort, uint8_t _ucByte)
000000  b513              PUSH     {r0,r1,r4,lr}
;;;235    {
;;;236    	comSendBuf(_ucPort, &_ucByte, 1);
000002  2201              MOVS     r2,#1
000004  a901              ADD      r1,sp,#4
000006  f7fffffe          BL       comSendBuf
;;;237    }
00000a  bd1c              POP      {r2-r4,pc}
;;;238    
                          ENDP


                          AREA ||i.comSetBaud||, CODE, READONLY, ALIGN=1

                  comSetBaud PROC
;;;315    */
;;;316    void comSetBaud(COM_PORT_E _ucPort, uint32_t _BaudRate)
000000  b510              PUSH     {r4,lr}
;;;317    {
;;;318    	USART_TypeDef* USARTx;
;;;319    	
;;;320    	USARTx = ComToUSARTx(_ucPort);
000002  f7fffffe          BL       ComToUSARTx
;;;321    	if (USARTx == 0)
000006  2800              CMP      r0,#0
000008  d003              BEQ      |L23.18|
;;;322    	{
;;;323    		return;
;;;324    	}
;;;325    	
;;;326    	USART_SetBaudRate(USARTx, _BaudRate);
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      USART_SetBaudRate
                  |L23.18|
;;;327    }
000012  bd10              POP      {r4,pc}
;;;328    
                          ENDP


                          AREA ||i.fgetc||, CODE, READONLY, ALIGN=1

                  fgetc PROC
;;;1177   */
;;;1178   int fgetc(FILE *f)
000000  b508              PUSH     {r3,lr}
                  |L24.2|
;;;1179   {
;;;1180   
;;;1181   #if 1	/* 从串口接收FIFO中取1个数据, 只有取到数据才返回 */
;;;1182   	uint8_t ucData;
;;;1183   
;;;1184   	while(comGetChar(COM1, &ucData) == 0);
000002  4669              MOV      r1,sp
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       comGetChar
00000a  2800              CMP      r0,#0
00000c  d0f9              BEQ      |L24.2|
;;;1185   
;;;1186   	return ucData;
00000e  f89d0000          LDRB     r0,[sp,#0]
;;;1187   #else
;;;1188   	/* 等待串口1输入数据 */
;;;1189   	while (USART_GetFlagStatus(USART1, USART_FLAG_RXNE) == RESET);
;;;1190   
;;;1191   	return (int)USART_ReceiveData(USART1);
;;;1192   #endif
;;;1193   }
000012  bd08              POP      {r3,pc}
;;;1194   
                          ENDP


                          AREA ||i.fputc||, CODE, READONLY, ALIGN=1

                  fputc PROC
;;;1151   */
;;;1152   int fputc(int ch, FILE *f)
000000  b510              PUSH     {r4,lr}
;;;1153   {
000002  4604              MOV      r4,r0
;;;1154   #if 1	/* 将需要printf的字符通过串口中断FIFO发送出去，printf函数会立即返回 */
;;;1155   	comSendChar(COM1, ch);
000004  b2c1              UXTB     r1,r0
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       comSendChar
;;;1156   
;;;1157   	return ch;
00000c  4620              MOV      r0,r4
;;;1158   #else	/* 采用阻塞方式发送每个字符,等待数据发送完毕 */
;;;1159   	/* 写一个字节到USART1 */
;;;1160   	USART_SendData(USART1, (uint8_t) ch);
;;;1161   
;;;1162   	/* 等待发送结束 */
;;;1163   	while (USART_GetFlagStatus(USART1, USART_FLAG_TC) == RESET)
;;;1164   	{}
;;;1165   
;;;1166   	return ch;
;;;1167   #endif
;;;1168   }
00000e  bd10              POP      {r4,pc}
;;;1169   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tUart1
                          %        40
                  g_TxBuf1
                          %        1024
                  g_RxBuf1
                          %        1024
                  g_tUart2
                          %        40
                  g_TxBuf2
                          %        1024
                  g_RxBuf2
                          %        1024
                  g_tUart3
                          %        40
                  g_TxBuf3
                          %        1024
                  g_RxBuf3
                          %        1024

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_uart_fifo.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_uart_fifo_c_b28b0d00____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH|
#line 128
|__asm___15_bsp_uart_fifo_c_b28b0d00____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
