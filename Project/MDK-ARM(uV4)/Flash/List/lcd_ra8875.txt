; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\lcd_ra8875.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\lcd_ra8875.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\lcd_ra8875.crf ..\..\User\bsp\src\LCD_RA8875.c]
                          THUMB

                          AREA ||i.BTE_SetTarBlock||, CODE, READONLY, ALIGN=1

                  BTE_SetTarBlock PROC
;;;555    */
;;;556    static void BTE_SetTarBlock(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t _ucLayer)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;557    {
000004  460c              MOV      r4,r1
000006  4607              MOV      r7,r0
;;;558    	/* 设置起点坐标 */
;;;559    	RA8875_WriteReg(0x58, _usX);
000008  b2c1              UXTB     r1,r0
00000a  461d              MOV      r5,r3                 ;557
00000c  4616              MOV      r6,r2                 ;557
00000e  2058              MOVS     r0,#0x58
000010  f8dd8018          LDR      r8,[sp,#0x18]
000014  f7fffffe          BL       RA8875_WriteReg
;;;560    	RA8875_WriteReg(0x59, _usX >> 8);
000018  0a39              LSRS     r1,r7,#8
00001a  2059              MOVS     r0,#0x59
00001c  f7fffffe          BL       RA8875_WriteReg
;;;561    
;;;562    	RA8875_WriteReg(0x5A, _usY);
000020  b2e1              UXTB     r1,r4
000022  205a              MOVS     r0,#0x5a
000024  f7fffffe          BL       RA8875_WriteReg
;;;563    	if (_ucLayer == 0)	/* 图层2 */
000028  f1b80f00          CMP      r8,#0
00002c  d017              BEQ      |L1.94|
;;;564    	{
;;;565    		RA8875_WriteReg(0x5B, _usY >> 8);
;;;566    	}
;;;567    	else
;;;568    	{
;;;569    		RA8875_WriteReg(0x5B, (1 << 7) | (_usY >> 8));	/* Bit7 表示图层， 0 图层1； 1 图层2*/
00002e  2080              MOVS     r0,#0x80
000030  ea402114          ORR      r1,r0,r4,LSR #8
                  |L1.52|
000034  205b              MOVS     r0,#0x5b
000036  f7fffffe          BL       RA8875_WriteReg
;;;570    	}
;;;571    
;;;572    	/* 设置区块宽度 */
;;;573    	RA8875_WriteReg(0x5C, _usWidth);
00003a  b2e9              UXTB     r1,r5
00003c  205c              MOVS     r0,#0x5c
00003e  f7fffffe          BL       RA8875_WriteReg
;;;574    	RA8875_WriteReg(0x5D, _usWidth >> 8);
000042  0a29              LSRS     r1,r5,#8
000044  205d              MOVS     r0,#0x5d
000046  f7fffffe          BL       RA8875_WriteReg
;;;575    
;;;576    	/* 设置区块高度 */
;;;577    	RA8875_WriteReg(0x5E, _usHeight);
00004a  b2f1              UXTB     r1,r6
00004c  205e              MOVS     r0,#0x5e
00004e  f7fffffe          BL       RA8875_WriteReg
;;;578    	RA8875_WriteReg(0x5F, _usHeight >> 8);
000052  0a31              LSRS     r1,r6,#8
000054  e8bd41f0          POP      {r4-r8,lr}
000058  205f              MOVS     r0,#0x5f
00005a  f7ffbffe          B.W      RA8875_WriteReg
                  |L1.94|
00005e  0a21              LSRS     r1,r4,#8              ;565
000060  e7e8              B        |L1.52|
;;;579    }
;;;580    
                          ENDP


                          AREA ||i.RA8875_ClrScr||, CODE, READONLY, ALIGN=2

                  RA8875_ClrScr PROC
;;;1021   */
;;;1022   void RA8875_ClrScr(uint16_t _usColor)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1023   {
;;;1024   	/* 也可以通过0x30-0x37寄存器获得获得当前激活的显示窗口 */
;;;1025   
;;;1026   	/* 单色填满功能, 中文pdf 第162页
;;;1027   	此功能使用于将选定特定区域画面清除或是\入给定某种前景色，R8875 填入的单色设定为BTE 前景色。
;;;1028   
;;;1029   	操作步骤:
;;;1030   		1. 设定目的图层和位置 REG[58h], [59h], [5Ah], [5Bh]
;;;1031   		2. 设定BTE 宽度和高度 REG[5Ch], [5Dh], [5Eh], [5Fh]
;;;1032   		3. 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch
;;;1033   		4. 设定前景色  REG[63h], [64h], [65h]
;;;1034   		5. 开启BTE 功能  REG[50h] Bit7 = 1
;;;1035   		6. 检查状态缓存器 STSR Bit6，确认BTE 是否完成
;;;1036   	*/
;;;1037   	BTE_SetTarBlock(s_WinX, s_WinY, s_WinHeight, s_WinWidth, 0);	/* 设置BTE位置和宽度高度以及目标图层（0或1） */
000002  4c12              LDR      r4,|L2.76|
000004  2600              MOVS     r6,#0
000006  9600              STR      r6,[sp,#0]
000008  4605              MOV      r5,r0                 ;1023
00000a  8923              LDRH     r3,[r4,#8]  ; s_WinWidth
00000c  88e2              LDRH     r2,[r4,#6]  ; s_WinHeight
00000e  88a1              LDRH     r1,[r4,#4]  ; s_WinY
000010  8860              LDRH     r0,[r4,#2]  ; s_WinX
000012  f7fffffe          BL       BTE_SetTarBlock
;;;1038   	BTE_SetOperateCode(0x0C);		/* 设定BTE 操作码和光栅运算码  REG[51h] Bit[3:0] = 0Ch */
000016  210c              MOVS     r1,#0xc
000018  2051              MOVS     r0,#0x51
00001a  f7fffffe          BL       RA8875_WriteReg
;;;1039   	RA8875_SetFrontColor(_usColor);	/* 设置BTE前景色 */
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       RA8875_SetFrontColor
000024  2001              MOVS     r0,#1
000026  7020              STRB     r0,[r4,#0]
000028  2050              MOVS     r0,#0x50
00002a  f7fffffe          BL       RA8875_WriteCmd
00002e  2080              MOVS     r0,#0x80
000030  f7fffffe          BL       RA8875_WriteData
000034  2500              MOVS     r5,#0
000036  4f06              LDR      r7,|L2.80|
                  |L2.56|
000038  f7fffffe          BL       RA8875_ReadStatus
00003c  0640              LSLS     r0,r0,#25
00003e  d502              BPL      |L2.70|
000040  1c6d              ADDS     r5,r5,#1
000042  42bd              CMP      r5,r7
000044  d3f8              BCC      |L2.56|
                  |L2.70|
000046  7026              STRB     r6,[r4,#0]
;;;1040   	BTE_Start();					/* 开启BTE 功能 */
;;;1041   	BTE_Wait();						/* 等待操作结束 */
;;;1042   }
000048  bdf8              POP      {r3-r7,pc}
;;;1043   
                          ENDP

00004a  0000              DCW      0x0000
                  |L2.76|
                          DCD      ||.data||
                  |L2.80|
                          DCD      0x000186a0

                          AREA ||i.RA8875_CtrlGPO||, CODE, READONLY, ALIGN=1

                  RA8875_CtrlGPO PROC
;;;1947   */
;;;1948   void RA8875_CtrlGPO(uint8_t _pin, uint8_t _value)
000000  4081              LSLS     r1,r1,r0
;;;1949   {
;;;1950   	RA8875_WriteReg(0x13, _value << _pin);
000002  b2c9              UXTB     r1,r1
000004  2013              MOVS     r0,#0x13
000006  f7ffbffe          B.W      RA8875_WriteReg
;;;1951   }
;;;1952   
                          ENDP


                          AREA ||i.RA8875_DispAscii||, CODE, READONLY, ALIGN=2

                  RA8875_DispAscii PROC
;;;1635   */
;;;1636   void RA8875_DispAscii(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1637   {
000002  4615              MOV      r5,r2
;;;1638   	/*
;;;1639   		RA8875 内建8x16 点的ASCII 字型ROM，提供使用者更方便的方式用特定编码 (Code) 输入文
;;;1640   		字。内建的字集支持ISO/IEC 8859-1~4 编码标准，此外，使用者可以透过REG[60h~62h] 选择
;;;1641   		文字前景颜色，以及透过REG[63h~65h] 选择背景颜色.
;;;1642   
;;;1643   		ISO/IEC 8859-1，又称Latin-1或“西欧语言”，是国际标准化组织内ISO/IEC 8859的第一个8位字符集。
;;;1644   		它以ASCII为基础，在空置的0xA0-0xFF的范围内，加入192个字母及符号，藉以供使用变音符号的拉丁字母语言使用。
;;;1645   
;;;1646   		ISO/IEC 8859-2 Latin-2或“中欧语言”，是国际标准化组织内ISO/IEC 8859的其中一个8位字符集 .
;;;1647   		ISO/IEC 8859-3 南欧语言字符集
;;;1648   		ISO/IEC 8859-4 北欧语言字符集
;;;1649   	*/
;;;1650   
;;;1651   	/*
;;;1652   	(1) Text mode  REG[40h] bit7=1
;;;1653   	(2) Internal Font ROM Select   REG[21h] bit7=0, bit5=0
;;;1654   	(3) Font foreground and background color Select  REG[63h~65h], REG[60h~62h]
;;;1655   	(4) Write the font Code  CMD_WR[02h]    DATA_WR[font_code]
;;;1656   	*/
;;;1657   	
;;;1658   	RA8875_SetTextCursor(_usX, _usY);
000004  f7fffffe          BL       RA8875_SetTextCursor
;;;1659   
;;;1660   	s_reg_40H |= (1 << 7);
000008  4c16              LDR      r4,|L4.100|
00000a  7860              LDRB     r0,[r4,#1]  ; s_reg_40H
00000c  f0400080          ORR      r0,r0,#0x80
000010  7060              STRB     r0,[r4,#1]
;;;1661   	RA8875_WriteReg(0x40, s_reg_40H);	/* 设置为文本模式 */
000012  7861              LDRB     r1,[r4,#1]  ; s_reg_40H
000014  2040              MOVS     r0,#0x40
000016  f7fffffe          BL       RA8875_WriteReg
;;;1662   
;;;1663   	/* 选择CGROM font; 选择内部CGROM; 内部CGROM 编码选择ISO/IEC 8859-1. */
;;;1664   	RA8875_WriteReg(0x2F, 0x00);
00001a  2100              MOVS     r1,#0
00001c  202f              MOVS     r0,#0x2f
00001e  f7fffffe          BL       RA8875_WriteReg
;;;1665   	RA8875_WriteReg(0x21, (0 << 7) | (0 << 5) | (0 << 1) | (0 << 0));
000022  2100              MOVS     r1,#0
000024  2021              MOVS     r0,#0x21
000026  f7fffffe          BL       RA8875_WriteReg
;;;1666   
;;;1667   	s_ucRA8875Busy = 1;
00002a  2001              MOVS     r0,#1
00002c  7020              STRB     r0,[r4,#0]
;;;1668   
;;;1669   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00002e  2002              MOVS     r0,#2
000030  f7fffffe          BL       RA8875_WriteCmd
;;;1670   
;;;1671   	/* 开始循环处理字符 */
;;;1672   	while (*_ptr != 0)
000034  e007              B        |L4.70|
;;;1673   	{
;;;1674   		RA8875_WriteData(*_ptr);
000036  bf00              NOP      
                  |L4.56|
000038  f7fffffe          BL       RA8875_WriteData
                  |L4.60|
;;;1675   		while ((RA8875_ReadStatus() & 0x80) == 0x80);	/* 必须等待内部写屏操作完成 */
00003c  f7fffffe          BL       RA8875_ReadStatus
000040  0600              LSLS     r0,r0,#24
000042  d4fb              BMI      |L4.60|
000044  1c6d              ADDS     r5,r5,#1
                  |L4.70|
000046  7828              LDRB     r0,[r5,#0]            ;1672
000048  2800              CMP      r0,#0                 ;1672
00004a  d1f5              BNE      |L4.56|
;;;1676   		_ptr++;
;;;1677   	}
;;;1678   	s_ucRA8875Busy = 0;
00004c  7020              STRB     r0,[r4,#0]
;;;1679   
;;;1680   	s_reg_40H &= 0x7F;
00004e  7860              LDRB     r0,[r4,#1]  ; s_reg_40H
000050  f000007f          AND      r0,r0,#0x7f
000054  7060              STRB     r0,[r4,#1]
;;;1681   	RA8875_WriteReg(0x40, s_reg_40H);	/* 还原为图形模式 */
000056  7861              LDRB     r1,[r4,#1]  ; s_reg_40H
000058  e8bd4070          POP      {r4-r6,lr}
00005c  2040              MOVS     r0,#0x40
00005e  f7ffbffe          B.W      RA8875_WriteReg
;;;1682   }
;;;1683   
                          ENDP

000062  0000              DCW      0x0000
                  |L4.100|
                          DCD      ||.data||

                          AREA ||i.RA8875_DispBmpInFlash||, CODE, READONLY, ALIGN=2

                  RA8875_DispBmpInFlash PROC
;;;1056   */
;;;1057   void RA8875_DispBmpInFlash(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth,
000000  b570              PUSH     {r4-r6,lr}
;;;1058   	uint32_t _uiFlashAddr)
;;;1059   {
000002  461d              MOV      r5,r3
000004  4616              MOV      r6,r2
;;;1060   	/* pdf 179页 7-10-1 连续内存直接存取模式
;;;1061   		1. 设定工作窗口范围 (REG[30h] ~REG[37h])和内存写入位置 (REG[46h] ~REG[49h])
;;;1062   		2. 设定Serial Flash/ROM 组态 (REG[05h])
;;;1063   		3. 设定 内存直接存取数据来源起始位置 (REG[B0h] ~REG[B2h])
;;;1064   		4. 设定 内存直接存取区块宽度 (REG[B4h] 和REG[B5h])
;;;1065   		5. 设定 内存直接存取区块高度 (REG[B6h] 和 REG[B7h])
;;;1066   		6. 设定内存直接存取来源图片宽度 (REG[B8h] 和 REG[B9h])
;;;1067   		7. 开启内存直接存取为区块搬移模式 (REG[BFh] bit 1)
;;;1068   		8. 开启内存直接存取起始讯号且检查内存直接存取忙碌讯号 (REG[BFh] bit 0)
;;;1069   	*/
;;;1070   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);	/* REG[30h] ~REG[37h] 和 REG[46h] ~REG[49h] */
000006  9c04              LDR      r4,[sp,#0x10]
000008  f7fffffe          BL       RA8875_SetDispWin
;;;1071   
;;;1072   	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
;;;1073   		7	Serial Flash/ROM I/F # 选择
;;;1074   				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板图库芯片接在 1 接口]
;;;1075   				1:选择Serial Flash/ROM 1 接口。
;;;1076   		6	Serial Flash/ROM 寻址模式
;;;1077   				0: 24 位寻址模式。
;;;1078   				此位必须设为0。
;;;1079   		5	Serial Flash/ROM 波形模式
;;;1080   				0: 波形模式 0。
;;;1081   				1: 波形模式 3。
;;;1082   		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
;;;1083   			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
;;;1084   			01b: 5 bus ??1 byte 空周期。
;;;1085   			1Xb: 6 bus ??2 byte 空周期。
;;;1086   		2	Serial Flash /ROM 存取模式 (Access Mode)
;;;1087   			0: 字型模式 。
;;;1088   			1: DMA 模式。
;;;1089   		1-0	Serial Flash /ROM I/F Data Latch 选择模式
;;;1090   			0Xb: 单一模式。
;;;1091   			10b: 双倍模式0。
;;;1092   			11b: 双倍模式1。
;;;1093   	*/
;;;1094   	
;;;1095   	/* 对于铁框屏，一片 W25Q128，前面2MB是字库。后面14MB是图片 */
;;;1096   	if (g_tW25.ChipID == W25Q128)
00000c  4829              LDR      r0,|L5.180|
00000e  492a              LDR      r1,|L5.184|
000010  6800              LDR      r0,[r0,#0]  ; g_tW25
000012  4288              CMP      r0,r1
000014  d104              BNE      |L5.32|
;;;1097   	{
;;;1098   		_uiFlashAddr += PIC_OFFSET;	/* 前面2MB分配给字库 */	
;;;1099   		#ifdef FLASH_DUAL_SPEED_EN			/* 双速模式， MOSI和MISO同时读取数据 */
;;;1100   			RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (2 << 0));
000016  2126              MOVS     r1,#0x26
000018  2005              MOVS     r0,#5
00001a  f5041400          ADD      r4,r4,#0x200000
00001e  e001              B        |L5.36|
                  |L5.32|
;;;1101   		#else				/* 普通模式，仅 MISO 读取数据 */
;;;1102   			RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (0 << 0));
;;;1103   		#endif		
;;;1104   	}	
;;;1105   	else	/* 增强型屏，1片W25Q64(8MB)做字库，1片W25Q64(8MB)做图库 */
;;;1106   	{
;;;1107   		#ifdef FLASH_DUAL_SPEED_EN			/* 双速模式， MOSI和MISO同时读取数据 */
;;;1108   			RA8875_WriteReg(0x05, (1 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (2 << 0));
000020  21a6              MOVS     r1,#0xa6
000022  2005              MOVS     r0,#5
                  |L5.36|
000024  f7fffffe          BL       RA8875_WriteReg
;;;1109   		#else				/* 普通模式，仅 MISO 读取数据 */
;;;1110   			RA8875_WriteReg(0x05, (1 << 7) | (0 << 6) | (1 << 5) | (0 << 3) | (1 << 2) | (0 << 0));
;;;1111   		#endif	
;;;1112   	}
;;;1113   
;;;1114   	/*
;;;1115   		Serial Flash/ROM 频率频率设定
;;;1116   			0xb: SFCL 频率 = 系统频率频率(当DMA 为使能状态，并且色彩深度为256 色，则SFCL 频率
;;;1117   				固定为=系统频率频率/ 2)
;;;1118   			10b: SFCL 频率 =系统频率频率/ 2
;;;1119   			11b: SFCL 频率 =系统频率频率/ 4
;;;1120   
;;;1121   		安富莱TFT驱动板。4.3寸系统频率为 68MHz； 7寸系统频率为 81.25MHz。
;;;1122   
;;;1123   		8M串行Flash的访问速度:SPI 时钟频率:80MHz(max.)
;;;1124   		因此可以设置为 1 分频
;;;1125   	*/
;;;1126   	RA8875_WriteReg(0x06, (0 << 0));	/* 设置SCL时钟频率 */
000028  2100              MOVS     r1,#0
00002a  2006              MOVS     r0,#6
00002c  f7fffffe          BL       RA8875_WriteReg
;;;1127   
;;;1128   	/* 设定源地址
;;;1129   		B0H   DMA 来源开始位置[7:0]
;;;1130   		B1H   DMA 来源开始位置[15:8]
;;;1131   		B2H   DMA 来源开始位置[23:16]
;;;1132   	*/
;;;1133   	RA8875_WriteReg(0xB0, (uint8_t)_uiFlashAddr);
000030  b2e1              UXTB     r1,r4
000032  20b0              MOVS     r0,#0xb0
000034  f7fffffe          BL       RA8875_WriteReg
;;;1134   	RA8875_WriteReg(0xB1, (uint8_t)(_uiFlashAddr >> 8));
000038  f3c42107          UBFX     r1,r4,#8,#8
00003c  20b1              MOVS     r0,#0xb1
00003e  f7fffffe          BL       RA8875_WriteReg
;;;1135   	RA8875_WriteReg(0xB2, (uint8_t)(_uiFlashAddr >> 16));
000042  f3c44107          UBFX     r1,r4,#16,#8
000046  20b2              MOVS     r0,#0xb2
000048  f7fffffe          BL       RA8875_WriteReg
;;;1136   
;;;1137   	/*
;;;1138   		设置区块大小
;;;1139   		B4   DMA 区块宽度[7:0]
;;;1140   		B5   DMA 区块宽度[9:8]
;;;1141   		B6   DMA 区块高度[7:0]
;;;1142   	    B7   DMA 区块高度[9:8]
;;;1143   	    B8   DMA 来源图片宽度[7:0]
;;;1144   	    B9   DMA 来源图片宽度[9:8]
;;;1145   	*/
;;;1146   	RA8875_WriteReg(0xB4, _usWidth);		/* DMA 区块宽度 */
00004c  b2e9              UXTB     r1,r5
00004e  20b4              MOVS     r0,#0xb4
000050  f7fffffe          BL       RA8875_WriteReg
;;;1147   	RA8875_WriteReg(0xB5, _usWidth >> 8);
000054  0a2c              LSRS     r4,r5,#8
000056  4621              MOV      r1,r4
000058  20b5              MOVS     r0,#0xb5
00005a  f7fffffe          BL       RA8875_WriteReg
;;;1148   
;;;1149   	RA8875_WriteReg(0xB6, _usHeight);		/* DMA 区块高度 */
00005e  b2f1              UXTB     r1,r6
000060  20b6              MOVS     r0,#0xb6
000062  f7fffffe          BL       RA8875_WriteReg
;;;1150   	RA8875_WriteReg(0xB7, _usHeight >> 8);
000066  0a31              LSRS     r1,r6,#8
000068  20b7              MOVS     r0,#0xb7
00006a  f7fffffe          BL       RA8875_WriteReg
;;;1151   
;;;1152   	RA8875_WriteReg(0xB8, _usWidth);		/* DMA 来源图片宽度 */
00006e  b2e9              UXTB     r1,r5
000070  20b8              MOVS     r0,#0xb8
000072  f7fffffe          BL       RA8875_WriteReg
000076  4621              MOV      r1,r4
;;;1153   	RA8875_WriteReg(0xB9, _usWidth >> 8);
000078  20b9              MOVS     r0,#0xb9
00007a  f7fffffe          BL       RA8875_WriteReg
;;;1154   
;;;1155   	RA8875_WriteReg(0xBF, 1 << 1);			/* 选择区块模式 */
00007e  2102              MOVS     r1,#2
000080  20bf              MOVS     r0,#0xbf
000082  f7fffffe          BL       RA8875_WriteReg
;;;1156   	RA8875_WriteReg(0xBF, 1 << 1);			/* 选择区块模式 */
000086  2102              MOVS     r1,#2
000088  20bf              MOVS     r0,#0xbf
00008a  f7fffffe          BL       RA8875_WriteReg
;;;1157   
;;;1158   	s_ucRA8875Busy = 1;
00008e  4c0b              LDR      r4,|L5.188|
000090  2001              MOVS     r0,#1
000092  7020              STRB     r0,[r4,#0]
;;;1159   	RA8875_WriteCmd(0xBF);
000094  20bf              MOVS     r0,#0xbf
000096  f7fffffe          BL       RA8875_WriteCmd
;;;1160   	RA8875_WriteData((1 << 1) | (1 << 0));
00009a  2003              MOVS     r0,#3
00009c  f7fffffe          BL       RA8875_WriteData
                  |L5.160|
;;;1161   	while (RA8875_ReadReg_Int(0xBF) & (1 << 0));	/* 等待结束 */
0000a0  20bf              MOVS     r0,#0xbf
0000a2  f7fffffe          BL       RA8875_ReadReg_Int
0000a6  07c0              LSLS     r0,r0,#31
0000a8  d1fa              BNE      |L5.160|
;;;1162   	s_ucRA8875Busy = 0;
0000aa  7020              STRB     r0,[r4,#0]
;;;1163   
;;;1164   	RA8875_QuitWinMode();					/* 退出小窗口绘图模式 */
0000ac  e8bd4070          POP      {r4-r6,lr}
0000b0  f7ffbffe          B.W      RA8875_QuitWinMode
;;;1165   }
;;;1166   
                          ENDP

                  |L5.180|
                          DCD      g_tW25
                  |L5.184|
                          DCD      0x00ef4018
                  |L5.188|
                          DCD      ||.data||

                          AREA ||i.RA8875_DispOff||, CODE, READONLY, ALIGN=1

                  RA8875_DispOff PROC
;;;903    */
;;;904    void RA8875_DispOff(void)
000000  2100              MOVS     r1,#0
;;;905    {
;;;906    	RA8875_WriteReg(0x01, 0x00);
000002  2001              MOVS     r0,#1
000004  f7ffbffe          B.W      RA8875_WriteReg
;;;907    }
;;;908    
                          ENDP


                          AREA ||i.RA8875_DispOn||, CODE, READONLY, ALIGN=1

                  RA8875_DispOn PROC
;;;890    */
;;;891    void RA8875_DispOn(void)
000000  2180              MOVS     r1,#0x80
;;;892    {
;;;893    	RA8875_WriteReg(0x01, 0x80);
000002  2001              MOVS     r0,#1
000004  f7ffbffe          B.W      RA8875_WriteReg
;;;894    }
;;;895    
                          ENDP


                          AREA ||i.RA8875_DispStr||, CODE, READONLY, ALIGN=2

                  RA8875_DispStr PROC
;;;1695   */
;;;1696   void RA8875_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr)
000000  b570              PUSH     {r4-r6,lr}
;;;1697   {
000002  4615              MOV      r5,r2
;;;1698   	/*
;;;1699   		RA8875 透过使用 ― 上海集通公司 (Genitop Inc) 外部串行式字体内存 (Font ROM)，可支持各样
;;;1700   		的文字写入到DDRAM 中。RA8875 与上海集通公司 (Genitop Inc) 兼容的产品包含 :
;;;1701   		GT21L16TW/GT21H16T1W 、GT23L16U2W 、GT23L24T3Y/GT23H24T3Y 、GT23L24M1Z 、
;;;1702   		及 GT23L32S4W/GT23H32S4W。这些字体包含16x16, 24x24, 32x32 点 (Dot) 与不同的字
;;;1703   
;;;1704   		安富莱RA8875驱动板集成的字库芯片为 集通字库芯片_GT23l32S4W
;;;1705   
;;;1706   		GT23L32S4W是一款内含11X12点阵、15X16点、24X24点阵、32X32点阵的汉字库芯片，支持GB2312
;;;1707   		国标汉字（含有国家信标委合法授权）及SCII字符。排列格式为横置横排。用户通过字符内码，利用本手
;;;1708   		册提供的方法计算出该字符点阵在芯片中的地址，可从该地址连续读出字符点阵信息。
;;;1709   	*/
;;;1710   
;;;1711   	/* 设置文本显示位置，注意文本模式的写入光标和图形模式的写入光标是不同的寄存器 */
;;;1712   	RA8875_SetTextCursor(_usX, _usY);
000004  f7fffffe          BL       RA8875_SetTextCursor
;;;1713   
;;;1714   	//RA8875_SetTextZoom(0, 0);	/* for test */
;;;1715   	
;;;1716   	s_reg_40H |= (1 << 7);
000008  4c1a              LDR      r4,|L8.116|
00000a  7860              LDRB     r0,[r4,#1]  ; s_reg_40H
00000c  f0400080          ORR      r0,r0,#0x80
000010  7060              STRB     r0,[r4,#1]
;;;1717   	RA8875_WriteReg(0x40, s_reg_40H);	/* 设置为文本模式 */
000012  7861              LDRB     r1,[r4,#1]  ; s_reg_40H
000014  2040              MOVS     r0,#0x40
000016  f7fffffe          BL       RA8875_WriteReg
;;;1718   
;;;1719   	/*
;;;1720   		Serial Flash/ROM 频率频率设定
;;;1721   			0xb: SFCL 频率 = 系统频率频率(当DMA 为致能状态，并且色彩深度为256 色，则SFCL 频率
;;;1722   				固定为=系统频率频率/ 2)
;;;1723   			10b: SFCL 频率 =系统频率频率/ 2
;;;1724   			11b: SFCL 频率 =系统频率频率/ 4
;;;1725   
;;;1726   		安富莱驱动板系统频率为 68MHz
;;;1727   
;;;1728   		GT23L32S4W的访问速度:SPI 时钟频率:20MHz(max.)
;;;1729   
;;;1730   		因此需要设置 4 分频, 17MHz
;;;1731   	*/
;;;1732   	RA8875_WriteReg(0x06, (3 << 0));	/* 设置为文本模式 */
00001a  2103              MOVS     r1,#3
00001c  2006              MOVS     r0,#6
00001e  f7fffffe          BL       RA8875_WriteReg
;;;1733   
;;;1734   	/* 选择外部字体ROM */
;;;1735   	RA8875_WriteReg(0x21, (0 << 7) | (1 << 5));
000022  2120              MOVS     r1,#0x20
000024  2021              MOVS     r0,#0x21
000026  f7fffffe          BL       RA8875_WriteReg
;;;1736   
;;;1737   	/* 05H  REG[05h] Serial Flash/ROM Configuration Register (SROC)
;;;1738   		7	Serial Flash/ROM I/F # 选择
;;;1739   				0:选择Serial Flash/ROM 0 接口。[安富莱RA8875驱动板字库芯片接在 0 接口]
;;;1740   				1:选择Serial Flash/ROM 1 接口。
;;;1741   		6	Serial Flash/ROM 寻址模式
;;;1742   				0: 24 位寻址模式。
;;;1743   				此位必须设为0。
;;;1744   		5	Serial Flash/ROM 波形模式
;;;1745   				0: 波形模式 0。
;;;1746   				1: 波形模式 3。
;;;1747   		4-3	Serial Flash /ROM 读取周期 (Read Cycle)
;;;1748   			00b: 4 bus ?? 无空周期 (No Dummy Cycle)。
;;;1749   			01b: 5 bus ??1 byte 空周期。
;;;1750   			1Xb: 6 bus ??2 byte 空周期。
;;;1751   		2	Serial Flash /ROM 存取模式 (Access Mode)
;;;1752   			0: 字型模式 。
;;;1753   			1: DMA 模式。
;;;1754   		1-0	Serial Flash /ROM I/F Data Latch 选择模式
;;;1755   			0Xb: 单一模式。
;;;1756   			10b: 双倍模式0。
;;;1757   			11b: 双倍模式1。
;;;1758   	*/
;;;1759   	RA8875_WriteReg(0x05, (0 << 7) | (0 << 6) | (1 << 5) | (1 << 3) | (0 << 2) | (0 << 1));
00002a  2128              MOVS     r1,#0x28
00002c  2005              MOVS     r0,#5
00002e  f7fffffe          BL       RA8875_WriteReg
;;;1760   
;;;1761   	/*
;;;1762   		设置外部字体芯片型号为 GT23L32S4W, 编码为GB2312,
;;;1763   
;;;1764   		Bit1:0 决定ASCII字符的格式:
;;;1765   			0 = NORMAL		 [笔画细, 和汉字顶部对齐]
;;;1766   			1 = Arial		 [笔画粗，和汉字底部对齐]
;;;1767   			2 = Roman		 [笔画细, 和汉字底部对齐]
;;;1768   			3 = Bold		 [乱码,不可用]
;;;1769   	 */
;;;1770   	RA8875_WriteReg(0x2F, (4 << 5) | (0 << 2) | (1 << 0));
000032  2181              MOVS     r1,#0x81
000034  202f              MOVS     r0,#0x2f
000036  f7fffffe          BL       RA8875_WriteReg
;;;1771   
;;;1772   	s_ucRA8875Busy = 1;
00003a  2001              MOVS     r0,#1
00003c  7020              STRB     r0,[r4,#0]
;;;1773   	RA8875_WriteCmd(0x02); 			/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00003e  2002              MOVS     r0,#2
000040  f7fffffe          BL       RA8875_WriteCmd
;;;1774   
;;;1775   	/* 开始循环处理字符 */
;;;1776   	while (*_ptr != 0)
000044  e007              B        |L8.86|
;;;1777   	{
;;;1778   		RA8875_WriteData(*_ptr);
000046  bf00              NOP      
                  |L8.72|
000048  f7fffffe          BL       RA8875_WriteData
                  |L8.76|
;;;1779   		while ((RA8875_ReadStatus() & 0x80) == 0x80);
00004c  f7fffffe          BL       RA8875_ReadStatus
000050  0600              LSLS     r0,r0,#24
000052  d4fb              BMI      |L8.76|
000054  1c6d              ADDS     r5,r5,#1
                  |L8.86|
000056  7828              LDRB     r0,[r5,#0]            ;1776
000058  2800              CMP      r0,#0                 ;1776
00005a  d1f5              BNE      |L8.72|
;;;1780   		//while ((RA8875_ReadStatus() & 0x01) != 0);	
;;;1781   		//while(RA8875_ReadBusy());
;;;1782   		_ptr++;
;;;1783   	}
;;;1784   	s_ucRA8875Busy = 0;
00005c  7020              STRB     r0,[r4,#0]
;;;1785   
;;;1786   	s_reg_40H &= 0x7F;
00005e  7860              LDRB     r0,[r4,#1]  ; s_reg_40H
000060  f000007f          AND      r0,r0,#0x7f
000064  7060              STRB     r0,[r4,#1]
;;;1787   	RA8875_WriteReg(0x40, s_reg_40H);	/* 还原为图形模式 */
000066  7861              LDRB     r1,[r4,#1]  ; s_reg_40H
000068  e8bd4070          POP      {r4-r6,lr}
00006c  2040              MOVS     r0,#0x40
00006e  f7ffbffe          B.W      RA8875_WriteReg
;;;1788   }
;;;1789   
                          ENDP

000072  0000              DCW      0x0000
                  |L8.116|
                          DCD      ||.data||

                          AREA ||i.RA8875_DrawBMP||, CODE, READONLY, ALIGN=2

                  RA8875_DrawBMP PROC
;;;1178   */
;;;1179   void RA8875_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1180   {
000004  4698              MOV      r8,r3
000006  4616              MOV      r6,r2
;;;1181   	uint32_t index = 0;
000008  2500              MOVS     r5,#0
;;;1182   	const uint16_t *p;
;;;1183   
;;;1184   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1185   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
00000a  9c06              LDR      r4,[sp,#0x18]
00000c  f7fffffe          BL       RA8875_SetDispWin
;;;1186   
;;;1187   	s_ucRA8875Busy = 1;
000010  4f0b              LDR      r7,|L9.64|
000012  2001              MOVS     r0,#1
000014  7038              STRB     r0,[r7,#0]
;;;1188   
;;;1189   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
000016  2002              MOVS     r0,#2
000018  f7fffffe          BL       RA8875_WriteCmd
;;;1190   
;;;1191   	p = _ptr;
;;;1192   	for (index = 0; index < _usHeight * _usWidth; index++)
00001c  fb06f608          MUL      r6,r6,r8
000020  e005              B        |L9.46|
;;;1193   	{
;;;1194   		/*
;;;1195   			armfly : 进行优化, 函数就地展开
;;;1196   			RA8875_WriteRAM(_ptr[index]);
;;;1197   
;;;1198   			此处可考虑用DMA操作
;;;1199   		*/
;;;1200   		RA8875_WriteData16(*p++);
000022  bf00              NOP      
                  |L9.36|
000024  f8340b02          LDRH     r0,[r4],#2
000028  f7fffffe          BL       RA8875_WriteData16
00002c  1c6d              ADDS     r5,r5,#1
                  |L9.46|
00002e  42ae              CMP      r6,r5                 ;1192
000030  d8f8              BHI      |L9.36|
;;;1201   	}
;;;1202   	s_ucRA8875Busy = 0;
000032  2000              MOVS     r0,#0
000034  7038              STRB     r0,[r7,#0]
;;;1203   
;;;1204   	/* 退出窗口绘图模式 */
;;;1205   	RA8875_QuitWinMode();
000036  e8bd41f0          POP      {r4-r8,lr}
00003a  f7ffbffe          B.W      RA8875_QuitWinMode
;;;1206   }
;;;1207   
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      ||.data||

                          AREA ||i.RA8875_DrawCircle||, CODE, READONLY, ALIGN=2

                  RA8875_DrawCircle PROC
;;;1457   */
;;;1458   void RA8875_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1459   {
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  4605              MOV      r5,r0
00000a  460c              MOV      r4,r1
;;;1460   	/*
;;;1461   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1462   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1463   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1464   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1465   		画出空心圆 (Not Fill
;;;1466   	*/
;;;1467   	/* 设置圆的半径 */
;;;1468   	if (_usRadius > 255)
00000c  2aff              CMP      r2,#0xff
00000e  d829              BHI      |L10.100|
;;;1469   	{
;;;1470   		return;
;;;1471   	}
;;;1472   
;;;1473   	if (g_LcdDirection > 1)	/* 竖屏  */
000010  4815              LDR      r0,|L10.104|
000012  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000014  2801              CMP      r0,#1
000016  d901              BLS      |L10.28|
;;;1474   	{
;;;1475   		uint16_t temp;
;;;1476   		
;;;1477   		temp = _usX;
000018  462c              MOV      r4,r5
;;;1478   		_usX = _usY;
00001a  460d              MOV      r5,r1
                  |L10.28|
;;;1479   		_usY = temp;
;;;1480   	}
;;;1481   	
;;;1482   	/* 设置圆心坐标 */
;;;1483   	RA8875_WriteReg(0x99, _usX);
00001c  b2e9              UXTB     r1,r5
00001e  2099              MOVS     r0,#0x99
000020  f7fffffe          BL       RA8875_WriteReg
;;;1484   	RA8875_WriteReg(0x9A, _usX >> 8);
000024  0a29              LSRS     r1,r5,#8
000026  209a              MOVS     r0,#0x9a
000028  f7fffffe          BL       RA8875_WriteReg
;;;1485   	RA8875_WriteReg(0x9B, _usY);
00002c  b2e1              UXTB     r1,r4
00002e  209b              MOVS     r0,#0x9b
000030  f7fffffe          BL       RA8875_WriteReg
;;;1486   	RA8875_WriteReg(0x9C, _usY >> 8);
000034  0a21              LSRS     r1,r4,#8
000036  209c              MOVS     r0,#0x9c
000038  f7fffffe          BL       RA8875_WriteReg
;;;1487   
;;;1488   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
00003c  b2f1              UXTB     r1,r6
00003e  209d              MOVS     r0,#0x9d
000040  f7fffffe          BL       RA8875_WriteReg
;;;1489   
;;;1490   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       RA8875_SetFrontColor
;;;1491   
;;;1492   	s_ucRA8875Busy = 1;
00004a  4c08              LDR      r4,|L10.108|
00004c  2001              MOVS     r0,#1
00004e  7020              STRB     r0,[r4,#0]
;;;1493   //	RA8875_WriteReg(0x90, (1 << 6) | (0 << 5));				/* 开始画圆, 不填充  */
;;;1494   	RA8875_WriteCmd(0x90);
000050  2090              MOVS     r0,#0x90
000052  f7fffffe          BL       RA8875_WriteCmd
;;;1495   	RA8875_WriteData( (1 << 6) | (0 << 5));
000056  2040              MOVS     r0,#0x40
000058  f7fffffe          BL       RA8875_WriteData
;;;1496   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1497   	RA8875_WaitBusy();
00005c  f7fffffe          BL       RA8875_WaitBusy
;;;1498   	s_ucRA8875Busy = 0;
000060  2000              MOVS     r0,#0
000062  7020              STRB     r0,[r4,#0]
                  |L10.100|
;;;1499   }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;1500   
                          ENDP

                  |L10.104|
                          DCD      g_LcdDirection
                  |L10.108|
                          DCD      ||.data||

                          AREA ||i.RA8875_DrawLine||, CODE, READONLY, ALIGN=2

                  RA8875_DrawLine PROC
;;;1260   */
;;;1261   void RA8875_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1262   {
000004  4617              MOV      r7,r2
;;;1263   	/* pdf 第131页
;;;1264   		RA8875 支持直线绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画直线。先设
;;;1265   		定直线的起始点REG[91h~94h] 与结束点REG[95h~98h]，直线的颜色REG[63h~65h]，然后启
;;;1266   		动绘图设定REG[90h] Bit4 = 0, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将直线的图形写入
;;;1267   		DDRAM，相对的在TFT 模块上就可以显示所画的直线。
;;;1268   	*/
;;;1269   
;;;1270   	if ((_usX1 == _usX2) && (_usY1 == _usY2))
000006  f8dd8018          LDR      r8,[sp,#0x18]
00000a  461e              MOV      r6,r3                 ;1262
00000c  460c              MOV      r4,r1                 ;1262
00000e  4605              MOV      r5,r0                 ;1262
000010  42b8              CMP      r0,r7
000012  d106              BNE      |L11.34|
000014  42b4              CMP      r4,r6
000016  d104              BNE      |L11.34|
;;;1271   	{
;;;1272   		RA8875_PutPixel(_usX1, _usY1, _usColor);
000018  4642              MOV      r2,r8
00001a  e8bd41f0          POP      {r4-r8,lr}
00001e  f7ffbffe          B.W      RA8875_PutPixel
                  |L11.34|
;;;1273   		return;
;;;1274   	}
;;;1275   
;;;1276   	if (g_LcdDirection > 1)	/* 竖屏  */
000022  481d              LDR      r0,|L11.152|
000024  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000026  2801              CMP      r0,#1
000028  d903              BLS      |L11.50|
;;;1277   	{
;;;1278   		uint16_t temp;
;;;1279   		
;;;1280   		temp = _usX1;
00002a  462c              MOV      r4,r5
;;;1281   		_usX1 = _usY1;
00002c  460d              MOV      r5,r1
;;;1282   		_usY1 = temp;
;;;1283   
;;;1284   		temp = _usX2;
;;;1285   		_usX2 = _usY2;
00002e  461f              MOV      r7,r3
;;;1286   		_usY2 = temp;		
000030  4616              MOV      r6,r2
                  |L11.50|
;;;1287   	}
;;;1288   	
;;;1289   	/* 设置起点坐标 */
;;;1290   	RA8875_WriteReg(0x91, _usX1);
000032  b2e9              UXTB     r1,r5
000034  2091              MOVS     r0,#0x91
000036  f7fffffe          BL       RA8875_WriteReg
;;;1291   	RA8875_WriteReg(0x92, _usX1 >> 8);
00003a  0a29              LSRS     r1,r5,#8
00003c  2092              MOVS     r0,#0x92
00003e  f7fffffe          BL       RA8875_WriteReg
;;;1292   	RA8875_WriteReg(0x93, _usY1);
000042  b2e1              UXTB     r1,r4
000044  2093              MOVS     r0,#0x93
000046  f7fffffe          BL       RA8875_WriteReg
;;;1293   	RA8875_WriteReg(0x94, _usY1 >> 8);
00004a  0a21              LSRS     r1,r4,#8
00004c  2094              MOVS     r0,#0x94
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1294   
;;;1295   	/* 设置终点坐标 */
;;;1296   	RA8875_WriteReg(0x95, _usX2);
000052  b2f9              UXTB     r1,r7
000054  2095              MOVS     r0,#0x95
000056  f7fffffe          BL       RA8875_WriteReg
;;;1297   	RA8875_WriteReg(0x96, _usX2 >> 8);
00005a  0a39              LSRS     r1,r7,#8
00005c  2096              MOVS     r0,#0x96
00005e  f7fffffe          BL       RA8875_WriteReg
;;;1298   	RA8875_WriteReg(0x97, _usY2);
000062  b2f1              UXTB     r1,r6
000064  2097              MOVS     r0,#0x97
000066  f7fffffe          BL       RA8875_WriteReg
;;;1299   	RA8875_WriteReg(0x98, _usY2 >> 8);
00006a  0a31              LSRS     r1,r6,#8
00006c  2098              MOVS     r0,#0x98
00006e  f7fffffe          BL       RA8875_WriteReg
;;;1300   
;;;1301   	RA8875_SetFrontColor(_usColor);	/* 设置直线的颜色 */
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       RA8875_SetFrontColor
;;;1302   
;;;1303   	s_ucRA8875Busy = 1;
000078  4c08              LDR      r4,|L11.156|
00007a  2001              MOVS     r0,#1
00007c  7020              STRB     r0,[r4,#0]
;;;1304   //	RA8875_WriteReg(0x90, (1 << 7) | (0 << 4) | (0 << 0));/* 开始画直线 */
;;;1305   	RA8875_WriteCmd(0x90);
00007e  2090              MOVS     r0,#0x90
000080  f7fffffe          BL       RA8875_WriteCmd
;;;1306   	RA8875_WriteData((1 << 7) | (0 << 4) | (0 << 0));
000084  2080              MOVS     r0,#0x80
000086  f7fffffe          BL       RA8875_WriteData
;;;1307   //	while (RA8875_ReadReg(0x90) & (1 << 7));				/* 等待结束 */
;;;1308   	RA8875_WaitBusy();
00008a  f7fffffe          BL       RA8875_WaitBusy
;;;1309   	s_ucRA8875Busy = 0;
00008e  2000              MOVS     r0,#0
000090  7020              STRB     r0,[r4,#0]
;;;1310   }
000092  e8bd81f0          POP      {r4-r8,pc}
;;;1311   
                          ENDP

000096  0000              DCW      0x0000
                  |L11.152|
                          DCD      g_LcdDirection
                  |L11.156|
                          DCD      ||.data||

                          AREA ||i.RA8875_DrawRect||, CODE, READONLY, ALIGN=2

                  RA8875_DrawRect PROC
;;;1323   */
;;;1324   void RA8875_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1325   {
000004  4605              MOV      r5,r0
;;;1326   	/*
;;;1327   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1328   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1329   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1330   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1331   	实心方形 (Fill)
;;;1332   
;;;1333   	 ---------------->---
;;;1334   	|(_usX，_usY)        |
;;;1335   	V                    V  _usHeight
;;;1336   	|                    |
;;;1337   	 ---------------->---
;;;1338   		  _usWidth
;;;1339   	*/
;;;1340   
;;;1341   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  4822              LDR      r0,|L12.144|
000008  f8dd8018          LDR      r8,[sp,#0x18]
00000c  461e              MOV      r6,r3                 ;1325
00000e  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000010  4617              MOV      r7,r2                 ;1325
000012  460c              MOV      r4,r1                 ;1325
000014  2801              CMP      r0,#1
000016  d903              BLS      |L12.32|
;;;1342   	{
;;;1343   		uint16_t temp;
;;;1344   		
;;;1345   		temp = _usX;
000018  462c              MOV      r4,r5
;;;1346   		_usX = _usY;
00001a  460d              MOV      r5,r1
;;;1347   		_usY = temp;
;;;1348   
;;;1349   		temp = _usHeight;
;;;1350   		_usHeight = _usWidth;
00001c  461f              MOV      r7,r3
;;;1351   		_usWidth = temp;		
00001e  4616              MOV      r6,r2
                  |L12.32|
;;;1352   	}
;;;1353   
;;;1354   	/* 设置起点坐标 */
;;;1355   	RA8875_WriteReg(0x91, _usX);
000020  b2e9              UXTB     r1,r5
000022  2091              MOVS     r0,#0x91
000024  f7fffffe          BL       RA8875_WriteReg
;;;1356   	RA8875_WriteReg(0x92, _usX >> 8);
000028  0a29              LSRS     r1,r5,#8
00002a  2092              MOVS     r0,#0x92
00002c  f7fffffe          BL       RA8875_WriteReg
;;;1357   	RA8875_WriteReg(0x93, _usY);
000030  b2e1              UXTB     r1,r4
000032  2093              MOVS     r0,#0x93
000034  f7fffffe          BL       RA8875_WriteReg
;;;1358   	RA8875_WriteReg(0x94, _usY >> 8);
000038  0a21              LSRS     r1,r4,#8
00003a  2094              MOVS     r0,#0x94
00003c  f7fffffe          BL       RA8875_WriteReg
;;;1359   
;;;1360   	/* 设置终点坐标 */
;;;1361   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
000040  4435              ADD      r5,r5,r6
000042  1e6d              SUBS     r5,r5,#1
000044  b2e9              UXTB     r1,r5
000046  2095              MOVS     r0,#0x95
000048  f7fffffe          BL       RA8875_WriteReg
;;;1362   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
00004c  f3c52107          UBFX     r1,r5,#8,#8
000050  2096              MOVS     r0,#0x96
000052  f7fffffe          BL       RA8875_WriteReg
;;;1363   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
000056  443c              ADD      r4,r4,r7
000058  1e64              SUBS     r4,r4,#1
00005a  b2e1              UXTB     r1,r4
00005c  2097              MOVS     r0,#0x97
00005e  f7fffffe          BL       RA8875_WriteReg
;;;1364   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
000062  f3c42107          UBFX     r1,r4,#8,#8
000066  2098              MOVS     r0,#0x98
000068  f7fffffe          BL       RA8875_WriteReg
;;;1365   
;;;1366   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
00006c  4640              MOV      r0,r8
00006e  f7fffffe          BL       RA8875_SetFrontColor
;;;1367   
;;;1368   	s_ucRA8875Busy = 1;
000072  4c08              LDR      r4,|L12.148|
000074  2001              MOVS     r0,#1
000076  7020              STRB     r0,[r4,#0]
;;;1369   //	RA8875_WriteReg(0x90, (1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));	/* 开始画矩形  */
;;;1370   	RA8875_WriteCmd(0x90);
000078  2090              MOVS     r0,#0x90
00007a  f7fffffe          BL       RA8875_WriteCmd
;;;1371   	RA8875_WriteData((1 << 7) | (0 << 5) | (1 << 4) | (0 << 0));
00007e  2090              MOVS     r0,#0x90
000080  f7fffffe          BL       RA8875_WriteData
;;;1372   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1373   	RA8875_WaitBusy();
000084  f7fffffe          BL       RA8875_WaitBusy
;;;1374   	s_ucRA8875Busy = 0;
000088  2000              MOVS     r0,#0
00008a  7020              STRB     r0,[r4,#0]
;;;1375   }
00008c  e8bd81f0          POP      {r4-r8,pc}
;;;1376   
                          ENDP

                  |L12.144|
                          DCD      g_LcdDirection
                  |L12.148|
                          DCD      ||.data||

                          AREA ||i.RA8875_FillCircle||, CODE, READONLY, ALIGN=2

                  RA8875_FillCircle PROC
;;;1511   */
;;;1512   void RA8875_FillCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1513   {
000004  461f              MOV      r7,r3
000006  4616              MOV      r6,r2
000008  4605              MOV      r5,r0
00000a  460c              MOV      r4,r1
;;;1514   	/*
;;;1515   		RA8875 支持圆形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画圆。先设定
;;;1516   		圆的中心点REG[99h~9Ch]，圆的半径REG[9Dh]，圆的颜色REG[63h~65h]，然后启动绘图
;;;1517   		REG[90h] Bit6 = 1，RA8875 就会将圆的图形写入DDRAM，相对的在TFT 模块上就可以显示所
;;;1518   		画的圆。若设定REG[90h] Bit5 = 1，则可画出一实心圆 (Fill)；若设定REG[90h] Bit5 = 0，则可
;;;1519   		画出空心圆 (Not Fill
;;;1520   	*/
;;;1521   	/* 设置圆的半径 */
;;;1522   	if (_usRadius > 255)
00000c  2aff              CMP      r2,#0xff
00000e  d829              BHI      |L13.100|
;;;1523   	{
;;;1524   		return;
;;;1525   	}
;;;1526   
;;;1527   	if (g_LcdDirection > 1)	/* 竖屏  */
000010  4815              LDR      r0,|L13.104|
000012  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
000014  2801              CMP      r0,#1
000016  d901              BLS      |L13.28|
;;;1528   	{
;;;1529   		uint16_t temp;
;;;1530   		
;;;1531   		temp = _usX;
000018  462c              MOV      r4,r5
;;;1532   		_usX = _usY;
00001a  460d              MOV      r5,r1
                  |L13.28|
;;;1533   		_usY = temp;
;;;1534   	}
;;;1535   	
;;;1536   	/* 设置圆心坐标 */
;;;1537   	RA8875_WriteReg(0x99, _usX);
00001c  b2e9              UXTB     r1,r5
00001e  2099              MOVS     r0,#0x99
000020  f7fffffe          BL       RA8875_WriteReg
;;;1538   	RA8875_WriteReg(0x9A, _usX >> 8);
000024  0a29              LSRS     r1,r5,#8
000026  209a              MOVS     r0,#0x9a
000028  f7fffffe          BL       RA8875_WriteReg
;;;1539   	RA8875_WriteReg(0x9B, _usY);
00002c  b2e1              UXTB     r1,r4
00002e  209b              MOVS     r0,#0x9b
000030  f7fffffe          BL       RA8875_WriteReg
;;;1540   	RA8875_WriteReg(0x9C, _usY >> 8);
000034  0a21              LSRS     r1,r4,#8
000036  209c              MOVS     r0,#0x9c
000038  f7fffffe          BL       RA8875_WriteReg
;;;1541   
;;;1542   	RA8875_WriteReg(0x9D, _usRadius);	/* 设置圆的半径 */
00003c  b2f1              UXTB     r1,r6
00003e  209d              MOVS     r0,#0x9d
000040  f7fffffe          BL       RA8875_WriteReg
;;;1543   
;;;1544   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
000044  4638              MOV      r0,r7
000046  f7fffffe          BL       RA8875_SetFrontColor
;;;1545   
;;;1546   	s_ucRA8875Busy = 1;
00004a  4c08              LDR      r4,|L13.108|
00004c  2001              MOVS     r0,#1
00004e  7020              STRB     r0,[r4,#0]
;;;1547   //	RA8875_WriteReg(0x90, (1 << 6) | (1 << 5));				/* 开始画圆, 填充  */
;;;1548   	RA8875_WriteCmd(0x90);
000050  2090              MOVS     r0,#0x90
000052  f7fffffe          BL       RA8875_WriteCmd
;;;1549   	RA8875_WriteData((1 << 6) | (1 << 5));
000056  2060              MOVS     r0,#0x60
000058  f7fffffe          BL       RA8875_WriteData
;;;1550   //	while (RA8875_ReadReg(0x90) & (1 << 6));				/* 等待结束 */
;;;1551   	RA8875_WaitBusy();
00005c  f7fffffe          BL       RA8875_WaitBusy
;;;1552   	s_ucRA8875Busy = 0;
000060  2000              MOVS     r0,#0
000062  7020              STRB     r0,[r4,#0]
                  |L13.100|
;;;1553   }
000064  e8bd81f0          POP      {r4-r8,pc}
;;;1554   
                          ENDP

                  |L13.104|
                          DCD      g_LcdDirection
                  |L13.108|
                          DCD      ||.data||

                          AREA ||i.RA8875_FillRect||, CODE, READONLY, ALIGN=2

                  RA8875_FillRect PROC
;;;1388   */
;;;1389   void RA8875_FillRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1390   {
000004  001e              MOVS     r6,r3
000006  f8dd8018          LDR      r8,[sp,#0x18]
00000a  4617              MOV      r7,r2
00000c  460c              MOV      r4,r1
00000e  4605              MOV      r5,r0
000010  d03f              BEQ      |L14.146|
;;;1391   	/*
;;;1392   		RA8875 支持方形绘图功能，让使用者以简易或低速的MCU 就可以在TFT 模块上画方形。先设
;;;1393   	定方形的起始点REG[91h~94h]与结束点REG[95h~98h]，方形的颜色REG[63h~65h]，然后启
;;;1394   	动绘图设定REG[90h] Bit4=1, Bit0=0 且REG[90h] Bit7 = 1，RA8875 就会将方形的图形写入
;;;1395   	DDRAM，相对的在TFT 模块上就可以显示所画的方形。若设定REG[90h] Bit5 = 1，则可画出一
;;;1396   	实心方形 (Fill)
;;;1397   
;;;1398   	 ---------------->---
;;;1399   	|(_usX，_usY)        |
;;;1400   	V                    V  _usHeight
;;;1401   	|                    |
;;;1402   	 ---------------->---
;;;1403   		  _usWidth
;;;1404   	*/
;;;1405   
;;;1406   	if (_usWidth == 0 || _usHeight == 0)
000012  2f00              CMP      r7,#0
000014  d03d              BEQ      |L14.146|
;;;1407   	{
;;;1408   		return;
;;;1409   	}
;;;1410   
;;;1411   	if (g_LcdDirection > 1)	/* 竖屏  */
000016  4820              LDR      r0,|L14.152|
000018  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00001a  2801              CMP      r0,#1
00001c  d903              BLS      |L14.38|
;;;1412   	{
;;;1413   		uint16_t temp;
;;;1414   		
;;;1415   		temp = _usX;
00001e  462c              MOV      r4,r5
;;;1416   		_usX = _usY;
000020  460d              MOV      r5,r1
;;;1417   		_usY = temp;
;;;1418   		
;;;1419   		temp = _usHeight;
;;;1420   		_usHeight = _usWidth;
000022  461f              MOV      r7,r3
;;;1421   		_usWidth = temp;
000024  4616              MOV      r6,r2
                  |L14.38|
;;;1422   	}
;;;1423   	
;;;1424   	/* 设置起点坐标 */
;;;1425   	RA8875_WriteReg(0x91, _usX);
000026  b2e9              UXTB     r1,r5
000028  2091              MOVS     r0,#0x91
00002a  f7fffffe          BL       RA8875_WriteReg
;;;1426   	RA8875_WriteReg(0x92, _usX >> 8);
00002e  0a29              LSRS     r1,r5,#8
000030  2092              MOVS     r0,#0x92
000032  f7fffffe          BL       RA8875_WriteReg
;;;1427   	RA8875_WriteReg(0x93, _usY);
000036  b2e1              UXTB     r1,r4
000038  2093              MOVS     r0,#0x93
00003a  f7fffffe          BL       RA8875_WriteReg
;;;1428   	RA8875_WriteReg(0x94, _usY >> 8);
00003e  0a21              LSRS     r1,r4,#8
000040  2094              MOVS     r0,#0x94
000042  f7fffffe          BL       RA8875_WriteReg
;;;1429   
;;;1430   	/* 设置终点坐标 */
;;;1431   	RA8875_WriteReg(0x95, _usX + _usWidth - 1);
000046  4435              ADD      r5,r5,r6
000048  1e6d              SUBS     r5,r5,#1
00004a  b2e9              UXTB     r1,r5
00004c  2095              MOVS     r0,#0x95
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1432   	RA8875_WriteReg(0x96, (_usX + _usWidth - 1) >> 8);
000052  f3c52107          UBFX     r1,r5,#8,#8
000056  2096              MOVS     r0,#0x96
000058  f7fffffe          BL       RA8875_WriteReg
;;;1433   	RA8875_WriteReg(0x97, _usY + _usHeight - 1);
00005c  443c              ADD      r4,r4,r7
00005e  1e64              SUBS     r4,r4,#1
000060  b2e1              UXTB     r1,r4
000062  2097              MOVS     r0,#0x97
000064  f7fffffe          BL       RA8875_WriteReg
;;;1434   	RA8875_WriteReg(0x98, (_usY + _usHeight - 1) >> 8);
000068  f3c42107          UBFX     r1,r4,#8,#8
00006c  2098              MOVS     r0,#0x98
00006e  f7fffffe          BL       RA8875_WriteReg
;;;1435   
;;;1436   	RA8875_SetFrontColor(_usColor);	/* 设置颜色 */
000072  4640              MOV      r0,r8
000074  f7fffffe          BL       RA8875_SetFrontColor
;;;1437   
;;;1438   	s_ucRA8875Busy = 1;
000078  4c08              LDR      r4,|L14.156|
00007a  2001              MOVS     r0,#1
00007c  7020              STRB     r0,[r4,#0]
;;;1439   //	RA8875_WriteReg(0x90, (1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));	/* 开始填充矩形  */
;;;1440   	RA8875_WriteCmd(0x90);
00007e  2090              MOVS     r0,#0x90
000080  f7fffffe          BL       RA8875_WriteCmd
;;;1441   	RA8875_WriteData((1 << 7) | (1 << 5) | (1 << 4) | (0 << 0));
000084  20b0              MOVS     r0,#0xb0
000086  f7fffffe          BL       RA8875_WriteData
;;;1442   //	while (RA8875_ReadReg(0x90) & (1 << 7));							/* 等待结束 */
;;;1443   	RA8875_WaitBusy();
00008a  f7fffffe          BL       RA8875_WaitBusy
;;;1444   	s_ucRA8875Busy = 0;
00008e  2000              MOVS     r0,#0
000090  7020              STRB     r0,[r4,#0]
                  |L14.146|
;;;1445   }
000092  e8bd81f0          POP      {r4-r8,pc}
;;;1446   
                          ENDP

000096  0000              DCW      0x0000
                  |L14.152|
                          DCD      g_LcdDirection
                  |L14.156|
                          DCD      ||.data||

                          AREA ||i.RA8875_GetPixel||, CODE, READONLY, ALIGN=2

                  RA8875_GetPixel PROC
;;;992    */
;;;993    uint16_t RA8875_GetPixel(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;994    {
;;;995    	uint16_t usRGB;
;;;996    
;;;997    //	RA8875_WriteReg(0x40, (1 << 0));	/* 设置为绘图模式，读取光标不自动加1 */
;;;998    
;;;999    	RA8875_SetReadCursor(_usX, _usY);	/* 设置读取光标位置 */
000002  4604              MOV      r4,r0
000004  4812              LDR      r0,|L15.80|
000006  460d              MOV      r5,r1
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  d901              BLS      |L15.18|
00000e  4625              MOV      r5,r4                 ;994
000010  460c              MOV      r4,r1                 ;994
                  |L15.18|
000012  b2e1              UXTB     r1,r4                 ;994
000014  204a              MOVS     r0,#0x4a              ;994
000016  f7fffffe          BL       RA8875_WriteReg
00001a  0a21              LSRS     r1,r4,#8              ;994
00001c  204b              MOVS     r0,#0x4b              ;994
00001e  f7fffffe          BL       RA8875_WriteReg
000022  b2e9              UXTB     r1,r5                 ;994
000024  204c              MOVS     r0,#0x4c              ;994
000026  f7fffffe          BL       RA8875_WriteReg
00002a  0a29              LSRS     r1,r5,#8              ;994
00002c  204d              MOVS     r0,#0x4d              ;994
00002e  f7fffffe          BL       RA8875_WriteReg
;;;1000   
;;;1001   	s_ucRA8875Busy = 1;
000032  4c08              LDR      r4,|L15.84|
000034  2001              MOVS     r0,#1
000036  7020              STRB     r0,[r4,#0]
;;;1002   
;;;1003   	RA8875_WriteCmd(0x02);
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       RA8875_WriteCmd
;;;1004   	usRGB = RA8875_ReadData16();	/* 第1次读取数据丢弃 */
00003e  f7fffffe          BL       RA8875_ReadData16
;;;1005   	usRGB = RA8875_ReadData16();
000042  f7fffffe          BL       RA8875_ReadData16
;;;1006   	usRGB = RA8875_ReadData16();
000046  f7fffffe          BL       RA8875_ReadData16
;;;1007   
;;;1008   	s_ucRA8875Busy = 0;
00004a  2100              MOVS     r1,#0
00004c  7021              STRB     r1,[r4,#0]
;;;1009   
;;;1010   	return usRGB;
;;;1011   }
00004e  bd70              POP      {r4-r6,pc}
;;;1012   
                          ENDP

                  |L15.80|
                          DCD      g_LcdDirection
                  |L15.84|
                          DCD      ||.data||

                          AREA ||i.RA8875_InitHard||, CODE, READONLY, ALIGN=2

                  RA8875_InitHard PROC
;;;152    */
;;;153    void RA8875_InitHard(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;154    {
;;;155    	uint8_t ucGPIX;
;;;156    	
;;;157    	RA8875_ConfigGPIO();	/* 配置GPIO FSMC等 */
000004  f7fffffe          BL       RA8875_ConfigGPIO
;;;158    
;;;159    	/* 读取 RA8875 芯片额GPIX引脚的电平状态；1表示4.3寸屏；0表示7寸屏
;;;160    	【备注】这是安富莱电子为了便于统一测试例程，在LCD模块上做的硬件标识。在做产品时，不必自动识别。
;;;161    	*/
;;;162    	ucGPIX = RA8875_ReadReg(0xC7);
000008  20c7              MOVS     r0,#0xc7
00000a  f7fffffe          BL       RA8875_ReadReg
;;;163    
;;;164    	if (ucGPIX == 1)	/* 	GPIX = 1 表示 4.3 寸屏 480x272 */
;;;165    	{
;;;166    		/* 初始化PLL.  晶振频率为25M */
;;;167    		RA8875_WriteCmd(0x88);
;;;168    		RA8875_Delaly1us();		/* 延迟1us */
;;;169    		RA8875_WriteData(10);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 10 */
;;;170    
;;;171    	    RA8875_Delaly1ms();
;;;172    
;;;173    		RA8875_WriteCmd(0x89);
;;;174    		RA8875_Delaly1us();		/* 延迟1us */
;;;175    		RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */
;;;176    
;;;177    		/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;178    		  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;179    		          = 25M * (10 + 1) / ((0 + 1) * (2 ^ 2))
;;;180    				  = 68.75MHz
;;;181    		*/
;;;182    
;;;183    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;184    	    RA8875_Delaly1ms();
;;;185    		RA8875_Delaly1ms();
;;;186    
;;;187    		/*
;;;188    			配置系统控制寄存器。 中文pdf 第18页:
;;;189    
;;;190    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;191    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;192    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;193    
;;;194    			bit1:0 MCUIF 选择
;;;195    				00b : 8-位MCU 接口。
;;;196    				1xb : 16-位MCU 接口。 【选这个】
;;;197    		*/
;;;198    		if (g_RA8875_IF == RA_HARD_8080_16)
;;;199    		{
;;;200    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
;;;201    		}
;;;202    		else
;;;203    		{
;;;204    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
;;;205    		}
;;;206    
;;;207    		/* REG[04h] Pixel Clock Setting Register   PCSR
;;;208    			bit7  PCLK Inversion
;;;209    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;210    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;211    			bit1:0 PCLK 频率周期设定
;;;212    				Pixel Clock  PCLK 频率周期设定。
;;;213    				00b: PCLK 频率周期= 系统频率周期。
;;;214    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;215    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;216    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;217    		*/
;;;218    	    RA8875_WriteReg(0x04, 0x82);    /* 设置PCLK反相 */
;;;219    	    RA8875_Delaly1ms();
;;;220    
;;;221    	    //Horizontal set
;;;222    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;223    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;224    	    RA8875_WriteReg(0x14, 0x3B);
;;;225    	    RA8875_WriteReg(0x15, 0x00);
;;;226    
;;;227    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;228    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;229    		RA8875_WriteReg(0x16, 0x01);
;;;230    
;;;231    	    //HSTR//HSYNC Start Position[4:0]
;;;232    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;233    		RA8875_WriteReg(0x17, 0x00);
;;;234    
;;;235    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;236    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;237    		RA8875_WriteReg(0x18, 0x05);
;;;238    
;;;239    	    //Vertical set
;;;240    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;241    	    //Vertical pixels = VDHR + 1
;;;242    		RA8875_WriteReg(0x19, 0x0F);
;;;243    
;;;244    	    //VDHR1 //Vertical Display Height Bit [8]
;;;245    	    //Vertical pixels = VDHR + 1
;;;246    		RA8875_WriteReg(0x1A, 0x01);
;;;247    
;;;248    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;249    	    //Vertical Non-Display area = (VNDR + 1)
;;;250    		RA8875_WriteReg(0x1B, 0x02);
;;;251    
;;;252    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;253    	    //Vertical Non-Display area = (VNDR + 1)
;;;254    		RA8875_WriteReg(0x1C, 0x00);
;;;255    
;;;256    	    //VSTR0 //VSYNC Start Position[7:0]
;;;257    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;258    		RA8875_WriteReg(0x1D, 0x07);
;;;259    
;;;260    	    //VSTR1 //VSYNC Start Position[8]
;;;261    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;262    		RA8875_WriteReg(0x1E, 0x00);
;;;263    
;;;264    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;265    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;266    	    RA8875_WriteReg(0x1F, 0x09);
;;;267    
;;;268    
;;;269    	    g_LcdHeight = LCD_43_HEIGHT;
00000e  4d6e              LDR      r5,|L16.456|
;;;270    		g_LcdWidth = LCD_43_WIDTH;
000010  4e6e              LDR      r6,|L16.460|
000012  4c6f              LDR      r4,|L16.464|
000014  f44f77f0          MOV      r7,#0x1e0
000018  2801              CMP      r0,#1                 ;164
00001a  d072              BEQ      |L16.258|
;;;271    	}
;;;272    	else	/* GPIX = 0 表示7寸屏(800x480) */
;;;273    	{
;;;274    	    g_LcdHeight = LCD_70_HEIGHT;
00001c  802f              STRH     r7,[r5,#0]
;;;275    		g_LcdWidth = LCD_70_WIDTH;
00001e  f44f7048          MOV      r0,#0x320
000022  8030              STRH     r0,[r6,#0]
;;;276    
;;;277    		#if 1	/* 75MHz */
;;;278    			RA8875_WriteCmd(0x88);
000024  2088              MOVS     r0,#0x88
000026  f7fffffe          BL       RA8875_WriteCmd
;;;279    			RA8875_Delaly1us();		/* 延迟1us */
00002a  f7fffffe          BL       RA8875_Delaly1us
;;;280    			RA8875_WriteData(11);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 11 */
00002e  200b              MOVS     r0,#0xb
000030  f7fffffe          BL       RA8875_WriteData
;;;281    
;;;282    			RA8875_Delaly1ms();
000034  f7fffffe          BL       RA8875_Delaly1ms
;;;283    
;;;284    			RA8875_WriteCmd(0x89);
000038  2089              MOVS     r0,#0x89
00003a  f7fffffe          BL       RA8875_WriteCmd
;;;285    			RA8875_Delaly1us();		/* 延迟1us */
00003e  f7fffffe          BL       RA8875_Delaly1us
;;;286    			RA8875_WriteData(2);		/* PLLDIVK[2:0] = 2, 除以4 */
000042  2002              MOVS     r0,#2
000044  f7fffffe          BL       RA8875_WriteData
;;;287    		#else	/* 81.25M */
;;;288    			/* 初始化PLL.  晶振频率为25M */
;;;289    			RA8875_WriteCmd(0x88);
;;;290    			RA8875_Delaly1us();		/* 延迟1us */
;;;291    			RA8875_WriteData(12);	/* PLLDIVM [7] = 0 ;  PLLDIVN [4:0] = 12 */
;;;292    
;;;293    			RA8875_Delaly1ms();
;;;294    
;;;295    			RA8875_WriteCmd(0x89);
;;;296    			RA8875_Delaly1us();		/* 延迟1us */
;;;297    			RA8875_WriteData(2);	/* PLLDIVK[2:0] = 2, 除以4 */
;;;298    
;;;299    			/* RA8875 的内部系统频率 (SYS_CLK) 是结合振荡电路及PLL 电路所产生，频率计算公式如下 :
;;;300    			  SYS_CLK = FIN * ( PLLDIVN [4:0] +1 ) / ((PLLDIVM+1 ) * ( 2^PLLDIVK [2:0] ))
;;;301    					  = 25M * (12 + 1) / ((0 + 1) * (2 ^ 2))
;;;302    					  = 81.25MHz
;;;303    			*/
;;;304    		#endif
;;;305    		
;;;306    
;;;307    		/* REG[88h]或REG[89h]被设定后，为保证PLL 输出稳定，须等待一段「锁频时间」(< 100us)。*/
;;;308    	    RA8875_Delaly1ms();
000048  f7fffffe          BL       RA8875_Delaly1ms
;;;309    
;;;310    		/*
;;;311    			配置系统控制寄存器。 中文pdf 第18页:
;;;312    
;;;313    			bit3:2 色彩深度设定 (Color Depth Setting)
;;;314    				00b : 8-bpp 的通用TFT 接口， i.e. 256 色。
;;;315    				1xb : 16-bpp 的通用TFT 接口， i.e. 65K 色。	 【选这个】
;;;316    
;;;317    			bit1:0 MCUIF 选择
;;;318    				00b : 8-位MCU 接口。
;;;319    				1xb : 16-位MCU 接口。 【选这个】
;;;320    		*/
;;;321    		if (g_RA8875_IF == RA_HARD_8080_16)
00004c  7820              LDRB     r0,[r4,#0]  ; g_RA8875_IF
00004e  2803              CMP      r0,#3
000050  d07d              BEQ      |L16.334|
;;;322    		{
;;;323    			RA8875_WriteReg(0x10, (1 <<3 ) | (1 << 1));	/* 配置16位MCU并口，65K色 */
;;;324    		}
;;;325    		else
;;;326    		{
;;;327    			RA8875_WriteReg(0x10, (1 <<3 ) | (0 << 1));	/* SPI接口时，配置8位，65K色 */
000052  2108              MOVS     r1,#8
                  |L16.84|
000054  2010              MOVS     r0,#0x10
000056  f7fffffe          BL       RA8875_WriteReg
;;;328    		}
;;;329    
;;;330    		/* REG[04h] Pixel Clock Setting Register (PCSR)
;;;331    			bit7  PCLK Inversion
;;;332    				0 : PDAT 是在PCLK 正缘上升 (Rising Edge) 时被取样。
;;;333    				1 : PDAT 是在PCLK 负缘下降 (Falling Edge) 时被取样。
;;;334    			bit1:0 PCLK 频率周期设定
;;;335    				Pixel Clock ,PCLK 频率周期设定。
;;;336    				00b: PCLK 频率周期= 系统频率周期。
;;;337    				01b: PCLK 频率周期= 2 倍的系统频率周期。
;;;338    				10b: PCLK 频率周期= 4 倍的系统频率周期。
;;;339    				11b: PCLK 频率周期= 8 倍的系统频率周期。
;;;340    		*/
;;;341    	    RA8875_WriteReg(0x04, 0x81);
00005a  2181              MOVS     r1,#0x81
00005c  2004              MOVS     r0,#4
00005e  f7fffffe          BL       RA8875_WriteReg
;;;342    	    RA8875_Delaly1ms();
000062  f7fffffe          BL       RA8875_Delaly1ms
;;;343    
;;;344    	#if 1
;;;345    		/* OTD9960 & OTA7001 设置 */
;;;346    		RA8875_WriteReg(0x14, 0x63);
000066  2163              MOVS     r1,#0x63
000068  2014              MOVS     r0,#0x14
00006a  f7fffffe          BL       RA8875_WriteReg
;;;347    		RA8875_WriteReg(0x15, 0x00);
00006e  2100              MOVS     r1,#0
000070  2015              MOVS     r0,#0x15
000072  f7fffffe          BL       RA8875_WriteReg
;;;348    		RA8875_WriteReg(0x16, 0x03);
000076  2103              MOVS     r1,#3
000078  2016              MOVS     r0,#0x16
00007a  f7fffffe          BL       RA8875_WriteReg
;;;349    		RA8875_WriteReg(0x17, 0x03);
00007e  2103              MOVS     r1,#3
000080  2017              MOVS     r0,#0x17
000082  f7fffffe          BL       RA8875_WriteReg
;;;350    		RA8875_WriteReg(0x18, 0x0B);
000086  210b              MOVS     r1,#0xb
000088  2018              MOVS     r0,#0x18
00008a  f7fffffe          BL       RA8875_WriteReg
;;;351    		RA8875_WriteReg(0x19, 0xDF);
00008e  21df              MOVS     r1,#0xdf
000090  2019              MOVS     r0,#0x19
000092  f7fffffe          BL       RA8875_WriteReg
;;;352    		RA8875_WriteReg(0x1A, 0x01);
000096  2101              MOVS     r1,#1
000098  201a              MOVS     r0,#0x1a
00009a  f7fffffe          BL       RA8875_WriteReg
;;;353    		RA8875_WriteReg(0x1B, 0x1F);
00009e  211f              MOVS     r1,#0x1f
0000a0  201b              MOVS     r0,#0x1b
0000a2  f7fffffe          BL       RA8875_WriteReg
;;;354    		RA8875_WriteReg(0x1C, 0x00);
0000a6  2100              MOVS     r1,#0
0000a8  201c              MOVS     r0,#0x1c
0000aa  f7fffffe          BL       RA8875_WriteReg
;;;355    		RA8875_WriteReg(0x1D, 0x16);
0000ae  2116              MOVS     r1,#0x16
0000b0  201d              MOVS     r0,#0x1d
0000b2  f7fffffe          BL       RA8875_WriteReg
;;;356    		RA8875_WriteReg(0x1E, 0x00);
0000b6  2100              MOVS     r1,#0
0000b8  201e              MOVS     r0,#0x1e
0000ba  f7fffffe          BL       RA8875_WriteReg
;;;357    		RA8875_WriteReg(0x1F, 0x01);
0000be  2101              MOVS     r1,#1
0000c0  201f              MOVS     r0,#0x1f
0000c2  f7fffffe          BL       RA8875_WriteReg
                  |L16.198|
;;;358    
;;;359    	#else	/* AT070TN92  setting */
;;;360    	    //Horizontal set
;;;361    	    //HDWR//Horizontal Display Width Setting Bit[6:0]
;;;362    	 	//Horizontal display width(pixels) = (HDWR + 1)*8
;;;363    	    RA8875_WriteReg(0x14, 0x4F);
;;;364    	    RA8875_WriteReg(0x15, 0x05);
;;;365    
;;;366    	    //HNDR//Horizontal Non-Display Period Bit[4:0]
;;;367    	    //Horizontal Non-Display Period (pixels) = (HNDR + 1)*8
;;;368    		RA8875_WriteReg(0x16, 0x0F);
;;;369    
;;;370    	    //HSTR//HSYNC Start Position[4:0]
;;;371    	    //HSYNC Start Position(PCLK) = (HSTR + 1)*8
;;;372    		RA8875_WriteReg(0x17, 0x01);
;;;373    
;;;374    	    //HPWR//HSYNC Polarity ,The period width of HSYNC.
;;;375    	    //HSYNC Width [4:0]   HSYNC Pulse width(PCLK) = (HPWR + 1)*8
;;;376    		RA8875_WriteReg(0x18, 0x00);
;;;377    
;;;378    	    //Vertical set
;;;379    	    //VDHR0 //Vertical Display Height Bit [7:0]
;;;380    	    //Vertical pixels = VDHR + 1
;;;381    		RA8875_WriteReg(0x19, 0xDF);
;;;382    
;;;383    	    //VDHR1 //Vertical Display Height Bit [8]
;;;384    	    //Vertical pixels = VDHR + 1
;;;385    		RA8875_WriteReg(0x1A, 0x01);
;;;386    
;;;387    	    //VNDR0 //Vertical Non-Display Period Bit [7:0]
;;;388    	    //Vertical Non-Display area = (VNDR + 1)
;;;389    		RA8875_WriteReg(0x1B, 0x0A);
;;;390    
;;;391    	    //VNDR1 //Vertical Non-Display Period Bit [8]
;;;392    	    //Vertical Non-Display area = (VNDR + 1)
;;;393    		RA8875_WriteReg(0x1C, 0x00);
;;;394    
;;;395    	    //VSTR0 //VSYNC Start Position[7:0]
;;;396    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;397    		RA8875_WriteReg(0x1D, 0x0E);
;;;398    
;;;399    	    //VSTR1 //VSYNC Start Position[8]
;;;400    	    //VSYNC Start Position(PCLK) = (VSTR + 1)
;;;401    		RA8875_WriteReg(0x1E, 0x00);
;;;402    
;;;403    	    //VPWR //VSYNC Polarity ,VSYNC Pulse Width[6:0]
;;;404    	    //VSYNC Pulse Width(PCLK) = (VPWR + 1)
;;;405    	    RA8875_WriteReg(0x1F, 0x01);
;;;406    	#endif
;;;407    	}
;;;408    
;;;409    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;410    	RA8875_WriteReg(0xC7, 0x01);	/* DISP = 1 */
0000c6  2101              MOVS     r1,#1
0000c8  20c7              MOVS     r0,#0xc7
0000ca  f7fffffe          BL       RA8875_WriteReg
;;;411    
;;;412    	/* LCD 显示/关闭讯号 (LCD Display on) */
;;;413    	RA8875_WriteReg(0x01, 0x80);
0000ce  2180              MOVS     r1,#0x80
0000d0  2001              MOVS     r0,#1
0000d2  f7fffffe          BL       RA8875_WriteReg
;;;414    
;;;415    	/* 	REG[40h] Memory Write Control Register 0 (MWCR0)
;;;416    
;;;417    		Bit 7	显示模式设定
;;;418    			0 : 绘图模式。
;;;419    			1 : 文字模式。
;;;420    
;;;421    		Bit 6	文字写入光标/内存写入光标设定
;;;422    			0 : 设定文字/内存写入光标为不显示。
;;;423    			1 : 设定文字/内存写入光标为显示。
;;;424    
;;;425    		Bit 5	文字写入光标/内存写入光标闪烁设定
;;;426    			0 : 游标不闪烁。
;;;427    			1 : 游标闪烁。
;;;428    
;;;429    		Bit 4   NA
;;;430    
;;;431    		Bit 3-2  绘图模式时的内存写入方向
;;;432    			00b : 左 -> 右，然后上 -> 下。
;;;433    			01b : 右 -> 左，然后上 -> 下。
;;;434    			10b : 上 -> 下，然后左 -> 右。
;;;435    			11b : 下 -> 上，然后左 -> 右。
;;;436    
;;;437    		Bit 1 	内存写入光标自动增加功能设定
;;;438    			0 : 当内存写入时光标位置自动加一。
;;;439    			1 : 当内存写入时光标位置不会自动加一。
;;;440    
;;;441    		Bit 0 内存读取光标自动增加功能设定
;;;442    			0 : 当内存读取时光标位置自动加一。
;;;443    			1 : 当内存读取时光标位置不会自动加一。
;;;444    	*/
;;;445    	//RA8875_WriteReg(0x40, 0x00);	/* 选择绘图模式 */	
;;;446    	RA8875_SetDirection(0);
0000d6  2000              MOVS     r0,#0
0000d8  f7fffffe          BL       RA8875_SetDirection
;;;447    
;;;448    	/* 	REG[41h] Memory Write Control Register1 (MWCR1)
;;;449    		写入目的位置，选择图层1
;;;450    	*/
;;;451    	RA8875_WriteReg(0x41, 0x00);	/* 选择绘图模式, 目的为CGRAM */
0000dc  2100              MOVS     r1,#0
0000de  2041              MOVS     r0,#0x41
0000e0  f7fffffe          BL       RA8875_WriteReg
;;;452    
;;;453    	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
0000e4  2100              MOVS     r1,#0
0000e6  8833              LDRH     r3,[r6,#0]  ; g_LcdWidth
0000e8  882a              LDRH     r2,[r5,#0]  ; g_LcdHeight
0000ea  4608              MOV      r0,r1
0000ec  f7fffffe          BL       RA8875_SetDispWin
;;;454    
;;;455    	if ((g_RA8875_IF == RA_HARD_SPI) || (g_RA8875_IF == RA_SOFT_SPI))
0000f0  7820              LDRB     r0,[r4,#0]  ; g_RA8875_IF
0000f2  2802              CMP      r0,#2
0000f4  d063              BEQ      |L16.446|
0000f6  2801              CMP      r0,#1
0000f8  d061              BEQ      |L16.446|
;;;456    	{
;;;457    		RA8875_HighSpeedSPI();		/* 配置完毕后，切换SPI到高速模式 */
;;;458    	}
;;;459    	else
;;;460    	{
;;;461    		#ifdef WRTIE_SF_EN		/* 使能了字库图片芯片写功能，配置CPU的SPI接口和PWM-GPIO */
;;;462    			bsp_InitRA8875Flash();		
0000fa  e8bd41f0          POP      {r4-r8,lr}
0000fe  f7ffbffe          B.W      bsp_InitRA8875Flash
                  |L16.258|
000102  2088              MOVS     r0,#0x88              ;167
000104  f7fffffe          BL       RA8875_WriteCmd
000108  f7fffffe          BL       RA8875_Delaly1us
00010c  200a              MOVS     r0,#0xa               ;169
00010e  f7fffffe          BL       RA8875_WriteData
000112  f7fffffe          BL       RA8875_Delaly1ms
000116  2089              MOVS     r0,#0x89              ;173
000118  f7fffffe          BL       RA8875_WriteCmd
00011c  f7fffffe          BL       RA8875_Delaly1us
000120  2002              MOVS     r0,#2                 ;175
000122  f7fffffe          BL       RA8875_WriteData
000126  f7fffffe          BL       RA8875_Delaly1ms
00012a  f7fffffe          BL       RA8875_Delaly1ms
00012e  7820              LDRB     r0,[r4,#0]            ;198  ; g_RA8875_IF
000130  2803              CMP      r0,#3                 ;198
000132  d040              BEQ      |L16.438|
000134  2108              MOVS     r1,#8                 ;204
                  |L16.310|
000136  2010              MOVS     r0,#0x10              ;204
000138  f7fffffe          BL       RA8875_WriteReg
00013c  2182              MOVS     r1,#0x82              ;218
00013e  2004              MOVS     r0,#4                 ;218
000140  f7fffffe          BL       RA8875_WriteReg
000144  f7fffffe          BL       RA8875_Delaly1ms
000148  213b              MOVS     r1,#0x3b              ;224
00014a  2014              MOVS     r0,#0x14              ;224
00014c  e000              B        |L16.336|
                  |L16.334|
00014e  e034              B        |L16.442|
                  |L16.336|
000150  f7fffffe          BL       RA8875_WriteReg
000154  2100              MOVS     r1,#0                 ;225
000156  2015              MOVS     r0,#0x15              ;225
000158  f7fffffe          BL       RA8875_WriteReg
00015c  2101              MOVS     r1,#1                 ;229
00015e  2016              MOVS     r0,#0x16              ;229
000160  f7fffffe          BL       RA8875_WriteReg
000164  2100              MOVS     r1,#0                 ;233
000166  2017              MOVS     r0,#0x17              ;233
000168  f7fffffe          BL       RA8875_WriteReg
00016c  2105              MOVS     r1,#5                 ;237
00016e  2018              MOVS     r0,#0x18              ;237
000170  f7fffffe          BL       RA8875_WriteReg
000174  210f              MOVS     r1,#0xf               ;242
000176  2019              MOVS     r0,#0x19              ;242
000178  f7fffffe          BL       RA8875_WriteReg
00017c  2101              MOVS     r1,#1                 ;246
00017e  201a              MOVS     r0,#0x1a              ;246
000180  f7fffffe          BL       RA8875_WriteReg
000184  2102              MOVS     r1,#2                 ;250
000186  201b              MOVS     r0,#0x1b              ;250
000188  f7fffffe          BL       RA8875_WriteReg
00018c  2100              MOVS     r1,#0                 ;254
00018e  201c              MOVS     r0,#0x1c              ;254
000190  f7fffffe          BL       RA8875_WriteReg
000194  2107              MOVS     r1,#7                 ;258
000196  201d              MOVS     r0,#0x1d              ;258
000198  f7fffffe          BL       RA8875_WriteReg
00019c  2100              MOVS     r1,#0                 ;262
00019e  201e              MOVS     r0,#0x1e              ;262
0001a0  f7fffffe          BL       RA8875_WriteReg
0001a4  2109              MOVS     r1,#9                 ;266
0001a6  201f              MOVS     r0,#0x1f              ;266
0001a8  f7fffffe          BL       RA8875_WriteReg
0001ac  f44f7088          MOV      r0,#0x110             ;269
0001b0  8028              STRH     r0,[r5,#0]            ;269
0001b2  8037              STRH     r7,[r6,#0]            ;270
0001b4  e787              B        |L16.198|
                  |L16.438|
0001b6  210a              MOVS     r1,#0xa               ;200
0001b8  e7bd              B        |L16.310|
                  |L16.442|
0001ba  210a              MOVS     r1,#0xa               ;323
0001bc  e74a              B        |L16.84|
                  |L16.446|
0001be  e8bd41f0          POP      {r4-r8,lr}            ;457
0001c2  f7ffbffe          B.W      RA8875_HighSpeedSPI
;;;463    		#endif	
;;;464    	}
;;;465    }
;;;466    
                          ENDP

0001c6  0000              DCW      0x0000
                  |L16.456|
                          DCD      g_LcdHeight
                  |L16.460|
                          DCD      g_LcdWidth
                  |L16.464|
                          DCD      g_RA8875_IF

                          AREA ||i.RA8875_IsBusy||, CODE, READONLY, ALIGN=2

                  RA8875_IsBusy PROC
;;;672    */
;;;673    uint8_t RA8875_IsBusy(void)
000000  4802              LDR      r0,|L17.12|
;;;674    {
;;;675    	if (s_ucRA8875Busy == 0)
000002  7800              LDRB     r0,[r0,#0]  ; s_ucRA8875Busy
000004  2800              CMP      r0,#0                 ;674
000006  d000              BEQ      |L17.10|
;;;676    	{
;;;677    		return 0;
;;;678    	}
;;;679    	return 1;
000008  2001              MOVS     r0,#1
                  |L17.10|
;;;680    }
00000a  4770              BX       lr
;;;681    
                          ENDP

                  |L17.12|
                          DCD      ||.data||

                          AREA ||i.RA8875_Layer1Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer1Visable PROC
;;;702    */
;;;703    void RA8875_Layer1Visable(void)
000000  b510              PUSH     {r4,lr}
;;;704    {
;;;705    	/* 0x52 寄存器的 Bit2:0
;;;706    		图层显示模式
;;;707    		000b : 只有图层1 显示。
;;;708    		001b : 只有图层2 显示。
;;;709    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;710    		011b : 显示图层1 与图层2 的通透模式。
;;;711    		100b : Boolean OR。
;;;712    		101b : Boolean AND。
;;;713    		110b : 浮动窗口模式 (Floating window mode)。
;;;714    		111b :保留。
;;;715    	*/
;;;716    	RA8875_WriteReg(0x52, RA8875_ReadReg(0x52) & 0xF8);	/* 只有图层1 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00001f8          AND      r1,r0,#0xf8
00000c  e8bd4010          POP      {r4,lr}
000010  2052              MOVS     r0,#0x52
000012  f7ffbffe          B.W      RA8875_WriteReg
;;;717    }
;;;718    
                          ENDP


                          AREA ||i.RA8875_Layer2Visable||, CODE, READONLY, ALIGN=1

                  RA8875_Layer2Visable PROC
;;;726    */
;;;727    void RA8875_Layer2Visable(void)
000000  b510              PUSH     {r4,lr}
;;;728    {
;;;729    	/* 0x52 寄存器的 Bit2:0
;;;730    		图层显示模式
;;;731    		000b : 只有图层1 显示。
;;;732    		001b : 只有图层2 显示。
;;;733    		010b : 显示图层1 与图层2 的渐进/渐出模式。
;;;734    		011b : 显示图层1 与图层2 的通透模式。
;;;735    		100b : Boolean OR。
;;;736    		101b : Boolean AND。
;;;737    		110b : 浮动窗口模式 (Floating window mode)。
;;;738    		111b :保留。
;;;739    	*/
;;;740    	RA8875_WriteReg(0x52, (RA8875_ReadReg(0x52) & 0xF8) | 0x01);	/* 只有图层2 显示 */
000002  2052              MOVS     r0,#0x52
000004  f7fffffe          BL       RA8875_ReadReg
000008  f00001f8          AND      r1,r0,#0xf8
00000c  2052              MOVS     r0,#0x52
00000e  e8bd4010          POP      {r4,lr}
000012  1c49              ADDS     r1,r1,#1
000014  f7ffbffe          B.W      RA8875_WriteReg
;;;741    }
;;;742    
                          ENDP


                          AREA ||i.RA8875_PutPixel||, CODE, READONLY, ALIGN=2

                  RA8875_PutPixel PROC
;;;939    */
;;;940    void RA8875_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;941    {	
000004  4693              MOV      r11,r2
;;;942    	if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
000006  4a1f              LDR      r2,|L20.132|
;;;943    	{
;;;944    		// 优化 RA8875_SetCursor(_usX, _usY);
;;;945    		s_ucRA8875Busy = 1;
000008  2501              MOVS     r5,#1
00000a  4c1f              LDR      r4,|L20.136|
00000c  7812              LDRB     r2,[r2,#0]            ;942  ; g_RA8875_IF
00000e  f04f0a00          MOV      r10,#0                ;942
000012  2a03              CMP      r2,#3                 ;942
000014  d009              BEQ      |L20.42|
;;;946    		{	
;;;947    			if (g_LcdDirection > 1)	/* 竖屏  */
;;;948    			{
;;;949    				RA8875_REG = 0x46; RA8875_RAM = _usY;
;;;950    				RA8875_REG = 0x47; RA8875_RAM = _usY >> 8;
;;;951    				RA8875_REG = 0x48; RA8875_RAM = _usX;
;;;952    				RA8875_REG = 0x49; RA8875_RAM = _usX >> 8;
;;;953    			}
;;;954    			else	/* 横屏 */
;;;955    			{
;;;956    				RA8875_REG = 0x46; RA8875_RAM = _usX;
;;;957    				RA8875_REG = 0x47; RA8875_RAM = _usX >> 8;
;;;958    				RA8875_REG = 0x48; RA8875_RAM = _usY;
;;;959    				RA8875_REG = 0x49; RA8875_RAM = _usY >> 8;	
;;;960    			}
;;;961    		}
;;;962    		
;;;963    		// 优化 RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
;;;964    		// 优化 RA8875_WriteData16(_usColor);
;;;965    		
;;;966    		RA8875_REG = 0x02;
;;;967    		RA8875_RAM = _usColor;
;;;968    
;;;969    		s_ucRA8875Busy = 0;
;;;970    	}
;;;971    	else	/* SPI接口分支 */
;;;972    	{
;;;973    		RA8875_SetCursor(_usX, _usY);
000016  f7fffffe          BL       RA8875_SetCursor
;;;974    		s_ucRA8875Busy = 1;
00001a  7025              STRB     r5,[r4,#0]
;;;975    
;;;976    		RA8875_WriteCmd(0x02); 		/* 用于设定RA8875 进入内存(DDRAM或CGRAM)读取/写入模式 */
00001c  2002              MOVS     r0,#2
00001e  f7fffffe          BL       RA8875_WriteCmd
;;;977    		RA8875_WriteData16(_usColor);
000022  4658              MOV      r0,r11
000024  f7fffffe          BL       RA8875_WriteData16
;;;978    
;;;979    		s_ucRA8875Busy = 0;
000028  e027              B        |L20.122|
                  |L20.42|
00002a  7025              STRB     r5,[r4,#0]            ;945
00002c  4a17              LDR      r2,|L20.140|
00002e  f04f0c46          MOV      r12,#0x46             ;949
000032  2647              MOVS     r6,#0x47              ;950
000034  f8928000          LDRB     r8,[r2,#0]            ;947  ; g_LcdDirection
000038  f04f42d8          MOV      r2,#0x6c000000        ;949
00003c  0a0d              LSRS     r5,r1,#8              ;950
00003e  2748              MOVS     r7,#0x48              ;951
000040  0a03              LSRS     r3,r0,#8              ;952
000042  f04f0949          MOV      r9,#0x49              ;952
000046  f1b80f01          CMP      r8,#1                 ;947
00004a  f8a2c002          STRH     r12,[r2,#2]           ;956
00004e  d908              BLS      |L20.98|
000050  8011              STRH     r1,[r2,#0]            ;949
000052  8056              STRH     r6,[r2,#2]            ;950
000054  8015              STRH     r5,[r2,#0]            ;950
000056  8057              STRH     r7,[r2,#2]            ;951
000058  8010              STRH     r0,[r2,#0]            ;951
00005a  f8a29002          STRH     r9,[r2,#2]            ;952
00005e  8013              STRH     r3,[r2,#0]            ;952
000060  e007              B        |L20.114|
                  |L20.98|
000062  8010              STRH     r0,[r2,#0]            ;956
000064  8056              STRH     r6,[r2,#2]            ;957
000066  8013              STRH     r3,[r2,#0]            ;957
000068  8057              STRH     r7,[r2,#2]            ;958
00006a  8011              STRH     r1,[r2,#0]            ;958
00006c  f8a29002          STRH     r9,[r2,#2]            ;959
000070  8015              STRH     r5,[r2,#0]            ;959
                  |L20.114|
000072  2002              MOVS     r0,#2                 ;966
000074  8050              STRH     r0,[r2,#2]            ;966
000076  f8a2b000          STRH     r11,[r2,#0]           ;967
                  |L20.122|
00007a  f884a000          STRB     r10,[r4,#0]           ;969
;;;980    	}
;;;981    }
00007e  e8bd9ff0          POP      {r4-r12,pc}
;;;982    
                          ENDP

000082  0000              DCW      0x0000
                  |L20.132|
                          DCD      g_RA8875_IF
                  |L20.136|
                          DCD      ||.data||
                  |L20.140|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_QuitDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_QuitDirectDraw PROC
;;;1241   */
;;;1242   void RA8875_QuitDirectDraw(void)
000000  4902              LDR      r1,|L21.12|
;;;1243   {
;;;1244   	s_ucRA8875Busy = 0;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;1245   
;;;1246   	/* 退出窗口绘图模式 */
;;;1247   	RA8875_QuitWinMode();
000006  f7ffbffe          B.W      RA8875_QuitWinMode
;;;1248   }
;;;1249   
                          ENDP

00000a  0000              DCW      0x0000
                  |L21.12|
                          DCD      ||.data||

                          AREA ||i.RA8875_QuitWinMode||, CODE, READONLY, ALIGN=2

                  RA8875_QuitWinMode PROC
;;;1932   */
;;;1933   void RA8875_QuitWinMode(void)
000000  4803              LDR      r0,|L22.16|
;;;1934   {
;;;1935   	RA8875_SetDispWin(0, 0, g_LcdHeight, g_LcdWidth);
000002  2100              MOVS     r1,#0
000004  8803              LDRH     r3,[r0,#0]  ; g_LcdWidth
000006  4803              LDR      r0,|L22.20|
000008  8802              LDRH     r2,[r0,#0]  ; g_LcdHeight
00000a  4608              MOV      r0,r1
00000c  f7ffbffe          B.W      RA8875_SetDispWin
;;;1936   }
;;;1937   
                          ENDP

                  |L22.16|
                          DCD      g_LcdWidth
                  |L22.20|
                          DCD      g_LcdHeight

                          AREA ||i.RA8875_ReadID||, CODE, READONLY, ALIGN=1

                  RA8875_ReadID PROC
;;;84     */
;;;85     uint16_t RA8875_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;86     {
;;;87     	RA8875_ConfigGPIO();
000002  f7fffffe          BL       RA8875_ConfigGPIO
;;;88     	
;;;89     	return RA8875_ReadReg(0x00);
000006  e8bd4010          POP      {r4,lr}
00000a  2000              MOVS     r0,#0
00000c  f7ffbffe          B.W      RA8875_ReadReg
;;;90     }
;;;91     
                          ENDP


                          AREA ||i.RA8875_ReadReg||, CODE, READONLY, ALIGN=2

                  RA8875_ReadReg PROC
;;;117    */
;;;118    uint8_t RA8875_ReadReg(uint8_t _ucRegAddr)
000000  b510              PUSH     {r4,lr}
;;;119    {
;;;120    	uint8_t value;
;;;121    	
;;;122    	s_ucRA8875Busy = 1;
000002  4c05              LDR      r4,|L24.24|
000004  2101              MOVS     r1,#1
000006  7021              STRB     r1,[r4,#0]
;;;123    	
;;;124    	RA8875_WriteCmd(_ucRegAddr);
000008  f7fffffe          BL       RA8875_WriteCmd
;;;125    	value = RA8875_ReadData();
00000c  f7fffffe          BL       RA8875_ReadData
;;;126    	
;;;127    	s_ucRA8875Busy = 0;
000010  2100              MOVS     r1,#0
000012  7021              STRB     r1,[r4,#0]
;;;128    	return value;	
;;;129    }
000014  bd10              POP      {r4,pc}
;;;130    
                          ENDP

000016  0000              DCW      0x0000
                  |L24.24|
                          DCD      ||.data||

                          AREA ||i.RA8875_ReadReg_Int||, CODE, READONLY, ALIGN=1

                  RA8875_ReadReg_Int PROC
;;;138    */
;;;139    uint8_t RA8875_ReadReg_Int(uint8_t _ucRegAddr)
000000  b510              PUSH     {r4,lr}
;;;140    {
;;;141    	RA8875_WriteCmd(_ucRegAddr);
000002  f7fffffe          BL       RA8875_WriteCmd
;;;142    	return RA8875_ReadData();
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      RA8875_ReadData
;;;143    }
;;;144    
                          ENDP


                          AREA ||i.RA8875_SetBackColor||, CODE, READONLY, ALIGN=1

                  RA8875_SetBackColor PROC
;;;617    */
;;;618    void RA8875_SetBackColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;619    {
000002  4604              MOV      r4,r0
;;;620    	RA8875_WriteReg(0x60, (_usColor & 0xF800) >> 11);	/* R5  */
000004  0ac1              LSRS     r1,r0,#11
000006  2060              MOVS     r0,#0x60
000008  f7fffffe          BL       RA8875_WriteReg
;;;621    	RA8875_WriteReg(0x61, (_usColor & 0x07E0) >> 5);	/* G6 */
00000c  f3c41145          UBFX     r1,r4,#5,#6
000010  2061              MOVS     r0,#0x61
000012  f7fffffe          BL       RA8875_WriteReg
;;;622    	RA8875_WriteReg(0x62, (_usColor & 0x001F));			/* B5 */
000016  f004011f          AND      r1,r4,#0x1f
00001a  e8bd4010          POP      {r4,lr}
00001e  2062              MOVS     r0,#0x62
000020  f7ffbffe          B.W      RA8875_WriteReg
;;;623    }
;;;624    
                          ENDP


                          AREA ||i.RA8875_SetBackLight||, CODE, READONLY, ALIGN=1

                  RA8875_SetBackLight PROC
;;;1960   */
;;;1961   void RA8875_SetBackLight(uint8_t _bright)
000000  b510              PUSH     {r4,lr}
;;;1962   {
000002  0004              MOVS     r4,r0
000004  d00b              BEQ      |L27.30|
;;;1963   	if (_bright == 0)
;;;1964   	{
;;;1965   		/* 关闭PWM, PWM1引脚缺省输出LOW  */
;;;1966   		RA8875_WriteReg(0x8A, 0 << 6);
;;;1967   	}
;;;1968   	else if (_bright == BRIGHT_MAX)	/* 最大亮度 */
000006  2cff              CMP      r4,#0xff
000008  d00b              BEQ      |L27.34|
;;;1969   	{
;;;1970   		/* 关闭PWM, PWM1引脚缺省输出HIGH */
;;;1971   		RA8875_WriteReg(0x8A, 1 << 6);
;;;1972   	}
;;;1973   	else
;;;1974   	{
;;;1975   		/* 使能PWM1, 进行占空比调节 */
;;;1976   
;;;1977   		/* 	REG[8Ah] PWM1 Control Register (P1CR)
;;;1978   
;;;1979   			Bit7 脉波宽度调变 (PWM1) 设定
;;;1980   				0 : 关闭，此状态下，PWM1 输出准位依照此缓存器Bit6 决定。
;;;1981   				1 : 开启。
;;;1982   
;;;1983   			Bit6 PWM1 关闭时的准位
;;;1984   				0 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”Low” 状态。
;;;1985   				1 : 当PWM 关闭或于睡眠模式时，PWM1 输出为”High” 状态。
;;;1986   
;;;1987   			Bit5 保留
;;;1988   
;;;1989   			Bit4 PWM1 功能选择
;;;1990   				0 : PWM1 功能。
;;;1991   				1 : PWM1 固定输出一频率为外部晶体振荡器Clock (Fin) 频率 1 /16 的Clock
;;;1992   
;;;1993   			Bit3-0  PWM1 电路的频率来源选择PWM_CLK	【不是PWM输出频率】
;;;1994   				0000b : SYS_CLK / 1   , 1000b : SYS_CLK / 256
;;;1995   				0001b : SYS_CLK / 2   , 1001b : SYS_CLK / 512
;;;1996   				0010b : SYS_CLK / 4   , 1010b : SYS_CLK / 1024
;;;1997   				0011b : SYS_CLK / 8   , 1011b : SYS_CLK / 2048
;;;1998   				0100b : SYS_CLK / 16  , 1100b : SYS_CLK / 4096
;;;1999   				0101b : SYS_CLK / 32  , 1101b : SYS_CLK / 8192
;;;2000   				0110b : SYS_CLK / 64  , 1110b : SYS_CLK / 16384
;;;2001   				0111b : SYS_CLK / 128 , 1111b : SYS_CLK / 32768
;;;2002   
;;;2003   				“SYS_CLK” 代表系统频率， 例如SYS_CLK 为20MHz， 当Bit[3:0] =0001b 时，PWM1 频率来源为10MHz。
;;;2004   				实际输出的PWM频率还需要除以 256，支持8位的分辨率。
;;;2005   
;;;2006   				安富莱的4.3寸(480*272)模块，SYS_CLK =  68.75MHz
;;;2007   				安富莱的7.0寸(800*480)模块，SYS_CLK =  81.25MHz
;;;2008   
;;;2009   				为了避免音频噪声，PWM频率可以选择
;;;2010   				（1） 低频100Hz
;;;2011   				（2） 高于 20KHz
;;;2012   
;;;2013   				比如，Bit3-0为0011b时 SYS_CLK / 8，
;;;2014   					4.3寸 输出的PWM频率为 (68.75MHz / 8) / 256 = 33.56KHz
;;;2015   					7寸 输出的PWM频率为 (75 MHz / 8) / 256 = 36.62KHz
;;;2016   		*/
;;;2017   
;;;2018   		// 5寸和7寸新屏可以用 3 ，高频PWM, 4.3寸不行
;;;2019   		RA8875_WriteReg(0x8A, (1 << 7) | 3);   
00000a  2183              MOVS     r1,#0x83
00000c  208a              MOVS     r0,#0x8a
00000e  f7fffffe          BL       RA8875_WriteReg
;;;2020   		// RA8875_WriteReg(0x8A, (1 << 7) | 12);
;;;2021   
;;;2022   		/* REG[8Bh] PWM1 Duty Cycle Register (P1DCR) */
;;;2023   		RA8875_WriteReg(0x8B, _bright);
000012  4621              MOV      r1,r4
000014  208b              MOVS     r0,#0x8b
                  |L27.22|
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      RA8875_WriteReg
                  |L27.30|
00001e  2100              MOVS     r1,#0                 ;1966
000020  e000              B        |L27.36|
                  |L27.34|
000022  2140              MOVS     r1,#0x40              ;1971
                  |L27.36|
000024  208a              MOVS     r0,#0x8a              ;1966
000026  e7f6              B        |L27.22|
;;;2024   	}
;;;2025   }
;;;2026   
                          ENDP


                          AREA ||i.RA8875_SetCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetCursor PROC
;;;1854   */
;;;1855   static void RA8875_SetCursor(uint16_t _usX, uint16_t _usY)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1856   {
000004  4605              MOV      r5,r0
;;;1857   	if (g_LcdDirection > 1)	/* 竖屏  */
000006  4813              LDR      r0,|L28.84|
;;;1858   	{
;;;1859   		RA8875_WriteReg(0x46, _usY);
;;;1860   		RA8875_WriteReg(0x47, _usY >> 8);
;;;1861   		RA8875_WriteReg(0x48, _usX);
;;;1862   		RA8875_WriteReg(0x49, _usX >> 8);
000008  0a2f              LSRS     r7,r5,#8
00000a  0a0e              LSRS     r6,r1,#8              ;1860
00000c  7800              LDRB     r0,[r0,#0]            ;1857  ; g_LcdDirection
00000e  460c              MOV      r4,r1                 ;1856
000010  2801              CMP      r0,#1                 ;1857
000012  d90d              BLS      |L28.48|
000014  b2c9              UXTB     r1,r1                 ;1859
000016  2046              MOVS     r0,#0x46              ;1859
000018  f7fffffe          BL       RA8875_WriteReg
00001c  4631              MOV      r1,r6                 ;1859
00001e  2047              MOVS     r0,#0x47              ;1860
000020  f7fffffe          BL       RA8875_WriteReg
000024  b2e9              UXTB     r1,r5                 ;1861
000026  2048              MOVS     r0,#0x48              ;1861
000028  f7fffffe          BL       RA8875_WriteReg
00002c  4639              MOV      r1,r7                 ;1861
00002e  e00c              B        |L28.74|
                  |L28.48|
;;;1863   	}
;;;1864   	else	/* 横屏 */
;;;1865   	{
;;;1866   		RA8875_WriteReg(0x46, _usX);
000030  b2e9              UXTB     r1,r5
000032  2046              MOVS     r0,#0x46
000034  f7fffffe          BL       RA8875_WriteReg
000038  4639              MOV      r1,r7
;;;1867   		RA8875_WriteReg(0x47, _usX >> 8);
00003a  2047              MOVS     r0,#0x47
00003c  f7fffffe          BL       RA8875_WriteReg
;;;1868   		RA8875_WriteReg(0x48, _usY);
000040  b2e1              UXTB     r1,r4
000042  2048              MOVS     r0,#0x48
000044  f7fffffe          BL       RA8875_WriteReg
000048  4631              MOV      r1,r6
                  |L28.74|
;;;1869   		RA8875_WriteReg(0x49, _usY >> 8);
00004a  e8bd41f0          POP      {r4-r8,lr}
00004e  2049              MOVS     r0,#0x49
000050  f7ffbffe          B.W      RA8875_WriteReg
;;;1870   	}
;;;1871   }
;;;1872   
                          ENDP

                  |L28.84|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetDirection||, CODE, READONLY, ALIGN=2

                  RA8875_SetDirection PROC
;;;474    */
;;;475    void RA8875_SetDirection(uint8_t _ucDir)
000000  b570              PUSH     {r4-r6,lr}
;;;476    {
000002  0004              MOVS     r4,r0
;;;477    	uint8_t reg20H = 0;
;;;478    	
;;;479    	s_reg_40H = 0x01;
000004  4817              LDR      r0,|L29.100|
000006  f04f0101          MOV      r1,#1
00000a  f04f0500          MOV      r5,#0                 ;477
00000e  7041              STRB     r1,[r0,#1]
000010  d007              BEQ      |L29.34|
;;;480    	
;;;481    	if (_ucDir == 0)
;;;482    	{
;;;483    		s_reg_40H = 0x01;
;;;484    		reg20H = (0 << 3) | (0 << 2);
;;;485    	}
;;;486    	else if (_ucDir == 1)
000012  2c01              CMP      r4,#1
000014  d007              BEQ      |L29.38|
;;;487    	{
;;;488    		s_reg_40H = 0x01;	/* 2015-04-21 由05修改为 01. 解决emwin下的问题 */
;;;489    		reg20H = (1 << 3) | (1 << 2);
;;;490    	}
;;;491    	else if (_ucDir == 2)
;;;492    	{
;;;493    		s_reg_40H = 0x09;
000016  2109              MOVS     r1,#9
000018  2c02              CMP      r4,#2                 ;491
00001a  d007              BEQ      |L29.44|
;;;494    		reg20H = (0 << 3) | (1 << 2);
;;;495    	}
;;;496    	else if (_ucDir == 3)
00001c  2c03              CMP      r4,#3
00001e  d008              BEQ      |L29.50|
000020  e009              B        |L29.54|
                  |L29.34|
000022  7041              STRB     r1,[r0,#1]            ;483
000024  e007              B        |L29.54|
                  |L29.38|
000026  7041              STRB     r1,[r0,#1]            ;488
000028  250c              MOVS     r5,#0xc               ;489
00002a  e004              B        |L29.54|
                  |L29.44|
00002c  7041              STRB     r1,[r0,#1]            ;493
00002e  2504              MOVS     r5,#4                 ;494
000030  e001              B        |L29.54|
                  |L29.50|
;;;497    	{
;;;498    		s_reg_40H = 0x09;
000032  7041              STRB     r1,[r0,#1]
;;;499    		reg20H = (1 << 3) | (0 << 2);
000034  2508              MOVS     r5,#8
                  |L29.54|
;;;500    	}
;;;501    	RA8875_WriteReg(0x40, s_reg_40H);	
000036  7841              LDRB     r1,[r0,#1]  ; s_reg_40H
000038  2040              MOVS     r0,#0x40
00003a  f7fffffe          BL       RA8875_WriteReg
;;;502    
;;;503    	/* 
;;;504    		REG[20h] Display Configuration Register (DPCR) 
;;;505    		Bit  说  明  初始值  Access
;;;506    		Bit7 
;;;507    			图层设定(Layer Control) 
;;;508    			0 : 单图层。
;;;509    			1 : 双图层。
;;;510    		Bit3  HDIR 水平扫描方向设定(n = SEG number) 
;;;511    			0 : 由SEG0 到SEG(n-1)。
;;;512    			1 : 由SEG(n-1) 到SEG0。
;;;513    		Bit2 VDIR 垂直扫描方向设定(n = COM number) 
;;;514    			0 : 由COM0 到COM(n-1)。
;;;515    			1 : 由COM(n-1) 到COM0。
;;;516    	*/
;;;517    	RA8875_WriteReg(0x20, reg20H);	
00003e  4629              MOV      r1,r5
000040  2020              MOVS     r0,#0x20
000042  f7fffffe          BL       RA8875_WriteReg
;;;518    
;;;519    	if (_ucDir > 1)	/* 竖屏  */
;;;520    	{
;;;521    		uint16_t temp;
;;;522    		
;;;523    		if (g_LcdHeight < g_LcdWidth)
000046  4908              LDR      r1,|L29.104|
000048  4a08              LDR      r2,|L29.108|
00004a  2c01              CMP      r4,#1                 ;519
;;;524    		{
;;;525    			temp = g_LcdHeight;
;;;526    			g_LcdHeight = g_LcdWidth;
;;;527    			g_LcdWidth = temp;
;;;528    		}
;;;529    	}		
;;;530    	else	/* 横屏 */
;;;531    	{
;;;532    		uint16_t temp;
;;;533    		
;;;534    		if (g_LcdHeight > g_LcdWidth)
00004c  8808              LDRH     r0,[r1,#0]  ; g_LcdHeight
00004e  8813              LDRH     r3,[r2,#0]  ; g_LcdWidth
000050  d904              BLS      |L29.92|
000052  4298              CMP      r0,r3                 ;523
000054  d201              BCS      |L29.90|
                  |L29.86|
000056  800b              STRH     r3,[r1,#0]            ;526
000058  8010              STRH     r0,[r2,#0]            ;527
                  |L29.90|
;;;535    		{
;;;536    			temp = g_LcdHeight;
;;;537    			g_LcdHeight = g_LcdWidth;
;;;538    			g_LcdWidth = temp;
;;;539    		}
;;;540    	}
;;;541    }
00005a  bd70              POP      {r4-r6,pc}
                  |L29.92|
00005c  4298              CMP      r0,r3                 ;534
00005e  d8fa              BHI      |L29.86|
000060  bd70              POP      {r4-r6,pc}
;;;542    
                          ENDP

000062  0000              DCW      0x0000
                  |L29.100|
                          DCD      ||.data||
                  |L29.104|
                          DCD      g_LcdHeight
                  |L29.108|
                          DCD      g_LcdWidth

                          AREA ||i.RA8875_SetDispWin||, CODE, READONLY, ALIGN=2

                  RA8875_SetDispWin PROC
;;;1801   */
;;;1802   void RA8875_SetDispWin(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1803   {
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
;;;1804   
;;;1805   	uint16_t usTemp;
;;;1806   
;;;1807   	/* 坐标系统示意图: （横屏）
;;;1808   			 -----------------------------
;;;1809   			|(0,0)                        |
;;;1810   			|     --------->              |
;;;1811   			|         |                   |
;;;1812   			|         |                   |
;;;1813   			|         |                   |
;;;1814   			|         V                   |
;;;1815   			|     --------->              |
;;;1816   			|                    (479,271)|
;;;1817   			 -----------------------------
;;;1818   
;;;1819   		左上角是坐标零点, 扫描方向，先从左到右，再从上到下。
;;;1820   
;;;1821   		如果需要做竖屏方式，你需要进行物理坐标和逻辑坐标的转换
;;;1822   	*/
;;;1823   	RA8875_WriteReg(0x30, _usX);
000008  b2c1              UXTB     r1,r0
00000a  4698              MOV      r8,r3                 ;1803
00000c  4616              MOV      r6,r2                 ;1803
00000e  2030              MOVS     r0,#0x30
000010  f7fffffe          BL       RA8875_WriteReg
;;;1824       RA8875_WriteReg(0x31, _usX >> 8);
000014  0a29              LSRS     r1,r5,#8
000016  2031              MOVS     r0,#0x31
000018  f7fffffe          BL       RA8875_WriteReg
;;;1825   
;;;1826   	RA8875_WriteReg(0x32, _usY);
00001c  b2e1              UXTB     r1,r4
00001e  2032              MOVS     r0,#0x32
000020  f7fffffe          BL       RA8875_WriteReg
;;;1827       RA8875_WriteReg(0x33, _usY >> 8);
000024  0a21              LSRS     r1,r4,#8
000026  2033              MOVS     r0,#0x33
000028  f7fffffe          BL       RA8875_WriteReg
;;;1828   
;;;1829   	usTemp = _usWidth + _usX - 1;
00002c  eb080005          ADD      r0,r8,r5
000030  1e40              SUBS     r0,r0,#1
000032  b287              UXTH     r7,r0
;;;1830   	RA8875_WriteReg(0x34, usTemp);
000034  b2f9              UXTB     r1,r7
000036  2034              MOVS     r0,#0x34
000038  f7fffffe          BL       RA8875_WriteReg
;;;1831       RA8875_WriteReg(0x35, usTemp >> 8);
00003c  0a39              LSRS     r1,r7,#8
00003e  2035              MOVS     r0,#0x35
000040  f7fffffe          BL       RA8875_WriteReg
;;;1832   
;;;1833   	usTemp = _usHeight + _usY - 1;
000044  1930              ADDS     r0,r6,r4
000046  1e40              SUBS     r0,r0,#1
000048  b287              UXTH     r7,r0
;;;1834   	RA8875_WriteReg(0x36, usTemp);
00004a  b2f9              UXTB     r1,r7
00004c  2036              MOVS     r0,#0x36
00004e  f7fffffe          BL       RA8875_WriteReg
;;;1835       RA8875_WriteReg(0x37, usTemp >> 8);
000052  0a39              LSRS     r1,r7,#8
000054  2037              MOVS     r0,#0x37
000056  f7fffffe          BL       RA8875_WriteReg
;;;1836   
;;;1837   	RA8875_SetCursor(_usX, _usY);
00005a  4621              MOV      r1,r4
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       RA8875_SetCursor
;;;1838   
;;;1839   	/* 保存当前窗口信息，提高以后单色填充操作的效率.
;;;1840   	另外一种做法是通过读取0x30-0x37寄存器获得当前窗口，不过效率较低 */
;;;1841   	s_WinX = _usX;
000062  4804              LDR      r0,|L30.116|
000064  8045              STRH     r5,[r0,#2]
;;;1842   	s_WinY = _usY;
000066  8084              STRH     r4,[r0,#4]
;;;1843   	s_WinHeight = _usHeight;
000068  80c6              STRH     r6,[r0,#6]
;;;1844   	s_WinWidth = _usWidth;
00006a  f8a08008          STRH     r8,[r0,#8]
;;;1845   }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;1846   
                          ENDP

000072  0000              DCW      0x0000
                  |L30.116|
                          DCD      ||.data||

                          AREA ||i.RA8875_SetFont||, CODE, READONLY, ALIGN=1

                  RA8875_SetFont PROC
;;;1566   */
;;;1567   void RA8875_SetFont(uint8_t _ucFontType, uint8_t _ucLineSpace, uint8_t _ucCharSpace)
000000  b570              PUSH     {r4-r6,lr}
;;;1568   {
000002  4614              MOV      r4,r2
000004  4605              MOV      r5,r0
;;;1569   	/*
;;;1570   		[29H]在文字模式下，用来设定文字间的行距 (单位: 像素) 。
;;;1571   		只有低5个bit有效，0-31
;;;1572   	*/
;;;1573   	if (_ucLineSpace >31)
000006  291f              CMP      r1,#0x1f
000008  d900              BLS      |L31.12|
;;;1574   	{
;;;1575   		_ucLineSpace = 31;
00000a  211f              MOVS     r1,#0x1f
                  |L31.12|
;;;1576   	}
;;;1577   	RA8875_WriteReg(0x29, _ucLineSpace);
00000c  2029              MOVS     r0,#0x29
00000e  f7fffffe          BL       RA8875_WriteReg
;;;1578   
;;;1579   	/*
;;;1580   		[2EH] 设置字符间距（像素单位，0-63），和字体（16*16，24*24，32*32）
;;;1581   	*/
;;;1582   	if (_ucCharSpace > 63)
000012  2c3f              CMP      r4,#0x3f
000014  d900              BLS      |L31.24|
;;;1583   	{
;;;1584   		_ucCharSpace = 63;
000016  243f              MOVS     r4,#0x3f
                  |L31.24|
;;;1585   	}
;;;1586   	if (_ucFontType > RA_FONT_32)
000018  2d02              CMP      r5,#2
00001a  d900              BLS      |L31.30|
;;;1587   	{
;;;1588   		_ucFontType = RA_FONT_16;
00001c  2500              MOVS     r5,#0
                  |L31.30|
;;;1589   	}
;;;1590   	RA8875_WriteReg(0x2E, (_ucCharSpace & 0x3F) | (_ucFontType << 6));
00001e  f365149f          BFI      r4,r5,#6,#26
000022  b2e1              UXTB     r1,r4
000024  e8bd4070          POP      {r4-r6,lr}
000028  202e              MOVS     r0,#0x2e
00002a  f7ffbffe          B.W      RA8875_WriteReg
;;;1591   }
;;;1592   
                          ENDP


                          AREA ||i.RA8875_SetFrontColor||, CODE, READONLY, ALIGN=1

                  RA8875_SetFrontColor PROC
;;;602    */
;;;603    void RA8875_SetFrontColor(uint16_t _usColor)
000000  b510              PUSH     {r4,lr}
;;;604    {
000002  4604              MOV      r4,r0
;;;605    	RA8875_WriteReg(0x63, (_usColor & 0xF800) >> 11);	/* R5  */
000004  0ac1              LSRS     r1,r0,#11
000006  2063              MOVS     r0,#0x63
000008  f7fffffe          BL       RA8875_WriteReg
;;;606    	RA8875_WriteReg(0x64, (_usColor & 0x07E0) >> 5);	/* G6 */
00000c  f3c41145          UBFX     r1,r4,#5,#6
000010  2064              MOVS     r0,#0x64
000012  f7fffffe          BL       RA8875_WriteReg
;;;607    	RA8875_WriteReg(0x65, (_usColor & 0x001F));			/* B5 */
000016  f004011f          AND      r1,r4,#0x1f
00001a  e8bd4010          POP      {r4,lr}
00001e  2065              MOVS     r0,#0x65
000020  f7ffbffe          B.W      RA8875_WriteReg
;;;608    }
;;;609    
                          ENDP


                          AREA ||i.RA8875_SetTextCursor||, CODE, READONLY, ALIGN=2

                  RA8875_SetTextCursor PROC
;;;1906   */
;;;1907   static void RA8875_SetTextCursor(uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1908   {
000002  4605              MOV      r5,r0
;;;1909   	if (g_LcdDirection > 1)	/* 竖屏  */
000004  480c              LDR      r0,|L33.56|
000006  460c              MOV      r4,r1                 ;1908
000008  7800              LDRB     r0,[r0,#0]  ; g_LcdDirection
00000a  2801              CMP      r0,#1
00000c  d901              BLS      |L33.18|
;;;1910   	{
;;;1911   		uint16_t temp;
;;;1912   		
;;;1913   		temp = _usX;
00000e  462c              MOV      r4,r5
;;;1914   		_usX = _usY;
000010  460d              MOV      r5,r1
                  |L33.18|
;;;1915   		_usY = temp;
;;;1916   	}
;;;1917   			
;;;1918   	/* 设置内存读光标的坐标 */
;;;1919   	RA8875_WriteReg(0x2A, _usX);
000012  b2e9              UXTB     r1,r5
000014  202a              MOVS     r0,#0x2a
000016  f7fffffe          BL       RA8875_WriteReg
;;;1920   	RA8875_WriteReg(0x2B, _usX >> 8);
00001a  0a29              LSRS     r1,r5,#8
00001c  202b              MOVS     r0,#0x2b
00001e  f7fffffe          BL       RA8875_WriteReg
;;;1921   	RA8875_WriteReg(0x2C, _usY);
000022  b2e1              UXTB     r1,r4
000024  202c              MOVS     r0,#0x2c
000026  f7fffffe          BL       RA8875_WriteReg
;;;1922   	RA8875_WriteReg(0x2D, _usY >> 8);
00002a  0a21              LSRS     r1,r4,#8
00002c  e8bd4070          POP      {r4-r6,lr}
000030  202d              MOVS     r0,#0x2d
000032  f7ffbffe          B.W      RA8875_WriteReg
;;;1923   }
;;;1924   
                          ENDP

000036  0000              DCW      0x0000
                  |L33.56|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_SetTextZoom||, CODE, READONLY, ALIGN=2

                  RA8875_SetTextZoom PROC
;;;1603   */
;;;1604   void RA8875_SetTextZoom(uint8_t _ucHSize, uint8_t _ucVSize)
000000  4a06              LDR      r2,|L34.28|
;;;1605   {
;;;1606   	/*
;;;1607   		pdf 第22页		[22H]
;;;1608   		bit7 用于对齐，一般不用，缺省设0
;;;1609   		bit6 用于通透，一般不用，缺省设0
;;;1610   		bit4 用于旋转90读，一般不用，缺省设0
;;;1611   		bit3-2 水平放大倍数
;;;1612   		bit1-0 垂直放大倍数
;;;1613   	*/
;;;1614   	if (g_LcdDirection > 1)	/* 竖屏  */
;;;1615   	{
;;;1616   		RA8875_WriteReg(0x22, (1 << 4) | ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
000002  f0000003          AND      r0,r0,#3
;;;1617   	}
;;;1618   	else	/* 横屏 */
;;;1619   	{
;;;1620   		RA8875_WriteReg(0x22, (0 << 4) | ((_ucHSize & 0x03) << 2) | ( _ucVSize & 0x03));
000006  f360019f          BFI      r1,r0,#2,#30
00000a  7812              LDRB     r2,[r2,#0]            ;1614  ; g_LcdDirection
00000c  2a01              CMP      r2,#1                 ;1614
00000e  d901              BLS      |L34.20|
000010  f0410110          ORR      r1,r1,#0x10           ;1616
                  |L34.20|
000014  2022              MOVS     r0,#0x22
000016  f7ffbffe          B.W      RA8875_WriteReg
;;;1621   	}
;;;1622   }
;;;1623   
                          ENDP

00001a  0000              DCW      0x0000
                  |L34.28|
                          DCD      g_LcdDirection

                          AREA ||i.RA8875_Sleep||, CODE, READONLY, ALIGN=1

                  RA8875_Sleep PROC
;;;916    */
;;;917    void RA8875_Sleep(void)
000000  b510              PUSH     {r4,lr}
;;;918    {
;;;919    	RA8875_SetBackLight(0);		/* 关闭背光 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       RA8875_SetBackLight
;;;920    
;;;921    	/* 设置TFT面板的 DISP  引脚为高，使能面板. 安富莱TFT模块的DISP引脚连接到RA8875芯片的GP0X脚 */
;;;922    	RA8875_WriteReg(0xC7, 0x00);	/* DISP = 0  */
000008  2100              MOVS     r1,#0
00000a  20c7              MOVS     r0,#0xc7
00000c  f7fffffe          BL       RA8875_WriteReg
;;;923    
;;;924    	RA8875_WriteReg(0x01, 0x01);
000010  2101              MOVS     r1,#1
000012  4608              MOV      r0,r1
000014  f7fffffe          BL       RA8875_WriteReg
;;;925    	RA8875_WriteReg(0x01, 0x00);
000018  2100              MOVS     r1,#0
00001a  2001              MOVS     r0,#1
00001c  f7fffffe          BL       RA8875_WriteReg
;;;926    
;;;927    	RA8875_WriteReg(0x01, 0x02);	/* RA8875 Sleep */
000020  2102              MOVS     r1,#2
000022  e8bd4010          POP      {r4,lr}
000026  2001              MOVS     r0,#1
000028  f7ffbffe          B.W      RA8875_WriteReg
;;;928    }
;;;929    
                          ENDP


                          AREA ||i.RA8875_StartDirectDraw||, CODE, READONLY, ALIGN=2

                  RA8875_StartDirectDraw PROC
;;;1218   */
;;;1219   void RA8875_StartDirectDraw(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth)
000000  b510              PUSH     {r4,lr}
;;;1220   {
;;;1221   	/* 设置图片的位置和大小， 即设置显示窗口 */
;;;1222   	RA8875_SetDispWin(_usX, _usY, _usHeight, _usWidth);
000002  f7fffffe          BL       RA8875_SetDispWin
;;;1223   
;;;1224   	s_ucRA8875Busy = 1;
000006  4904              LDR      r1,|L36.24|
000008  2001              MOVS     r0,#1
00000a  7008              STRB     r0,[r1,#0]
;;;1225   
;;;1226   	RA8875_WriteCmd(0x02); 		/* 准备读写显存 */
00000c  e8bd4010          POP      {r4,lr}
000010  2002              MOVS     r0,#2
000012  f7ffbffe          B.W      RA8875_WriteCmd
;;;1227   
;;;1228   	/* 之后，应用程序可以直接绘图 */
;;;1229   }
;;;1230   
                          ENDP

000016  0000              DCW      0x0000
                  |L36.24|
                          DCD      ||.data||

                          AREA ||i.RA8875_TouchInit||, CODE, READONLY, ALIGN=1

                  RA8875_TouchInit PROC
;;;750    */
;;;751    void RA8875_TouchInit(void)
000000  b510              PUSH     {r4,lr}
;;;752    {
;;;753    	RA8875_WriteReg(0xF0, (1 << 2));	/* 开启触控面板中断位 */
000002  2104              MOVS     r1,#4
000004  20f0              MOVS     r0,#0xf0
000006  f7fffffe          BL       RA8875_WriteReg
;;;754    
;;;755    	/*
;;;756    		REG[71h] Touch Panel Control Register 1 (TPCR1)
;;;757    
;;;758    		Bit7 N/A
;;;759    		Bit6 触控面板模式设定
;;;760    			0 : 自动模式。
;;;761    			1 : 手动模式。
;;;762    		Bit5 触控面板控制器ADC 参考电压(Vref)来源设定
;;;763    			0 : 内部产生参考电压。
;;;764    			1 : 外部输入参考电压，ADC 参考电压准位= 1/2 VDD。
;;;765    		Bit4-3 N/A
;;;766    		Bit2 触控中断讯号的消除弹跳电路选择
;;;767    			0: 关闭消除弹跳电路。
;;;768    			1: 开启消除弹跳电路。
;;;769    		Bit1-0 触控面板手动模式之选择位
;;;770    			00b : 闲置模式。触控控制单元进入闲置模式。
;;;771    			01b : 侦测触摸事件发生。在此模式控制器会侦测触摸事件的发
;;;772    				生，事件发生可以引发中断或是由缓存器得知(REG[F1h]
;;;773    				Bit2)。
;;;774    			10b : X 轴数据撷取模式。在此模式触摸位置的X 轴数据会被储
;;;775    				存至 REG[72h] 和REG[74h]。
;;;776    			11b : Y 轴数据撷取模式。在此模式触摸位置的Y 轴数据会被储
;;;777    				存至REG[73h] and REG[74h]。
;;;778    	*/
;;;779    	RA8875_WriteReg(0x71, (0 << 6) | (0 << 5) | (1 << 2));	/* 选择自动模式 */
00000a  2104              MOVS     r1,#4
00000c  2071              MOVS     r0,#0x71
00000e  f7fffffe          BL       RA8875_WriteReg
;;;780    
;;;781    	/*
;;;782    		REG[70h] Touch Panel Control Register 0 (TPCR0)
;;;783    
;;;784    		Bit7 触控面板功能设定
;;;785    			0 : 关闭。
;;;786    			1 : 开启。
;;;787    		Bit6-4 触控面板控制器取样时间设定
;;;788    			000b : ADC 取样时间为512 个系统频率周期。
;;;789    			001b : ADC 取样时间为 1024 个系统频率周期。
;;;790    			010b : ADC 取样时间为 2048 个系统频率周期。
;;;791    			011b : ADC 取样时间为 4096 个系统频率周期。
;;;792    			100b : ADC 取样时间为 8192 个系统频率周期。
;;;793    			101b : ADC 取样时间为 16384 个系统频率周期。
;;;794    			110b : ADC 取样时间为 32768 个系统频率周期。
;;;795    			111b : ADC 取样时间为65536 个系统频率周期。
;;;796    		Bit3 触控面板唤醒模式
;;;797    			0 : 关闭触控事件唤醒模式。
;;;798    			1 : 触控事件可唤醒睡眠模式。
;;;799    		Bit2-0 触控面板控制器ADC 频率设定
;;;800    			000b : 系统频率。
;;;801    			001b : 系统频率 / 2。
;;;802    			010b : 系统频率 / 4。
;;;803    			011b : 系统频率 / 8。
;;;804    			100b : 系统频率 / 16。
;;;805    			101b : 系统频率 / 32。
;;;806    			110b : 系统频率 / 64。
;;;807    			111b : 系统频率 / 128。
;;;808    
;;;809    		注 : ADC 的输入频率设定不能超过10MHz。
;;;810    	*/
;;;811    	RA8875_WriteReg(0x70, (1 << 7) | (3 << 4) | (0 << 3) | (2 << 0));	/* 开启触摸功能； */
000012  21b2              MOVS     r1,#0xb2
000014  e8bd4010          POP      {r4,lr}
000018  2070              MOVS     r0,#0x70
00001a  f7ffbffe          B.W      RA8875_WriteReg
;;;812    }
;;;813    
                          ENDP


                          AREA ||i.RA8875_TouchReadX||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadX PROC
;;;821    */
;;;822    uint16_t RA8875_TouchReadX(void)
000000  b570              PUSH     {r4-r6,lr}
;;;823    {
;;;824    	uint16_t usAdc;
;;;825    	uint8_t ucRegValue;
;;;826    	uint8_t ucReg74;
;;;827    
;;;828    	/* 软件读取中断事件标志 */
;;;829    	ucRegValue = RA8875_ReadReg_Int(0xF1);
000002  20f1              MOVS     r0,#0xf1
000004  f7fffffe          BL       RA8875_ReadReg_Int
;;;830    	if (ucRegValue & (1 << 2))
;;;831    	{
;;;832    		ucReg74 = RA8875_ReadReg_Int(0x74);
;;;833    		usAdc = RA8875_ReadReg_Int(0x72);	/* Bit9-2 */
;;;834    		usAdc <<= 2;
;;;835    		usAdc += (ucReg74 & 0x03);
;;;836    
;;;837    		s_usTouchX = usAdc;
000008  4c12              LDR      r4,|L38.84|
00000a  0740              LSLS     r0,r0,#29             ;830
00000c  d517              BPL      |L38.62|
00000e  2074              MOVS     r0,#0x74              ;832
000010  f7fffffe          BL       RA8875_ReadReg_Int
000014  4605              MOV      r5,r0                 ;832
000016  2072              MOVS     r0,#0x72              ;833
000018  f7fffffe          BL       RA8875_ReadReg_Int
00001c  f64f76ff          MOV      r6,#0xffff            ;834
000020  ea060180          AND      r1,r6,r0,LSL #2       ;834
000024  f0050003          AND      r0,r5,#3              ;835
000028  4408              ADD      r0,r0,r1              ;835
00002a  8160              STRH     r0,[r4,#0xa]
;;;838    
;;;839    		usAdc = RA8875_ReadReg_Int(0x73);	/* Bit9-2 */
00002c  2073              MOVS     r0,#0x73
00002e  f7fffffe          BL       RA8875_ReadReg_Int
;;;840    		usAdc <<= 2;
000032  ea060180          AND      r1,r6,r0,LSL #2
;;;841    		usAdc += ((ucReg74 & 0x0C) >> 2);
000036  f3c50081          UBFX     r0,r5,#2,#2
00003a  4408              ADD      r0,r0,r1
;;;842    
;;;843    		s_usTouchY = usAdc;
00003c  e001              B        |L38.66|
                  |L38.62|
;;;844    	}
;;;845    	else
;;;846    	{
;;;847    		s_usTouchX = 0;
00003e  2000              MOVS     r0,#0
000040  8160              STRH     r0,[r4,#0xa]
                  |L38.66|
;;;848    		s_usTouchY = 0;
000042  81a0              STRH     r0,[r4,#0xc]
;;;849    	}
;;;850    
;;;851    	/*
;;;852    		bit2 写入功能?? 触控面板中断清除位
;;;853    		0 : 未操作。
;;;854    		1 : 清除触控面板中断。
;;;855    		读取功能?? 触控面板中断状态
;;;856    		0 : 未发生触控面板中断。
;;;857    		1 : 发生触控面板中断。
;;;858    	*/
;;;859    
;;;860    	/*
;;;861    		不要调用这个函数写寄存器，因为该函数改写了busy标志
;;;862    		RA8875_WriteReg(0xF1, (1 << 2));	 必须清除， 才会下次采样.
;;;863    	*/
;;;864    	RA8875_WriteCmd(0xF1);
000044  20f1              MOVS     r0,#0xf1
000046  f7fffffe          BL       RA8875_WriteCmd
;;;865    	RA8875_WriteData(1 << 2);
00004a  2004              MOVS     r0,#4
00004c  f7fffffe          BL       RA8875_WriteData
;;;866    
;;;867    	return s_usTouchX;
000050  8960              LDRH     r0,[r4,#0xa]  ; s_usTouchX
;;;868    }
000052  bd70              POP      {r4-r6,pc}
;;;869    
                          ENDP

                  |L38.84|
                          DCD      ||.data||

                          AREA ||i.RA8875_TouchReadY||, CODE, READONLY, ALIGN=2

                  RA8875_TouchReadY PROC
;;;877    */
;;;878    uint16_t RA8875_TouchReadY(void)
000000  4801              LDR      r0,|L39.8|
;;;879    {
;;;880    	return s_usTouchY;
000002  8980              LDRH     r0,[r0,#0xc]  ; s_usTouchY
;;;881    }
000004  4770              BX       lr
;;;882    
                          ENDP

000006  0000              DCW      0x0000
                  |L39.8|
                          DCD      ||.data||

                          AREA ||i.RA8875_WaitBusy||, CODE, READONLY, ALIGN=2

                  RA8875_WaitBusy PROC
;;;689    */
;;;690    void RA8875_WaitBusy(void)
000000  e92d4010          PUSH.W   {r4,lr}
                  |L40.4|
;;;691    {
;;;692    	while ((RA8875_ReadStatus() & 0x80) == 0x80);
000004  f7fffffe          BL       RA8875_ReadStatus
000008  0600              LSLS     r0,r0,#24
00000a  d4fb              BMI      |L40.4|
;;;693    }
00000c  bd10              POP      {r4,pc}
;;;694    
                          ENDP


                          AREA ||i.RA8875_WriteReg||, CODE, READONLY, ALIGN=2

                  RA8875_WriteReg PROC
;;;99     */
;;;100    void RA8875_WriteReg(uint8_t _ucRegAddr, uint8_t _ucRegValue)
000000  b570              PUSH     {r4-r6,lr}
;;;101    {
;;;102    	s_ucRA8875Busy = 1;				/* 设置忙标志，避免触摸中断中的程序访问冲突 */
000002  4c06              LDR      r4,|L41.28|
000004  460d              MOV      r5,r1                 ;101
000006  2101              MOVS     r1,#1
000008  7021              STRB     r1,[r4,#0]
;;;103    
;;;104    	RA8875_WriteCmd(_ucRegAddr);
00000a  f7fffffe          BL       RA8875_WriteCmd
;;;105    	RA8875_WriteData(_ucRegValue);
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       RA8875_WriteData
;;;106    
;;;107    	s_ucRA8875Busy = 0;
000014  2000              MOVS     r0,#0
000016  7020              STRB     r0,[r4,#0]
;;;108    }
000018  bd70              POP      {r4-r6,pc}
;;;109    
                          ENDP

00001a  0000              DCW      0x0000
                  |L41.28|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=1

                  s_ucRA8875Busy
000000  00                DCB      0x00
                  s_reg_40H
000001  00                DCB      0x00
                  s_WinX
000002  0000              DCW      0x0000
                  s_WinY
000004  0000              DCW      0x0000
                  s_WinHeight
000006  0110              DCW      0x0110
                  s_WinWidth
000008  01e0              DCW      0x01e0
                  s_usTouchX
00000a  0000              DCB      0x00,0x00
                  s_usTouchY
00000c  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\LCD_RA8875.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_LCD_RA8875_c_fad3ed70____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_LCD_RA8875_c_fad3ed70____REVSH|
#line 128
|__asm___12_LCD_RA8875_c_fad3ed70____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
