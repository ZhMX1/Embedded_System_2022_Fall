; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\uip.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\uip.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\uip.crf ..\..\User\uIP\uip\uip.c]
                          THUMB

                          AREA ||i.chksum||, CODE, READONLY, ALIGN=1

                  chksum PROC
;;;279    static u16_t
;;;280    chksum(u16_t sum, const u8_t *data, u16_t len)
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282      u16_t t;
;;;283      const u8_t *dataptr;
;;;284      const u8_t *last_byte;
;;;285    
;;;286      dataptr = data;
;;;287      last_byte = data + len - 1;
000002  440a              ADD      r2,r2,r1
000004  1e52              SUBS     r2,r2,#1
000006  e00b              B        |L1.32|
                  |L1.8|
;;;288    
;;;289      while(dataptr < last_byte) {	/* At least two more bytes */
;;;290        t = (dataptr[0] << 8) + dataptr[1];
000008  784b              LDRB     r3,[r1,#1]
00000a  780c              LDRB     r4,[r1,#0]
00000c  eb032304          ADD      r3,r3,r4,LSL #8
000010  b29b              UXTH     r3,r3
;;;291        sum += t;
000012  4418              ADD      r0,r0,r3
000014  b280              UXTH     r0,r0
;;;292        if(sum < t) {
000016  4298              CMP      r0,r3
000018  d201              BCS      |L1.30|
00001a  1c40              ADDS     r0,r0,#1
;;;293          sum++;		/* carry */
00001c  b280              UXTH     r0,r0
                  |L1.30|
00001e  1c89              ADDS     r1,r1,#2
                  |L1.32|
000020  4291              CMP      r1,r2                 ;289
000022  d3f1              BCC      |L1.8|
;;;294        }
;;;295        dataptr += 2;
;;;296      }
;;;297    
;;;298      if(dataptr == last_byte) {
000024  4291              CMP      r1,r2
000026  d107              BNE      |L1.56|
;;;299        t = (dataptr[0] << 8) + 0;
000028  7809              LDRB     r1,[r1,#0]
00002a  0209              LSLS     r1,r1,#8
;;;300        sum += t;
00002c  4408              ADD      r0,r0,r1
00002e  b280              UXTH     r0,r0
;;;301        if(sum < t) {
000030  4288              CMP      r0,r1
000032  d201              BCS      |L1.56|
000034  1c40              ADDS     r0,r0,#1
;;;302          sum++;		/* carry */
000036  b280              UXTH     r0,r0
                  |L1.56|
;;;303        }
;;;304      }
;;;305    
;;;306      /* Return sum in host byte order. */
;;;307      return sum;
;;;308    }
000038  bd10              POP      {r4,pc}
;;;309    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.htons||, CODE, READONLY, ALIGN=1

                  htons PROC
;;;1882   u16_t
;;;1883   htons(u16_t val)
000000  0201              LSLS     r1,r0,#8
;;;1884   {
;;;1885     return HTONS(val);
000002  ea412010          ORR      r0,r1,r0,LSR #8
000006  b280              UXTH     r0,r0
;;;1886   }
000008  4770              BX       lr
;;;1887   /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_add32||, CODE, READONLY, ALIGN=2

                  uip_add32 PROC
;;;248    void
;;;249    uip_add32(u8_t *op32, u16_t op16)
000000  b530              PUSH     {r4,r5,lr}
;;;250    {
;;;251      uip_acc32[3] = op32[3] + (op16 & 0xff);
000002  78c2              LDRB     r2,[r0,#3]
000004  440a              ADD      r2,r2,r1
000006  b2d5              UXTB     r5,r2
000008  4a13              LDR      r2,|L3.88|
00000a  70d5              STRB     r5,[r2,#3]
;;;252      uip_acc32[2] = op32[2] + (op16 >> 8);
00000c  7883              LDRB     r3,[r0,#2]
00000e  eb032311          ADD      r3,r3,r1,LSR #8
000012  b2db              UXTB     r3,r3
000014  7093              STRB     r3,[r2,#2]
;;;253      uip_acc32[1] = op32[1];
000016  7844              LDRB     r4,[r0,#1]
000018  7054              STRB     r4,[r2,#1]
;;;254      uip_acc32[0] = op32[0];
00001a  7800              LDRB     r0,[r0,#0]
00001c  7010              STRB     r0,[r2,#0]
;;;255    
;;;256      if(uip_acc32[2] < (op16 >> 8)) {
00001e  ebb32f11          CMP      r3,r1,LSR #8
000022  d206              BCS      |L3.50|
000024  1c64              ADDS     r4,r4,#1              ;250
;;;257        ++uip_acc32[1];
000026  f01404ff          ANDS     r4,r4,#0xff
00002a  7054              STRB     r4,[r2,#1]
;;;258        if(uip_acc32[1] == 0) {
00002c  d101              BNE      |L3.50|
00002e  1c40              ADDS     r0,r0,#1
;;;259          ++uip_acc32[0];
000030  7010              STRB     r0,[r2,#0]
                  |L3.50|
;;;260        }
;;;261      }
;;;262    
;;;263    
;;;264      if(uip_acc32[3] < (op16 & 0xff)) {
000032  b2c8              UXTB     r0,r1
000034  4285              CMP      r5,r0
000036  d20d              BCS      |L3.84|
000038  1c5b              ADDS     r3,r3,#1
;;;265        ++uip_acc32[2];
00003a  f01300ff          ANDS     r0,r3,#0xff
00003e  7090              STRB     r0,[r2,#2]
;;;266        if(uip_acc32[2] == 0) {
000040  d108              BNE      |L3.84|
;;;267          ++uip_acc32[1];
000042  7850              LDRB     r0,[r2,#1]  ; uip_acc32
000044  1c40              ADDS     r0,r0,#1
000046  f01000ff          ANDS     r0,r0,#0xff
00004a  7050              STRB     r0,[r2,#1]
;;;268          if(uip_acc32[1] == 0) {
00004c  d102              BNE      |L3.84|
;;;269    	++uip_acc32[0];
00004e  7810              LDRB     r0,[r2,#0]  ; uip_acc32
000050  1c40              ADDS     r0,r0,#1
000052  7010              STRB     r0,[r2,#0]
                  |L3.84|
;;;270          }
;;;271        }
;;;272      }
;;;273    }
000054  bd30              POP      {r4,r5,pc}
;;;274    
                          ENDP

000056  0000              DCW      0x0000
                  |L3.88|
                          DCD      ||area_number.22||+0x24

                          AREA ||i.uip_add_rcv_nxt||, CODE, READONLY, ALIGN=2

                  uip_add_rcv_nxt PROC
;;;671    static void
;;;672    uip_add_rcv_nxt(u16_t n)
000000  b510              PUSH     {r4,lr}
;;;673    {
;;;674      uip_add32(uip_conn->rcv_nxt, n);
000002  4c09              LDR      r4,|L4.40|
000004  4601              MOV      r1,r0
000006  69e0              LDR      r0,[r4,#0x1c]  ; uip_conn
000008  3008              ADDS     r0,r0,#8
00000a  f7fffffe          BL       uip_add32
;;;675      uip_conn->rcv_nxt[0] = uip_acc32[0];
00000e  f1040024          ADD      r0,r4,#0x24
000012  69e1              LDR      r1,[r4,#0x1c]  ; uip_conn
000014  7802              LDRB     r2,[r0,#0]  ; uip_acc32
000016  720a              STRB     r2,[r1,#8]
;;;676      uip_conn->rcv_nxt[1] = uip_acc32[1];
000018  7842              LDRB     r2,[r0,#1]  ; uip_acc32
00001a  724a              STRB     r2,[r1,#9]
;;;677      uip_conn->rcv_nxt[2] = uip_acc32[2];
00001c  7882              LDRB     r2,[r0,#2]  ; uip_acc32
00001e  728a              STRB     r2,[r1,#0xa]
;;;678      uip_conn->rcv_nxt[3] = uip_acc32[3];
000020  78c0              LDRB     r0,[r0,#3]  ; uip_acc32
000022  72c8              STRB     r0,[r1,#0xb]
;;;679    }
000024  bd10              POP      {r4,pc}
;;;680    /*---------------------------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L4.40|
                          DCD      ||area_number.22||

                          AREA ||i.uip_chksum||, CODE, READONLY, ALIGN=1

                  uip_chksum PROC
;;;310    u16_t
;;;311    uip_chksum(u16_t *data, u16_t len)
000000  460a              MOV      r2,r1
;;;312    {
000002  b510              PUSH     {r4,lr}
;;;313      return htons(chksum(0, (u8_t *)data, len));
000004  4601              MOV      r1,r0
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       chksum
00000c  e8bd4010          POP      {r4,lr}
000010  f7ffbffe          B.W      htons
;;;314    }
;;;315    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_connect||, CODE, READONLY, ALIGN=2

                  uip_connect PROC
;;;406    struct uip_conn *
;;;407    uip_connect(uip_ipaddr_t *ripaddr, u16_t rport)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;408    {
000004  4689              MOV      r9,r1
;;;409      register struct uip_conn *conn, *cconn;
;;;410    
;;;411      /* Find an unused local port. */
;;;412     again:
;;;413      ++lastport;
;;;414    
;;;415      if(lastport >= 32000) {
;;;416        lastport = 4096;
;;;417      }
;;;418    
;;;419      /* Check if this port is already in use, and if so try to find
;;;420         another one. */
;;;421      for(c = 0; c < UIP_CONNS; ++c) {
;;;422        conn = &uip_conns[c];
000006  4b36              LDR      r3,|L6.224|
000008  4936              LDR      r1,|L6.228|
00000a  4604              MOV      r4,r0                 ;408
00000c  f44f4cfa          MOV      r12,#0x7d00           ;415
000010  f44f5880          MOV      r8,#0x1000            ;416
000014  2200              MOVS     r2,#0                 ;416
                  |L6.22|
000016  8948              LDRH     r0,[r1,#0xa]          ;413  ; lastport
000018  1c40              ADDS     r0,r0,#1              ;413
00001a  b280              UXTH     r0,r0                 ;413
00001c  8148              STRH     r0,[r1,#0xa]          ;413
00001e  4560              CMP      r0,r12                ;415
000020  d301              BCC      |L6.38|
000022  f8a1800a          STRH     r8,[r1,#0xa]          ;416
                  |L6.38|
000026  704a              STRB     r2,[r1,#1]            ;421
000028  894d              LDRH     r5,[r1,#0xa]          ;413
;;;423        if(conn->tcpstateflags != UIP_CLOSED &&
;;;424           conn->lport == htons(lastport)) {
00002a  0228              LSLS     r0,r5,#8
00002c  ea402015          ORR      r0,r0,r5,LSR #8
000030  b286              UXTH     r6,r0
                  |L6.50|
000032  784d              LDRB     r5,[r1,#1]            ;422  ; c
000034  eb051005          ADD      r0,r5,r5,LSL #4       ;422
000038  eb000040          ADD      r0,r0,r0,LSL #1       ;422
00003c  eb030080          ADD      r0,r3,r0,LSL #2       ;422
000040  7e47              LDRB     r7,[r0,#0x19]         ;423
000042  b117              CBZ      r7,|L6.74|
000044  8880              LDRH     r0,[r0,#4]
000046  4286              CMP      r6,r0
000048  d0e5              BEQ      |L6.22|
                  |L6.74|
00004a  1c6d              ADDS     r5,r5,#1
00004c  b2e8              UXTB     r0,r5                 ;421
00004e  7048              STRB     r0,[r1,#1]            ;421
000050  2828              CMP      r0,#0x28              ;421
000052  d3ee              BCC      |L6.50|
;;;425          goto again;
;;;426        }
;;;427      }
;;;428    
;;;429      conn = 0;
000054  2500              MOVS     r5,#0
;;;430      for(c = 0; c < UIP_CONNS; ++c) {
000056  704a              STRB     r2,[r1,#1]
                  |L6.88|
;;;431        cconn = &uip_conns[c];
000058  784e              LDRB     r6,[r1,#1]  ; c
00005a  eb061006          ADD      r0,r6,r6,LSL #4
00005e  eb000040          ADD      r0,r0,r0,LSL #1
000062  eb030080          ADD      r0,r3,r0,LSL #2
;;;432        if(cconn->tcpstateflags == UIP_CLOSED) {
000066  7e47              LDRB     r7,[r0,#0x19]
000068  b117              CBZ      r7,|L6.112|
;;;433          conn = cconn;
;;;434          break;
;;;435        }
;;;436        if(cconn->tcpstateflags == UIP_TIME_WAIT) {
00006a  2f07              CMP      r7,#7
00006c  d002              BEQ      |L6.116|
00006e  e008              B        |L6.130|
                  |L6.112|
000070  4605              MOV      r5,r0                 ;433
000072  e00b              B        |L6.140|
                  |L6.116|
;;;437          if(conn == 0 ||
000074  b125              CBZ      r5,|L6.128|
;;;438    	 cconn->timer > conn->timer) {
000076  7e87              LDRB     r7,[r0,#0x1a]
000078  f895c01a          LDRB     r12,[r5,#0x1a]
00007c  4567              CMP      r7,r12
00007e  d900              BLS      |L6.130|
                  |L6.128|
;;;439    	conn = cconn;
000080  4605              MOV      r5,r0
                  |L6.130|
000082  1c76              ADDS     r6,r6,#1
000084  b2f0              UXTB     r0,r6                 ;430
000086  7048              STRB     r0,[r1,#1]            ;430
000088  2828              CMP      r0,#0x28              ;430
00008a  d3e5              BCC      |L6.88|
                  |L6.140|
;;;440          }
;;;441        }
;;;442      }
;;;443    
;;;444      if(conn == 0) {
00008c  b32d              CBZ      r5,|L6.218|
;;;445        return 0;
;;;446      }
;;;447    
;;;448      conn->tcpstateflags = UIP_SYN_SENT;
00008e  2002              MOVS     r0,#2
000090  7668              STRB     r0,[r5,#0x19]
;;;449    
;;;450      conn->snd_nxt[0] = iss[0];
000092  4814              LDR      r0,|L6.228|
000094  3020              ADDS     r0,r0,#0x20
000096  7803              LDRB     r3,[r0,#0]  ; iss
000098  732b              STRB     r3,[r5,#0xc]
;;;451      conn->snd_nxt[1] = iss[1];
00009a  7843              LDRB     r3,[r0,#1]  ; iss
00009c  736b              STRB     r3,[r5,#0xd]
;;;452      conn->snd_nxt[2] = iss[2];
00009e  7883              LDRB     r3,[r0,#2]  ; iss
0000a0  73ab              STRB     r3,[r5,#0xe]
;;;453      conn->snd_nxt[3] = iss[3];
0000a2  78c0              LDRB     r0,[r0,#3]  ; iss
0000a4  73e8              STRB     r0,[r5,#0xf]
;;;454    
;;;455      conn->initialmss = conn->mss = UIP_TCP_MSS;
0000a6  f24050a6          MOV      r0,#0x5a6
0000aa  8268              STRH     r0,[r5,#0x12]
0000ac  82a8              STRH     r0,[r5,#0x14]
;;;456    
;;;457      conn->len = 1;   /* TCP length of the SYN is one. */
0000ae  2001              MOVS     r0,#1
0000b0  8228              STRH     r0,[r5,#0x10]
;;;458      conn->nrtx = 0;
0000b2  76ea              STRB     r2,[r5,#0x1b]
;;;459      conn->timer = 1; /* Send the SYN next time around. */
0000b4  76a8              STRB     r0,[r5,#0x1a]
;;;460      conn->rto = UIP_RTO;
0000b6  2003              MOVS     r0,#3
0000b8  7628              STRB     r0,[r5,#0x18]
;;;461      conn->sa = 0;
0000ba  75aa              STRB     r2,[r5,#0x16]
;;;462      conn->sv = 16;   /* Initial value of the RTT variance. */
0000bc  2010              MOVS     r0,#0x10
0000be  75e8              STRB     r0,[r5,#0x17]
;;;463      conn->lport = htons(lastport);
0000c0  8948              LDRH     r0,[r1,#0xa]  ; lastport
0000c2  f7fffffe          BL       htons
0000c6  80a8              STRH     r0,[r5,#4]
;;;464      conn->rport = rport;
0000c8  f8a59006          STRH     r9,[r5,#6]
;;;465      uip_ipaddr_copy(&conn->ripaddr, ripaddr);
0000cc  8820              LDRH     r0,[r4,#0]
0000ce  8028              STRH     r0,[r5,#0]
0000d0  8860              LDRH     r0,[r4,#2]
0000d2  8068              STRH     r0,[r5,#2]
;;;466    
;;;467      return conn;
0000d4  4628              MOV      r0,r5
                  |L6.214|
;;;468    }
0000d6  e8bd83f0          POP      {r4-r9,pc}
                  |L6.218|
0000da  2000              MOVS     r0,#0                 ;445
0000dc  e7fb              B        |L6.214|
;;;469    #endif /* UIP_ACTIVE_OPEN */
                          ENDP

0000de  0000              DCW      0x0000
                  |L6.224|
                          DCD      ||.bss||+0x5e0
                  |L6.228|
                          DCD      ||area_number.22||

                          AREA ||i.uip_init||, CODE, READONLY, ALIGN=2

                  uip_init PROC
;;;378    void
;;;379    uip_init(void)
000000  480f              LDR      r0,|L7.64|
;;;380    {
000002  b510              PUSH     {r4,lr}
;;;381      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000004  2100              MOVS     r1,#0
;;;382        uip_listenports[c] = 0;
000006  4b0f              LDR      r3,|L7.68|
000008  7041              STRB     r1,[r0,#1]            ;381
                  |L7.10|
00000a  7842              LDRB     r2,[r0,#1]  ; c
00000c  f8231012          STRH     r1,[r3,r2,LSL #1]
000010  1c52              ADDS     r2,r2,#1
000012  b2d2              UXTB     r2,r2                 ;381
000014  7042              STRB     r2,[r0,#1]            ;381
000016  2a28              CMP      r2,#0x28              ;381
000018  d3f7              BCC      |L7.10|
;;;383      }
;;;384      for(c = 0; c < UIP_CONNS; ++c) {
;;;385        uip_conns[c].tcpstateflags = UIP_CLOSED;
00001a  4b0b              LDR      r3,|L7.72|
00001c  7041              STRB     r1,[r0,#1]            ;384
                  |L7.30|
00001e  7842              LDRB     r2,[r0,#1]  ; c
000020  eb021402          ADD      r4,r2,r2,LSL #4
000024  eb040444          ADD      r4,r4,r4,LSL #1
000028  eb030484          ADD      r4,r3,r4,LSL #2
00002c  1c52              ADDS     r2,r2,#1
00002e  b2d2              UXTB     r2,r2                 ;384
000030  7661              STRB     r1,[r4,#0x19]
000032  7042              STRB     r2,[r0,#1]            ;384
000034  2a28              CMP      r2,#0x28              ;384
000036  d3f2              BCC      |L7.30|
;;;386      }
;;;387    #if UIP_ACTIVE_OPEN
;;;388      lastport = 1024;
000038  f44f6180          MOV      r1,#0x400
00003c  8141              STRH     r1,[r0,#0xa]
;;;389    #endif /* UIP_ACTIVE_OPEN */
;;;390    
;;;391    #if UIP_UDP
;;;392      for(c = 0; c < UIP_UDP_CONNS; ++c) {
;;;393        uip_udp_conns[c].lport = 0;
;;;394      }
;;;395    #endif /* UIP_UDP */
;;;396    
;;;397    
;;;398      /* IPv4 initialization. */
;;;399    #if UIP_FIXEDADDR == 0
;;;400      /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
;;;401    #endif /* UIP_FIXEDADDR */
;;;402    
;;;403    }
00003e  bd10              POP      {r4,pc}
;;;404    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L7.64|
                          DCD      ||area_number.22||
                  |L7.68|
                          DCD      ||.bss||+0x25c0
                  |L7.72|
                          DCD      ||.bss||+0x5e0

                          AREA ||i.uip_ipchksum||, CODE, READONLY, ALIGN=2

                  uip_ipchksum PROC
;;;317    u16_t
;;;318    uip_ipchksum(void)
000000  b510              PUSH     {r4,lr}
;;;319    {
;;;320      u16_t sum;
;;;321    
;;;322      sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
000002  2214              MOVS     r2,#0x14
000004  4906              LDR      r1,|L8.32|
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       chksum
;;;323      DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
;;;324      return (sum == 0) ? 0xffff : htons(sum);
00000c  b120              CBZ      r0,|L8.24|
00000e  0201              LSLS     r1,r0,#8
000010  ea412010          ORR      r0,r1,r0,LSR #8
000014  b280              UXTH     r0,r0
;;;325    }
000016  bd10              POP      {r4,pc}
                  |L8.24|
000018  f64f70ff          MOV      r0,#0xffff            ;324
00001c  bd10              POP      {r4,pc}
;;;326    #endif
                          ENDP

00001e  0000              DCW      0x0000
                  |L8.32|
                          DCD      ||.bss||+0xe

                          AREA ||i.uip_listen||, CODE, READONLY, ALIGN=2

                  uip_listen PROC
;;;528    void
;;;529    uip_listen(u16_t port)
000000  4909              LDR      r1,|L9.40|
;;;530    {
000002  b510              PUSH     {r4,lr}
;;;531      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000004  2200              MOVS     r2,#0
;;;532        if(uip_listenports[c] == 0) {
000006  4b09              LDR      r3,|L9.44|
000008  704a              STRB     r2,[r1,#1]            ;531
                  |L9.10|
00000a  b2d2              UXTB     r2,r2
00000c  f8334012          LDRH     r4,[r3,r2,LSL #1]
000010  b12c              CBZ      r4,|L9.30|
000012  1c52              ADDS     r2,r2,#1
000014  b2d2              UXTB     r2,r2                 ;531
000016  704a              STRB     r2,[r1,#1]            ;531
000018  2a28              CMP      r2,#0x28              ;531
00001a  d3f6              BCC      |L9.10|
;;;533          uip_listenports[c] = port;
;;;534          return;
;;;535        }
;;;536      }
;;;537    }
00001c  bd10              POP      {r4,pc}
                  |L9.30|
00001e  b2d1              UXTB     r1,r2                 ;533
000020  f8230011          STRH     r0,[r3,r1,LSL #1]     ;533
000024  bd10              POP      {r4,pc}
;;;538    /*---------------------------------------------------------------------------*/
                          ENDP

000026  0000              DCW      0x0000
                  |L9.40|
                          DCD      ||area_number.22||
                  |L9.44|
                          DCD      ||.bss||+0x25c0

                          AREA ||i.uip_process||, CODE, READONLY, ALIGN=2

                  uip_process PROC
;;;681    void
;;;682    uip_process(u8_t flag)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;683    {
;;;684      register struct uip_conn *uip_connr = uip_conn;
000004  4efd              LDR      r6,|L10.1020|
;;;685    
;;;686    #if UIP_UDP
;;;687      if(flag == UIP_UDP_SEND_CONN) {
;;;688        goto udp_send;
;;;689      }
;;;690    #endif /* UIP_UDP */
;;;691    
;;;692      uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
000006  49fe              LDR      r1,|L10.1024|
000008  4632              MOV      r2,r6
00000a  69f4              LDR      r4,[r6,#0x1c]  ; uip_conn
00000c  6151              STR      r1,[r2,#0x14]  ; uip_appdata
00000e  2700              MOVS     r7,#0
;;;693    
;;;694      /* Check if we were invoked because of a poll request for a
;;;695         particular connection. */
;;;696      if(flag == UIP_POLL_REQUEST) {
;;;697        if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
;;;698           !uip_outstanding(uip_connr)) {
;;;699    	uip_flags = UIP_POLL;
;;;700    	UIP_APPCALL();
;;;701    	goto appsend;
;;;702        }
;;;703        goto drop;
;;;704    
;;;705        /* Check if we were invoked because of the perodic timer fireing. */
;;;706      } else if(flag == UIP_TIMER) {
;;;707    #if UIP_REASSEMBLY
;;;708        if(uip_reasstmr != 0) {
;;;709          --uip_reasstmr;
;;;710        }
;;;711    #endif /* UIP_REASSEMBLY */
;;;712        /* Increase the initial sequence number. */
;;;713        if(++iss[3] == 0) {
;;;714          if(++iss[2] == 0) {
;;;715    	if(++iss[1] == 0) {
;;;716    	  ++iss[0];
;;;717    	}
;;;718          }
;;;719        }
;;;720    
;;;721        /* Reset the length variables. */
;;;722        uip_len = 0;
;;;723        uip_slen = 0;
;;;724    
;;;725        /* Check if the connection is in a state in which we simply wait
;;;726           for the connection to time out. If so, we increase the
;;;727           connection's timer and remove the connection if it times
;;;728           out. */
;;;729        if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
;;;730           uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
;;;731          ++(uip_connr->timer);
;;;732          if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
;;;733    	uip_connr->tcpstateflags = UIP_CLOSED;
;;;734          }
;;;735        } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
;;;736          /* If the connection has outstanding data, we increase the
;;;737    	 connection's timer and see if it has reached the RTO value
;;;738    	 in which case we retransmit. */
;;;739          if(uip_outstanding(uip_connr)) {
;;;740    	if(uip_connr->timer-- == 0) {
;;;741    	  if(uip_connr->nrtx == UIP_MAXRTX ||
;;;742    	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
;;;743    	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
;;;744    	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
;;;745    	    uip_connr->tcpstateflags = UIP_CLOSED;
;;;746    
;;;747    	    /* We call UIP_APPCALL() with uip_flags set to
;;;748    	       UIP_TIMEDOUT to inform the application that the
;;;749    	       connection has timed out. */
;;;750    	    uip_flags = UIP_TIMEDOUT;
;;;751    	    UIP_APPCALL();
;;;752    
;;;753    	    /* We also send a reset packet to the remote host. */
;;;754    	    BUF->flags = TCP_RST | TCP_ACK;
;;;755    	    goto tcp_send_nodata;
;;;756    	  }
;;;757    
;;;758    	  /* Exponential backoff. */
;;;759    	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
;;;760    					 4:
;;;761    					 uip_connr->nrtx);
;;;762    	  ++(uip_connr->nrtx);
;;;763    
;;;764    	  /* Ok, so we need to retransmit. We do this differently
;;;765    	     depending on which state we are in. In ESTABLISHED, we
;;;766    	     call upon the application so that it may prepare the
;;;767    	     data for the retransmit. In SYN_RCVD, we resend the
;;;768    	     SYNACK that we sent earlier and in LAST_ACK we have to
;;;769    	     retransmit our FINACK. */
;;;770    	  UIP_STAT(++uip_stat.tcp.rexmit);
;;;771    	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
;;;772    	  case UIP_SYN_RCVD:
;;;773    	    /* In the SYN_RCVD state, we should retransmit our
;;;774                   SYNACK. */
;;;775    	    goto tcp_send_synack;
;;;776    
;;;777    #if UIP_ACTIVE_OPEN
;;;778    	  case UIP_SYN_SENT:
;;;779    	    /* In the SYN_SENT state, we retransmit out SYN. */
;;;780    	    BUF->flags = 0;
;;;781    	    goto tcp_send_syn;
;;;782    #endif /* UIP_ACTIVE_OPEN */
;;;783    
;;;784    	  case UIP_ESTABLISHED:
;;;785    	    /* In the ESTABLISHED state, we call upon the application
;;;786                   to do the actual retransmit after which we jump into
;;;787                   the code for sending out the packet (the apprexmit
;;;788                   label). */
;;;789    	    uip_flags = UIP_REXMIT;
;;;790    	    UIP_APPCALL();
;;;791    	    goto apprexmit;
;;;792    
;;;793    	  case UIP_FIN_WAIT_1:
;;;794    	  case UIP_CLOSING:
;;;795    	  case UIP_LAST_ACK:
;;;796    	    /* In all these states we should retransmit a FINACK. */
;;;797    	    goto tcp_send_finack;
;;;798    
;;;799    	  }
;;;800    	}
;;;801          } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
;;;802    	/* If there was no need for a retransmission, we poll the
;;;803               application for new data. */
;;;804    	uip_flags = UIP_POLL;
;;;805    	UIP_APPCALL();
;;;806    	goto appsend;
;;;807          }
;;;808        }
;;;809        goto drop;
;;;810      }
;;;811    #if UIP_UDP
;;;812      if(flag == UIP_UDP_TIMER) {
;;;813        if(uip_udp_conn->lport != 0) {
;;;814          uip_conn = NULL;
;;;815          uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;816          uip_len = uip_slen = 0;
;;;817          uip_flags = UIP_POLL;
;;;818          UIP_UDP_APPCALL();
;;;819          goto udp_send;
;;;820        } else {
;;;821          goto drop;
;;;822        }
;;;823      }
;;;824    #endif
;;;825    
;;;826      /* This is where the input processing starts. */
;;;827      UIP_STAT(++uip_stat.ip.recv);
;;;828    
;;;829      /* Start of IP input header processing code. */
;;;830    
;;;831    #if UIP_CONF_IPV6
;;;832      /* Check validity of the IP header. */
;;;833      if((BUF->vtc & 0xf0) != 0x60)  { /* IP version and header length. */
;;;834        UIP_STAT(++uip_stat.ip.drop);
;;;835        UIP_STAT(++uip_stat.ip.vhlerr);
;;;836        UIP_LOG("ipv6: invalid version.");
;;;837        goto drop;
;;;838      }
;;;839    #else /* UIP_CONF_IPV6 */
;;;840      /* Check validity of the IP header. */
;;;841      if(BUF->vhl != 0x45)  { /* IP version and header length. */
;;;842        UIP_STAT(++uip_stat.ip.drop);
;;;843        UIP_STAT(++uip_stat.ip.vhlerr);
;;;844        UIP_LOG("ip: invalid version or header length.");
;;;845        goto drop;
;;;846      }
;;;847    #endif /* UIP_CONF_IPV6 */
;;;848    
;;;849      /* Check the size of the packet. If the size reported to us in
;;;850         uip_len is smaller the size reported in the IP header, we assume
;;;851         that the packet has been corrupted in transit. If the size of
;;;852         uip_len is larger than the size reported in the IP packet header,
;;;853         the packet has been padded and we set uip_len to the correct
;;;854         value.. */
;;;855    
;;;856      if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
;;;857        uip_len = (BUF->len[0] << 8) + BUF->len[1];
;;;858    #if UIP_CONF_IPV6
;;;859        uip_len += 40; /* The length reported in the IPv6 header is the
;;;860    		      length of the payload that follows the
;;;861    		      header. However, uIP uses the uip_len variable
;;;862    		      for holding the size of the entire packet,
;;;863    		      including the IP header. For IPv4 this is not a
;;;864    		      problem as the length field in the IPv4 header
;;;865    		      contains the length of the entire packet. But
;;;866    		      for IPv6 we need to add the size of the IPv6
;;;867    		      header (40 bytes). */
;;;868    #endif /* UIP_CONF_IPV6 */
;;;869      } else {
;;;870        UIP_LOG("ip: packet shorter than reported in IP header.");
;;;871        goto drop;
;;;872      }
;;;873    
;;;874    #if !UIP_CONF_IPV6
;;;875      /* Check the fragment flag. */
;;;876      if((BUF->ipoffset[0] & 0x3f) != 0 ||
;;;877         BUF->ipoffset[1] != 0) {
;;;878    #if UIP_REASSEMBLY
;;;879        uip_len = uip_reass();
;;;880        if(uip_len == 0) {
;;;881          goto drop;
;;;882        }
;;;883    #else /* UIP_REASSEMBLY */
;;;884        UIP_STAT(++uip_stat.ip.drop);
;;;885        UIP_STAT(++uip_stat.ip.fragerr);
;;;886        UIP_LOG("ip: fragment dropped.");
;;;887        goto drop;
;;;888    #endif /* UIP_REASSEMBLY */
;;;889      }
;;;890    #endif /* UIP_CONF_IPV6 */
;;;891    
;;;892      if(uip_ipaddr_cmp(uip_hostaddr, all_zeroes_addr)) {
;;;893        /* If we are configured to use ping IP address configuration and
;;;894           hasn't been assigned an IP address yet, we accept all ICMP
;;;895           packets. */
;;;896    #if UIP_PINGADDRCONF && !UIP_CONF_IPV6
;;;897        if(BUF->proto == UIP_PROTO_ICMP) {
;;;898          UIP_LOG("ip: possible ping config packet received.");
;;;899          goto icmp_input;
;;;900        } else {
;;;901          UIP_LOG("ip: packet dropped since no address assigned.");
;;;902          goto drop;
;;;903        }
;;;904    #endif /* UIP_PINGADDRCONF */
;;;905    
;;;906      } else {
;;;907        /* If IP broadcast support is configured, we check for a broadcast
;;;908           UDP packet, which may be destined to us. */
;;;909    #if UIP_BROADCAST
;;;910        DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
;;;911        if(BUF->proto == UIP_PROTO_UDP &&
;;;912           uip_ipaddr_cmp(BUF->destipaddr, all_ones_addr)
;;;913           /*&&
;;;914    	 uip_ipchksum() == 0xffff*/) {
;;;915          goto udp_input;
;;;916        }
;;;917    #endif /* UIP_BROADCAST */
;;;918    
;;;919        /* Check if the packet is destined for our IP address. */
;;;920    #if !UIP_CONF_IPV6
;;;921        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr)) {
;;;922          UIP_STAT(++uip_stat.ip.drop);
;;;923          goto drop;
;;;924        }
;;;925    #else /* UIP_CONF_IPV6 */
;;;926        /* For IPv6, packet reception is a little trickier as we need to
;;;927           make sure that we listen to certain multicast addresses (all
;;;928           hosts multicast address, and the solicited-node multicast
;;;929           address) as well. However, we will cheat here and accept all
;;;930           multicast packets that are sent to the ff02::/16 addresses. */
;;;931        if(!uip_ipaddr_cmp(BUF->destipaddr, uip_hostaddr) &&
;;;932           BUF->destipaddr[0] != HTONS(0xff02)) {
;;;933          UIP_STAT(++uip_stat.ip.drop);
;;;934          goto drop;
;;;935        }
;;;936    #endif /* UIP_CONF_IPV6 */
;;;937      }
;;;938    
;;;939    #if !UIP_CONF_IPV6
;;;940      if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
;;;941    				    checksum. */
;;;942        UIP_STAT(++uip_stat.ip.drop);
;;;943        UIP_STAT(++uip_stat.ip.chkerr);
;;;944        UIP_LOG("ip: bad checksum.");
;;;945        goto drop;
;;;946      }
;;;947    #endif /* UIP_CONF_IPV6 */
;;;948    
;;;949    
;;;950      if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
;;;951    				       proceed with TCP input
;;;952    				       processing. */
;;;953        goto tcp_input;
;;;954      }
;;;955    
;;;956    #if UIP_UDP
;;;957      if(BUF->proto == UIP_PROTO_UDP) {
;;;958        goto udp_input;
;;;959      }
;;;960    #endif /* UIP_UDP */
;;;961    
;;;962    #if !UIP_CONF_IPV6
;;;963      /* ICMPv4 processing code follows. */
;;;964      if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
;;;965    					here. */
;;;966        UIP_STAT(++uip_stat.ip.drop);
;;;967        UIP_STAT(++uip_stat.ip.protoerr);
;;;968        UIP_LOG("ip: neither tcp nor icmp.");
;;;969        goto drop;
;;;970      }
;;;971    
;;;972    #if UIP_PINGADDRCONF
;;;973     icmp_input:
;;;974    #endif /* UIP_PINGADDRCONF */
;;;975      UIP_STAT(++uip_stat.icmp.recv);
;;;976    
;;;977      /* ICMP echo (i.e., ping) processing. This is simple, we only change
;;;978         the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
;;;979         checksum before we return the packet. */
;;;980      if(ICMPBUF->type != ICMP_ECHO) {
;;;981        UIP_STAT(++uip_stat.icmp.drop);
;;;982        UIP_STAT(++uip_stat.icmp.typeerr);
;;;983        UIP_LOG("icmp: not icmp echo.");
;;;984        goto drop;
;;;985      }
;;;986    
;;;987      /* If we are configured to use ping IP address assignment, we use
;;;988         the destination IP address of this ping packet and assign it to
;;;989         ourself. */
;;;990    #if UIP_PINGADDRCONF
;;;991      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0) {
;;;992        uip_hostaddr[0] = BUF->destipaddr[0];
;;;993        uip_hostaddr[1] = BUF->destipaddr[1];
;;;994      }
;;;995    #endif /* UIP_PINGADDRCONF */
;;;996    
;;;997      ICMPBUF->type = ICMP_ECHO_REPLY;
;;;998    
;;;999      if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
;;;1000       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
;;;1001     } else {
;;;1002       ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
;;;1003     }
;;;1004   
;;;1005     /* Swap IP addresses. */
;;;1006     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1007     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1008   
;;;1009     UIP_STAT(++uip_stat.icmp.sent);
;;;1010     goto send;
;;;1011   
;;;1012     /* End of IPv4 input header processing code. */
;;;1013   #else /* !UIP_CONF_IPV6 */
;;;1014   
;;;1015     /* This is IPv6 ICMPv6 processing code. */
;;;1016     DEBUG_PRINTF("icmp6_input: length %d\n", uip_len);
;;;1017   
;;;1018     if(BUF->proto != UIP_PROTO_ICMP6) { /* We only allow ICMPv6 packets from
;;;1019   					 here. */
;;;1020       UIP_STAT(++uip_stat.ip.drop);
;;;1021       UIP_STAT(++uip_stat.ip.protoerr);
;;;1022       UIP_LOG("ip: neither tcp nor icmp6.");
;;;1023       goto drop;
;;;1024     }
;;;1025   
;;;1026     UIP_STAT(++uip_stat.icmp.recv);
;;;1027   
;;;1028     /* If we get a neighbor solicitation for our address we should send
;;;1029        a neighbor advertisement message back. */
;;;1030     if(ICMPBUF->type == ICMP6_NEIGHBOR_SOLICITATION) {
;;;1031       if(uip_ipaddr_cmp(ICMPBUF->icmp6data, uip_hostaddr)) {
;;;1032   
;;;1033         if(ICMPBUF->options[0] == ICMP6_OPTION_SOURCE_LINK_ADDRESS) {
;;;1034   	/* Save the sender's address in our neighbor list. */
;;;1035   	uip_neighbor_add(ICMPBUF->srcipaddr, &(ICMPBUF->options[2]));
;;;1036         }
;;;1037   
;;;1038         /* We should now send a neighbor advertisement back to where the
;;;1039   	 neighbor solicication came from. */
;;;1040         ICMPBUF->type = ICMP6_NEIGHBOR_ADVERTISEMENT;
;;;1041         ICMPBUF->flags = ICMP6_FLAG_S; /* Solicited flag. */
;;;1042   
;;;1043         ICMPBUF->reserved1 = ICMPBUF->reserved2 = ICMPBUF->reserved3 = 0;
;;;1044   
;;;1045         uip_ipaddr_copy(ICMPBUF->destipaddr, ICMPBUF->srcipaddr);
;;;1046         uip_ipaddr_copy(ICMPBUF->srcipaddr, uip_hostaddr);
;;;1047         ICMPBUF->options[0] = ICMP6_OPTION_TARGET_LINK_ADDRESS;
;;;1048         ICMPBUF->options[1] = 1;  /* Options length, 1 = 8 bytes. */
;;;1049         memcpy(&(ICMPBUF->options[2]), &uip_ethaddr, sizeof(uip_ethaddr));
;;;1050         ICMPBUF->icmpchksum = 0;
;;;1051         ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1052         goto send;
;;;1053   
;;;1054       }
;;;1055       goto drop;
;;;1056     } else if(ICMPBUF->type == ICMP6_ECHO) {
;;;1057       /* ICMP echo (i.e., ping) processing. This is simple, we only
;;;1058          change the ICMP type from ECHO to ECHO_REPLY and update the
;;;1059          ICMP checksum before we return the packet. */
;;;1060   
;;;1061       ICMPBUF->type = ICMP6_ECHO_REPLY;
;;;1062   
;;;1063       uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1064       uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1065       ICMPBUF->icmpchksum = 0;
;;;1066       ICMPBUF->icmpchksum = ~uip_icmp6chksum();
;;;1067   
;;;1068       UIP_STAT(++uip_stat.icmp.sent);
;;;1069       goto send;
;;;1070     } else {
;;;1071       DEBUG_PRINTF("Unknown icmp6 message type %d\n", ICMPBUF->type);
;;;1072       UIP_STAT(++uip_stat.icmp.drop);
;;;1073       UIP_STAT(++uip_stat.icmp.typeerr);
;;;1074       UIP_LOG("icmp: unknown ICMP message.");
;;;1075       goto drop;
;;;1076     }
;;;1077   
;;;1078     /* End of IPv6 ICMP processing. */
;;;1079   
;;;1080   #endif /* !UIP_CONF_IPV6 */
;;;1081   
;;;1082   #if UIP_UDP
;;;1083     /* UDP input processing. */
;;;1084    udp_input:
;;;1085     /* UDP processing is really just a hack. We don't do anything to the
;;;1086        UDP/IP headers, but let the UDP application do all the hard
;;;1087        work. If the application sets uip_slen, it has a packet to
;;;1088        send. */
;;;1089   #if UIP_UDP_CHECKSUMS
;;;1090     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1091     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1092     if(UDPBUF->udpchksum != 0 && uip_udpchksum() != 0xffff) {
;;;1093       UIP_STAT(++uip_stat.udp.drop);
;;;1094       UIP_STAT(++uip_stat.udp.chkerr);
;;;1095       UIP_LOG("udp: bad checksum.");
;;;1096       goto drop;
;;;1097     }
;;;1098   #else /* UIP_UDP_CHECKSUMS */
;;;1099     uip_len = uip_len - UIP_IPUDPH_LEN;
;;;1100   #endif /* UIP_UDP_CHECKSUMS */
;;;1101   
;;;1102     /* Demultiplex this UDP packet between the UDP "connections". */
;;;1103     for(uip_udp_conn = &uip_udp_conns[0];
;;;1104         uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
;;;1105         ++uip_udp_conn) {
;;;1106       /* If the local UDP port is non-zero, the connection is considered
;;;1107          to be used. If so, the local port number is checked against the
;;;1108          destination port number in the received packet. If the two port
;;;1109          numbers match, the remote port number is checked if the
;;;1110          connection is bound to a remote port. Finally, if the
;;;1111          connection is bound to a remote IP address, the source IP
;;;1112          address of the packet is checked. */
;;;1113       if(uip_udp_conn->lport != 0 &&
;;;1114          UDPBUF->destport == uip_udp_conn->lport &&
;;;1115          (uip_udp_conn->rport == 0 ||
;;;1116           UDPBUF->srcport == uip_udp_conn->rport) &&
;;;1117          (uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_zeroes_addr) ||
;;;1118   	uip_ipaddr_cmp(uip_udp_conn->ripaddr, all_ones_addr) ||
;;;1119   	uip_ipaddr_cmp(BUF->srcipaddr, uip_udp_conn->ripaddr))) {
;;;1120         goto udp_found;
;;;1121       }
;;;1122     }
;;;1123     UIP_LOG("udp: no matching connection found");
;;;1124     goto drop;
;;;1125   
;;;1126    udp_found:
;;;1127     uip_conn = NULL;
;;;1128     uip_flags = UIP_NEWDATA;
;;;1129     uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
;;;1130     uip_slen = 0;
;;;1131     UIP_UDP_APPCALL();
;;;1132    udp_send:
;;;1133     if(uip_slen == 0) {
;;;1134       goto drop;
;;;1135     }
;;;1136     uip_len = uip_slen + UIP_IPUDPH_LEN;
;;;1137   
;;;1138   #if UIP_CONF_IPV6
;;;1139     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1140        length. */
;;;1141     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1142     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1143   #else /* UIP_CONF_IPV6 */
;;;1144     BUF->len[0] = (uip_len >> 8);
;;;1145     BUF->len[1] = (uip_len & 0xff);
;;;1146   #endif /* UIP_CONF_IPV6 */
;;;1147   
;;;1148     BUF->ttl = uip_udp_conn->ttl;
;;;1149     BUF->proto = UIP_PROTO_UDP;
;;;1150   
;;;1151     UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
;;;1152     UDPBUF->udpchksum = 0;
;;;1153   
;;;1154     BUF->srcport  = uip_udp_conn->lport;
;;;1155     BUF->destport = uip_udp_conn->rport;
;;;1156   
;;;1157     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1158     uip_ipaddr_copy(BUF->destipaddr, uip_udp_conn->ripaddr);
;;;1159   
;;;1160     uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
;;;1161   
;;;1162   #if UIP_UDP_CHECKSUMS
;;;1163     /* Calculate UDP checksum. */
;;;1164     UDPBUF->udpchksum = ~(uip_udpchksum());
;;;1165     if(UDPBUF->udpchksum == 0) {
;;;1166       UDPBUF->udpchksum = 0xffff;
;;;1167     }
;;;1168   #endif /* UIP_UDP_CHECKSUMS */
;;;1169   
;;;1170     goto ip_send_nolen;
;;;1171   #endif /* UIP_UDP */
;;;1172   
;;;1173     /* TCP input processing. */
;;;1174    tcp_input:
;;;1175     UIP_STAT(++uip_stat.tcp.recv);
;;;1176   
;;;1177     /* Start of TCP input header processing code. */
;;;1178   
;;;1179     if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
;;;1180   				       checksum. */
;;;1181       UIP_STAT(++uip_stat.tcp.drop);
;;;1182       UIP_STAT(++uip_stat.tcp.chkerr);
;;;1183       UIP_LOG("tcp: bad checksum.");
;;;1184       goto drop;
;;;1185     }
;;;1186   
;;;1187   
;;;1188     /* Demultiplex this segment. */
;;;1189     /* First check any active connections. */
;;;1190     for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
;;;1191         ++uip_connr) {
;;;1192       if(uip_connr->tcpstateflags != UIP_CLOSED &&
;;;1193          BUF->destport == uip_connr->lport &&
;;;1194          BUF->srcport == uip_connr->rport &&
;;;1195          uip_ipaddr_cmp(BUF->srcipaddr, uip_connr->ripaddr)) {
;;;1196         goto found;
;;;1197       }
;;;1198     }
;;;1199   
;;;1200     /* If we didn't find and active connection that expected the packet,
;;;1201        either this packet is an old duplicate, or this is a SYN packet
;;;1202        destined for a connection in LISTEN. If the SYN flag isn't set,
;;;1203        it is an old packet and we send a RST. */
;;;1204     if((BUF->flags & TCP_CTL) != TCP_SYN) {
;;;1205       goto reset;
;;;1206     }
;;;1207   
;;;1208     tmp16 = BUF->destport;
;;;1209     /* Next, check listening connections. */
;;;1210     for(c = 0; c < UIP_LISTENPORTS; ++c) {
;;;1211       if(tmp16 == uip_listenports[c])
;;;1212         goto found_listen;
;;;1213     }
;;;1214   
;;;1215     /* No matching connection found, so we send a RST packet. */
;;;1216     UIP_STAT(++uip_stat.tcp.synrst);
;;;1217    reset:
;;;1218   
;;;1219     /* We do not send resets in response to resets. */
;;;1220     if(BUF->flags & TCP_RST) {
;;;1221       goto drop;
;;;1222     }
;;;1223   
;;;1224     UIP_STAT(++uip_stat.tcp.rst);
;;;1225   
;;;1226     BUF->flags = TCP_RST | TCP_ACK;
;;;1227     uip_len = UIP_IPTCPH_LEN;
;;;1228     BUF->tcpoffset = 5 << 4;
;;;1229   
;;;1230     /* Flip the seqno and ackno fields in the TCP header. */
;;;1231     c = BUF->seqno[3];
;;;1232     BUF->seqno[3] = BUF->ackno[3];
;;;1233     BUF->ackno[3] = c;
;;;1234   
;;;1235     c = BUF->seqno[2];
;;;1236     BUF->seqno[2] = BUF->ackno[2];
;;;1237     BUF->ackno[2] = c;
;;;1238   
;;;1239     c = BUF->seqno[1];
;;;1240     BUF->seqno[1] = BUF->ackno[1];
;;;1241     BUF->ackno[1] = c;
;;;1242   
;;;1243     c = BUF->seqno[0];
;;;1244     BUF->seqno[0] = BUF->ackno[0];
;;;1245     BUF->ackno[0] = c;
;;;1246   
;;;1247     /* We also have to increase the sequence number we are
;;;1248        acknowledging. If the least significant byte overflowed, we need
;;;1249        to propagate the carry to the other bytes as well. */
;;;1250     if(++BUF->ackno[3] == 0) {
;;;1251       if(++BUF->ackno[2] == 0) {
;;;1252         if(++BUF->ackno[1] == 0) {
;;;1253   	++BUF->ackno[0];
;;;1254         }
;;;1255       }
;;;1256     }
;;;1257   
;;;1258     /* Swap port numbers. */
;;;1259     tmp16 = BUF->srcport;
;;;1260     BUF->srcport = BUF->destport;
;;;1261     BUF->destport = tmp16;
;;;1262   
;;;1263     /* Swap IP addresses. */
;;;1264     uip_ipaddr_copy(BUF->destipaddr, BUF->srcipaddr);
;;;1265     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
;;;1266   
;;;1267     /* And send out the RST packet! */
;;;1268     goto tcp_send_noconn;
;;;1269   
;;;1270     /* This label will be jumped to if we matched the incoming packet
;;;1271        with a connection in LISTEN. In that case, we should create a new
;;;1272        connection and send a SYNACK in return. */
;;;1273    found_listen:
;;;1274     /* First we check if there are any connections avaliable. Unused
;;;1275        connections are kept in the same table as used connections, but
;;;1276        unused ones have the tcpstate set to CLOSED. Also, connections in
;;;1277        TIME_WAIT are kept track of and we'll use the oldest one if no
;;;1278        CLOSED connections are found. Thanks to Eddie C. Dost for a very
;;;1279        nice algorithm for the TIME_WAIT search. */
;;;1280     uip_connr = 0;
;;;1281     for(c = 0; c < UIP_CONNS; ++c) {
;;;1282       if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
;;;1283         uip_connr = &uip_conns[c];
;;;1284         break;
;;;1285       }
;;;1286       if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
;;;1287         if(uip_connr == 0 ||
;;;1288   	 uip_conns[c].timer > uip_connr->timer) {
;;;1289   	uip_connr = &uip_conns[c];
;;;1290         }
;;;1291       }
;;;1292     }
;;;1293   
;;;1294     if(uip_connr == 0) {
;;;1295       /* All connections are used already, we drop packet and hope that
;;;1296          the remote end will retransmit the packet at a time when we
;;;1297          have more spare connections. */
;;;1298       UIP_STAT(++uip_stat.tcp.syndrop);
;;;1299       UIP_LOG("tcp: found no unused connections.");
;;;1300       goto drop;
;;;1301     }
;;;1302     uip_conn = uip_connr;
;;;1303   
;;;1304     /* Fill in the necessary fields for the new connection. */
;;;1305     uip_connr->rto = uip_connr->timer = UIP_RTO;
;;;1306     uip_connr->sa = 0;
;;;1307     uip_connr->sv = 4;
;;;1308     uip_connr->nrtx = 0;
;;;1309     uip_connr->lport = BUF->destport;
;;;1310     uip_connr->rport = BUF->srcport;
;;;1311     uip_ipaddr_copy(uip_connr->ripaddr, BUF->srcipaddr);
;;;1312     uip_connr->tcpstateflags = UIP_SYN_RCVD;
;;;1313   
;;;1314     uip_connr->snd_nxt[0] = iss[0];
;;;1315     uip_connr->snd_nxt[1] = iss[1];
;;;1316     uip_connr->snd_nxt[2] = iss[2];
;;;1317     uip_connr->snd_nxt[3] = iss[3];
;;;1318     uip_connr->len = 1;
;;;1319   
;;;1320     /* rcv_nxt should be the seqno from the incoming packet + 1. */
;;;1321     uip_connr->rcv_nxt[3] = BUF->seqno[3];
;;;1322     uip_connr->rcv_nxt[2] = BUF->seqno[2];
;;;1323     uip_connr->rcv_nxt[1] = BUF->seqno[1];
;;;1324     uip_connr->rcv_nxt[0] = BUF->seqno[0];
;;;1325     uip_add_rcv_nxt(1);
;;;1326   
;;;1327     /* Parse the TCP MSS option, if present. */
;;;1328     if((BUF->tcpoffset & 0xf0) > 0x50) {
;;;1329       for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
;;;1330         opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
;;;1331         if(opt == TCP_OPT_END) {
;;;1332   	/* End of options. */
;;;1333   	break;
;;;1334         } else if(opt == TCP_OPT_NOOP) {
;;;1335   	++c;
;;;1336   	/* NOP option. */
;;;1337         } else if(opt == TCP_OPT_MSS &&
;;;1338   		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
;;;1339   	/* An MSS option with the right option length. */
;;;1340   	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
;;;1341   	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
;;;1342   	uip_connr->initialmss = uip_connr->mss =
;;;1343   	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
;;;1344   
;;;1345   	/* And we are done processing options. */
;;;1346   	break;
;;;1347         } else {
;;;1348   	/* All other options have a length field, so that we easily
;;;1349   	   can skip past them. */
;;;1350   	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
;;;1351   	  /* If the length field is zero, the options are malformed
;;;1352   	     and we don't process them further. */
;;;1353   	  break;
;;;1354   	}
;;;1355   	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
;;;1356         }
;;;1357       }
;;;1358     }
;;;1359   
;;;1360     /* Our response will be a SYNACK. */
;;;1361   #if UIP_ACTIVE_OPEN
;;;1362    tcp_send_synack:
;;;1363     BUF->flags = TCP_ACK;
000010  f04f0a10          MOV      r10,#0x10
000014  f1a10536          SUB      r5,r1,#0x36           ;692
000018  6191              STR      r1,[r2,#0x18]         ;696  ; uip_sappdata
00001a  2803              CMP      r0,#3                 ;696
00001c  d014              BEQ      |L10.72|
00001e  f1020920          ADD      r9,r2,#0x20           ;713
000022  2802              CMP      r0,#2                 ;706
000024  d01b              BEQ      |L10.94|
000026  4cf7              LDR      r4,|L10.1028|
000028  8860              LDRH     r0,[r4,#2]            ;827  ; uip_stat
00002a  1c40              ADDS     r0,r0,#1              ;827
00002c  8060              STRH     r0,[r4,#2]            ;827
00002e  4620              MOV      r0,r4                 ;770
000030  7ba9              LDRB     r1,[r5,#0xe]          ;841  ; uip_buf
000032  8800              LDRH     r0,[r0,#0]            ;842
000034  1c40              ADDS     r0,r0,#1              ;842
000036  b280              UXTH     r0,r0                 ;842
000038  2945              CMP      r1,#0x45              ;841
00003a  d079              BEQ      |L10.304|
00003c  8020              STRH     r0,[r4,#0]            ;842
00003e  88e0              LDRH     r0,[r4,#6]            ;843  ; uip_stat
000040  1c40              ADDS     r0,r0,#1              ;843
000042  80e0              STRH     r0,[r4,#6]            ;843
000044  a0f0              ADR      r0,|L10.1032|
000046  e25b              B        |L10.1280|
                  |L10.72|
000048  7e60              LDRB     r0,[r4,#0x19]         ;697
00004a  f000000f          AND      r0,r0,#0xf            ;697
00004e  2803              CMP      r0,#3                 ;697
                  |L10.80|
000050  d13d              BNE      |L10.206|
000052  8a20              LDRH     r0,[r4,#0x10]         ;698
000054  2800              CMP      r0,#0                 ;698
000056  d1fb              BNE      |L10.80|
                  |L10.88|
000058  2008              MOVS     r0,#8                 ;699
00005a  7030              STRB     r0,[r6,#0]            ;699
00005c  e3cf              B        |L10.2046|
                  |L10.94|
00005e  f8991003          LDRB     r1,[r9,#3]            ;713  ; iss
000062  4648              MOV      r0,r9                 ;713
000064  1c49              ADDS     r1,r1,#1              ;713
000066  f01101ff          ANDS     r1,r1,#0xff           ;713
00006a  f8891003          STRB     r1,[r9,#3]            ;713
00006e  d10f              BNE      |L10.144|
000070  7881              LDRB     r1,[r0,#2]            ;714  ; iss
000072  1c49              ADDS     r1,r1,#1              ;714
000074  f01101ff          ANDS     r1,r1,#0xff           ;714
000078  7081              STRB     r1,[r0,#2]            ;714
00007a  d109              BNE      |L10.144|
00007c  7841              LDRB     r1,[r0,#1]            ;715  ; iss
00007e  1c49              ADDS     r1,r1,#1              ;715
000080  f01101ff          ANDS     r1,r1,#0xff           ;715
000084  7041              STRB     r1,[r0,#1]            ;715
000086  d103              BNE      |L10.144|
000088  7801              LDRB     r1,[r0,#0]            ;716  ; iss
00008a  1c49              ADDS     r1,r1,#1              ;716
00008c  f8891000          STRB     r1,[r9,#0]            ;716
                  |L10.144|
000090  80b7              STRH     r7,[r6,#4]            ;722
000092  80f7              STRH     r7,[r6,#6]            ;723
000094  7e60              LDRB     r0,[r4,#0x19]         ;729
000096  2807              CMP      r0,#7                 ;729
000098  d012              BEQ      |L10.192|
00009a  2805              CMP      r0,#5                 ;730
00009c  d010              BEQ      |L10.192|
00009e  2800              CMP      r0,#0                 ;735
0000a0  d015              BEQ      |L10.206|
0000a2  8a21              LDRH     r1,[r4,#0x10]         ;739
0000a4  b3a9              CBZ      r1,|L10.274|
0000a6  7ea0              LDRB     r0,[r4,#0x1a]         ;740
0000a8  1e41              SUBS     r1,r0,#1              ;740
0000aa  76a1              STRB     r1,[r4,#0x1a]         ;740
0000ac  d20f              BCS      |L10.206|
0000ae  7ee0              LDRB     r0,[r4,#0x1b]         ;741
0000b0  2808              CMP      r0,#8                 ;741
0000b2  d028              BEQ      |L10.262|
0000b4  7e61              LDRB     r1,[r4,#0x19]         ;742
0000b6  2902              CMP      r1,#2                 ;742
0000b8  d00a              BEQ      |L10.208|
0000ba  2901              CMP      r1,#1                 ;743
0000bc  d008              BEQ      |L10.208|
0000be  e009              B        |L10.212|
                  |L10.192|
0000c0  7ea0              LDRB     r0,[r4,#0x1a]         ;731
0000c2  1c40              ADDS     r0,r0,#1              ;731
0000c4  b2c0              UXTB     r0,r0                 ;731
0000c6  76a0              STRB     r0,[r4,#0x1a]         ;731
0000c8  2878              CMP      r0,#0x78              ;732
0000ca  d1c1              BNE      |L10.80|
0000cc  7667              STRB     r7,[r4,#0x19]         ;733
                  |L10.206|
0000ce  e02e              B        |L10.302|
                  |L10.208|
0000d0  2805              CMP      r0,#5                 ;744
0000d2  d018              BEQ      |L10.262|
                  |L10.212|
0000d4  2804              CMP      r0,#4                 ;759
0000d6  d900              BLS      |L10.218|
0000d8  2004              MOVS     r0,#4                 ;760
                  |L10.218|
0000da  2103              MOVS     r1,#3                 ;761
0000dc  4081              LSLS     r1,r1,r0              ;761
0000de  76a1              STRB     r1,[r4,#0x1a]         ;761
0000e0  7ee0              LDRB     r0,[r4,#0x1b]         ;762
0000e2  1c40              ADDS     r0,r0,#1              ;762
0000e4  76e0              STRB     r0,[r4,#0x1b]         ;762
0000e6  48c7              LDR      r0,|L10.1028|
0000e8  8cc1              LDRH     r1,[r0,#0x26]         ;770  ; uip_stat
0000ea  1c49              ADDS     r1,r1,#1              ;770
0000ec  84c1              STRH     r1,[r0,#0x26]         ;770
0000ee  7e60              LDRB     r0,[r4,#0x19]         ;771
0000f0  f000000f          AND      r0,r0,#0xf            ;771
0000f4  2809              CMP      r0,#9                 ;771
0000f6  d2ea              BCS      |L10.206|
0000f8  e8dff000          TBB      [pc,r0]               ;771
0000fc  19fd0d10          DCB      0x19,0xfd,0x0d,0x10
000100  fc19fc19          DCB      0xfc,0x19,0xfc,0x19
000104  fc00              DCB      0xfc,0x00
                  |L10.262|
000106  7667              STRB     r7,[r4,#0x19]         ;745
000108  2080              MOVS     r0,#0x80              ;750
00010a  7030              STRB     r0,[r6,#0]            ;750
00010c  f7fffffe          BL       httpd_appcall
000110  e37c              B        |L10.2060|
                  |L10.274|
000112  e008              B        |L10.294|
000114  e00c              B        |L10.304|
000116  f885702f          STRB     r7,[r5,#0x2f]         ;780
00011a  e211              B        |L10.1344|
00011c  2004              MOVS     r0,#4                 ;789
00011e  7030              STRB     r0,[r6,#0]            ;789
000120  f7fffffe          BL       httpd_appcall
000124  e389              B        |L10.2106|
                  |L10.294|
000126  f000000f          AND      r0,r0,#0xf            ;801
00012a  2803              CMP      r0,#3                 ;801
00012c  d094              BEQ      |L10.88|
                  |L10.302|
00012e  e136              B        |L10.926|
                  |L10.304|
000130  7c69              LDRB     r1,[r5,#0x11]         ;856  ; uip_buf
000132  7c2a              LDRB     r2,[r5,#0x10]         ;856  ; uip_buf
000134  eb012102          ADD      r1,r1,r2,LSL #8       ;856
000138  88b2              LDRH     r2,[r6,#4]            ;856  ; uip_len
00013a  4291              CMP      r1,r2                 ;856
00013c  d804              BHI      |L10.328|
00013e  80b1              STRH     r1,[r6,#4]            ;857
000140  7d29              LDRB     r1,[r5,#0x14]         ;876  ; uip_buf
000142  0689              LSLS     r1,r1,#26             ;876
000144  d104              BNE      |L10.336|
000146  e001              B        |L10.332|
                  |L10.328|
000148  a0b9              ADR      r0,|L10.1072|
00014a  e1d9              B        |L10.1280|
                  |L10.332|
00014c  7d69              LDRB     r1,[r5,#0x15]         ;877  ; uip_buf
00014e  b129              CBZ      r1,|L10.348|
                  |L10.336|
000150  8020              STRH     r0,[r4,#0]            ;884
000152  89a0              LDRH     r0,[r4,#0xc]          ;885  ; uip_stat
000154  1c40              ADDS     r0,r0,#1              ;885
000156  81a0              STRH     r0,[r4,#0xc]          ;885
000158  a0c1              ADR      r0,|L10.1120|
00015a  e1d1              B        |L10.1280|
                  |L10.348|
00015c  49a7              LDR      r1,|L10.1020|
00015e  310e              ADDS     r1,r1,#0xe            ;892
000160  880a              LDRH     r2,[r1,#0]            ;892  ; uip_hostaddr
000162  8849              LDRH     r1,[r1,#2]            ;892
000164  b902              CBNZ     r2,|L10.360|
000166  b139              CBZ      r1,|L10.376|
                  |L10.360|
000168  8beb              LDRH     r3,[r5,#0x1e]         ;921  ; uip_buf
00016a  4293              CMP      r3,r2                 ;921
00016c  d102              BNE      |L10.372|
00016e  8c2a              LDRH     r2,[r5,#0x20]         ;921  ; uip_buf
000170  428a              CMP      r2,r1                 ;921
000172  d001              BEQ      |L10.376|
                  |L10.372|
000174  8020              STRH     r0,[r4,#0]            ;922
000176  e112              B        |L10.926|
                  |L10.376|
000178  f7fffffe          BL       uip_ipchksum
00017c  f64f78ff          MOV      r8,#0xffff            ;940
000180  4540              CMP      r0,r8                 ;940
000182  d007              BEQ      |L10.404|
000184  8820              LDRH     r0,[r4,#0]            ;942  ; uip_stat
000186  1c40              ADDS     r0,r0,#1              ;942
000188  8020              STRH     r0,[r4,#0]            ;942
00018a  89e0              LDRH     r0,[r4,#0xe]          ;943  ; uip_stat
00018c  1c40              ADDS     r0,r0,#1              ;943
00018e  81e0              STRH     r0,[r4,#0xe]          ;943
000190  a0b9              ADR      r0,|L10.1144|
000192  e1b5              B        |L10.1280|
                  |L10.404|
000194  7de8              LDRB     r0,[r5,#0x17]         ;950  ; uip_buf
000196  2806              CMP      r0,#6                 ;950
000198  d031              BEQ      |L10.510|
00019a  2801              CMP      r0,#1                 ;964
00019c  d007              BEQ      |L10.430|
00019e  8820              LDRH     r0,[r4,#0]            ;966  ; uip_stat
0001a0  1c40              ADDS     r0,r0,#1              ;966
0001a2  8020              STRH     r0,[r4,#0]            ;966
0001a4  8a20              LDRH     r0,[r4,#0x10]         ;967  ; uip_stat
0001a6  1c40              ADDS     r0,r0,#1              ;967
0001a8  8220              STRH     r0,[r4,#0x10]         ;967
0001aa  a0b8              ADR      r0,|L10.1164|
0001ac  e1a8              B        |L10.1280|
                  |L10.430|
0001ae  8aa0              LDRH     r0,[r4,#0x14]         ;975  ; uip_stat
0001b0  1c40              ADDS     r0,r0,#1              ;975
0001b2  82a0              STRH     r0,[r4,#0x14]         ;975
0001b4  f8950022          LDRB     r0,[r5,#0x22]         ;980  ; uip_buf
0001b8  2808              CMP      r0,#8                 ;980
0001ba  d007              BEQ      |L10.460|
0001bc  8a60              LDRH     r0,[r4,#0x12]         ;981  ; uip_stat
0001be  1c40              ADDS     r0,r0,#1              ;981
0001c0  8260              STRH     r0,[r4,#0x12]         ;981
0001c2  8b20              LDRH     r0,[r4,#0x18]         ;982  ; uip_stat
0001c4  1c40              ADDS     r0,r0,#1              ;982
0001c6  8320              STRH     r0,[r4,#0x18]         ;982
0001c8  a0b7              ADR      r0,|L10.1192|
0001ca  e199              B        |L10.1280|
                  |L10.460|
0001cc  f8857022          STRB     r7,[r5,#0x22]         ;997
0001d0  8ca8              LDRH     r0,[r5,#0x24]         ;999  ; uip_buf
0001d2  f64f71f7          MOV      r1,#0xfff7            ;999
0001d6  4288              CMP      r0,r1                 ;999
0001d8  d301              BCC      |L10.478|
0001da  3009              ADDS     r0,r0,#9              ;999
0001dc  e000              B        |L10.480|
                  |L10.478|
0001de  3008              ADDS     r0,r0,#8              ;1000
                  |L10.480|
0001e0  84a8              STRH     r0,[r5,#0x24]         ;1002
0001e2  8b68              LDRH     r0,[r5,#0x1a]         ;1006  ; uip_buf
0001e4  83e8              STRH     r0,[r5,#0x1e]         ;1006
0001e6  8ba8              LDRH     r0,[r5,#0x1c]         ;1006  ; uip_buf
0001e8  8428              STRH     r0,[r5,#0x20]         ;1006
0001ea  4884              LDR      r0,|L10.1020|
0001ec  300e              ADDS     r0,r0,#0xe            ;1007
0001ee  8801              LDRH     r1,[r0,#0]            ;1007  ; uip_hostaddr
0001f0  8369              STRH     r1,[r5,#0x1a]         ;1007
0001f2  8840              LDRH     r0,[r0,#2]            ;1007  ; uip_hostaddr
0001f4  83a8              STRH     r0,[r5,#0x1c]         ;1007
0001f6  8ae0              LDRH     r0,[r4,#0x16]         ;1009  ; uip_stat
0001f8  1c40              ADDS     r0,r0,#1              ;1009
0001fa  82e0              STRH     r0,[r4,#0x16]         ;1009
0001fc  e3fd              B        |L10.2554|
                  |L10.510|
0001fe  8ba1              LDRH     r1,[r4,#0x1c]         ;1175  ; uip_stat
000200  46a3              MOV      r11,r4                ;1175
000202  1c49              ADDS     r1,r1,#1              ;1175
000204  83a1              STRH     r1,[r4,#0x1c]         ;1175
000206  f7fffffe          BL       uip_tcpchksum
00020a  4540              CMP      r0,r8                 ;1179
00020c  d00b              BEQ      |L10.550|
00020e  f8bb101a          LDRH     r1,[r11,#0x1a]        ;1181  ; uip_stat
000212  a0ab              ADR      r0,|L10.1216|
000214  1c49              ADDS     r1,r1,#1              ;1181
000216  f8ab101a          STRH     r1,[r11,#0x1a]        ;1181
00021a  f8bb1020          LDRH     r1,[r11,#0x20]        ;1182  ; uip_stat
00021e  1c49              ADDS     r1,r1,#1              ;1182
000220  f8ab1020          STRH     r1,[r11,#0x20]        ;1182
000224  e16c              B        |L10.1280|
                  |L10.550|
000226  4cab              LDR      r4,|L10.1236|
000228  f8b58022          LDRH     r8,[r5,#0x22]         ;1194
00022c  8b6a              LDRH     r2,[r5,#0x1a]         ;1006
00022e  8bab              LDRH     r3,[r5,#0x1c]         ;1006
000230  49a9              LDR      r1,|L10.1240|
000232  8ca8              LDRH     r0,[r5,#0x24]         ;999
000234  e016              B        |L10.612|
000236  bf00              NOP                            ;1192
                  |L10.568|
000238  f894c019          LDRB     r12,[r4,#0x19]        ;1192
00023c  f1bc0f00          CMP      r12,#0                ;1192
000240  d00f              BEQ      |L10.610|
000242  f8b4c004          LDRH     r12,[r4,#4]           ;1193
000246  4560              CMP      r0,r12                ;1193
000248  d10b              BNE      |L10.610|
00024a  f8b4c006          LDRH     r12,[r4,#6]           ;1194
00024e  45e0              CMP      r8,r12                ;1194
000250  d107              BNE      |L10.610|
000252  f8b4c000          LDRH     r12,[r4,#0]           ;1195
000256  4562              CMP      r2,r12                ;1195
000258  d103              BNE      |L10.610|
00025a  f8b4c002          LDRH     r12,[r4,#2]           ;1195
00025e  4563              CMP      r3,r12                ;1195
000260  d073              BEQ      |L10.842|
                  |L10.610|
000262  34cc              ADDS     r4,r4,#0xcc           ;1195
                  |L10.612|
000264  428c              CMP      r4,r1                 ;1190
000266  d9e7              BLS      |L10.568|
000268  f895102f          LDRB     r1,[r5,#0x2f]         ;1204  ; uip_buf
00026c  f001013f          AND      r1,r1,#0x3f           ;1204
000270  2902              CMP      r1,#2                 ;1204
000272  d112              BNE      |L10.666|
000274  4a63              LDR      r2,|L10.1028|
000276  81b0              STRH     r0,[r6,#0xc]          ;1208
000278  7077              STRB     r7,[r6,#1]            ;1210
00027a  3a50              SUBS     r2,r2,#0x50           ;1211
                  |L10.636|
00027c  7871              LDRB     r1,[r6,#1]            ;1211  ; c
00027e  f8323011          LDRH     r3,[r2,r1,LSL #1]     ;1211
000282  4283              CMP      r3,r0                 ;1211
000284  d062              BEQ      |L10.844|
000286  1c49              ADDS     r1,r1,#1              ;1211
000288  b2c9              UXTB     r1,r1                 ;1210
00028a  7071              STRB     r1,[r6,#1]            ;1210
00028c  2928              CMP      r1,#0x28              ;1210
00028e  d3f5              BCC      |L10.636|
000290  f8bb102a          LDRH     r1,[r11,#0x2a]        ;1216  ; uip_stat
000294  1c49              ADDS     r1,r1,#1              ;1216
000296  f8ab102a          STRH     r1,[r11,#0x2a]        ;1216
                  |L10.666|
00029a  f895002f          LDRB     r0,[r5,#0x2f]         ;1220  ; uip_buf
00029e  0740              LSLS     r0,r0,#29             ;1220
0002a0  d47d              BMI      |L10.926|
0002a2  f8bb1024          LDRH     r1,[r11,#0x24]        ;1224  ; uip_stat
0002a6  2014              MOVS     r0,#0x14              ;1226
0002a8  1c49              ADDS     r1,r1,#1              ;1224
0002aa  f8ab1024          STRH     r1,[r11,#0x24]        ;1224
0002ae  f885002f          STRB     r0,[r5,#0x2f]         ;1226
0002b2  2028              MOVS     r0,#0x28              ;1227
0002b4  80b0              STRH     r0,[r6,#4]            ;1227
0002b6  2050              MOVS     r0,#0x50              ;1228
0002b8  f885002e          STRB     r0,[r5,#0x2e]         ;1228
0002bc  f8953029          LDRB     r3,[r5,#0x29]         ;1231  ; uip_buf
0002c0  f895002d          LDRB     r0,[r5,#0x2d]         ;1232  ; uip_buf
0002c4  f8850029          STRB     r0,[r5,#0x29]         ;1232
0002c8  f8952028          LDRB     r2,[r5,#0x28]         ;1235  ; uip_buf
0002cc  f895002c          LDRB     r0,[r5,#0x2c]         ;1236  ; uip_buf
0002d0  f8850028          STRB     r0,[r5,#0x28]         ;1236
0002d4  f885202c          STRB     r2,[r5,#0x2c]         ;1237
0002d8  f8951027          LDRB     r1,[r5,#0x27]         ;1239  ; uip_buf
0002dc  f895002b          LDRB     r0,[r5,#0x2b]         ;1240  ; uip_buf
0002e0  f8850027          STRB     r0,[r5,#0x27]         ;1240
0002e4  f885102b          STRB     r1,[r5,#0x2b]         ;1241
0002e8  f8950026          LDRB     r0,[r5,#0x26]         ;1243  ; uip_buf
0002ec  7070              STRB     r0,[r6,#1]            ;1243
0002ee  f895402a          LDRB     r4,[r5,#0x2a]         ;1244  ; uip_buf
0002f2  e001              B        |L10.760|
0002f4  e256              B        |L10.1956|
0002f6  e121              B        |L10.1340|
                  |L10.760|
0002f8  f8854026          STRB     r4,[r5,#0x26]         ;1244
0002fc  1c5b              ADDS     r3,r3,#1              ;1245
0002fe  f885002a          STRB     r0,[r5,#0x2a]         ;1245
000302  f01303ff          ANDS     r3,r3,#0xff           ;1250
000306  f885302d          STRB     r3,[r5,#0x2d]         ;1250
00030a  d10e              BNE      |L10.810|
00030c  1c52              ADDS     r2,r2,#1              ;1250
00030e  f01202ff          ANDS     r2,r2,#0xff           ;1251
000312  f885202c          STRB     r2,[r5,#0x2c]         ;1251
000316  d108              BNE      |L10.810|
000318  1c49              ADDS     r1,r1,#1              ;1251
00031a  f01101ff          ANDS     r1,r1,#0xff           ;1252
00031e  f885102b          STRB     r1,[r5,#0x2b]         ;1252
000322  d102              BNE      |L10.810|
000324  1c40              ADDS     r0,r0,#1              ;1252
000326  f885002a          STRB     r0,[r5,#0x2a]         ;1253
                  |L10.810|
00032a  8c68              LDRH     r0,[r5,#0x22]         ;1259  ; uip_buf
00032c  81b0              STRH     r0,[r6,#0xc]          ;1259
00032e  8ca9              LDRH     r1,[r5,#0x24]         ;1260  ; uip_buf
000330  8469              STRH     r1,[r5,#0x22]         ;1260
000332  84a8              STRH     r0,[r5,#0x24]         ;1261
000334  8b68              LDRH     r0,[r5,#0x1a]         ;1264  ; uip_buf
000336  83e8              STRH     r0,[r5,#0x1e]         ;1264
000338  8ba8              LDRH     r0,[r5,#0x1c]         ;1264  ; uip_buf
00033a  8428              STRH     r0,[r5,#0x20]         ;1264
00033c  482f              LDR      r0,|L10.1020|
00033e  300e              ADDS     r0,r0,#0xe            ;1265
000340  8801              LDRH     r1,[r0,#0]            ;1265  ; uip_hostaddr
000342  8369              STRH     r1,[r5,#0x1a]         ;1265
000344  8840              LDRH     r0,[r0,#2]            ;1265  ; uip_hostaddr
000346  83a8              STRH     r0,[r5,#0x1c]         ;1265
000348  e33b              B        |L10.2498|
                  |L10.842|
00034a  e11d              B        |L10.1416|
                  |L10.844|
00034c  4a61              LDR      r2,|L10.1236|
00034e  2400              MOVS     r4,#0                 ;1280
000350  7077              STRB     r7,[r6,#1]            ;1281
000352  46b0              MOV      r8,r6                 ;684
                  |L10.852|
000354  f8981001          LDRB     r1,[r8,#1]            ;1282  ; c
000358  eb011001          ADD      r0,r1,r1,LSL #4       ;1282
00035c  eb000040          ADD      r0,r0,r0,LSL #1       ;1282
000360  eb020080          ADD      r0,r2,r0,LSL #2       ;1282
000364  7e43              LDRB     r3,[r0,#0x19]         ;1282
000366  b113              CBZ      r3,|L10.878|
000368  2b07              CMP      r3,#7                 ;1286
00036a  d008              BEQ      |L10.894|
00036c  e00e              B        |L10.908|
                  |L10.878|
00036e  b2c8              UXTB     r0,r1                 ;1283
000370  eb001000          ADD      r0,r0,r0,LSL #4       ;1283
000374  eb000040          ADD      r0,r0,r0,LSL #1       ;1283
000378  eb020480          ADD      r4,r2,r0,LSL #2       ;1283
00037c  e00c              B        |L10.920|
                  |L10.894|
00037e  b124              CBZ      r4,|L10.906|
000380  7e83              LDRB     r3,[r0,#0x1a]         ;1288
000382  f894c01a          LDRB     r12,[r4,#0x1a]        ;1288
000386  4563              CMP      r3,r12                ;1288
000388  d900              BLS      |L10.908|
                  |L10.906|
00038a  4604              MOV      r4,r0                 ;1289
                  |L10.908|
00038c  1c49              ADDS     r1,r1,#1              ;1289
00038e  b2c8              UXTB     r0,r1                 ;1281
000390  f8880001          STRB     r0,[r8,#1]            ;1281
000394  2828              CMP      r0,#0x28              ;1281
000396  d3dd              BCC      |L10.852|
                  |L10.920|
000398  b374              CBZ      r4,|L10.1016|
00039a  2003              MOVS     r0,#3                 ;1305
00039c  e000              B        |L10.928|
                  |L10.926|
00039e  e1e4              B        |L10.1898|
                  |L10.928|
0003a0  f8c8401c          STR      r4,[r8,#0x1c]         ;1305  ; uip_conn
0003a4  76a0              STRB     r0,[r4,#0x1a]         ;1305
0003a6  7620              STRB     r0,[r4,#0x18]         ;1305
0003a8  75a7              STRB     r7,[r4,#0x16]         ;1306
0003aa  2004              MOVS     r0,#4                 ;1307
0003ac  75e0              STRB     r0,[r4,#0x17]         ;1307
0003ae  76e7              STRB     r7,[r4,#0x1b]         ;1308
0003b0  8ca8              LDRH     r0,[r5,#0x24]         ;1309  ; uip_buf
0003b2  80a0              STRH     r0,[r4,#4]            ;1309
0003b4  8c68              LDRH     r0,[r5,#0x22]         ;1310  ; uip_buf
0003b6  80e0              STRH     r0,[r4,#6]            ;1310
0003b8  f8350f1a          LDRH     r0,[r5,#0x1a]!        ;1311  ; uip_buf
0003bc  8020              STRH     r0,[r4,#0]            ;1311
0003be  8868              LDRH     r0,[r5,#2]            ;1311  ; uip_buf
0003c0  8060              STRH     r0,[r4,#2]            ;1311
0003c2  2201              MOVS     r2,#1                 ;1312
0003c4  7662              STRB     r2,[r4,#0x19]         ;1312
0003c6  f8991000          LDRB     r1,[r9,#0]            ;1314  ; iss
0003ca  7321              STRB     r1,[r4,#0xc]          ;1314
0003cc  f8991001          LDRB     r1,[r9,#1]            ;1315  ; iss
0003d0  7361              STRB     r1,[r4,#0xd]          ;1315
0003d2  f8991002          LDRB     r1,[r9,#2]            ;1316  ; iss
0003d6  73a1              STRB     r1,[r4,#0xe]          ;1316
0003d8  f8990003          LDRB     r0,[r9,#3]            ;1317  ; iss
0003dc  73e0              STRB     r0,[r4,#0xf]          ;1317
0003de  8222              STRH     r2,[r4,#0x10]         ;1318
0003e0  7be8              LDRB     r0,[r5,#0xf]          ;1321  ; uip_buf
0003e2  72e0              STRB     r0,[r4,#0xb]          ;1321
0003e4  7ba8              LDRB     r0,[r5,#0xe]          ;1322  ; uip_buf
0003e6  72a0              STRB     r0,[r4,#0xa]          ;1322
0003e8  7b68              LDRB     r0,[r5,#0xd]          ;1323  ; uip_buf
0003ea  7260              STRB     r0,[r4,#9]            ;1323
0003ec  7b28              LDRB     r0,[r5,#0xc]          ;1324  ; uip_buf
0003ee  7220              STRB     r0,[r4,#8]            ;1324
0003f0  2001              MOVS     r0,#1                 ;1325
0003f2  f7fffffe          BL       uip_add_rcv_nxt
0003f6  e071              B        |L10.1244|
                  |L10.1016|
0003f8  e07c              B        |L10.1268|
0003fa  0000              DCW      0x0000
                  |L10.1020|
                          DCD      ||area_number.22||
                  |L10.1024|
                          DCD      ||.bss||+0x36
                  |L10.1028|
                          DCD      ||.bss||+0x2610
                  |L10.1032|
000408  69703a20          DCB      "ip: invalid version or header length.",0
00040c  696e7661
000410  6c696420
000414  76657273
000418  696f6e20
00041c  6f722068
000420  65616465
000424  72206c65
000428  6e677468
00042c  2e00    
00042e  00                DCB      0
00042f  00                DCB      0
                  |L10.1072|
000430  69703a20          DCB      "ip: packet shorter than reported in IP header.",0
000434  7061636b
000438  65742073
00043c  686f7274
000440  65722074
000444  68616e20
000448  7265706f
00044c  72746564
000450  20696e20
000454  49502068
000458  65616465
00045c  722e00  
00045f  00                DCB      0
                  |L10.1120|
000460  69703a20          DCB      "ip: fragment dropped.",0
000464  66726167
000468  6d656e74
00046c  2064726f
000470  70706564
000474  2e00    
000476  00                DCB      0
000477  00                DCB      0
                  |L10.1144|
000478  69703a20          DCB      "ip: bad checksum.",0
00047c  62616420
000480  63686563
000484  6b73756d
000488  2e00    
00048a  00                DCB      0
00048b  00                DCB      0
                  |L10.1164|
00048c  69703a20          DCB      "ip: neither tcp nor icmp.",0
000490  6e656974
000494  68657220
000498  74637020
00049c  6e6f7220
0004a0  69636d70
0004a4  2e00    
0004a6  00                DCB      0
0004a7  00                DCB      0
                  |L10.1192|
0004a8  69636d70          DCB      "icmp: not icmp echo.",0
0004ac  3a206e6f
0004b0  74206963
0004b4  6d702065
0004b8  63686f2e
0004bc  00      
0004bd  00                DCB      0
0004be  00                DCB      0
0004bf  00                DCB      0
                  |L10.1216|
0004c0  7463703a          DCB      "tcp: bad checksum.",0
0004c4  20626164
0004c8  20636865
0004cc  636b7375
0004d0  6d2e00  
0004d3  00                DCB      0
                  |L10.1236|
                          DCD      ||.bss||+0x5e0
                  |L10.1240|
                          DCD      ||.bss||+0x24f4
                  |L10.1244|
0004dc  7d28              LDRB     r0,[r5,#0x14]         ;1328  ; uip_buf
0004de  3d1a              SUBS     r5,r5,#0x1a           ;1328
0004e0  f00001f0          AND      r1,r0,#0xf0           ;1328
0004e4  2950              CMP      r1,#0x50              ;1328
0004e6  d929              BLS      |L10.1340|
0004e8  0900              LSRS     r0,r0,#4              ;1329
0004ea  0081              LSLS     r1,r0,#2              ;1329
0004ec  f8887001          STRB     r7,[r8,#1]            ;1329
0004f0  3914              SUBS     r1,r1,#0x14           ;1329
0004f2  e01f              B        |L10.1332|
                  |L10.1268|
0004f4  f8bb1028          LDRH     r1,[r11,#0x28]        ;1298  ; uip_stat
0004f8  a0fa              ADR      r0,|L10.2276|
0004fa  1c49              ADDS     r1,r1,#1              ;1298
0004fc  f8ab1028          STRH     r1,[r11,#0x28]        ;1298
                  |L10.1280|
000500  f7fffffe          BL       uip_log
000504  e255              B        |L10.2482|
                  |L10.1286|
000506  182b              ADDS     r3,r5,r0              ;1330
000508  f8932036          LDRB     r2,[r3,#0x36]         ;1330
00050c  f8882002          STRB     r2,[r8,#2]            ;1330
000510  b1a2              CBZ      r2,|L10.1340|
000512  2a01              CMP      r2,#1                 ;1334
000514  d002              BEQ      |L10.1308|
000516  2a02              CMP      r2,#2                 ;1337
000518  d002              BEQ      |L10.1312|
00051a  e005              B        |L10.1320|
                  |L10.1308|
00051c  1c40              ADDS     r0,r0,#1              ;1337
00051e  e007              B        |L10.1328|
                  |L10.1312|
000520  f8932037          LDRB     r2,[r3,#0x37]         ;1338
000524  2a04              CMP      r2,#4                 ;1338
000526  d021              BEQ      |L10.1388|
                  |L10.1320|
000528  f8932037          LDRB     r2,[r3,#0x37]         ;1350
00052c  b132              CBZ      r2,|L10.1340|
00052e  4410              ADD      r0,r0,r2              ;1355
                  |L10.1328|
000530  f8880001          STRB     r0,[r8,#1]            ;1355
                  |L10.1332|
000534  f8980001          LDRB     r0,[r8,#1]            ;1329  ; c
000538  4281              CMP      r1,r0                 ;1329
00053a  dce4              BGT      |L10.1286|
                  |L10.1340|
00053c  f885a02f          STRB     r10,[r5,#0x2f]
                  |L10.1344|
;;;1364   
;;;1365    tcp_send_syn:
;;;1366     BUF->flags |= TCP_SYN;
000540  f895002f          LDRB     r0,[r5,#0x2f]  ; uip_buf
000544  f0400002          ORR      r0,r0,#2
000548  f885002f          STRB     r0,[r5,#0x2f]
;;;1367   #else /* UIP_ACTIVE_OPEN */
;;;1368    tcp_send_synack:
;;;1369     BUF->flags = TCP_SYN | TCP_ACK;
;;;1370   #endif /* UIP_ACTIVE_OPEN */
;;;1371   
;;;1372     /* We send out the TCP Maximum Segment Size option with our
;;;1373        SYNACK. */
;;;1374     BUF->optdata[0] = TCP_OPT_MSS;
00054c  2002              MOVS     r0,#2
00054e  f8850036          STRB     r0,[r5,#0x36]
;;;1375     BUF->optdata[1] = TCP_OPT_MSS_LEN;
000552  2004              MOVS     r0,#4
000554  f8850037          STRB     r0,[r5,#0x37]
;;;1376     BUF->optdata[2] = (UIP_TCP_MSS) / 256;
000558  2005              MOVS     r0,#5
00055a  f8850038          STRB     r0,[r5,#0x38]
;;;1377     BUF->optdata[3] = (UIP_TCP_MSS) & 255;
00055e  20a6              MOVS     r0,#0xa6
000560  f8850039          STRB     r0,[r5,#0x39]
;;;1378     uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
000564  202c              MOVS     r0,#0x2c
000566  80b0              STRH     r0,[r6,#4]
;;;1379     BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
000568  2060              MOVS     r0,#0x60
;;;1380     goto tcp_send;
00056a  e1ea              B        |L10.2370|
                  |L10.1388|
00056c  b2c0              UXTB     r0,r0                 ;1340
00056e  4428              ADD      r0,r0,r5              ;1340
000570  f24051a6          MOV      r1,#0x5a6             ;1342
000574  8f00              LDRH     r0,[r0,#0x38]         ;1340
000576  ba40              REV16    r0,r0                 ;1340
000578  f8a8000c          STRH     r0,[r8,#0xc]          ;1340
00057c  4288              CMP      r0,r1                 ;1342
00057e  d900              BLS      |L10.1410|
000580  4608              MOV      r0,r1                 ;1343
                  |L10.1410|
000582  8260              STRH     r0,[r4,#0x12]         ;1343
000584  82a0              STRH     r0,[r4,#0x14]         ;1343
000586  e7d9              B        |L10.1340|
                  |L10.1416|
;;;1381   
;;;1382     /* This label will be jumped to if we found an active connection. */
;;;1383    found:
;;;1384     uip_conn = uip_connr;
;;;1385     uip_flags = 0;
000588  61f4              STR      r4,[r6,#0x1c]  ; uip_conn
00058a  7037              STRB     r7,[r6,#0]
;;;1386     /* We do a very naive form of TCP reset processing; we just accept
;;;1387        any RST and kill our connection. We should in fact check if the
;;;1388        sequence number of this reset is wihtin our advertised window
;;;1389        before we accept the reset. */
;;;1390     if(BUF->flags & TCP_RST) {
00058c  f895002f          LDRB     r0,[r5,#0x2f]  ; uip_buf
000590  0741              LSLS     r1,r0,#29
000592  d506              BPL      |L10.1442|
;;;1391       uip_connr->tcpstateflags = UIP_CLOSED;
000594  7667              STRB     r7,[r4,#0x19]
;;;1392       UIP_LOG("tcp: got reset, aborting connection.");
000596  a0dc              ADR      r0,|L10.2312|
000598  f7fffffe          BL       uip_log
;;;1393       uip_flags = UIP_ABORT;
00059c  2020              MOVS     r0,#0x20
00059e  7030              STRB     r0,[r6,#0]
;;;1394       UIP_APPCALL();
;;;1395       goto drop;
0005a0  e170              B        |L10.2180|
                  |L10.1442|
;;;1396     }
;;;1397     /* Calculated the length of the data, if the application has sent
;;;1398        any data to us. */
;;;1399     c = (BUF->tcpoffset >> 4) << 2;
0005a2  f895102e          LDRB     r1,[r5,#0x2e]  ; uip_buf
0005a6  46a8              MOV      r8,r5
0005a8  0909              LSRS     r1,r1,#4
0005aa  0089              LSLS     r1,r1,#2
0005ac  7071              STRB     r1,[r6,#1]
;;;1400     /* uip_len will contain the length of the actual TCP data. This is
;;;1401        calculated by subtracing the length of the TCP header (in
;;;1402        c) and the length of the IP header (20 bytes). */
;;;1403     uip_len = uip_len - c - UIP_IPH_LEN;
0005ae  88b2              LDRH     r2,[r6,#4]  ; uip_len
0005b0  1a51              SUBS     r1,r2,r1
0005b2  3914              SUBS     r1,r1,#0x14
0005b4  b289              UXTH     r1,r1
0005b6  80b1              STRH     r1,[r6,#4]
;;;1404   
;;;1405     /* First, check if the sequence number of the incoming packet is
;;;1406        what we're expecting next. If not, we send out an ACK with the
;;;1407        correct numbers in. */
;;;1408     if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
0005b8  7e62              LDRB     r2,[r4,#0x19]
0005ba  f002020f          AND      r2,r2,#0xf
0005be  2a02              CMP      r2,#2
0005c0  d103              BNE      |L10.1482|
0005c2  f000023f          AND      r2,r0,#0x3f
0005c6  2a12              CMP      r2,#0x12
0005c8  d017              BEQ      |L10.1530|
                  |L10.1482|
;;;1409          ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
;;;1410       if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
0005ca  b909              CBNZ     r1,|L10.1488|
0005cc  0781              LSLS     r1,r0,#30
0005ce  d014              BEQ      |L10.1530|
                  |L10.1488|
;;;1411          (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
0005d0  f8951026          LDRB     r1,[r5,#0x26]  ; uip_buf
0005d4  7a22              LDRB     r2,[r4,#8]
0005d6  462b              MOV      r3,r5
0005d8  4291              CMP      r1,r2
                  |L10.1498|
0005da  d17c              BNE      |L10.1750|
;;;1412   	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
0005dc  f8931027          LDRB     r1,[r3,#0x27]  ; uip_buf
0005e0  7a62              LDRB     r2,[r4,#9]
0005e2  4291              CMP      r1,r2
0005e4  d1f9              BNE      |L10.1498|
;;;1413   	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
0005e6  f8931028          LDRB     r1,[r3,#0x28]  ; uip_buf
0005ea  7aa2              LDRB     r2,[r4,#0xa]
0005ec  4291              CMP      r1,r2
0005ee  d1f4              BNE      |L10.1498|
;;;1414   	BUF->seqno[3] != uip_connr->rcv_nxt[3])) {
0005f0  f8951029          LDRB     r1,[r5,#0x29]  ; uip_buf
0005f4  7ae2              LDRB     r2,[r4,#0xb]
0005f6  4291              CMP      r1,r2
0005f8  d1ef              BNE      |L10.1498|
                  |L10.1530|
;;;1415         goto tcp_send_ack;
;;;1416       }
;;;1417     }
;;;1418   
;;;1419     /* Next, check if the incoming segment acknowledges any outstanding
;;;1420        data. If so, we update the sequence number, reset the length of
;;;1421        the outstanding data, calculate RTT estimations, and reset the
;;;1422        retransmission timer. */
;;;1423     if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
0005fa  06c0              LSLS     r0,r0,#27
0005fc  d53e              BPL      |L10.1660|
0005fe  8a21              LDRH     r1,[r4,#0x10]
000600  b3e1              CBZ      r1,|L10.1660|
000602  f104000c          ADD      r0,r4,#0xc
;;;1424       uip_add32(uip_connr->snd_nxt, uip_connr->len);
000606  f7fffffe          BL       uip_add32
;;;1425   
;;;1426       if(BUF->ackno[0] == uip_acc32[0] &&
00060a  48c9              LDR      r0,|L10.2352|
00060c  f898102a          LDRB     r1,[r8,#0x2a]  ; uip_buf
000610  46c1              MOV      r9,r8
000612  7802              LDRB     r2,[r0,#0]  ; uip_acc32
000614  4291              CMP      r1,r2
000616  d131              BNE      |L10.1660|
;;;1427          BUF->ackno[1] == uip_acc32[1] &&
000618  f899102b          LDRB     r1,[r9,#0x2b]  ; uip_buf
00061c  7843              LDRB     r3,[r0,#1]  ; uip_acc32
00061e  4299              CMP      r1,r3
000620  d12c              BNE      |L10.1660|
;;;1428          BUF->ackno[2] == uip_acc32[2] &&
000622  f899102c          LDRB     r1,[r9,#0x2c]  ; uip_buf
000626  f890c002          LDRB     r12,[r0,#2]  ; uip_acc32
00062a  4561              CMP      r1,r12
00062c  d126              BNE      |L10.1660|
;;;1429          BUF->ackno[3] == uip_acc32[3]) {
00062e  f898102d          LDRB     r1,[r8,#0x2d]  ; uip_buf
000632  78c0              LDRB     r0,[r0,#3]  ; uip_acc32
000634  4281              CMP      r1,r0
000636  d121              BNE      |L10.1660|
;;;1430         /* Update sequence number. */
;;;1431         uip_connr->snd_nxt[0] = uip_acc32[0];
000638  7322              STRB     r2,[r4,#0xc]
;;;1432         uip_connr->snd_nxt[1] = uip_acc32[1];
00063a  7363              STRB     r3,[r4,#0xd]
;;;1433         uip_connr->snd_nxt[2] = uip_acc32[2];
00063c  f884c00e          STRB     r12,[r4,#0xe]
;;;1434         uip_connr->snd_nxt[3] = uip_acc32[3];
000640  73e0              STRB     r0,[r4,#0xf]
;;;1435   
;;;1436   
;;;1437         /* Do RTT estimation, unless we have done retransmissions. */
;;;1438         if(uip_connr->nrtx == 0) {
000642  7ee0              LDRB     r0,[r4,#0x1b]
000644  b9a8              CBNZ     r0,|L10.1650|
;;;1439   	signed char m;
;;;1440   	m = uip_connr->rto - uip_connr->timer;
000646  7e20              LDRB     r0,[r4,#0x18]
000648  7ea1              LDRB     r1,[r4,#0x1a]
00064a  1a40              SUBS     r0,r0,r1
;;;1441   	/* This is taken directly from VJs original code in his paper */
;;;1442   	m = m - (uip_connr->sa >> 3);
00064c  7da1              LDRB     r1,[r4,#0x16]
00064e  eba000d1          SUB      r0,r0,r1,LSR #3
000652  b240              SXTB     r0,r0
;;;1443   	uip_connr->sa += m;
000654  4401              ADD      r1,r1,r0
000656  b2c9              UXTB     r1,r1
000658  75a1              STRB     r1,[r4,#0x16]
;;;1444   	if(m < 0) {
00065a  2800              CMP      r0,#0
00065c  da01              BGE      |L10.1634|
;;;1445   	  m = -m;
00065e  4240              RSBS     r0,r0,#0
000660  b240              SXTB     r0,r0
                  |L10.1634|
;;;1446   	}
;;;1447   	m = m - (uip_connr->sv >> 2);
000662  7de2              LDRB     r2,[r4,#0x17]
000664  eba00092          SUB      r0,r0,r2,LSR #2
;;;1448   	uip_connr->sv += m;
000668  4410              ADD      r0,r0,r2
00066a  75e0              STRB     r0,[r4,#0x17]
;;;1449   	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
00066c  eb0000d1          ADD      r0,r0,r1,LSR #3
000670  7620              STRB     r0,[r4,#0x18]
                  |L10.1650|
;;;1450   
;;;1451         }
;;;1452         /* Set the acknowledged flag. */
;;;1453         uip_flags = UIP_ACKDATA;
000672  2001              MOVS     r0,#1
000674  7030              STRB     r0,[r6,#0]
;;;1454         /* Reset the retransmission timer. */
;;;1455         uip_connr->timer = uip_connr->rto;
000676  7e20              LDRB     r0,[r4,#0x18]
000678  76a0              STRB     r0,[r4,#0x1a]
;;;1456   
;;;1457         /* Reset length of outstanding data. */
;;;1458         uip_connr->len = 0;
00067a  8227              STRH     r7,[r4,#0x10]
                  |L10.1660|
;;;1459       }
;;;1460   
;;;1461     }
;;;1462   
;;;1463     /* Do different things depending on in what state the connection is. */
;;;1464     switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
00067c  7e62              LDRB     r2,[r4,#0x19]
00067e  f04f0907          MOV      r9,#7                 ;697
000682  f002000f          AND      r0,r2,#0xf
000686  2809              CMP      r0,#9
000688  d26f              BCS      |L10.1898|
00068a  e8dff000          TBB      [pc,r0]
00068e  6e05              DCB      0x6e,0x05
000690  146ffef3          DCB      0x14,0x6f,0xfe,0xf3
000694  f224f500          DCB      0xf2,0x24,0xf5,0x00
;;;1465       /* CLOSED and LISTEN are not handled here. CLOSE_WAIT is not
;;;1466   	implemented, since we force the application to close when the
;;;1467   	peer sends a FIN (hence the application goes directly from
;;;1468   	ESTABLISHED to LAST_ACK). */
;;;1469     case UIP_SYN_RCVD:
;;;1470       /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
;;;1471          we are waiting for an ACK that acknowledges the data we sent
;;;1472          out the last time. Therefore, we want to have the UIP_ACKDATA
;;;1473          flag set. If so, we enter the ESTABLISHED state. */
;;;1474       if(uip_flags & UIP_ACKDATA) {
000698  7830              LDRB     r0,[r6,#0]  ; uip_flags
00069a  07c0              LSLS     r0,r0,#31
00069c  d065              BEQ      |L10.1898|
;;;1475         uip_connr->tcpstateflags = UIP_ESTABLISHED;
00069e  2003              MOVS     r0,#3
0006a0  7660              STRB     r0,[r4,#0x19]
;;;1476         uip_flags = UIP_CONNECTED;
0006a2  2040              MOVS     r0,#0x40
0006a4  7030              STRB     r0,[r6,#0]
;;;1477         uip_connr->len = 0;
0006a6  8227              STRH     r7,[r4,#0x10]
;;;1478         if(uip_len > 0) {
0006a8  88b0              LDRH     r0,[r6,#4]  ; uip_len
0006aa  b370              CBZ      r0,|L10.1802|
;;;1479           uip_flags |= UIP_NEWDATA;
0006ac  2142              MOVS     r1,#0x42
0006ae  7031              STRB     r1,[r6,#0]
;;;1480           uip_add_rcv_nxt(uip_len);
0006b0  f7fffffe          BL       uip_add_rcv_nxt
0006b4  e0a2              B        |L10.2044|
;;;1481         }
;;;1482         uip_slen = 0;
;;;1483         UIP_APPCALL();
;;;1484         goto appsend;
;;;1485       }
;;;1486       goto drop;
;;;1487   #if UIP_ACTIVE_OPEN
;;;1488     case UIP_SYN_SENT:
;;;1489       /* In SYN_SENT, we wait for a SYNACK that is sent in response to
;;;1490          our SYN. The rcv_nxt is set to sequence number in the SYNACK
;;;1491          plus one, and we send an ACK. We move into the ESTABLISHED
;;;1492          state. */
;;;1493       if((uip_flags & UIP_ACKDATA) &&
0006b6  7830              LDRB     r0,[r6,#0]  ; uip_flags
0006b8  07c0              LSLS     r0,r0,#31
0006ba  d005              BEQ      |L10.1736|
;;;1494          (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
0006bc  f898002f          LDRB     r0,[r8,#0x2f]  ; uip_buf
0006c0  f000003f          AND      r0,r0,#0x3f
0006c4  2812              CMP      r0,#0x12
0006c6  d007              BEQ      |L10.1752|
                  |L10.1736|
;;;1495   
;;;1496         /* Parse the TCP MSS option, if present. */
;;;1497         if((BUF->tcpoffset & 0xf0) > 0x50) {
;;;1498   	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
;;;1499   	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
;;;1500   	  if(opt == TCP_OPT_END) {
;;;1501   	    /* End of options. */
;;;1502   	    break;
;;;1503   	  } else if(opt == TCP_OPT_NOOP) {
;;;1504   	    ++c;
;;;1505   	    /* NOP option. */
;;;1506   	  } else if(opt == TCP_OPT_MSS &&
;;;1507   		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
;;;1508   	    /* An MSS option with the right option length. */
;;;1509   	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
;;;1510   	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
;;;1511   	    uip_connr->initialmss =
;;;1512   	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
;;;1513   
;;;1514   	    /* And we are done processing options. */
;;;1515   	    break;
;;;1516   	  } else {
;;;1517   	    /* All other options have a length field, so that we easily
;;;1518   	       can skip past them. */
;;;1519   	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
;;;1520   	      /* If the length field is zero, the options are malformed
;;;1521   		 and we don't process them further. */
;;;1522   	      break;
;;;1523   	    }
;;;1524   	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
;;;1525   	  }
;;;1526   	}
;;;1527         }
;;;1528         uip_connr->tcpstateflags = UIP_ESTABLISHED;
;;;1529         uip_connr->rcv_nxt[0] = BUF->seqno[0];
;;;1530         uip_connr->rcv_nxt[1] = BUF->seqno[1];
;;;1531         uip_connr->rcv_nxt[2] = BUF->seqno[2];
;;;1532         uip_connr->rcv_nxt[3] = BUF->seqno[3];
;;;1533         uip_add_rcv_nxt(1);
;;;1534         uip_flags = UIP_CONNECTED | UIP_NEWDATA;
;;;1535         uip_connr->len = 0;
;;;1536         uip_len = 0;
;;;1537         uip_slen = 0;
;;;1538         UIP_APPCALL();
;;;1539         goto appsend;
;;;1540       }
;;;1541       /* Inform the application that the connection failed */
;;;1542       uip_flags = UIP_ABORT;
0006c8  2020              MOVS     r0,#0x20
0006ca  7030              STRB     r0,[r6,#0]
;;;1543       UIP_APPCALL();
0006cc  f7fffffe          BL       httpd_appcall
;;;1544       /* The connection is closed after we send the RST */
;;;1545       uip_conn->tcpstateflags = UIP_CLOSED;
0006d0  69f0              LDR      r0,[r6,#0x1c]  ; uip_conn
0006d2  7647              STRB     r7,[r0,#0x19]
;;;1546       goto reset;
0006d4  e5e1              B        |L10.666|
                  |L10.1750|
0006d6  e12f              B        |L10.2360|
                  |L10.1752|
0006d8  f898002e          LDRB     r0,[r8,#0x2e]         ;1497  ; uip_buf
0006dc  f00001f0          AND      r1,r0,#0xf0           ;1497
0006e0  2950              CMP      r1,#0x50              ;1497
0006e2  d91f              BLS      |L10.1828|
0006e4  0900              LSRS     r0,r0,#4              ;1329
0006e6  0081              LSLS     r1,r0,#2              ;1329
0006e8  7077              STRB     r7,[r6,#1]            ;1498
0006ea  3914              SUBS     r1,r1,#0x14           ;1329
0006ec  e017              B        |L10.1822|
0006ee  bf00              NOP                            ;1499
                  |L10.1776|
0006f0  eb080300          ADD      r3,r8,r0              ;1499
0006f4  f8932036          LDRB     r2,[r3,#0x36]         ;1499
0006f8  70b2              STRB     r2,[r6,#2]            ;1499
0006fa  b19a              CBZ      r2,|L10.1828|
0006fc  2a01              CMP      r2,#1                 ;1503
0006fe  d002              BEQ      |L10.1798|
000700  2a02              CMP      r2,#2                 ;1506
000702  d003              BEQ      |L10.1804|
000704  e006              B        |L10.1812|
                  |L10.1798|
000706  1c40              ADDS     r0,r0,#1              ;1506
000708  e008              B        |L10.1820|
                  |L10.1802|
00070a  e077              B        |L10.2044|
                  |L10.1804|
00070c  f8932037          LDRB     r2,[r3,#0x37]         ;1507
000710  2a04              CMP      r2,#4                 ;1507
000712  d01d              BEQ      |L10.1872|
                  |L10.1812|
000714  f8932037          LDRB     r2,[r3,#0x37]         ;1519
000718  b122              CBZ      r2,|L10.1828|
00071a  4410              ADD      r0,r0,r2              ;1524
                  |L10.1820|
00071c  7070              STRB     r0,[r6,#1]            ;1524
                  |L10.1822|
00071e  7870              LDRB     r0,[r6,#1]            ;1498  ; c
000720  4281              CMP      r1,r0                 ;1498
000722  dce5              BGT      |L10.1776|
                  |L10.1828|
000724  2003              MOVS     r0,#3                 ;1528
000726  7660              STRB     r0,[r4,#0x19]         ;1528
000728  f8980026          LDRB     r0,[r8,#0x26]         ;1529  ; uip_buf
00072c  7220              STRB     r0,[r4,#8]            ;1529
00072e  f8980027          LDRB     r0,[r8,#0x27]         ;1530  ; uip_buf
000732  7260              STRB     r0,[r4,#9]            ;1530
000734  f8980028          LDRB     r0,[r8,#0x28]         ;1531  ; uip_buf
000738  72a0              STRB     r0,[r4,#0xa]          ;1531
00073a  f8980029          LDRB     r0,[r8,#0x29]         ;1532  ; uip_buf
00073e  72e0              STRB     r0,[r4,#0xb]          ;1532
000740  2001              MOVS     r0,#1                 ;1533
000742  f7fffffe          BL       uip_add_rcv_nxt
000746  2042              MOVS     r0,#0x42              ;1534
000748  7030              STRB     r0,[r6,#0]            ;1534
00074a  8227              STRH     r7,[r4,#0x10]         ;1535
00074c  80b7              STRH     r7,[r6,#4]            ;1536
00074e  e055              B        |L10.2044|
                  |L10.1872|
000750  b2c0              UXTB     r0,r0                 ;1509
000752  4440              ADD      r0,r0,r8              ;1509
000754  f24051a6          MOV      r1,#0x5a6             ;1511
000758  8f00              LDRH     r0,[r0,#0x38]         ;1509
00075a  ba40              REV16    r0,r0                 ;1509
00075c  81b0              STRH     r0,[r6,#0xc]          ;1509
00075e  4288              CMP      r0,r1                 ;1511
000760  d900              BLS      |L10.1892|
000762  4608              MOV      r0,r1                 ;1512
                  |L10.1892|
000764  8260              STRH     r0,[r4,#0x12]         ;1512
000766  82a0              STRH     r0,[r4,#0x14]         ;1512
000768  e7dc              B        |L10.1828|
                  |L10.1898|
00076a  e045              B        |L10.2040|
;;;1547   #endif /* UIP_ACTIVE_OPEN */
;;;1548   
;;;1549     case UIP_ESTABLISHED:
;;;1550       /* In the ESTABLISHED state, we call upon the application to feed
;;;1551       data into the uip_buf. If the UIP_ACKDATA flag is set, the
;;;1552       application should put new data into the buffer, otherwise we are
;;;1553       retransmitting an old segment, and the application should put that
;;;1554       data into the buffer.
;;;1555   
;;;1556       If the incoming packet is a FIN, we should close the connection on
;;;1557       this side as well, and we send out a FIN and enter the LAST_ACK
;;;1558       state. We require that there is no outstanding data; otherwise the
;;;1559       sequence numbers will be screwed up. */
;;;1560   
;;;1561       if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
00076c  f898002f          LDRB     r0,[r8,#0x2f]  ; uip_buf
000770  07c1              LSLS     r1,r0,#31
000772  d019              BEQ      |L10.1960|
000774  06d1              LSLS     r1,r2,#27
000776  d417              BMI      |L10.1960|
;;;1562         if(uip_outstanding(uip_connr)) {
000778  8a20              LDRH     r0,[r4,#0x10]
00077a  bbe8              CBNZ     r0,|L10.2040|
;;;1563   	goto drop;
;;;1564         }
;;;1565         uip_add_rcv_nxt(1 + uip_len);
00077c  88b0              LDRH     r0,[r6,#4]  ; uip_len
00077e  1c40              ADDS     r0,r0,#1
000780  b280              UXTH     r0,r0
000782  f7fffffe          BL       uip_add_rcv_nxt
;;;1566         uip_flags |= UIP_CLOSE;
000786  7830              LDRB     r0,[r6,#0]  ; uip_flags
000788  f0400010          ORR      r0,r0,#0x10
00078c  7030              STRB     r0,[r6,#0]
;;;1567         if(uip_len > 0) {
00078e  88b1              LDRH     r1,[r6,#4]  ; uip_len
000790  b111              CBZ      r1,|L10.1944|
;;;1568   	uip_flags |= UIP_NEWDATA;
000792  f0400002          ORR      r0,r0,#2
000796  7030              STRB     r0,[r6,#0]
                  |L10.1944|
;;;1569         }
;;;1570         UIP_APPCALL();
000798  f7fffffe          BL       httpd_appcall
;;;1571         uip_connr->len = 1;
00079c  2001              MOVS     r0,#1
00079e  8220              STRH     r0,[r4,#0x10]
;;;1572         uip_connr->tcpstateflags = UIP_LAST_ACK;
0007a0  2008              MOVS     r0,#8
;;;1573         uip_connr->nrtx = 0;
;;;1574       tcp_send_finack:
0007a2  e03d              B        |L10.2080|
                  |L10.1956|
;;;1575         BUF->flags = TCP_FIN | TCP_ACK;
0007a4  2011              MOVS     r0,#0x11
;;;1576         goto tcp_send_nodata;
0007a6  e032              B        |L10.2062|
                  |L10.1960|
;;;1577       }
;;;1578   
;;;1579       /* Check the URG flag. If this is set, the segment carries urgent
;;;1580          data that we must pass to the application. */
;;;1581       if((BUF->flags & TCP_URG) != 0) {
0007a8  0680              LSLS     r0,r0,#26
0007aa  d509              BPL      |L10.1984|
;;;1582   #if UIP_URGDATA > 0
;;;1583         uip_urglen = (BUF->urgp[0] << 8) | BUF->urgp[1];
;;;1584         if(uip_urglen > uip_len) {
;;;1585   	/* There is more urgent data in the next segment to come. */
;;;1586   	uip_urglen = uip_len;
;;;1587         }
;;;1588         uip_add_rcv_nxt(uip_urglen);
;;;1589         uip_len -= uip_urglen;
;;;1590         uip_urgdata = uip_appdata;
;;;1591         uip_appdata += uip_urglen;
;;;1592       } else {
;;;1593         uip_urglen = 0;
;;;1594   #else /* UIP_URGDATA > 0 */
;;;1595         uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
0007ac  f8b80034          LDRH     r0,[r8,#0x34]  ; uip_buf
0007b0  6973              LDR      r3,[r6,#0x14]  ; uip_appdata
0007b2  ba41              REV16    r1,r0
0007b4  4419              ADD      r1,r1,r3
;;;1596         uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
0007b6  6171              STR      r1,[r6,#0x14]  ; uip_appdata
0007b8  88b1              LDRH     r1,[r6,#4]  ; uip_len
0007ba  ba40              REV16    r0,r0
0007bc  1a08              SUBS     r0,r1,r0
0007be  80b0              STRH     r0,[r6,#4]
                  |L10.1984|
;;;1597   #endif /* UIP_URGDATA > 0 */
;;;1598       }
;;;1599   
;;;1600       /* If uip_len > 0 we have TCP data in the packet, and we flag this
;;;1601          by setting the UIP_NEWDATA flag and update the sequence number
;;;1602          we acknowledge. If the application has stopped the dataflow
;;;1603          using uip_stop(), we must not accept any data packets from the
;;;1604          remote host. */
;;;1605       if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
0007c0  88b0              LDRH     r0,[r6,#4]  ; uip_len
0007c2  b138              CBZ      r0,|L10.2004|
0007c4  06d1              LSLS     r1,r2,#27
0007c6  d405              BMI      |L10.2004|
;;;1606         uip_flags |= UIP_NEWDATA;
0007c8  7831              LDRB     r1,[r6,#0]  ; uip_flags
0007ca  f0410102          ORR      r1,r1,#2
0007ce  7031              STRB     r1,[r6,#0]
;;;1607         uip_add_rcv_nxt(uip_len);
0007d0  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2004|
;;;1608       }
;;;1609   
;;;1610       /* Check if the available buffer space advertised by the other end
;;;1611          is smaller than the initial MSS for this connection. If so, we
;;;1612          set the current MSS to the window size to ensure that the
;;;1613          application does not send more data than the other end can
;;;1614          handle.
;;;1615   
;;;1616          If the remote host advertises a zero window, we set the MSS to
;;;1617          the initial MSS so that the application will send an entire MSS
;;;1618          of data. This data will not be acknowledged by the receiver,
;;;1619          and the application will retransmit it. This is called the
;;;1620          "persistent timer" and uses the retransmission mechanim.
;;;1621       */
;;;1622       tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
0007d4  f8980031          LDRB     r0,[r8,#0x31]  ; uip_buf
0007d8  f8981030          LDRB     r1,[r8,#0x30]  ; uip_buf
0007dc  eb002001          ADD      r0,r0,r1,LSL #8
0007e0  b280              UXTH     r0,r0
0007e2  81b0              STRH     r0,[r6,#0xc]
;;;1623       if(tmp16 > uip_connr->initialmss ||
0007e4  8aa1              LDRH     r1,[r4,#0x14]
0007e6  4281              CMP      r1,r0
0007e8  d300              BCC      |L10.2028|
;;;1624          tmp16 == 0) {
0007ea  b900              CBNZ     r0,|L10.2030|
                  |L10.2028|
;;;1625         tmp16 = uip_connr->initialmss;
0007ec  81b1              STRH     r1,[r6,#0xc]
                  |L10.2030|
;;;1626       }
;;;1627       uip_connr->mss = tmp16;
0007ee  89b0              LDRH     r0,[r6,#0xc]  ; tmp16
0007f0  8260              STRH     r0,[r4,#0x12]
;;;1628   
;;;1629       /* If this packet constitutes an ACK for outstanding data (flagged
;;;1630          by the UIP_ACKDATA flag, we should call the application since it
;;;1631          might want to send more data. If the incoming packet had data
;;;1632          from the peer (as flagged by the UIP_NEWDATA flag), the
;;;1633          application must also be notified.
;;;1634   
;;;1635          When the application is called, the global variable uip_len
;;;1636          contains the length of the incoming data. The application can
;;;1637          access the incoming data through the global pointer
;;;1638          uip_appdata, which usually points UIP_IPTCPH_LEN + UIP_LLH_LEN
;;;1639          bytes into the uip_buf array.
;;;1640   
;;;1641          If the application wishes to send any data, this data should be
;;;1642          put into the uip_appdata and the length of the data should be
;;;1643          put into uip_len. If the application don't have any data to
;;;1644          send, uip_len must be set to 0. */
;;;1645       if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
0007f2  7830              LDRB     r0,[r6,#0]  ; uip_flags
0007f4  0780              LSLS     r0,r0,#30
0007f6  e000              B        |L10.2042|
                  |L10.2040|
0007f8  e046              B        |L10.2184|
                  |L10.2042|
0007fa  d045              BEQ      |L10.2184|
                  |L10.2044|
;;;1646         uip_slen = 0;
0007fc  80f7              STRH     r7,[r6,#6]
                  |L10.2046|
;;;1647         UIP_APPCALL();
0007fe  f7fffffe          BL       httpd_appcall
;;;1648   
;;;1649       appsend:
;;;1650   
;;;1651         if(uip_flags & UIP_ABORT) {
000802  7830              LDRB     r0,[r6,#0]  ; uip_flags
000804  0681              LSLS     r1,r0,#26
000806  d505              BPL      |L10.2068|
;;;1652   	uip_slen = 0;
000808  80f7              STRH     r7,[r6,#6]
;;;1653   	uip_connr->tcpstateflags = UIP_CLOSED;
00080a  7667              STRB     r7,[r4,#0x19]
                  |L10.2060|
00080c  2014              MOVS     r0,#0x14              ;754
                  |L10.2062|
;;;1654   	BUF->flags = TCP_RST | TCP_ACK;
;;;1655   	goto tcp_send_nodata;
;;;1656         }
;;;1657   
;;;1658         if(uip_flags & UIP_CLOSE) {
;;;1659   	uip_slen = 0;
;;;1660   	uip_connr->len = 1;
;;;1661   	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
;;;1662   	uip_connr->nrtx = 0;
;;;1663   	BUF->flags = TCP_FIN | TCP_ACK;
00080e  f885002f          STRB     r0,[r5,#0x2f]
000812  e093              B        |L10.2364|
                  |L10.2068|
000814  06c1              LSLS     r1,r0,#27             ;1658
000816  d506              BPL      |L10.2086|
000818  80f7              STRH     r7,[r6,#6]            ;1659
00081a  2001              MOVS     r0,#1                 ;1660
00081c  8220              STRH     r0,[r4,#0x10]         ;1660
00081e  2004              MOVS     r0,#4                 ;1661
                  |L10.2080|
000820  7660              STRB     r0,[r4,#0x19]         ;1661
000822  76e7              STRB     r7,[r4,#0x1b]         ;1662
000824  e7be              B        |L10.1956|
                  |L10.2086|
;;;1664   	goto tcp_send_nodata;
;;;1665         }
;;;1666   
;;;1667         /* If uip_slen > 0, the application has data to be sent. */
;;;1668         if(uip_slen > 0) {
000826  88f1              LDRH     r1,[r6,#6]  ; uip_slen
000828  b131              CBZ      r1,|L10.2104|
;;;1669   
;;;1670   	/* If the connection has acknowledged data, the contents of
;;;1671   	   the ->len variable should be discarded. */
;;;1672   	if((uip_flags & UIP_ACKDATA) != 0) {
00082a  07c0              LSLS     r0,r0,#31
00082c  d001              BEQ      |L10.2098|
;;;1673   	  uip_connr->len = 0;
00082e  8227              STRH     r7,[r4,#0x10]
000830  e00f              B        |L10.2130|
                  |L10.2098|
;;;1674   	}
;;;1675   
;;;1676   	/* If the ->len variable is non-zero the connection has
;;;1677   	   already data in transit and cannot send anymore right
;;;1678   	   now. */
;;;1679   	if(uip_connr->len == 0) {
000832  8a20              LDRH     r0,[r4,#0x10]
000834  b168              CBZ      r0,|L10.2130|
;;;1680   
;;;1681   	  /* The application cannot send more than what is allowed by
;;;1682   	     the mss (the minumum of the MSS and the available
;;;1683   	     window). */
;;;1684   	  if(uip_slen > uip_connr->mss) {
;;;1685   	    uip_slen = uip_connr->mss;
;;;1686   	  }
;;;1687   
;;;1688   	  /* Remember how much data we send out now so that we know
;;;1689   	     when everything has been acknowledged. */
;;;1690   	  uip_connr->len = uip_slen;
;;;1691   	} else {
;;;1692   
;;;1693   	  /* If the application already had unacknowledged data, we
;;;1694   	     make sure that the application does not send (i.e.,
;;;1695   	     retransmit) out more than it previously sent out. */
;;;1696   	  uip_slen = uip_connr->len;
000836  80f0              STRH     r0,[r6,#6]
                  |L10.2104|
;;;1697   	}
;;;1698         }
;;;1699         uip_connr->nrtx = 0;
000838  76e7              STRB     r7,[r4,#0x1b]
                  |L10.2106|
;;;1700       apprexmit:
;;;1701         uip_appdata = uip_sappdata;
00083a  69b0              LDR      r0,[r6,#0x18]  ; uip_sappdata
;;;1702   
;;;1703         /* If the application has data to be sent, or if the incoming
;;;1704            packet had new data in it, we must send out a packet. */
;;;1705         if(uip_slen > 0 && uip_connr->len > 0) {
00083c  6170              STR      r0,[r6,#0x14]  ; uip_appdata
00083e  88f0              LDRH     r0,[r6,#6]  ; uip_slen
000840  b170              CBZ      r0,|L10.2144|
000842  8a20              LDRH     r0,[r4,#0x10]
000844  b160              CBZ      r0,|L10.2144|
000846  3028              ADDS     r0,r0,#0x28
;;;1706   	/* Add the length of the IP and TCP headers. */
;;;1707   	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
000848  80b0              STRH     r0,[r6,#4]
;;;1708   	/* We always set the ACK flag in response packets. */
;;;1709   	BUF->flags = TCP_ACK | TCP_PSH;
00084a  2018              MOVS     r0,#0x18
00084c  f885002f          STRB     r0,[r5,#0x2f]
;;;1710   	/* Send the packet. */
;;;1711   	goto tcp_send_noopts;
000850  e076              B        |L10.2368|
                  |L10.2130|
000852  8a60              LDRH     r0,[r4,#0x12]         ;1684
000854  4288              CMP      r0,r1                 ;1684
000856  d200              BCS      |L10.2138|
000858  80f0              STRH     r0,[r6,#6]            ;1685
                  |L10.2138|
00085a  88f0              LDRH     r0,[r6,#6]            ;1690  ; uip_slen
00085c  8220              STRH     r0,[r4,#0x10]         ;1690
00085e  e7eb              B        |L10.2104|
                  |L10.2144|
;;;1712         }
;;;1713         /* If there is no data to send, just send out a pure ACK if
;;;1714   	 there is newdata. */
;;;1715         if(uip_flags & UIP_NEWDATA) {
000860  7830              LDRB     r0,[r6,#0]  ; uip_flags
000862  0780              LSLS     r0,r0,#30
000864  d510              BPL      |L10.2184|
;;;1716   	uip_len = UIP_TCPIP_HLEN;
000866  2028              MOVS     r0,#0x28
000868  80b0              STRH     r0,[r6,#4]
;;;1717   	BUF->flags = TCP_ACK;
00086a  f885a02f          STRB     r10,[r5,#0x2f]
;;;1718   	goto tcp_send_noopts;
00086e  e067              B        |L10.2368|
000870  e002              B        |L10.2168|
000872  e098              B        |L10.2470|
000874  e029              B        |L10.2250|
000876  e008              B        |L10.2186|
                  |L10.2168|
;;;1719         }
;;;1720       }
;;;1721       goto drop;
;;;1722     case UIP_LAST_ACK:
;;;1723       /* We can close this connection if the peer has acknowledged our
;;;1724          FIN. This is indicated by the UIP_ACKDATA flag. */
;;;1725       if(uip_flags & UIP_ACKDATA) {
000878  7830              LDRB     r0,[r6,#0]  ; uip_flags
00087a  07c0              LSLS     r0,r0,#31
00087c  d004              BEQ      |L10.2184|
;;;1726         uip_connr->tcpstateflags = UIP_CLOSED;
00087e  7667              STRB     r7,[r4,#0x19]
;;;1727         uip_flags = UIP_CLOSE;
000880  f886a000          STRB     r10,[r6,#0]
                  |L10.2180|
;;;1728         UIP_APPCALL();
000884  f7fffffe          BL       httpd_appcall
                  |L10.2184|
000888  e093              B        |L10.2482|
                  |L10.2186|
;;;1729       }
;;;1730       break;
;;;1731   
;;;1732     case UIP_FIN_WAIT_1:
;;;1733       /* The application has closed the connection, but the remote host
;;;1734          hasn't closed its end yet. Thus we do nothing but wait for a
;;;1735          FIN from the other side. */
;;;1736       if(uip_len > 0) {
00088a  88b0              LDRH     r0,[r6,#4]  ; uip_len
00088c  b108              CBZ      r0,|L10.2194|
;;;1737         uip_add_rcv_nxt(uip_len);
00088e  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2194|
;;;1738       }
;;;1739       if(BUF->flags & TCP_FIN) {
000892  f898002f          LDRB     r0,[r8,#0x2f]  ; uip_buf
000896  07c0              LSLS     r0,r0,#31
;;;1740         if(uip_flags & UIP_ACKDATA) {
;;;1741   	uip_connr->tcpstateflags = UIP_TIME_WAIT;
;;;1742   	uip_connr->timer = 0;
;;;1743   	uip_connr->len = 0;
;;;1744         } else {
;;;1745   	uip_connr->tcpstateflags = UIP_CLOSING;
;;;1746         }
;;;1747         uip_add_rcv_nxt(1);
;;;1748         uip_flags = UIP_CLOSE;
;;;1749         UIP_APPCALL();
;;;1750         goto tcp_send_ack;
;;;1751       } else if(uip_flags & UIP_ACKDATA) {
000898  7830              LDRB     r0,[r6,#0]  ; uip_flags
00089a  ea4f70c0          LSL      r0,r0,#31
00089e  d00f              BEQ      |L10.2240|
0008a0  b120              CBZ      r0,|L10.2220|
0008a2  f8849019          STRB     r9,[r4,#0x19]         ;1741
0008a6  76a7              STRB     r7,[r4,#0x1a]         ;1742
0008a8  8227              STRH     r7,[r4,#0x10]         ;1743
0008aa  e001              B        |L10.2224|
                  |L10.2220|
0008ac  2006              MOVS     r0,#6                 ;1745
0008ae  7660              STRB     r0,[r4,#0x19]         ;1745
                  |L10.2224|
0008b0  2001              MOVS     r0,#1                 ;1747
0008b2  f7fffffe          BL       uip_add_rcv_nxt
0008b6  f886a000          STRB     r10,[r6,#0]           ;1748
0008ba  f7fffffe          BL       httpd_appcall
0008be  e03b              B        |L10.2360|
                  |L10.2240|
0008c0  b178              CBZ      r0,|L10.2274|
;;;1752         uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
0008c2  2005              MOVS     r0,#5
0008c4  7660              STRB     r0,[r4,#0x19]
;;;1753         uip_connr->len = 0;
0008c6  8227              STRH     r7,[r4,#0x10]
;;;1754         goto drop;
0008c8  e073              B        |L10.2482|
                  |L10.2250|
;;;1755       }
;;;1756       if(uip_len > 0) {
;;;1757         goto tcp_send_ack;
;;;1758       }
;;;1759       goto drop;
;;;1760   
;;;1761     case UIP_FIN_WAIT_2:
;;;1762       if(uip_len > 0) {
0008ca  88b0              LDRH     r0,[r6,#4]  ; uip_len
0008cc  b108              CBZ      r0,|L10.2258|
;;;1763         uip_add_rcv_nxt(uip_len);
0008ce  f7fffffe          BL       uip_add_rcv_nxt
                  |L10.2258|
;;;1764       }
;;;1765       if(BUF->flags & TCP_FIN) {
0008d2  f898002f          LDRB     r0,[r8,#0x2f]  ; uip_buf
0008d6  07c0              LSLS     r0,r0,#31
0008d8  d02c              BEQ      |L10.2356|
;;;1766         uip_connr->tcpstateflags = UIP_TIME_WAIT;
0008da  f8849019          STRB     r9,[r4,#0x19]
;;;1767         uip_connr->timer = 0;
0008de  76a7              STRB     r7,[r4,#0x1a]
;;;1768         uip_add_rcv_nxt(1);
;;;1769         uip_flags = UIP_CLOSE;
;;;1770         UIP_APPCALL();
;;;1771         goto tcp_send_ack;
0008e0  e7e6              B        |L10.2224|
                  |L10.2274|
0008e2  e027              B        |L10.2356|
                  |L10.2276|
0008e4  7463703a          DCB      "tcp: found no unused connections.",0
0008e8  20666f75
0008ec  6e64206e
0008f0  6f20756e
0008f4  75736564
0008f8  20636f6e
0008fc  6e656374
000900  696f6e73
000904  2e00    
000906  00                DCB      0
000907  00                DCB      0
                  |L10.2312|
000908  7463703a          DCB      "tcp: got reset, aborting connection.",0
00090c  20676f74
000910  20726573
000914  65742c20
000918  61626f72
00091c  74696e67
000920  20636f6e
000924  6e656374
000928  696f6e2e
00092c  00      
00092d  00                DCB      0
00092e  00                DCB      0
00092f  00                DCB      0
                  |L10.2352|
                          DCD      ||area_number.22||+0x24
                  |L10.2356|
;;;1772       }
;;;1773       if(uip_len > 0) {
000934  88b0              LDRH     r0,[r6,#4]  ; uip_len
000936  b3a8              CBZ      r0,|L10.2468|
                  |L10.2360|
;;;1774         goto tcp_send_ack;
;;;1775       }
;;;1776       goto drop;
;;;1777   
;;;1778     case UIP_TIME_WAIT:
;;;1779       goto tcp_send_ack;
;;;1780   
;;;1781     case UIP_CLOSING:
;;;1782       if(uip_flags & UIP_ACKDATA) {
;;;1783         uip_connr->tcpstateflags = UIP_TIME_WAIT;
;;;1784         uip_connr->timer = 0;
;;;1785       }
;;;1786     }
;;;1787     goto drop;
;;;1788   
;;;1789   
;;;1790     /* We jump here when we are ready to send the packet, and just want
;;;1791        to set the appropriate TCP sequence numbers in the TCP header. */
;;;1792    tcp_send_ack:
;;;1793     BUF->flags = TCP_ACK;
000938  f888a02f          STRB     r10,[r8,#0x2f]
                  |L10.2364|
;;;1794    tcp_send_nodata:
;;;1795     uip_len = UIP_IPTCPH_LEN;
00093c  2028              MOVS     r0,#0x28
00093e  80b0              STRH     r0,[r6,#4]
                  |L10.2368|
;;;1796    tcp_send_noopts:
;;;1797     BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
000940  2050              MOVS     r0,#0x50
                  |L10.2370|
000942  f885002e          STRB     r0,[r5,#0x2e]
;;;1798    tcp_send:
;;;1799     /* We're done with the input processing. We are now ready to send a
;;;1800        reply. Our job is to fill in all the fields of the TCP and IP
;;;1801        headers before calculating the checksum and finally send the
;;;1802        packet. */
;;;1803     BUF->ackno[0] = uip_connr->rcv_nxt[0];
000946  7a20              LDRB     r0,[r4,#8]
000948  f885002a          STRB     r0,[r5,#0x2a]
;;;1804     BUF->ackno[1] = uip_connr->rcv_nxt[1];
00094c  7a60              LDRB     r0,[r4,#9]
00094e  f885002b          STRB     r0,[r5,#0x2b]
;;;1805     BUF->ackno[2] = uip_connr->rcv_nxt[2];
000952  7aa0              LDRB     r0,[r4,#0xa]
000954  f885002c          STRB     r0,[r5,#0x2c]
;;;1806     BUF->ackno[3] = uip_connr->rcv_nxt[3];
000958  7ae0              LDRB     r0,[r4,#0xb]
00095a  f885002d          STRB     r0,[r5,#0x2d]
;;;1807   
;;;1808     BUF->seqno[0] = uip_connr->snd_nxt[0];
00095e  7b20              LDRB     r0,[r4,#0xc]
000960  f8850026          STRB     r0,[r5,#0x26]
;;;1809     BUF->seqno[1] = uip_connr->snd_nxt[1];
000964  7b60              LDRB     r0,[r4,#0xd]
000966  f8850027          STRB     r0,[r5,#0x27]
;;;1810     BUF->seqno[2] = uip_connr->snd_nxt[2];
00096a  7ba0              LDRB     r0,[r4,#0xe]
00096c  f8850028          STRB     r0,[r5,#0x28]
;;;1811     BUF->seqno[3] = uip_connr->snd_nxt[3];
000970  7be0              LDRB     r0,[r4,#0xf]
000972  f8850029          STRB     r0,[r5,#0x29]
;;;1812   
;;;1813     BUF->proto = UIP_PROTO_TCP;
000976  2006              MOVS     r0,#6
000978  75e8              STRB     r0,[r5,#0x17]
;;;1814   
;;;1815     BUF->srcport  = uip_connr->lport;
00097a  88a0              LDRH     r0,[r4,#4]
00097c  8468              STRH     r0,[r5,#0x22]
;;;1816     BUF->destport = uip_connr->rport;
00097e  88e0              LDRH     r0,[r4,#6]
000980  84a8              STRH     r0,[r5,#0x24]
;;;1817   
;;;1818     uip_ipaddr_copy(BUF->srcipaddr, uip_hostaddr);
000982  4826              LDR      r0,|L10.2588|
000984  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
000986  8369              STRH     r1,[r5,#0x1a]
000988  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
00098a  83a8              STRH     r0,[r5,#0x1c]
;;;1819     uip_ipaddr_copy(BUF->destipaddr, uip_connr->ripaddr);
00098c  8820              LDRH     r0,[r4,#0]
00098e  83e8              STRH     r0,[r5,#0x1e]
000990  8860              LDRH     r0,[r4,#2]
000992  8428              STRH     r0,[r5,#0x20]
;;;1820   
;;;1821     if(uip_connr->tcpstateflags & UIP_STOPPED) {
000994  7e60              LDRB     r0,[r4,#0x19]
000996  06c0              LSLS     r0,r0,#27
000998  d50d              BPL      |L10.2486|
;;;1822       /* If the connection has issued uip_stop(), we advertise a zero
;;;1823          window so that the remote host will stop sending data. */
;;;1824       BUF->wnd[0] = BUF->wnd[1] = 0;
00099a  f8857031          STRB     r7,[r5,#0x31]
00099e  f8857030          STRB     r7,[r5,#0x30]
0009a2  e00e              B        |L10.2498|
                  |L10.2468|
0009a4  e005              B        |L10.2482|
                  |L10.2470|
0009a6  7830              LDRB     r0,[r6,#0]            ;1782  ; uip_flags
0009a8  07c0              LSLS     r0,r0,#31             ;1782
0009aa  d002              BEQ      |L10.2482|
0009ac  f8849019          STRB     r9,[r4,#0x19]         ;1783
0009b0  76a7              STRB     r7,[r4,#0x1a]         ;1784
                  |L10.2482|
;;;1825     } else {
;;;1826       BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
;;;1827       BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
;;;1828     }
;;;1829   
;;;1830    tcp_send_noconn:
;;;1831     BUF->ttl = UIP_TTL;
;;;1832   #if UIP_CONF_IPV6
;;;1833     /* For IPv6, the IP length field does not include the IPv6 IP header
;;;1834        length. */
;;;1835     BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;1836     BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;1837   #else /* UIP_CONF_IPV6 */
;;;1838     BUF->len[0] = (uip_len >> 8);
;;;1839     BUF->len[1] = (uip_len & 0xff);
;;;1840   #endif /* UIP_CONF_IPV6 */
;;;1841   
;;;1842     BUF->urgp[0] = BUF->urgp[1] = 0;
;;;1843   
;;;1844     /* Calculate TCP checksum. */
;;;1845     BUF->tcpchksum = 0;
;;;1846     BUF->tcpchksum = ~(uip_tcpchksum());
;;;1847   
;;;1848    ip_send_nolen:
;;;1849   
;;;1850   #if UIP_CONF_IPV6
;;;1851     BUF->vtc = 0x60;
;;;1852     BUF->tcflow = 0x00;
;;;1853     BUF->flow = 0x00;
;;;1854   #else /* UIP_CONF_IPV6 */
;;;1855     BUF->vhl = 0x45;
;;;1856     BUF->tos = 0;
;;;1857     BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
;;;1858     ++ipid;
;;;1859     BUF->ipid[0] = ipid >> 8;
;;;1860     BUF->ipid[1] = ipid & 0xff;
;;;1861     /* Calculate IP checksum. */
;;;1862     BUF->ipchksum = 0;
;;;1863     BUF->ipchksum = ~(uip_ipchksum());
;;;1864     DEBUG_PRINTF("uip ip_send_nolen: chkecum 0x%04x\n", uip_ipchksum());
;;;1865   #endif /* UIP_CONF_IPV6 */
;;;1866   
;;;1867     UIP_STAT(++uip_stat.tcp.sent);
;;;1868    send:
;;;1869     DEBUG_PRINTF("Sending packet with length %d (%d)\n", uip_len,
;;;1870   	       (BUF->len[0] << 8) | BUF->len[1]);
;;;1871   
;;;1872     UIP_STAT(++uip_stat.ip.sent);
;;;1873     /* Return and let the caller do the actual transmission. */
;;;1874     uip_flags = 0;
;;;1875     return;
;;;1876    drop:
;;;1877     uip_len = 0;
0009b2  80b7              STRH     r7,[r6,#4]
;;;1878     uip_flags = 0;
;;;1879     return;
0009b4  e02e              B        |L10.2580|
                  |L10.2486|
0009b6  2005              MOVS     r0,#5                 ;1826
0009b8  f8850030          STRB     r0,[r5,#0x30]         ;1826
0009bc  20a6              MOVS     r0,#0xa6              ;1827
0009be  f8850031          STRB     r0,[r5,#0x31]         ;1827
                  |L10.2498|
0009c2  2040              MOVS     r0,#0x40              ;1831
0009c4  75a8              STRB     r0,[r5,#0x16]         ;1831
0009c6  88b0              LDRH     r0,[r6,#4]            ;1838  ; uip_len
0009c8  0a01              LSRS     r1,r0,#8              ;1838
0009ca  7429              STRB     r1,[r5,#0x10]         ;1838
0009cc  7468              STRB     r0,[r5,#0x11]         ;1839
0009ce  f8857035          STRB     r7,[r5,#0x35]         ;1842
0009d2  f8857034          STRB     r7,[r5,#0x34]         ;1842
0009d6  866f              STRH     r7,[r5,#0x32]         ;1845
0009d8  f7fffffe          BL       uip_tcpchksum
0009dc  43c0              MVNS     r0,r0                 ;1846
0009de  8668              STRH     r0,[r5,#0x32]         ;1846
0009e0  2045              MOVS     r0,#0x45              ;1855
0009e2  73a8              STRB     r0,[r5,#0xe]          ;1855
0009e4  73ef              STRB     r7,[r5,#0xf]          ;1856
0009e6  756f              STRB     r7,[r5,#0x15]         ;1857
0009e8  752f              STRB     r7,[r5,#0x14]         ;1857
0009ea  8930              LDRH     r0,[r6,#8]            ;1858  ; ipid
0009ec  1c40              ADDS     r0,r0,#1              ;1858
0009ee  8130              STRH     r0,[r6,#8]            ;1858
0009f0  0a01              LSRS     r1,r0,#8              ;1859
0009f2  74a9              STRB     r1,[r5,#0x12]         ;1859
0009f4  74e8              STRB     r0,[r5,#0x13]         ;1860
0009f6  832f              STRH     r7,[r5,#0x18]         ;1862
0009f8  e000              B        |L10.2556|
                  |L10.2554|
0009fa  e007              B        |L10.2572|
                  |L10.2556|
0009fc  f7fffffe          BL       uip_ipchksum
000a00  4907              LDR      r1,|L10.2592|
000a02  43c0              MVNS     r0,r0                 ;1863
000a04  8328              STRH     r0,[r5,#0x18]         ;1863
000a06  8bc8              LDRH     r0,[r1,#0x1e]         ;1867  ; uip_stat
000a08  1c40              ADDS     r0,r0,#1              ;1867
000a0a  83c8              STRH     r0,[r1,#0x1e]         ;1867
                  |L10.2572|
000a0c  4904              LDR      r1,|L10.2592|
000a0e  8888              LDRH     r0,[r1,#4]            ;1872  ; uip_stat
000a10  1c40              ADDS     r0,r0,#1              ;1872
000a12  8088              STRH     r0,[r1,#4]            ;1872
                  |L10.2580|
000a14  7037              STRB     r7,[r6,#0]            ;1878
;;;1880   }
000a16  e8bd9ff0          POP      {r4-r12,pc}
;;;1881   /*---------------------------------------------------------------------------*/
                          ENDP

000a1a  0000              DCW      0x0000
                  |L10.2588|
                          DCD      ||area_number.22||+0xe
                  |L10.2592|
                          DCD      ||.bss||+0x2610

                          AREA ||i.uip_send||, CODE, READONLY, ALIGN=2

                  uip_send PROC
;;;1888   void
;;;1889   uip_send(const void *data, int len)
000000  2900              CMP      r1,#0
;;;1890   {
000002  dd09              BLE      |L11.24|
;;;1891     if(len > 0) {
;;;1892       uip_slen = len;
000004  b28a              UXTH     r2,r1
000006  4905              LDR      r1,|L11.28|
000008  80ca              STRH     r2,[r1,#6]
;;;1893       if(data != uip_sappdata) {
00000a  698b              LDR      r3,[r1,#0x18]  ; uip_sappdata
00000c  4298              CMP      r0,r3
00000e  d003              BEQ      |L11.24|
;;;1894         memcpy(uip_sappdata, (data), uip_slen);
000010  4601              MOV      r1,r0
000012  4618              MOV      r0,r3
000014  f7ffbffe          B.W      __aeabi_memcpy
                  |L11.24|
;;;1895       }
;;;1896     }
;;;1897   }
000018  4770              BX       lr
;;;1898   /** @} */
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      ||area_number.22||

                          AREA ||i.uip_setipid||, CODE, READONLY, ALIGN=2

                  uip_setipid PROC
;;;180    
;;;181    void uip_setipid(u16_t id) { ipid = id; }
000000  4901              LDR      r1,|L12.8|
000002  8108              STRH     r0,[r1,#8]
000004  4770              BX       lr
;;;182    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      ||area_number.22||

                          AREA ||i.uip_tcpchksum||, CODE, READONLY, ALIGN=1

                  uip_tcpchksum PROC
;;;363    u16_t
;;;364    uip_tcpchksum(void)
000000  2006              MOVS     r0,#6
;;;365    {
;;;366      return upper_layer_chksum(UIP_PROTO_TCP);
000002  f7ffbffe          B.W      upper_layer_chksum
;;;367    }
;;;368    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.uip_udpchksum||, CODE, READONLY, ALIGN=1

                  uip_udpchksum PROC
;;;370    u16_t
;;;371    uip_udpchksum(void)
000000  2011              MOVS     r0,#0x11
;;;372    {
;;;373      return upper_layer_chksum(UIP_PROTO_UDP);
000002  f7ffbffe          B.W      upper_layer_chksum
;;;374    }
;;;375    #endif /* UIP_UDP_CHECKSUMS */
                          ENDP


                          AREA ||i.uip_unlisten||, CODE, READONLY, ALIGN=2

                  uip_unlisten PROC
;;;517    void
;;;518    uip_unlisten(u16_t port)
000000  b530              PUSH     {r4,r5,lr}
;;;519    {
;;;520      for(c = 0; c < UIP_LISTENPORTS; ++c) {
000002  4909              LDR      r1,|L15.40|
000004  2400              MOVS     r4,#0
;;;521        if(uip_listenports[c] == port) {
000006  4b09              LDR      r3,|L15.44|
000008  704c              STRB     r4,[r1,#1]            ;520
                  |L15.10|
00000a  784a              LDRB     r2,[r1,#1]  ; c
00000c  f8335012          LDRH     r5,[r3,r2,LSL #1]
000010  4285              CMP      r5,r0
000012  d103              BNE      |L15.28|
;;;522          uip_listenports[c] = 0;
000014  b2d0              UXTB     r0,r2
000016  f8234010          STRH     r4,[r3,r0,LSL #1]
;;;523          return;
;;;524        }
;;;525      }
;;;526    }
00001a  bd30              POP      {r4,r5,pc}
                  |L15.28|
00001c  1c52              ADDS     r2,r2,#1
00001e  b2d2              UXTB     r2,r2                 ;520
000020  704a              STRB     r2,[r1,#1]            ;520
000022  2a28              CMP      r2,#0x28              ;520
000024  d3f1              BCC      |L15.10|
000026  bd30              POP      {r4,r5,pc}
;;;527    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L15.40|
                          DCD      ||area_number.22||
                  |L15.44|
                          DCD      ||.bss||+0x25c0

                          AREA ||i.upper_layer_chksum||, CODE, READONLY, ALIGN=2

                  upper_layer_chksum PROC
;;;328    static u16_t
;;;329    upper_layer_chksum(u8_t proto)
000000  490f              LDR      r1,|L16.64|
;;;330    {
000002  b510              PUSH     {r4,lr}
;;;331      u16_t upper_layer_len;
;;;332      u16_t sum;
;;;333    
;;;334    #if UIP_CONF_IPV6
;;;335      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
;;;336    #else /* UIP_CONF_IPV6 */
;;;337      upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
000004  7c4a              LDRB     r2,[r1,#0x11]  ; uip_buf
000006  7c09              LDRB     r1,[r1,#0x10]  ; uip_buf
000008  f06f0313          MVN      r3,#0x13
00000c  eb032101          ADD      r1,r3,r1,LSL #8
000010  4411              ADD      r1,r1,r2
000012  b28c              UXTH     r4,r1
;;;338    #endif /* UIP_CONF_IPV6 */
;;;339    
;;;340      /* First sum pseudoheader. */
;;;341    
;;;342      /* IP protocol and length fields. This addition cannot carry. */
;;;343      sum = upper_layer_len + proto;
;;;344      /* Sum IP source and destination addresses. */
;;;345      sum = chksum(sum, (u8_t *)&BUF->srcipaddr[0], 2 * sizeof(uip_ipaddr_t));
000014  490a              LDR      r1,|L16.64|
000016  4420              ADD      r0,r0,r4              ;343
000018  b280              UXTH     r0,r0                 ;343
00001a  2208              MOVS     r2,#8
00001c  311a              ADDS     r1,r1,#0x1a
00001e  f7fffffe          BL       chksum
;;;346    
;;;347      /* Sum TCP header and data. */
;;;348      sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
000022  4907              LDR      r1,|L16.64|
000024  4622              MOV      r2,r4
000026  3122              ADDS     r1,r1,#0x22
000028  f7fffffe          BL       chksum
;;;349    	       upper_layer_len);
;;;350    
;;;351      return (sum == 0) ? 0xffff : htons(sum);
00002c  b120              CBZ      r0,|L16.56|
00002e  0201              LSLS     r1,r0,#8
000030  ea412010          ORR      r0,r1,r0,LSR #8
000034  b280              UXTH     r0,r0
;;;352    }
000036  bd10              POP      {r4,pc}
                  |L16.56|
000038  f64f70ff          MOV      r0,#0xffff            ;351
00003c  bd10              POP      {r4,pc}
;;;353    /*---------------------------------------------------------------------------*/
                          ENDP

00003e  0000              DCW      0x0000
                  |L16.64|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  uip_buf
                          %        1504
                  uip_conns
                          %        8160
                  uip_listenports
                          %        80
                  uip_stat
                          %        44

                          AREA ||.constdata||, DATA, READONLY, ALIGN=1

                  all_zeroes_addr
000000  00000000          DCW      0x0000,0x0000

                          AREA ||.data||, DATA, ALIGN=0

                  uip_ethaddr
000000  00000000          DCB      0x00,0x00,0x00,0x00
000004  0000              DCB      0x00,0x00

                          AREA ||area_number.22||, DATA, ALIGN=2

                          EXPORTAS ||area_number.22||, ||.data||
                  uip_flags
000000  00                DCB      0x00
                  c
000001  00                DCB      0x00
                  opt
000002  0000              DCB      0x00,0x00
                  uip_len
000004  0000              DCB      0x00,0x00
                  uip_slen
000006  0000              DCB      0x00,0x00
                  ipid
000008  0000              DCB      0x00,0x00
                  lastport
00000a  0000              DCB      0x00,0x00
                  tmp16
00000c  0000              DCB      0x00,0x00
                  uip_hostaddr
00000e  0000              DCB      0x00,0x00
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  uip_appdata
                          DCD      0x00000000
                  uip_sappdata
                          DCD      0x00000000
                  uip_conn
                          DCD      0x00000000
                  iss
                          DCD      0x00000000
                  uip_acc32
                          DCD      0x00000000

                          AREA ||area_number.23||, DATA, ALIGN=1

                          EXPORTAS ||area_number.23||, ||.data||
                  uip_draddr
                          DCDU     0x00000000

                          AREA ||area_number.24||, DATA, ALIGN=1

                          EXPORTAS ||area_number.24||, ||.data||
                  uip_netmask
                          DCDU     0x00000000
