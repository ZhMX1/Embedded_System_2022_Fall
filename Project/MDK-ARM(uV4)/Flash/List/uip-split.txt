; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\uip-split.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\uip-split.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\uip-split.crf ..\..\User\uIP\uip\uip-split.c]
                          THUMB

                          AREA ||i.uip_split_output||, CODE, READONLY, ALIGN=2

                  uip_split_output PROC
;;;48     void
;;;49     uip_split_output(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;50     {
;;;51       u16_t tcplen, len1, len2;
;;;52     
;;;53       /* We only try to split maximum sized TCP segments. */
;;;54       if(BUF->proto == UIP_PROTO_TCP &&
000004  4c27              LDR      r4,|L1.164|
000006  7de0              LDRB     r0,[r4,#0x17]  ; uip_buf
000008  2806              CMP      r0,#6
00000a  d147              BNE      |L1.156|
;;;55          uip_len == UIP_BUFSIZE - UIP_LLH_LEN) {
00000c  4926              LDR      r1,|L1.168|
00000e  8808              LDRH     r0,[r1,#0]  ; uip_len
000010  f5a062a0          SUB      r2,r0,#0x500
000014  3ace              SUBS     r2,r2,#0xce
000016  d141              BNE      |L1.156|
000018  3828              SUBS     r0,r0,#0x28
;;;56     
;;;57         tcplen = uip_len - UIP_TCPIP_HLEN;
00001a  b280              UXTH     r0,r0
;;;58         /* Split the segment in two. If the original packet length was
;;;59            odd, we make the second packet one byte larger. */
;;;60         len1 = len2 = tcplen / 2;
00001c  0845              LSRS     r5,r0,#1
;;;61         if(len1 + len2 < tcplen) {
00001e  006a              LSLS     r2,r5,#1
000020  462e              MOV      r6,r5                 ;60
000022  4282              CMP      r2,r0
000024  d200              BCS      |L1.40|
;;;62           ++len2;
000026  1c75              ADDS     r5,r6,#1
                  |L1.40|
;;;63         }
;;;64     
;;;65         /* Create the first packet. This is done by altering the length
;;;66            field of the IP header and updating the checksums. */
;;;67         uip_len = len1 + UIP_TCPIP_HLEN;
000028  f1060028          ADD      r0,r6,#0x28
00002c  4688              MOV      r8,r1
00002e  8008              STRH     r0,[r1,#0]
;;;68     #if UIP_CONF_IPV6
;;;69         /* For IPv6, the IP length field does not include the IPv6 IP header
;;;70            length. */
;;;71         BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;72         BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;73     #else /* UIP_CONF_IPV6 */
;;;74         BUF->len[0] = uip_len >> 8;
000030  0a01              LSRS     r1,r0,#8
000032  f8041f10          STRB     r1,[r4,#0x10]!
;;;75         BUF->len[1] = uip_len & 0xff;
;;;76     #endif /* UIP_CONF_IPV6 */
;;;77     
;;;78         /* Recalculate the TCP checksum. */
;;;79         BUF->tcpchksum = 0;
000036  2700              MOVS     r7,#0
000038  7060              STRB     r0,[r4,#1]            ;75
00003a  8467              STRH     r7,[r4,#0x22]
;;;80         BUF->tcpchksum = ~(uip_tcpchksum());
00003c  f7fffffe          BL       uip_tcpchksum
000040  43c0              MVNS     r0,r0
000042  8460              STRH     r0,[r4,#0x22]
;;;81     
;;;82     #if !UIP_CONF_IPV6
;;;83         /* Recalculate the IP checksum. */
;;;84         BUF->ipchksum = 0;
000044  8127              STRH     r7,[r4,#8]
;;;85         BUF->ipchksum = ~(uip_ipchksum());
000046  f7fffffe          BL       uip_ipchksum
00004a  43c0              MVNS     r0,r0
00004c  8120              STRH     r0,[r4,#8]
;;;86     #endif /* UIP_CONF_IPV6 */
;;;87     
;;;88         /* Transmit the first packet. */
;;;89         uip_fw_output(); /* armfly : */
00004e  f7fffffe          BL       uip_fw_output
;;;90         //tcpip_output();
;;;91     
;;;92         /* Now, create the second packet. To do this, it is not enough to
;;;93            just alter the length field, but we must also update the TCP
;;;94            sequence number and point the uip_appdata to a new place in
;;;95            memory. This place is detemined by the length of the first
;;;96            packet (len1). */
;;;97         uip_len = len2 + UIP_TCPIP_HLEN;
000052  f1050028          ADD      r0,r5,#0x28
000056  f8a80000          STRH     r0,[r8,#0]
;;;98     #if UIP_CONF_IPV6
;;;99         /* For IPv6, the IP length field does not include the IPv6 IP header
;;;100           length. */
;;;101        BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
;;;102        BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
;;;103    #else /* UIP_CONF_IPV6 */
;;;104        BUF->len[0] = uip_len >> 8;
00005a  0a01              LSRS     r1,r0,#8
00005c  7021              STRB     r1,[r4,#0]
;;;105        BUF->len[1] = uip_len & 0xff;
00005e  7060              STRB     r0,[r4,#1]
;;;106    #endif /* UIP_CONF_IPV6 */
;;;107    
;;;108        /*    uip_appdata += len1;*/
;;;109        memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
000060  4812              LDR      r0,|L1.172|
000062  462a              MOV      r2,r5
000064  6800              LDR      r0,[r0,#0]  ; uip_appdata
000066  1981              ADDS     r1,r0,r6
000068  f7fffffe          BL       __aeabi_memcpy
;;;110    
;;;111        uip_add32(BUF->seqno, len1);
00006c  480d              LDR      r0,|L1.164|
00006e  4631              MOV      r1,r6
000070  3026              ADDS     r0,r0,#0x26
000072  f7fffffe          BL       uip_add32
;;;112        BUF->seqno[0] = uip_acc32[0];
000076  480e              LDR      r0,|L1.176|
000078  7801              LDRB     r1,[r0,#0]  ; uip_acc32
00007a  75a1              STRB     r1,[r4,#0x16]
;;;113        BUF->seqno[1] = uip_acc32[1];
00007c  7841              LDRB     r1,[r0,#1]  ; uip_acc32
00007e  75e1              STRB     r1,[r4,#0x17]
;;;114        BUF->seqno[2] = uip_acc32[2];
000080  7881              LDRB     r1,[r0,#2]  ; uip_acc32
000082  7621              STRB     r1,[r4,#0x18]
;;;115        BUF->seqno[3] = uip_acc32[3];
000084  78c0              LDRB     r0,[r0,#3]  ; uip_acc32
000086  7660              STRB     r0,[r4,#0x19]
;;;116    
;;;117        /* Recalculate the TCP checksum. */
;;;118        BUF->tcpchksum = 0;
000088  8467              STRH     r7,[r4,#0x22]
;;;119        BUF->tcpchksum = ~(uip_tcpchksum());
00008a  f7fffffe          BL       uip_tcpchksum
00008e  43c0              MVNS     r0,r0
000090  8460              STRH     r0,[r4,#0x22]
;;;120    
;;;121    #if !UIP_CONF_IPV6
;;;122        /* Recalculate the IP checksum. */
;;;123        BUF->ipchksum = 0;
000092  8127              STRH     r7,[r4,#8]
;;;124        BUF->ipchksum = ~(uip_ipchksum());
000094  f7fffffe          BL       uip_ipchksum
000098  43c0              MVNS     r0,r0
00009a  8120              STRH     r0,[r4,#8]
                  |L1.156|
;;;125    #endif /* UIP_CONF_IPV6 */
;;;126    
;;;127        /* Transmit the second packet. */
;;;128        uip_fw_output(); /* armfly */
;;;129        /* tcpip_output(); */
;;;130      } else {
;;;131        uip_fw_output();  /* armfly */
00009c  e8bd41f0          POP      {r4-r8,lr}
0000a0  f7ffbffe          B.W      uip_fw_output
;;;132        /* tcpip_output(); */
;;;133      }
;;;134    
;;;135    }
;;;136    /*-----------------------------------------------------------------------------*/
                          ENDP

                  |L1.164|
                          DCD      uip_buf
                  |L1.168|
                          DCD      uip_len
                  |L1.172|
                          DCD      uip_appdata
                  |L1.176|
                          DCD      uip_acc32
