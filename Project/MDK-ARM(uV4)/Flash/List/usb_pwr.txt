; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_pwr.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_pwr.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\usb_pwr.crf ..\..\User\usb_mass\usb_pwr.c]
                          THUMB

                          AREA ||i.PowerOff||, CODE, READONLY, ALIGN=2

                  PowerOff PROC
;;;86     *******************************************************************************/
;;;87     RESULT PowerOff()
000000  b510              PUSH     {r4,lr}
;;;88     {
;;;89     #ifndef STM32F10X_CL  
;;;90       /* disable all interrupts and force USB reset */
;;;91       _SetCNTR(CNTR_FRES);
000002  4c06              LDR      r4,|L1.28|
000004  2001              MOVS     r0,#1
000006  6020              STR      r0,[r4,#0]
;;;92       /* clear interrupt status register */
;;;93       _SetISTR(0);
000008  1d21              ADDS     r1,r4,#4
00000a  2000              MOVS     r0,#0
00000c  6008              STR      r0,[r1,#0]
;;;94       /* Disable the Pull-Up*/
;;;95       USB_Cable_Config(DISABLE);
00000e  f7fffffe          BL       USB_Cable_Config
;;;96       /* switch-off device */
;;;97       _SetCNTR(CNTR_FRES + CNTR_PDWN);
000012  2003              MOVS     r0,#3
000014  6020              STR      r0,[r4,#0]
;;;98       /* sw variables reset */
;;;99       /* ... */
;;;100    #endif /* STM32F10X_CL */
;;;101    
;;;102      return USB_SUCCESS;
000016  2000              MOVS     r0,#0
;;;103    }
000018  bd10              POP      {r4,pc}
;;;104    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40005c40

                          AREA ||i.PowerOn||, CODE, READONLY, ALIGN=2

                  PowerOn PROC
;;;53     *******************************************************************************/
;;;54     RESULT PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;55     {
;;;56     #ifndef STM32F10X_CL
;;;57       uint16_t wRegVal;
;;;58       
;;;59       /*** cable plugged-in ? ***/
;;;60       /*while(!CablePluggedIn());*/
;;;61       USB_Cable_Config(ENABLE);
000002  2001              MOVS     r0,#1
000004  f7fffffe          BL       USB_Cable_Config
;;;62     
;;;63       /*** CNTR_PWDN = 0 ***/
;;;64       wRegVal = CNTR_FRES;
;;;65       _SetCNTR(wRegVal);
000008  4806              LDR      r0,|L2.36|
00000a  2101              MOVS     r1,#1                 ;64
00000c  6001              STR      r1,[r0,#0]
;;;66     
;;;67       /*** CNTR_FRES = 0 ***/
;;;68       wInterrupt_Mask = 0;
00000e  2100              MOVS     r1,#0
000010  4a05              LDR      r2,|L2.40|
;;;69       _SetCNTR(wInterrupt_Mask);
000012  6001              STR      r1,[r0,#0]
;;;70       /*** Clear pending interrupts ***/
;;;71       _SetISTR(0);
000014  1d03              ADDS     r3,r0,#4
000016  6019              STR      r1,[r3,#0]
;;;72       /*** Set interrupt mask ***/
;;;73       wInterrupt_Mask = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;
000018  f44f51e0          MOV      r1,#0x1c00
00001c  8011              STRH     r1,[r2,#0]
;;;74       _SetCNTR(wInterrupt_Mask);
00001e  6001              STR      r1,[r0,#0]
;;;75     #endif /* STM32F10X_CL */
;;;76       
;;;77       return USB_SUCCESS;
000020  2000              MOVS     r0,#0
;;;78     }
000022  bd10              POP      {r4,pc}
;;;79     
                          ENDP

                  |L2.36|
                          DCD      0x40005c40
                  |L2.40|
                          DCD      wInterrupt_Mask

                          AREA ||i.Resume||, CODE, READONLY, ALIGN=2

                  Resume PROC
;;;188    *******************************************************************************/
;;;189    void Resume(RESUME_STATE eResumeSetVal)
000000  b570              PUSH     {r4-r6,lr}
;;;190    {
;;;191    #ifndef STM32F10X_CL
;;;192      uint16_t wCNTR;
;;;193    #endif /* STM32F10X_CL */
;;;194    
;;;195      if (eResumeSetVal != RESUME_ESOF)
;;;196        ResumeS.eState = eResumeSetVal;
000002  4c1c              LDR      r4,|L3.116|
000004  2807              CMP      r0,#7                 ;195
000006  d000              BEQ      |L3.10|
000008  7020              STRB     r0,[r4,#0]
                  |L3.10|
;;;197    
;;;198      switch (ResumeS.eState)
00000a  7821              LDRB     r1,[r4,#0]  ; ResumeS
;;;199      {
;;;200        case RESUME_EXTERNAL:
;;;201          Resume_Init();
;;;202          ResumeS.eState = RESUME_OFF;
00000c  2606              MOVS     r6,#6
;;;203          break;
;;;204        case RESUME_INTERNAL:
;;;205          Resume_Init();
;;;206          ResumeS.eState = RESUME_START;
00000e  2504              MOVS     r5,#4
;;;207          break;
;;;208        case RESUME_LATER:
;;;209          ResumeS.bESOFcnt = 2;
;;;210          ResumeS.eState = RESUME_WAIT;
;;;211          break;
;;;212        case RESUME_WAIT:
;;;213          ResumeS.bESOFcnt--;
;;;214          if (ResumeS.bESOFcnt == 0)
;;;215            ResumeS.eState = RESUME_START;
;;;216          break;
;;;217        case RESUME_START:
;;;218         #ifdef STM32F10X_CL
;;;219          OTGD_FS_SetRemoteWakeup();
;;;220         #else 
;;;221          wCNTR = _GetCNTR();
000010  4819              LDR      r0,|L3.120|
000012  2906              CMP      r1,#6                 ;198
000014  d22c              BCS      |L3.112|
000016  e8dff001          TBB      [pc,r1]               ;198
00001a  0306              DCB      0x03,0x06
00001c  090e1620          DCB      0x09,0x0e,0x16,0x20
000020  f7fffffe          BL       Resume_Init
000024  e024              B        |L3.112|
000026  f7fffffe          BL       Resume_Init
00002a  e00a              B        |L3.66|
00002c  2002              MOVS     r0,#2                 ;209
00002e  7060              STRB     r0,[r4,#1]            ;209
000030  2003              MOVS     r0,#3                 ;210
000032  7020              STRB     r0,[r4,#0]            ;210
                  |L3.52|
;;;222          wCNTR |= CNTR_RESUME;
;;;223          _SetCNTR(wCNTR);
;;;224         #endif /* STM32F10X_CL */
;;;225          ResumeS.eState = RESUME_ON;
;;;226          ResumeS.bESOFcnt = 10;
;;;227          break;
;;;228        case RESUME_ON:
;;;229        #ifndef STM32F10X_CL      
;;;230          ResumeS.bESOFcnt--;
;;;231          if (ResumeS.bESOFcnt == 0)
;;;232          {
;;;233         #endif /* STM32F10X_CL */    
;;;234           #ifdef STM32F10X_CL
;;;235            OTGD_FS_ResetRemoteWakeup();
;;;236           #else
;;;237            wCNTR = _GetCNTR();
;;;238            wCNTR &= (~CNTR_RESUME);
;;;239            _SetCNTR(wCNTR);
;;;240           #endif /* STM32F10X_CL */
;;;241            ResumeS.eState = RESUME_OFF;
;;;242         #ifndef STM32F10X_CL
;;;243          }
;;;244         #endif /* STM32F10X_CL */
;;;245          break;
;;;246        case RESUME_OFF:
;;;247        case RESUME_ESOF:
;;;248        default:
;;;249          ResumeS.eState = RESUME_OFF;
;;;250          break;
;;;251      }
;;;252    }
000034  bd70              POP      {r4-r6,pc}
000036  7860              LDRB     r0,[r4,#1]            ;213  ; ResumeS
000038  1e40              SUBS     r0,r0,#1              ;213
00003a  7060              STRB     r0,[r4,#1]            ;213
00003c  7860              LDRB     r0,[r4,#1]            ;214  ; ResumeS
00003e  2800              CMP      r0,#0                 ;214
000040  d1f8              BNE      |L3.52|
                  |L3.66|
000042  7025              STRB     r5,[r4,#0]            ;215
000044  bd70              POP      {r4-r6,pc}
000046  6801              LDR      r1,[r0,#0]            ;221
000048  b289              UXTH     r1,r1                 ;221
00004a  f0410110          ORR      r1,r1,#0x10           ;222
00004e  6001              STR      r1,[r0,#0]            ;223
000050  2005              MOVS     r0,#5                 ;225
000052  7020              STRB     r0,[r4,#0]            ;225
000054  200a              MOVS     r0,#0xa               ;226
000056  7060              STRB     r0,[r4,#1]            ;226
                  |L3.88|
000058  bd70              POP      {r4-r6,pc}
00005a  7861              LDRB     r1,[r4,#1]            ;230  ; ResumeS
00005c  1e49              SUBS     r1,r1,#1              ;230
00005e  7061              STRB     r1,[r4,#1]            ;230
000060  7861              LDRB     r1,[r4,#1]            ;231  ; ResumeS
000062  2900              CMP      r1,#0                 ;231
000064  d1f8              BNE      |L3.88|
000066  6801              LDR      r1,[r0,#0]            ;237
000068  b289              UXTH     r1,r1                 ;237
00006a  f0210110          BIC      r1,r1,#0x10           ;238
00006e  6001              STR      r1,[r0,#0]            ;239
                  |L3.112|
000070  7026              STRB     r6,[r4,#0]            ;249
000072  bd70              POP      {r4-r6,pc}
;;;253    
                          ENDP

                  |L3.116|
                          DCD      ||area_number.10||
                  |L3.120|
                          DCD      0x40005c40

                          AREA ||i.Resume_Init||, CODE, READONLY, ALIGN=2

                  Resume_Init PROC
;;;149    *******************************************************************************/
;;;150    void Resume_Init(void)
000000  b510              PUSH     {r4,lr}
;;;151    {
;;;152      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;153      /* restart the clocks */
;;;154      /* ...  */
;;;155    #ifndef STM32F10X_CL
;;;156      uint16_t wCNTR;
;;;157      
;;;158      /* CNTR_LPMODE = 0 */
;;;159      wCNTR = _GetCNTR();
000002  4c06              LDR      r4,|L4.28|
000004  6820              LDR      r0,[r4,#0]
000006  b280              UXTH     r0,r0
;;;160      wCNTR &= (~CNTR_LPMODE);
000008  f0200004          BIC      r0,r0,#4
;;;161      _SetCNTR(wCNTR);
00000c  6020              STR      r0,[r4,#0]
;;;162    #endif /* STM32F10X_CL */
;;;163      
;;;164      /* restore full power */
;;;165      /* ... on connected devices */
;;;166      Leave_LowPowerMode();
00000e  f7fffffe          BL       Leave_LowPowerMode
;;;167    
;;;168    #ifndef STM32F10X_CL
;;;169      /* reset FSUSP bit */
;;;170      _SetCNTR(IMR_MSK);
000012  f44f4004          MOV      r0,#0x8400
000016  6020              STR      r0,[r4,#0]
;;;171    #endif /* STM32F10X_CL */
;;;172      
;;;173      /* reverse suspend preparation */
;;;174      /* ... */
;;;175    }
000018  bd10              POP      {r4,pc}
;;;176    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      0x40005c40

                          AREA ||i.Suspend||, CODE, READONLY, ALIGN=2

                  Suspend PROC
;;;111    *******************************************************************************/
;;;112    void Suspend(void)
000000  4806              LDR      r0,|L5.28|
;;;113    {
;;;114    
;;;115      /* suspend preparation */
;;;116      /* ... */
;;;117      
;;;118    #ifndef STM32F10X_CL
;;;119      uint16_t wCNTR;
;;;120    
;;;121      /* macrocell enters suspend mode */
;;;122      wCNTR = _GetCNTR();
000002  6801              LDR      r1,[r0,#0]
000004  b289              UXTH     r1,r1
;;;123      wCNTR |= CNTR_FSUSP;
000006  f0410108          ORR      r1,r1,#8
;;;124      _SetCNTR(wCNTR);
00000a  6001              STR      r1,[r0,#0]
;;;125    #endif /* STM32F10X_CL */
;;;126      
;;;127      /* ------------------ ONLY WITH BUS-POWERED DEVICES ---------------------- */
;;;128      /* power reduction */
;;;129      /* ... on connected devices */
;;;130    
;;;131    #ifndef STM32F10X_CL
;;;132      /* force low-power mode in the macrocell */
;;;133      wCNTR = _GetCNTR();
00000c  6801              LDR      r1,[r0,#0]
00000e  b289              UXTH     r1,r1
;;;134      wCNTR |= CNTR_LPMODE;
000010  f0410104          ORR      r1,r1,#4
;;;135      _SetCNTR(wCNTR);
000014  6001              STR      r1,[r0,#0]
;;;136    #endif /* STM32F10X_CL */
;;;137    
;;;138      /* switch-off the clocks */
;;;139      /* ... */
;;;140      Enter_LowPowerMode();
000016  f7ffbffe          B.W      Enter_LowPowerMode
;;;141    }
;;;142    
                          ENDP

00001a  0000              DCW      0x0000
                  |L5.28|
                          DCD      0x40005c40

                          AREA ||.data||, DATA, ALIGN=2

                  bDeviceState
                          DCD      0x00000000

                          AREA ||area_number.9||, DATA, ALIGN=0

                          EXPORTAS ||area_number.9||, ||.data||
                  fSuspendEnabled
000000  01                DCB      0x01

                          AREA ||area_number.10||, DATA, ALIGN=0

                          EXPORTAS ||area_number.10||, ||.data||
                  ResumeS
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\usb_mass\\usb_pwr.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_usb_pwr_c_e4e9521d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_usb_pwr_c_e4e9521d____REVSH|
#line 128
|__asm___9_usb_pwr_c_e4e9521d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
