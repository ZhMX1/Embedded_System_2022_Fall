; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_gt811.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_gt811.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_gt811.crf ..\..\User\bsp\src\bsp_gt811.c]
                          THUMB

                          AREA ||i.GT811_InitHard||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  GT811_InitHard PROC
;;;227    */
;;;228    void GT811_InitHard(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;229    {
;;;230    	uint16_t ver;
;;;231    
;;;232    	g_GT811.TimerCount = 0;
000004  4f15              LDR      r7,|L1.92|
000006  2000              MOVS     r0,#0
000008  7078              STRB     r0,[r7,#1]
;;;233    	
;;;234    	ver = GT811_ReadVersion();
00000a  f7fffffe          BL       GT811_ReadVersion
00000e  4601              MOV      r1,r0
;;;235    
;;;236    	printf("GT811 Version : %04X\r\n", ver);
000010  a013              ADR      r0,|L1.96|
000012  f7fffffe          BL       __2printf
;;;237    
;;;238    	/* I2C总线初始化在 bsp.c 中执行 */
;;;239    	
;;;240    	GT811_WriteReg(GT811_CONFIG_REG, (uint8_t *)s_GT811_CfgParams, sizeof(s_GT811_CfgParams));
000016  4e18              LDR      r6,|L1.120|
000018  256a              MOVS     r5,#0x6a
00001a  f7fffffe          BL       i2c_Start
00001e  20ba              MOVS     r0,#0xba
000020  f7fffffe          BL       i2c_SendByte
000024  f7fffffe          BL       i2c_WaitAck
000028  2006              MOVS     r0,#6
00002a  f7fffffe          BL       i2c_SendByte
00002e  f7fffffe          BL       i2c_WaitAck
000032  20a2              MOVS     r0,#0xa2
000034  f7fffffe          BL       i2c_SendByte
000038  f7fffffe          BL       i2c_WaitAck
00003c  2400              MOVS     r4,#0
                  |L1.62|
00003e  5d30              LDRB     r0,[r6,r4]
000040  f7fffffe          BL       i2c_SendByte
000044  f7fffffe          BL       i2c_WaitAck
000048  1c64              ADDS     r4,r4,#1
00004a  b2e4              UXTB     r4,r4
00004c  42ac              CMP      r4,r5
00004e  d3f6              BCC      |L1.62|
000050  f7fffffe          BL       i2c_Stop
;;;241    	
;;;242    	g_GT811.Enable = 1;
000054  2001              MOVS     r0,#1
000056  7038              STRB     r0,[r7,#0]
;;;243    }
000058  e8bd81f0          POP      {r4-r8,pc}
;;;244    
                          ENDP

                  |L1.92|
                          DCD      ||.bss||
                  |L1.96|
000060  47543831          DCB      "GT811 Version : %04X\r\n",0
000064  31205665
000068  7273696f
00006c  6e203a20
000070  25303458
000074  0d0a00  
000077  00                DCB      0
                  |L1.120|
                          DCD      ||.data||+0x6

                          AREA ||i.GT811_ReadReg||, CODE, READONLY, ALIGN=2

                  GT811_ReadReg PROC
;;;306    */
;;;307    static void GT811_ReadReg(uint16_t _usRegAddr, uint8_t *_pRegBuf, uint8_t _ucLen)
000000  b570              PUSH     {r4-r6,lr}
;;;308    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
000006  4604              MOV      r4,r0
;;;309    	uint8_t i;
;;;310    
;;;311        i2c_Start();					/* 总线开始信号 */
000008  f7fffffe          BL       i2c_Start
;;;312    
;;;313        i2c_SendByte(GT811_I2C_ADDR);	/* 发送设备地址+写信号 */
00000c  20ba              MOVS     r0,#0xba
00000e  f7fffffe          BL       i2c_SendByte
;;;314    	i2c_WaitAck();
000012  f7fffffe          BL       i2c_WaitAck
;;;315    
;;;316        i2c_SendByte(_usRegAddr >> 8);	/* 地址高8位 */
000016  0a20              LSRS     r0,r4,#8
000018  f7fffffe          BL       i2c_SendByte
;;;317    	i2c_WaitAck();
00001c  f7fffffe          BL       i2c_WaitAck
;;;318    
;;;319        i2c_SendByte(_usRegAddr);		/* 地址低8位 */
000020  b2e0              UXTB     r0,r4
000022  f7fffffe          BL       i2c_SendByte
;;;320    	i2c_WaitAck();
000026  f7fffffe          BL       i2c_WaitAck
;;;321    
;;;322    	i2c_Start();
00002a  f7fffffe          BL       i2c_Start
;;;323        i2c_SendByte(GT811_I2C_ADDR + 0x01);	/* 发送设备地址+读信号 */
00002e  20bb              MOVS     r0,#0xbb
000030  f7fffffe          BL       i2c_SendByte
;;;324    	i2c_WaitAck();
000034  f7fffffe          BL       i2c_WaitAck
;;;325    
;;;326    	for (i = 0; i < _ucLen - 1; i++)
000038  2400              MOVS     r4,#0
00003a  1e6d              SUBS     r5,r5,#1
00003c  e007              B        |L2.78|
;;;327    	{
;;;328    	    _pRegBuf[i] = i2c_ReadByte();	/* 读寄存器数据 */
00003e  bf00              NOP      
                  |L2.64|
000040  f7fffffe          BL       i2c_ReadByte
000044  5530              STRB     r0,[r6,r4]
;;;329    		i2c_Ack();
000046  f7fffffe          BL       i2c_Ack
00004a  1c64              ADDS     r4,r4,#1
00004c  b2e4              UXTB     r4,r4                 ;326
                  |L2.78|
00004e  42ac              CMP      r4,r5                 ;326
000050  dbf6              BLT      |L2.64|
;;;330    	}
;;;331    
;;;332    	/* 最后一个数据 */
;;;333    	 _pRegBuf[i] = i2c_ReadByte();		/* 读寄存器数据 */
000052  f7fffffe          BL       i2c_ReadByte
000056  5530              STRB     r0,[r6,r4]
;;;334    	i2c_NAck();
000058  f7fffffe          BL       i2c_NAck
;;;335    
;;;336        i2c_Stop();							/* 总线停止信号 */
00005c  e8bd4070          POP      {r4-r6,lr}
000060  f7ffbffe          B.W      i2c_Stop
;;;337    }
;;;338    
                          ENDP


                          AREA ||i.GT811_ReadVersion||, CODE, READONLY, ALIGN=1

                  GT811_ReadVersion PROC
;;;252    */
;;;253    uint16_t GT811_ReadVersion(void)
000000  b508              PUSH     {r3,lr}
;;;254    {
;;;255    	uint8_t buf[2];
;;;256    
;;;257    	GT811_ReadReg(0x717, buf, 2);
000002  2202              MOVS     r2,#2
000004  4669              MOV      r1,sp
000006  f2407017          MOV      r0,#0x717
00000a  f7fffffe          BL       GT811_ReadReg
;;;258    
;;;259    	return ((uint16_t)buf[0] << 8) + buf[1];
00000e  f89d0001          LDRB     r0,[sp,#1]
000012  f89d1000          LDRB     r1,[sp,#0]
000016  eb002001          ADD      r0,r0,r1,LSL #8
00001a  b280              UXTH     r0,r0
;;;260    }
00001c  bd08              POP      {r3,pc}
;;;261    
                          ENDP


                          AREA ||i.GT811_Scan||, CODE, READONLY, ALIGN=2

                  GT811_Scan PROC
;;;359    */
;;;360    void GT811_Scan(void)
000000  b570              PUSH     {r4-r6,lr}
;;;361    {
;;;362    	uint8_t buf[48];
;;;363    	//uint8_t i;
;;;364    	static uint8_t s_tp_down = 0;
;;;365    	uint16_t x, y;
;;;366    	static uint16_t x_save, y_save;
;;;367    
;;;368    	if (g_GT811.Enable == 0)
000002  4c4d              LDR      r4,|L4.312|
000004  b08c              SUB      sp,sp,#0x30           ;361
000006  7820              LDRB     r0,[r4,#0]  ; g_GT811
000008  2800              CMP      r0,#0                 ;361
00000a  d07d              BEQ      |L4.264|
;;;369    	{
;;;370    		return;
;;;371    	}
;;;372    	
;;;373    	/* 20ms 执行一次 */
;;;374    	if (g_GT811.TimerCount < 20)
00000c  7860              LDRB     r0,[r4,#1]  ; g_GT811
00000e  2814              CMP      r0,#0x14
000010  d37a              BCC      |L4.264|
;;;375    	{
;;;376    		return;
;;;377    	}
;;;378    
;;;379    	g_GT811.TimerCount = 0;
000012  2600              MOVS     r6,#0
000014  7066              STRB     r6,[r4,#1]
;;;380    	
;;;381    	GT811_ReadReg(GT811_READ_XY_REG, buf, 1);		
000016  2201              MOVS     r2,#1
000018  4669              MOV      r1,sp
00001a  f2407021          MOV      r0,#0x721
00001e  f7fffffe          BL       GT811_ReadReg
;;;382    	if ((buf[0] & 0x01) == 0)
000022  f89d0000          LDRB     r0,[sp,#0]
;;;383    	{
;;;384    		if (s_tp_down == 1)
000026  4d45              LDR      r5,|L4.316|
000028  07c0              LSLS     r0,r0,#31             ;382
00002a  d075              BEQ      |L4.280|
;;;385    		{
;;;386    			s_tp_down = 0;
;;;387    			TOUCH_PutKey(TOUCH_RELEASE, x_save, y_save);
;;;388    		}
;;;389    		return;
;;;390    	}
;;;391    					
;;;392    	GT811_ReadReg(GT811_READ_XY_REG + 1, &buf[1], 33);
00002c  2221              MOVS     r2,#0x21
00002e  f2407022          MOV      r0,#0x722
000032  f10d0101          ADD      r1,sp,#1
000036  f7fffffe          BL       GT811_ReadReg
;;;393    	
;;;394    	/*
;;;395    	0x721  R  TouchpointFlag  Sensor_ID  key  tp4  tp3  tp2  tp1  tp0
;;;396    	0x722  R  Touchkeystate     0  0  0  0  key4  key3  key2  key1
;;;397    
;;;398    	0x723  R  Point0Xh  触摸点 0，X 坐标高 8 位
;;;399    	0x724  R  Point0Xl  触摸点 0，X 坐标低 8 位
;;;400    	0x725  R  Point0Yh  触摸点 0，Y 坐标高 8 位
;;;401    	0x726  R  Point0Yl  触摸点 0，Y 坐标低 8 位
;;;402    	0x727  R  Point0Pressure  触摸点 0，触摸压力
;;;403    
;;;404    	0x728  R  Point1Xh  触摸点 1，X 坐标高 8 位
;;;405    	0x729  R  Point1Xl  触摸点 1，X 坐标低 8 位
;;;406    	0x72A  R  Point1Yh  触摸点 1，Y 坐标高 8 位
;;;407    	0x72B  R  Point1Yl  触摸点 1，Y 坐标低 8 位
;;;408    	0x72C  R  Point1Pressure  触摸点 1，触摸压力
;;;409    
;;;410    	0x72D  R  Point2Xh  触摸点 2，X 坐标高 8 位
;;;411    	0x72E  R  Point2Xl  触摸点 2，X 坐标低 8 位
;;;412    	0x72F  R  Point2Yh  触摸点 2，Y 坐标高 8 位
;;;413    	0x730  R  Point2Yl  触摸点 2，Y 坐标低 8 位
;;;414    	0x731  R  Point2Pressure  触摸点 2，触摸压力
;;;415    
;;;416    	0x732  R  Point3Xh  触摸点 3，X 坐标高 8 位
;;;417    	0x733-0x738  R    Reserve  none
;;;418    	0x739  R  Point3Xl  触摸点 3，X 坐标低 8 位
;;;419    	0x73A  R  Point3Yh  触摸点 3，Y 坐标高 8 位
;;;420    	0x73B  R  Point3Yl  触摸点 3，Y 坐标低 8 位
;;;421    	0x73C  R  Point3Pressure  触摸点 3，触摸压力
;;;422    
;;;423    	0x73D  R  Point4Xh  触摸点 4，X 坐标高 8 位
;;;424    	0x73E  R  Point4Xl  触摸点 4，X 坐标低 8 位
;;;425    	0x73F  R  Point4Yh  触摸点 4，Y 坐标高 8 位
;;;426    	0x740  R  Point4Yl  触摸点 4，Y 坐标低 8 位
;;;427    	0x741  R  Point4Pressure  触摸点 4，触摸压力
;;;428    
;;;429    	0x742  R  Data_check_sum  Data check Sum
;;;430    	*/
;;;431    
;;;432    	g_GT811.TouchpointFlag = buf[0];
00003a  f89d0000          LDRB     r0,[sp,#0]
00003e  70a0              STRB     r0,[r4,#2]
;;;433    	g_GT811.Touchkeystate = buf[1];
000040  f89d0001          LDRB     r0,[sp,#1]
000044  70e0              STRB     r0,[r4,#3]
;;;434    
;;;435    	g_GT811.X0 = ((uint16_t)buf[2] << 8) + buf[3];
000046  f89d0003          LDRB     r0,[sp,#3]
00004a  f89d1002          LDRB     r1,[sp,#2]
00004e  eb002001          ADD      r0,r0,r1,LSL #8
000052  80a0              STRH     r0,[r4,#4]
;;;436    	g_GT811.Y0 = ((uint16_t)buf[4] << 8) + buf[5];
000054  f89d1005          LDRB     r1,[sp,#5]
000058  f89d2004          LDRB     r2,[sp,#4]
;;;437    	g_GT811.P0 = buf[6];
;;;438    
;;;439    	g_GT811.X1 = ((uint16_t)buf[7] << 8) + buf[8];
;;;440    	g_GT811.Y1 = ((uint16_t)buf[9] << 8) + buf[10];
;;;441    	g_GT811.P1 = buf[11];
;;;442    
;;;443    	g_GT811.X2 = ((uint16_t)buf[12] << 8) + buf[13];
;;;444    	g_GT811.Y2 = ((uint16_t)buf[14] << 8) + buf[15];
;;;445    	g_GT811.P2 = buf[16];
;;;446    
;;;447    	/* 触摸点3的地址不连续 */
;;;448    	g_GT811.X3 = ((uint16_t)buf[17] << 8) + buf[24];
;;;449    	g_GT811.Y3 = ((uint16_t)buf[25] << 8) + buf[26];
;;;450    	g_GT811.P3 = buf[27];
;;;451    
;;;452    	g_GT811.X4 = ((uint16_t)buf[28] << 8) + buf[29];
;;;453    	g_GT811.Y4 = ((uint16_t)buf[30] << 8) + buf[31];
;;;454    	g_GT811.P4 = buf[32];
00005c  f2a010df          SUB      r0,r0,#0x1df
000060  eb012102          ADD      r1,r1,r2,LSL #8       ;436
000064  b28e              UXTH     r6,r1                 ;436
000066  80e6              STRH     r6,[r4,#6]            ;436
000068  f89d1006          LDRB     r1,[sp,#6]            ;437
00006c  7221              STRB     r1,[r4,#8]            ;437
00006e  f89d1008          LDRB     r1,[sp,#8]            ;439
000072  f89d2007          LDRB     r2,[sp,#7]            ;439
;;;455    
;;;456    	/* 检测按下 */
;;;457    	{
;;;458    		/* 坐标转换 :
;;;459    			电容触摸板左下角是 (0，0);  右上角是 (479，799)
;;;460    			需要转到LCD的像素坐标 (左上角是 (0，0), 右下角是 (799，479)
;;;461    		*/
;;;462    		x = g_GT811.Y0;
;;;463    		y = 479 - g_GT811.X0;
000076  4240              RSBS     r0,r0,#0
000078  eb012102          ADD      r1,r1,r2,LSL #8       ;439
00007c  8161              STRH     r1,[r4,#0xa]          ;439
00007e  f89d100a          LDRB     r1,[sp,#0xa]          ;440
000082  f89d2009          LDRB     r2,[sp,#9]            ;440
000086  eb012102          ADD      r1,r1,r2,LSL #8       ;440
00008a  81a1              STRH     r1,[r4,#0xc]          ;440
00008c  f89d100b          LDRB     r1,[sp,#0xb]          ;441
000090  73a1              STRB     r1,[r4,#0xe]          ;441
000092  f89d100d          LDRB     r1,[sp,#0xd]          ;443
000096  f89d200c          LDRB     r2,[sp,#0xc]          ;443
00009a  eb012102          ADD      r1,r1,r2,LSL #8       ;443
00009e  8221              STRH     r1,[r4,#0x10]         ;443
0000a0  f89d100f          LDRB     r1,[sp,#0xf]          ;444
0000a4  f89d200e          LDRB     r2,[sp,#0xe]          ;444
0000a8  eb012102          ADD      r1,r1,r2,LSL #8       ;444
0000ac  8261              STRH     r1,[r4,#0x12]         ;444
0000ae  f89d1010          LDRB     r1,[sp,#0x10]         ;445
0000b2  7521              STRB     r1,[r4,#0x14]         ;445
0000b4  f89d1018          LDRB     r1,[sp,#0x18]         ;448
0000b8  f89d2011          LDRB     r2,[sp,#0x11]         ;448
0000bc  eb012102          ADD      r1,r1,r2,LSL #8       ;448
0000c0  82e1              STRH     r1,[r4,#0x16]         ;448
0000c2  f89d101a          LDRB     r1,[sp,#0x1a]         ;449
0000c6  f89d2019          LDRB     r2,[sp,#0x19]         ;449
0000ca  eb012102          ADD      r1,r1,r2,LSL #8       ;449
0000ce  8321              STRH     r1,[r4,#0x18]         ;449
0000d0  f89d101b          LDRB     r1,[sp,#0x1b]         ;450
0000d4  76a1              STRB     r1,[r4,#0x1a]         ;450
0000d6  f89d101d          LDRB     r1,[sp,#0x1d]         ;452
0000da  f89d201c          LDRB     r2,[sp,#0x1c]         ;452
0000de  eb012102          ADD      r1,r1,r2,LSL #8       ;452
0000e2  83a1              STRH     r1,[r4,#0x1c]         ;452
0000e4  f89d101f          LDRB     r1,[sp,#0x1f]         ;453
0000e8  f89d201e          LDRB     r2,[sp,#0x1e]         ;453
0000ec  eb012102          ADD      r1,r1,r2,LSL #8       ;453
0000f0  83e1              STRH     r1,[r4,#0x1e]         ;453
0000f2  f89d1020          LDRB     r1,[sp,#0x20]         ;454
0000f6  f8841020          STRB     r1,[r4,#0x20]         ;454
0000fa  b284              UXTH     r4,r0
;;;464    	}
;;;465    	
;;;466    	if (s_tp_down == 0)
0000fc  7828              LDRB     r0,[r5,#0]  ; s_tp_down
0000fe  b1a8              CBZ      r0,|L4.300|
;;;467    	{
;;;468    		s_tp_down = 1;
;;;469    		
;;;470    		TOUCH_PutKey(TOUCH_DOWN, x, y);
;;;471    	}
;;;472    	else
;;;473    	{
;;;474    		TOUCH_PutKey(TOUCH_MOVE, x, y);
000100  4622              MOV      r2,r4
000102  4631              MOV      r1,r6
000104  2002              MOVS     r0,#2
                  |L4.262|
000106  e001              B        |L4.268|
                  |L4.264|
000108  e004              B        |L4.276|
00010a  e005              B        |L4.280|
                  |L4.268|
00010c  f7fffffe          BL       TOUCH_PutKey
;;;475    	}
;;;476    	x_save = x;	/* 保存坐标，用于释放事件 */
000110  806e              STRH     r6,[r5,#2]
;;;477    	y_save = y;
000112  80ac              STRH     r4,[r5,#4]
                  |L4.276|
;;;478    
;;;479    #if 0
;;;480    	for (i = 0; i < 34; i++)
;;;481    	{
;;;482    		printf("%02X ", buf[i]);
;;;483    	}
;;;484    	printf("\r\n");
;;;485    
;;;486    	printf("(%5d,%5d,%3d) ",  g_GT811.X0, g_GT811.Y0, g_GT811.P0);
;;;487    	printf("(%5d,%5d,%3d) ",  g_GT811.X1, g_GT811.Y1, g_GT811.P1);
;;;488    	printf("(%5d,%5d,%3d) ",  g_GT811.X2, g_GT811.Y2, g_GT811.P2);
;;;489    	printf("(%5d,%5d,%3d) ",  g_GT811.X3, g_GT811.Y3, g_GT811.P3);
;;;490    	printf("(%5d,%5d,%3d) ",  x, y, g_GT811.P4);
;;;491    	printf("\r\n");
;;;492    #endif	
;;;493    }
000114  b00c              ADD      sp,sp,#0x30
000116  bd70              POP      {r4-r6,pc}
                  |L4.280|
000118  7828              LDRB     r0,[r5,#0]            ;384  ; s_tp_down
00011a  2801              CMP      r0,#1                 ;384
00011c  d1fa              BNE      |L4.276|
00011e  702e              STRB     r6,[r5,#0]            ;386
000120  88aa              LDRH     r2,[r5,#4]            ;387  ; y_save
000122  8869              LDRH     r1,[r5,#2]            ;387  ; x_save
000124  2003              MOVS     r0,#3                 ;387
000126  f7fffffe          BL       TOUCH_PutKey
00012a  e7f3              B        |L4.276|
                  |L4.300|
00012c  2001              MOVS     r0,#1                 ;468
00012e  7028              STRB     r0,[r5,#0]            ;468
000130  4622              MOV      r2,r4                 ;470
000132  4631              MOV      r1,r6                 ;470
000134  e7e7              B        |L4.262|
;;;494    
                          ENDP

000136  0000              DCW      0x0000
                  |L4.312|
                          DCD      ||.bss||
                  |L4.316|
                          DCD      ||.data||

                          AREA ||i.GT811_Timer1ms||, CODE, READONLY, ALIGN=2

                  GT811_Timer1ms PROC
;;;346    */
;;;347    void GT811_Timer1ms(void)
000000  4802              LDR      r0,|L5.12|
;;;348    {
;;;349    	g_GT811.TimerCount++;
000002  7841              LDRB     r1,[r0,#1]  ; g_GT811
000004  1c49              ADDS     r1,r1,#1
000006  7041              STRB     r1,[r0,#1]
;;;350    }
000008  4770              BX       lr
;;;351    
                          ENDP

00000a  0000              DCW      0x0000
                  |L5.12|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  g_GT811
                          %        34

                          AREA ||.data||, DATA, ALIGN=1

                  s_tp_down
000000  0000              DCB      0x00,0x00
                  x_save
000002  0000              DCB      0x00,0x00
                  y_save
000004  0000              DCB      0x00,0x00
                  s_GT811_CfgParams
000006  1210              DCB      0x12,0x10
000008  0e0c0a08          DCB      0x0e,0x0c,0x0a,0x08
00000c  06040200          DCB      0x06,0x04,0x02,0x00
000010  05551555          DCB      0x05,0x55,0x15,0x55
000014  25553555          DCB      0x25,0x55,0x35,0x55
000018  45555555          DCB      0x45,0x55,0x55,0x55
00001c  65557555          DCB      0x65,0x55,0x75,0x55
000020  85559555          DCB      0x85,0x55,0x95,0x55
000024  a555b555          DCB      0xa5,0x55,0xb5,0x55
000028  c555d555          DCB      0xc5,0x55,0xd5,0x55
00002c  e555f555          DCB      0xe5,0x55,0xf5,0x55
000030  1b030000          DCB      0x1b,0x03,0x00,0x00
000034  00131313          DCB      0x00,0x13,0x13,0x13
000038  0f0f0a50          DCB      0x0f,0x0f,0x0a,0x50
00003c  30050364          DCB      0x30,0x05,0x03,0x64
000040  05e00120          DCB      0x05,0xe0,0x01,0x20
000044  03000032          DCB      0x03,0x00,0x00,0x32
000048  2c342e00          DCB      0x2c,0x34,0x2e,0x00
00004c  00041422          DCB      0x00,0x04,0x14,0x22
000050  04000000          DCB      0x04,0x00,0x00,0x00
000054  00002014          DCB      0x00,0x00,0x20,0x14
000058  ec010000          DCB      0xec,0x01,0x00,0x00
00005c  00000000          DCB      0x00,0x00,0x00,0x00
000060  00000000          DCB      0x00,0x00,0x00,0x00
000064  0c302528          DCB      0x0c,0x30,0x25,0x28
000068  14000000          DCB      0x14,0x00,0x00,0x00
00006c  00000001          DCB      0x00,0x00,0x00,0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_gt811.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_gt811_c_2208b836____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_gt811_c_2208b836____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_gt811_c_2208b836____REVSH|
#line 128
|__asm___11_bsp_gt811_c_2208b836____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
