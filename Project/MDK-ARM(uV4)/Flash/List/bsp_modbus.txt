; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_modbus.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_modbus.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_modbus.crf ..\..\User\bsp\src\bsp_modbus.c]
                          THUMB

                          AREA ||i.MODBUS_AnalyzeApp||, CODE, READONLY, ALIGN=2

                  MODBUS_AnalyzeApp PROC
;;;303    */
;;;304    void MODBUS_AnalyzeApp(void)
000000  480a              LDR      r0,|L1.44|
;;;305    {
;;;306    	/* Modbus从机 */
;;;307    	switch (g_tModbus.RxBuf[1])			/* 第2个字节 功能码 */
000002  7841              LDRB     r1,[r0,#1]  ; g_tModbus
000004  2904              CMP      r1,#4
000006  d006              BEQ      |L1.22|
000008  dc06              BGT      |L1.24|
00000a  2901              CMP      r1,#1
00000c  d003              BEQ      |L1.22|
00000e  2902              CMP      r1,#2
000010  d001              BEQ      |L1.22|
000012  2903              CMP      r1,#3
000014  d106              BNE      |L1.36|
                  |L1.22|
;;;308    	{
;;;309    		case 0x01:	/* 读取线圈状态（对应远程开关D01/D02/D03） */
;;;310    			MODBUS_01H();
;;;311    			break;
;;;312    
;;;313    		case 0x02:	/* 读取输入状态（对应T01～T18） */
;;;314    			MODBUS_02H();
;;;315    			break;
;;;316    
;;;317    		case 0x03:	/* 读取保持寄存器 在一个或多个保持寄存器中取得当前的二进制值 */
;;;318    			MODBUS_03H();
;;;319    			break;
;;;320    
;;;321    		case 0x04:	/* 读取输入寄存器（对应A01/A02） ） */
;;;322    			MODBUS_04H();
;;;323    			break;
;;;324    
;;;325    		case 0x05:	/* 强制单线圈（对应D01/D02/D03） */
;;;326    			MODBUS_05H();
;;;327    			break;
;;;328    
;;;329    		case 0x06:	/* 写单个寄存器 (存储在EEPROM中的参数) */
;;;330    			MODBUS_06H();
;;;331    			break;
;;;332    
;;;333    		case 0x10:	/* 写多个寄存器 （改写时钟） */
;;;334    			MODBUS_10H();
;;;335    			break;
;;;336    
;;;337    		default:
;;;338    			g_tModbus.RspCode = RSP_ERR_CMD;
;;;339    			//MODBUS_SendAckErr(g_tModbus.RspCode);	/* 告诉主机命令错误 */
;;;340    			break;
;;;341    	}
;;;342    }
000016  4770              BX       lr
                  |L1.24|
000018  2905              CMP      r1,#5                 ;307
00001a  d0fc              BEQ      |L1.22|
00001c  2906              CMP      r1,#6                 ;307
00001e  d0fa              BEQ      |L1.22|
000020  2910              CMP      r1,#0x10              ;307
000022  d0f8              BEQ      |L1.22|
                  |L1.36|
000024  2101              MOVS     r1,#1                 ;338
000026  f880110c          STRB     r1,[r0,#0x10c]        ;338
00002a  4770              BX       lr
;;;343    
                          ENDP

                  |L1.44|
                          DCD      ||.bss||

                          AREA ||i.MODBUS_InitVar||, CODE, READONLY, ALIGN=2

                  MODBUS_InitVar PROC
;;;31     */
;;;32     void MODBUS_InitVar(uint32_t _Baud, uint8_t _WorkMode)
000000  4a05              LDR      r2,|L2.24|
;;;33     {
;;;34     	g_rtu_timeout = 0;
000002  2100              MOVS     r1,#0
000004  7011              STRB     r1,[r2,#0]
;;;35     	g_tModbus.RxCount = 0;
000006  4a05              LDR      r2,|L2.28|
000008  f8821080          STRB     r1,[r2,#0x80]
;;;36     
;;;37     	g_tModbus.Baud = _Baud;
;;;38     
;;;39     	g_tModbus.WorkMode = WKM_NO_CRC;	/* 接收数据帧不进行CRC校验 */
00000c  f8c20108          STR      r0,[r2,#0x108]  ; g_tModbus
000010  f882118e          STRB     r1,[r2,#0x18e]
;;;40     
;;;41     	RS485_SetBaud(_Baud);
000014  f7ffbffe          B.W      RS485_SetBaud
;;;42     }
;;;43     
                          ENDP

                  |L2.24|
                          DCD      ||.data||
                  |L2.28|
                          DCD      ||.bss||

                          AREA ||i.MODBUS_Poll||, CODE, READONLY, ALIGN=2

                  MODBUS_Poll PROC
;;;51     */
;;;52     void MODBUS_Poll(void)
000000  b570              PUSH     {r4-r6,lr}
;;;53     {
;;;54     	uint16_t crc1;
;;;55     
;;;56     	if (g_rtu_timeout == 0)
000002  481e              LDR      r0,|L3.124|
000004  7801              LDRB     r1,[r0,#0]  ; g_rtu_timeout
000006  2900              CMP      r1,#0                 ;53
000008  d036              BEQ      |L3.120|
;;;57     	{
;;;58     		/* 没有超时，继续接收。不要清零 g_tModbus.RxCount */
;;;59     		return;
;;;60     	}
;;;61     
;;;62     	/* 收到命令
;;;63     		05 06 00 88 04 57 3B70 (8 字节)
;;;64     			05    :  数码管屏的号站，
;;;65     			06    :  指令
;;;66     			00 88 :  数码管屏的显示寄存器
;;;67     			04 57 :  数据,,,转换成 10 进制是 1111.高位在前,
;;;68     			3B70  :  二个字节 CRC 码	从05到 57的校验
;;;69     	*/
;;;70     	g_rtu_timeout = 0;
00000a  2600              MOVS     r6,#0
;;;71     
;;;72     	switch (g_tModbus.WorkMode)
00000c  4c1c              LDR      r4,|L3.128|
00000e  7006              STRB     r6,[r0,#0]            ;70
000010  4620              MOV      r0,r4
000012  f894218e          LDRB     r2,[r4,#0x18e]  ; g_tModbus
;;;73     	{
;;;74     		case WKM_NO_CRC:	/* 接收数据帧不进行CRC校验. 用于ASCII协议 */
;;;75     			{
;;;76     				/* 将接收的数据复制到另外一个缓冲区，等待APP程序读取 */
;;;77     				memcpy(g_tModbus.AppRxBuf, g_tModbus.RxBuf, g_tModbus.RxCount);
000016  f8901080          LDRB     r1,[r0,#0x80]
00001a  f1000583          ADD      r5,r0,#0x83
00001e  b122              CBZ      r2,|L3.42|
000020  2a01              CMP      r2,#1                 ;72
000022  d004              BEQ      |L3.46|
000024  2a02              CMP      r2,#2                 ;72
000026  d125              BNE      |L3.116|
000028  e019              B        |L3.94|
                  |L3.42|
00002a  460a              MOV      r2,r1                 ;72
;;;78     				g_tModbus.AppRxCount = g_tModbus.RxCount;
;;;79     				bsp_PutMsg(MSG_485_RX, 0);		/* 发送一个收到485数据帧的消息给主程序 */
;;;80     			}
;;;81     			break;
00002c  e00a              B        |L3.68|
                  |L3.46|
;;;82     
;;;83     		case WKM_MODBUS_HOST:			/* Modbus 主机模式 */
;;;84     			if (g_tModbus.RxCount < 4)
00002e  2904              CMP      r1,#4
000030  d320              BCC      |L3.116|
;;;85     			{
;;;86     				goto err_ret;
;;;87     			}
;;;88     
;;;89     			/* 计算CRC校验和 */
;;;90     			crc1 = CRC16_Modbus(g_tModbus.RxBuf, g_tModbus.RxCount);
000032  4813              LDR      r0,|L3.128|
000034  f7fffffe          BL       CRC16_Modbus
;;;91     			if (crc1 != 0)
000038  b9e0              CBNZ     r0,|L3.116|
;;;92     			{
;;;93     				goto err_ret;
;;;94     			}
;;;95     
;;;96     			/* 站地址 (1字节） */
;;;97     			g_tModbus.AppRxAddr = g_tModbus.RxBuf[0];	/* 第1字节 站号 */
00003a  7820              LDRB     r0,[r4,#0]  ; g_tModbus
00003c  f8840104          STRB     r0,[r4,#0x104]
;;;98     
;;;99     			/* 将接收的数据复制到另外一个缓冲区，等待APP程序读取 */
;;;100    			memcpy(g_tModbus.AppRxBuf, g_tModbus.RxBuf, g_tModbus.RxCount);
000040  f8942080          LDRB     r2,[r4,#0x80]  ; g_tModbus
                  |L3.68|
000044  490e              LDR      r1,|L3.128|
000046  4628              MOV      r0,r5
000048  f7fffffe          BL       __aeabi_memcpy
;;;101    			g_tModbus.AppRxCount = g_tModbus.RxCount;
00004c  f8940080          LDRB     r0,[r4,#0x80]  ; g_tModbus
000050  f8840103          STRB     r0,[r4,#0x103]
;;;102    			bsp_PutMsg(MSG_485_RX, 0);		/* 借用按键FIFO，发送一个收到485数据帧的消息 */
000054  2100              MOVS     r1,#0
000056  2001              MOVS     r0,#1
000058  f7fffffe          BL       bsp_PutMsg
00005c  e00a              B        |L3.116|
                  |L3.94|
;;;103    			break;
;;;104    
;;;105    		case WKM_MODBUS_DEVICE:			/* Modbus 从机模式 */
;;;106    			if (g_tModbus.RxCount < 4)
00005e  2904              CMP      r1,#4
000060  d308              BCC      |L3.116|
;;;107    			{
;;;108    				goto err_ret;
;;;109    			}
;;;110    
;;;111    			/* 计算CRC校验和 */
;;;112    			crc1 = CRC16_Modbus(g_tModbus.RxBuf, g_tModbus.RxCount);
000062  4807              LDR      r0,|L3.128|
000064  f7fffffe          BL       CRC16_Modbus
;;;113    			if (crc1 != 0)
000068  b920              CBNZ     r0,|L3.116|
;;;114    			{
;;;115    				goto err_ret;
;;;116    			}
;;;117    
;;;118    			/* 站地址 (1字节） */
;;;119    			g_tModbus.AppRxAddr = g_tModbus.RxBuf[0];	/* 第1字节 站号 */
00006a  7820              LDRB     r0,[r4,#0]  ; g_tModbus
00006c  f8840104          STRB     r0,[r4,#0x104]
;;;120    
;;;121    			/* 分析应用层协议 */
;;;122    			MODBUS_AnalyzeApp();
000070  f7fffffe          BL       MODBUS_AnalyzeApp
                  |L3.116|
;;;123    			break;
;;;124    
;;;125    		default:
;;;126    			break;
;;;127    	}
;;;128    
;;;129    err_ret:
;;;130    	g_tModbus.RxCount = 0;	/* 必须清零计数器，方便下次帧同步 */
000074  f8846080          STRB     r6,[r4,#0x80]
                  |L3.120|
;;;131    }
000078  bd70              POP      {r4-r6,pc}
;;;132    
                          ENDP

00007a  0000              DCW      0x0000
                  |L3.124|
                          DCD      ||.data||
                  |L3.128|
                          DCD      ||.bss||

                          AREA ||i.MODBUS_ReciveNew||, CODE, READONLY, ALIGN=2

                  MODBUS_ReciveNew PROC
;;;140    */
;;;141    void MODBUS_ReciveNew(uint8_t _byte)
000000  b570              PUSH     {r4-r6,lr}
;;;142    {
;;;143    	/*
;;;144    		3.5个字符的时间间隔，只是用在RTU模式下面，因为RTU模式没有开始符和结束符，
;;;145    		两个数据包之间只能靠时间间隔来区分，Modbus定义在不同的波特率下，间隔时间是不一样的，
;;;146    		所以就是3.5个字符的时间，波特率高，这个时间间隔就小，波特率低，这个时间间隔相应就大
;;;147    
;;;148            4800  = 7.297ms
;;;149            9600  = 3.646ms
;;;150            19200  = 1.771ms
;;;151            38400  = 0.885ms
;;;152    	*/
;;;153    	uint32_t timeout;
;;;154    
;;;155    	timeout = 35000000 / g_tModbus.Baud;		/* 计算超时时间，单位us */
000002  4c0a              LDR      r4,|L4.44|
000004  4605              MOV      r5,r0                 ;142
000006  490a              LDR      r1,|L4.48|
000008  f8d40108          LDR      r0,[r4,#0x108]  ; g_tModbus
;;;156    
;;;157    	/* 硬件定时中断，定时精度us 定时器4用于Modbus */
;;;158    	bsp_StartHardTimer(4, timeout, (void *)MODBUS_RxTimeOut);
00000c  4a09              LDR      r2,|L4.52|
00000e  fbb1f1f0          UDIV     r1,r1,r0              ;155
000012  2004              MOVS     r0,#4
000014  f7fffffe          BL       bsp_StartHardTimer
;;;159    
;;;160    	if (g_tModbus.RxCount < MODBUS_RX_SIZE)
000018  f8940080          LDRB     r0,[r4,#0x80]  ; g_tModbus
00001c  2880              CMP      r0,#0x80
00001e  d204              BCS      |L4.42|
;;;161    	{
;;;162    		g_tModbus.RxBuf[g_tModbus.RxCount++] = _byte;
000020  5425              STRB     r5,[r4,r0]
000022  f8140f80          LDRB     r0,[r4,#0x80]!  ; g_tModbus
000026  1c40              ADDS     r0,r0,#1
000028  7020              STRB     r0,[r4,#0]
                  |L4.42|
;;;163    	}
;;;164    }
00002a  bd70              POP      {r4-r6,pc}
;;;165    
                          ENDP

                  |L4.44|
                          DCD      ||.bss||
                  |L4.48|
                          DCD      0x02160ec0
                  |L4.52|
                          DCD      MODBUS_RxTimeOut

                          AREA ||i.MODBUS_RxTimeOut||, CODE, READONLY, ALIGN=2

                  MODBUS_RxTimeOut PROC
;;;173    */
;;;174    static void MODBUS_RxTimeOut(void)
000000  4901              LDR      r1,|L5.8|
;;;175    {
;;;176    	g_rtu_timeout = 1;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;177    }
000006  4770              BX       lr
;;;178    
                          ENDP

                  |L5.8|
                          DCD      ||.data||

                          AREA ||i.MODBUS_SendWithCRC||, CODE, READONLY, ALIGN=1

                  MODBUS_SendWithCRC PROC
;;;187    */
;;;188    void MODBUS_SendWithCRC(uint8_t *_pBuf, uint8_t _ucLen)
000000  b530              PUSH     {r4,r5,lr}
;;;189    {
000002  460c              MOV      r4,r1
;;;190    	uint16_t crc;
;;;191    	uint8_t buf[MODBUS_TX_SIZE];
;;;192    
;;;193    	memcpy(buf, _pBuf, _ucLen);
000004  460a              MOV      r2,r1
000006  b0a1              SUB      sp,sp,#0x84           ;189
000008  4605              MOV      r5,r0                 ;189
00000a  4601              MOV      r1,r0
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __aeabi_memcpy
;;;194    	crc = CRC16_Modbus(_pBuf, _ucLen);
000012  4621              MOV      r1,r4
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       CRC16_Modbus
;;;195    	buf[_ucLen++] = crc >> 8;
00001a  0a01              LSRS     r1,r0,#8
00001c  f80d1004          STRB     r1,[sp,r4]
000020  1c64              ADDS     r4,r4,#1
000022  b2e1              UXTB     r1,r4
;;;196    	buf[_ucLen++] = crc;
000024  f80d0001          STRB     r0,[sp,r1]
000028  1c49              ADDS     r1,r1,#1
00002a  b2c9              UXTB     r1,r1
;;;197    	RS485_SendBuf(buf, _ucLen);
00002c  4668              MOV      r0,sp
00002e  f7fffffe          BL       RS485_SendBuf
;;;198    }
000032  b021              ADD      sp,sp,#0x84
000034  bd30              POP      {r4,r5,pc}
;;;199    
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tModbus
                          %        400

                          AREA ||.data||, DATA, ALIGN=0

                  g_rtu_timeout
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_modbus.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_modbus_c_a16e2304____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_modbus_c_a16e2304____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_modbus_c_a16e2304____REVSH|
#line 128
|__asm___12_bsp_modbus_c_a16e2304____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
