; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_key.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_key.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_key.crf ..\..\User\bsp\src\bsp_key.c]
                          THUMB

                          AREA ||i.IsKeyDown1||, CODE, READONLY, ALIGN=2

                  IsKeyDown1 PROC
;;;91     #if 1	/* 为了区分3个事件:　K1单独按下, K2单独按下， K1和K2同时按下 */
;;;92     static uint8_t IsKeyDown1(void)
000000  4807              LDR      r0,|L1.32|
;;;93     {
;;;94     	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0
000002  6880              LDR      r0,[r0,#8]
000004  0480              LSLS     r0,r0,#18
000006  d409              BMI      |L1.28|
000008  4806              LDR      r0,|L1.36|
00000a  6800              LDR      r0,[r0,#0]
00000c  07c0              LSLS     r0,r0,#31
00000e  d105              BNE      |L1.28|
;;;95     		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0)
000010  4805              LDR      r0,|L1.40|
000012  6880              LDR      r0,[r0,#8]
000014  05c0              LSLS     r0,r0,#23
000016  d501              BPL      |L1.28|
;;;96     		return 1;
000018  2001              MOVS     r0,#1
;;;97     	else 
;;;98     		return 0;
;;;99     }
00001a  4770              BX       lr
                  |L1.28|
00001c  2000              MOVS     r0,#0                 ;98
00001e  4770              BX       lr
;;;100    static uint8_t IsKeyDown2(void)
                          ENDP

                  |L1.32|
                          DCD      0x40011000
                  |L1.36|
                          DCD      0x40010808
                  |L1.40|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown10||, CODE, READONLY, ALIGN=2

                  IsKeyDown10 PROC
;;;123    }
;;;124    static uint8_t IsKeyDown10(void)	/* K2 K3组合键 */
000000  4807              LDR      r0,|L2.32|
;;;125    {
;;;126    	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) != 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0
000002  6880              LDR      r0,[r0,#8]
000004  0480              LSLS     r0,r0,#18
000006  d509              BPL      |L2.28|
000008  4806              LDR      r0,|L2.36|
00000a  6800              LDR      r0,[r0,#0]
00000c  07c0              LSLS     r0,r0,#31
00000e  d005              BEQ      |L2.28|
;;;127    		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0)
000010  4805              LDR      r0,|L2.40|
000012  6880              LDR      r0,[r0,#8]
000014  05c0              LSLS     r0,r0,#23
000016  d401              BMI      |L2.28|
;;;128    		return 1;
000018  2001              MOVS     r0,#1
;;;129    	else 
;;;130    		return 0;
;;;131    }
00001a  4770              BX       lr
                  |L2.28|
00001c  2000              MOVS     r0,#0                 ;130
00001e  4770              BX       lr
;;;132    #else	
                          ENDP

                  |L2.32|
                          DCD      0x40011000
                  |L2.36|
                          DCD      0x40010808
                  |L2.40|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown2||, CODE, READONLY, ALIGN=2

                  IsKeyDown2 PROC
;;;99     }
;;;100    static uint8_t IsKeyDown2(void)
000000  4807              LDR      r0,|L3.32|
;;;101    {
;;;102    	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) != 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0
000002  6880              LDR      r0,[r0,#8]
000004  0480              LSLS     r0,r0,#18
000006  d509              BPL      |L3.28|
000008  4806              LDR      r0,|L3.36|
00000a  6800              LDR      r0,[r0,#0]
00000c  07c0              LSLS     r0,r0,#31
00000e  d005              BEQ      |L3.28|
;;;103    		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0)
000010  4805              LDR      r0,|L3.40|
000012  6880              LDR      r0,[r0,#8]
000014  05c0              LSLS     r0,r0,#23
000016  d501              BPL      |L3.28|
;;;104    		return 1;
000018  2001              MOVS     r0,#1
;;;105    	else 
;;;106    		return 0;
;;;107    }
00001a  4770              BX       lr
                  |L3.28|
00001c  2000              MOVS     r0,#0                 ;106
00001e  4770              BX       lr
;;;108    static uint8_t IsKeyDown3(void)
                          ENDP

                  |L3.32|
                          DCD      0x40011000
                  |L3.36|
                          DCD      0x40010808
                  |L3.40|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown3||, CODE, READONLY, ALIGN=2

                  IsKeyDown3 PROC
;;;107    }
;;;108    static uint8_t IsKeyDown3(void)
000000  4807              LDR      r0,|L4.32|
;;;109    {
;;;110    	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) != 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) == 0
000002  6880              LDR      r0,[r0,#8]
000004  0480              LSLS     r0,r0,#18
000006  d509              BPL      |L4.28|
000008  4806              LDR      r0,|L4.36|
00000a  6800              LDR      r0,[r0,#0]
00000c  07c0              LSLS     r0,r0,#31
00000e  d105              BNE      |L4.28|
;;;111    		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) == 0)
000010  4805              LDR      r0,|L4.40|
000012  6880              LDR      r0,[r0,#8]
000014  05c0              LSLS     r0,r0,#23
000016  d401              BMI      |L4.28|
;;;112    		return 1;
000018  2001              MOVS     r0,#1
;;;113    	else 
;;;114    		return 0;
;;;115    }
00001a  4770              BX       lr
                  |L4.28|
00001c  2000              MOVS     r0,#0                 ;114
00001e  4770              BX       lr
;;;116    static uint8_t IsKeyDown9(void)	/* K1 K2组合键 */
                          ENDP

                  |L4.32|
                          DCD      0x40011000
                  |L4.36|
                          DCD      0x40010808
                  |L4.40|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown4||, CODE, READONLY, ALIGN=2

                  IsKeyDown4 PROC
;;;142    /* 5方向摇杆 */
;;;143    static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
000000  4803              LDR      r0,|L5.16|
000002  6880              LDR      r0,[r0,#8]
000004  0400              LSLS     r0,r0,#16
000006  d401              BMI      |L5.12|
000008  2001              MOVS     r0,#1
00000a  4770              BX       lr
                  |L5.12|
00000c  2000              MOVS     r0,#0
00000e  4770              BX       lr
;;;144    static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 0) return 1;else return 0;}
                          ENDP

                  |L5.16|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown5||, CODE, READONLY, ALIGN=2

                  IsKeyDown5 PROC
;;;143    static uint8_t IsKeyDown4(void) {if ((GPIO_PORT_K4->IDR & GPIO_PIN_K4) == 0) return 1;else return 0;}
;;;144    static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 0) return 1;else return 0;}
000000  4803              LDR      r0,|L6.16|
000002  6800              LDR      r0,[r0,#0]
000004  0700              LSLS     r0,r0,#28
000006  d401              BMI      |L6.12|
000008  2001              MOVS     r0,#1
00000a  4770              BX       lr
                  |L6.12|
00000c  2000              MOVS     r0,#0
00000e  4770              BX       lr
;;;145    static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
                          ENDP

                  |L6.16|
                          DCD      0x40011408

                          AREA ||i.IsKeyDown6||, CODE, READONLY, ALIGN=2

                  IsKeyDown6 PROC
;;;144    static uint8_t IsKeyDown5(void) {if ((GPIO_PORT_K5->IDR & GPIO_PIN_K5) == 0) return 1;else return 0;}
;;;145    static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
000000  4803              LDR      r0,|L7.16|
000002  6880              LDR      r0,[r0,#8]
000004  0440              LSLS     r0,r0,#17
000006  d401              BMI      |L7.12|
000008  2001              MOVS     r0,#1
00000a  4770              BX       lr
                  |L7.12|
00000c  2000              MOVS     r0,#0
00000e  4770              BX       lr
;;;146    static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
                          ENDP

                  |L7.16|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown7||, CODE, READONLY, ALIGN=2

                  IsKeyDown7 PROC
;;;145    static uint8_t IsKeyDown6(void) {if ((GPIO_PORT_K6->IDR & GPIO_PIN_K6) == 0) return 1;else return 0;}
;;;146    static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
000000  4803              LDR      r0,|L8.16|
000002  6880              LDR      r0,[r0,#8]
000004  0480              LSLS     r0,r0,#18
000006  d401              BMI      |L8.12|
000008  2001              MOVS     r0,#1
00000a  4770              BX       lr
                  |L8.12|
00000c  2000              MOVS     r0,#0
00000e  4770              BX       lr
;;;147    static uint8_t IsKeyDown8(void) {if ((GPIO_PORT_K8->IDR & GPIO_PIN_K8) == 0) return 1;else return 0;}
                          ENDP

                  |L8.16|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown8||, CODE, READONLY, ALIGN=2

                  IsKeyDown8 PROC
;;;146    static uint8_t IsKeyDown7(void) {if ((GPIO_PORT_K7->IDR & GPIO_PIN_K7) == 0) return 1;else return 0;}
;;;147    static uint8_t IsKeyDown8(void) {if ((GPIO_PORT_K8->IDR & GPIO_PIN_K8) == 0) return 1;else return 0;}
000000  4803              LDR      r0,|L9.16|
000002  6880              LDR      r0,[r0,#8]
000004  0600              LSLS     r0,r0,#24
000006  d401              BMI      |L9.12|
000008  2001              MOVS     r0,#1
00000a  4770              BX       lr
                  |L9.12|
00000c  2000              MOVS     r0,#0
00000e  4770              BX       lr
;;;148    
                          ENDP

                  |L9.16|
                          DCD      0x40012000

                          AREA ||i.IsKeyDown9||, CODE, READONLY, ALIGN=2

                  IsKeyDown9 PROC
;;;115    }
;;;116    static uint8_t IsKeyDown9(void)	/* K1 K2组合键 */
000000  4807              LDR      r0,|L10.32|
;;;117    {
;;;118    	if ((GPIO_PORT_K1->IDR & GPIO_PIN_K1) == 0 && (GPIO_PORT_K2->IDR & GPIO_PIN_K2) != 0
000002  6880              LDR      r0,[r0,#8]
000004  0480              LSLS     r0,r0,#18
000006  d409              BMI      |L10.28|
000008  4806              LDR      r0,|L10.36|
00000a  6800              LDR      r0,[r0,#0]
00000c  07c0              LSLS     r0,r0,#31
00000e  d005              BEQ      |L10.28|
;;;119    		&& (GPIO_PORT_K3->IDR & GPIO_PIN_K3) != 0)
000010  4805              LDR      r0,|L10.40|
000012  6880              LDR      r0,[r0,#8]
000014  05c0              LSLS     r0,r0,#23
000016  d501              BPL      |L10.28|
;;;120    		return 1;
000018  2001              MOVS     r0,#1
;;;121    	else 
;;;122    		return 0;
;;;123    }
00001a  4770              BX       lr
                  |L10.28|
00001c  2000              MOVS     r0,#0                 ;122
00001e  4770              BX       lr
;;;124    static uint8_t IsKeyDown10(void)	/* K2 K3组合键 */
                          ENDP

                  |L10.32|
                          DCD      0x40011000
                  |L10.36|
                          DCD      0x40010808
                  |L10.40|
                          DCD      0x40012000

                          AREA ||i.bsp_ClearKey||, CODE, READONLY, ALIGN=2

                  bsp_ClearKey PROC
;;;274    */
;;;275    void bsp_ClearKey(void)
000000  4801              LDR      r0,|L11.8|
;;;276    {
;;;277    	s_tKey.Read = s_tKey.Write;
000002  7ac1              LDRB     r1,[r0,#0xb]  ; s_tKey
000004  7281              STRB     r1,[r0,#0xa]
;;;278    }
000006  4770              BX       lr
;;;279    
                          ENDP

                  |L11.8|
                          DCD      ||.bss||+0xa0

                          AREA ||i.bsp_DetectKey||, CODE, READONLY, ALIGN=2

                  bsp_DetectKey PROC
;;;388    */
;;;389    static void bsp_DetectKey(uint8_t i)
000000  b570              PUSH     {r4-r6,lr}
;;;390    {
000002  4606              MOV      r6,r0
;;;391    	KEY_T *pBtn;
;;;392    
;;;393    	/*
;;;394    		如果没有初始化按键函数，则报错
;;;395    		if (s_tBtn[i].IsKeyDownFunc == 0)
;;;396    		{
;;;397    			printf("Fault : DetectButton(), s_tBtn[i].IsKeyDownFunc undefine");
;;;398    		}
;;;399    	*/
;;;400    
;;;401    	pBtn = &s_tBtn[i];
000004  4828              LDR      r0,|L12.168|
000006  eb001406          ADD      r4,r0,r6,LSL #4
;;;402    	if (pBtn->IsKeyDownFunc())
00000a  6820              LDR      r0,[r4,#0]
00000c  4780              BLX      r0
;;;403    	{
;;;404    		if (pBtn->Count < KEY_FILTER_TIME)
;;;405    		{
;;;406    			pBtn->Count = KEY_FILTER_TIME;
00000e  2105              MOVS     r1,#5
;;;407    		}
;;;408    		else if(pBtn->Count < 2 * KEY_FILTER_TIME)
;;;409    		{
;;;410    			pBtn->Count++;
;;;411    		}
;;;412    		else
;;;413    		{
;;;414    			if (pBtn->State == 0)
;;;415    			{
;;;416    				pBtn->State = 1;
;;;417    
;;;418    				/* 发送按钮按下的消息 */
;;;419    				bsp_PutKey((uint8_t)(3 * i + 1));
000010  2500              MOVS     r5,#0
000012  2800              CMP      r0,#0                 ;402
;;;420    			}
;;;421    
;;;422    			if (pBtn->LongTime > 0)
;;;423    			{
;;;424    				if (pBtn->LongCount < pBtn->LongTime)
;;;425    				{
;;;426    					/* 发送按钮持续按下的消息 */
;;;427    					if (++pBtn->LongCount == pBtn->LongTime)
;;;428    					{
;;;429    						/* 键值放入按键FIFO */
;;;430    						bsp_PutKey((uint8_t)(3 * i + 3));
;;;431    					}
;;;432    				}
;;;433    				else
;;;434    				{
;;;435    					if (pBtn->RepeatSpeed > 0)
;;;436    					{
;;;437    						if (++pBtn->RepeatCount >= pBtn->RepeatSpeed)
;;;438    						{
;;;439    							pBtn->RepeatCount = 0;
;;;440    							/* 长按键后，每隔10ms发送1个按键 */
;;;441    							bsp_PutKey((uint8_t)(3 * i + 1));
;;;442    						}
;;;443    					}
;;;444    				}
;;;445    			}
;;;446    		}
;;;447    	}
;;;448    	else
;;;449    	{
;;;450    		if(pBtn->Count > KEY_FILTER_TIME)
000014  7920              LDRB     r0,[r4,#4]
000016  eb060346          ADD      r3,r6,r6,LSL #1       ;419
00001a  d031              BEQ      |L12.128|
00001c  2805              CMP      r0,#5                 ;404
00001e  d201              BCS      |L12.36|
000020  7121              STRB     r1,[r4,#4]            ;406
;;;451    		{
;;;452    			pBtn->Count = KEY_FILTER_TIME;
;;;453    		}
;;;454    		else if(pBtn->Count != 0)
;;;455    		{
;;;456    			pBtn->Count--;
;;;457    		}
;;;458    		else
;;;459    		{
;;;460    			if (pBtn->State == 1)
;;;461    			{
;;;462    				pBtn->State = 0;
;;;463    
;;;464    				/* 发送按钮弹起的消息 */
;;;465    				bsp_PutKey((uint8_t)(3 * i + 2));
;;;466    			}
;;;467    		}
;;;468    
;;;469    		pBtn->LongCount = 0;
;;;470    		pBtn->RepeatCount = 0;
;;;471    	}
;;;472    }
000022  bd70              POP      {r4-r6,pc}
                  |L12.36|
000024  280a              CMP      r0,#0xa               ;408
000026  d202              BCS      |L12.46|
000028  1c40              ADDS     r0,r0,#1              ;408
00002a  7120              STRB     r0,[r4,#4]            ;410
                  |L12.44|
00002c  bd70              POP      {r4-r6,pc}
                  |L12.46|
00002e  7aa0              LDRB     r0,[r4,#0xa]          ;414
000030  eb060646          ADD      r6,r6,r6,LSL #1       ;419
000034  1c76              ADDS     r6,r6,#1              ;419
000036  b920              CBNZ     r0,|L12.66|
000038  2001              MOVS     r0,#1                 ;416
00003a  72a0              STRB     r0,[r4,#0xa]          ;416
00003c  b2f0              UXTB     r0,r6                 ;419
00003e  f7fffffe          BL       bsp_PutKey
                  |L12.66|
000042  8921              LDRH     r1,[r4,#8]            ;422
000044  2900              CMP      r1,#0                 ;422
000046  d0f1              BEQ      |L12.44|
000048  88e0              LDRH     r0,[r4,#6]            ;424
00004a  4288              CMP      r0,r1                 ;424
00004c  d208              BCS      |L12.96|
00004e  1c40              ADDS     r0,r0,#1              ;424
000050  b280              UXTH     r0,r0                 ;427
000052  80e0              STRH     r0,[r4,#6]            ;427
000054  8921              LDRH     r1,[r4,#8]            ;427
000056  4288              CMP      r0,r1                 ;427
000058  d1e8              BNE      |L12.44|
00005a  1cdb              ADDS     r3,r3,#3              ;427
00005c  b2d8              UXTB     r0,r3                 ;430
00005e  e00b              B        |L12.120|
                  |L12.96|
000060  7ae0              LDRB     r0,[r4,#0xb]          ;435
000062  2800              CMP      r0,#0                 ;435
000064  d0e2              BEQ      |L12.44|
000066  7b20              LDRB     r0,[r4,#0xc]          ;437
000068  1c40              ADDS     r0,r0,#1              ;437
00006a  b2c0              UXTB     r0,r0                 ;437
00006c  7320              STRB     r0,[r4,#0xc]          ;437
00006e  7ae1              LDRB     r1,[r4,#0xb]          ;437
000070  4288              CMP      r0,r1                 ;437
000072  d3db              BCC      |L12.44|
000074  7325              STRB     r5,[r4,#0xc]          ;439
000076  b2f0              UXTB     r0,r6                 ;441
                  |L12.120|
000078  e8bd4070          POP      {r4-r6,lr}            ;441
00007c  f7ffbffe          B.W      bsp_PutKey
                  |L12.128|
000080  2805              CMP      r0,#5                 ;450
000082  d901              BLS      |L12.136|
000084  7121              STRB     r1,[r4,#4]            ;452
000086  e00b              B        |L12.160|
                  |L12.136|
000088  b110              CBZ      r0,|L12.144|
00008a  1e40              SUBS     r0,r0,#1              ;454
00008c  7120              STRB     r0,[r4,#4]            ;456
00008e  e007              B        |L12.160|
                  |L12.144|
000090  7aa0              LDRB     r0,[r4,#0xa]          ;460
000092  2801              CMP      r0,#1                 ;460
000094  d104              BNE      |L12.160|
000096  1c9b              ADDS     r3,r3,#2              ;462
000098  72a5              STRB     r5,[r4,#0xa]          ;462
00009a  b2d8              UXTB     r0,r3                 ;465
00009c  f7fffffe          BL       bsp_PutKey
                  |L12.160|
0000a0  80e5              STRH     r5,[r4,#6]            ;469
0000a2  7325              STRB     r5,[r4,#0xc]          ;470
0000a4  bd70              POP      {r4-r6,pc}
;;;473    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L12.168|
                          DCD      ||.bss||

                          AREA ||i.bsp_GetKey||, CODE, READONLY, ALIGN=2

                  bsp_GetKey PROC
;;;188    */
;;;189    uint8_t bsp_GetKey(void)
000000  4907              LDR      r1,|L13.32|
;;;190    {
;;;191    	uint8_t ret;
;;;192    
;;;193    	if (s_tKey.Read == s_tKey.Write)
000002  7a8a              LDRB     r2,[r1,#0xa]  ; s_tKey
000004  7ac8              LDRB     r0,[r1,#0xb]  ; s_tKey
000006  4282              CMP      r2,r0
000008  d101              BNE      |L13.14|
;;;194    	{
;;;195    		return KEY_NONE;
00000a  2000              MOVS     r0,#0
                  |L13.12|
;;;196    	}
;;;197    	else
;;;198    	{
;;;199    		ret = s_tKey.Buf[s_tKey.Read];
;;;200    
;;;201    		if (++s_tKey.Read >= KEY_FIFO_SIZE)
;;;202    		{
;;;203    			s_tKey.Read = 0;
;;;204    		}
;;;205    		return ret;
;;;206    	}
;;;207    }
00000c  4770              BX       lr
                  |L13.14|
00000e  5c88              LDRB     r0,[r1,r2]            ;199
000010  1c52              ADDS     r2,r2,#1              ;199
000012  b2d2              UXTB     r2,r2                 ;201
000014  728a              STRB     r2,[r1,#0xa]          ;201
000016  2a0a              CMP      r2,#0xa               ;201
000018  d3f8              BCC      |L13.12|
00001a  2200              MOVS     r2,#0                 ;203
00001c  728a              STRB     r2,[r1,#0xa]          ;203
00001e  4770              BX       lr
;;;208    
                          ENDP

                  |L13.32|
                          DCD      ||.bss||+0xa0

                          AREA ||i.bsp_GetKey2||, CODE, READONLY, ALIGN=2

                  bsp_GetKey2 PROC
;;;216    */
;;;217    uint8_t bsp_GetKey2(void)
000000  4907              LDR      r1,|L14.32|
;;;218    {
;;;219    	uint8_t ret;
;;;220    
;;;221    	if (s_tKey.Read2 == s_tKey.Write)
000002  7b0a              LDRB     r2,[r1,#0xc]  ; s_tKey
000004  7ac8              LDRB     r0,[r1,#0xb]  ; s_tKey
000006  4282              CMP      r2,r0
000008  d101              BNE      |L14.14|
;;;222    	{
;;;223    		return KEY_NONE;
00000a  2000              MOVS     r0,#0
                  |L14.12|
;;;224    	}
;;;225    	else
;;;226    	{
;;;227    		ret = s_tKey.Buf[s_tKey.Read2];
;;;228    
;;;229    		if (++s_tKey.Read2 >= KEY_FIFO_SIZE)
;;;230    		{
;;;231    			s_tKey.Read2 = 0;
;;;232    		}
;;;233    		return ret;
;;;234    	}
;;;235    }
00000c  4770              BX       lr
                  |L14.14|
00000e  5c88              LDRB     r0,[r1,r2]            ;227
000010  1c52              ADDS     r2,r2,#1              ;227
000012  b2d2              UXTB     r2,r2                 ;229
000014  730a              STRB     r2,[r1,#0xc]          ;229
000016  2a0a              CMP      r2,#0xa               ;229
000018  d3f8              BCC      |L14.12|
00001a  2200              MOVS     r2,#0                 ;231
00001c  730a              STRB     r2,[r1,#0xc]          ;231
00001e  4770              BX       lr
;;;236    
                          ENDP

                  |L14.32|
                          DCD      ||.bss||+0xa0

                          AREA ||i.bsp_GetKeyState||, CODE, READONLY, ALIGN=2

                  bsp_GetKeyState PROC
;;;244    */
;;;245    uint8_t bsp_GetKeyState(KEY_ID_E _ucKeyID)
000000  4902              LDR      r1,|L15.12|
;;;246    {
;;;247    	return s_tBtn[_ucKeyID].State;
000002  eb011000          ADD      r0,r1,r0,LSL #4
000006  7a80              LDRB     r0,[r0,#0xa]
;;;248    }
000008  4770              BX       lr
;;;249    
                          ENDP

00000a  0000              DCW      0x0000
                  |L15.12|
                          DCD      ||.bss||

                          AREA ||i.bsp_InitKey||, CODE, READONLY, ALIGN=1

                  bsp_InitKey PROC
;;;156    */
;;;157    void bsp_InitKey(void)
000000  b510              PUSH     {r4,lr}
;;;158    {
;;;159    	bsp_InitKeyVar();		/* 初始化按键变量 */
000002  f7fffffe          BL       bsp_InitKeyVar
;;;160    	bsp_InitKeyHard();		/* 初始化按键硬件 */
000006  e8bd4010          POP      {r4,lr}
00000a  f7ffbffe          B.W      bsp_InitKeyHard
;;;161    }
;;;162    
                          ENDP


                          AREA ||i.bsp_InitKeyHard||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyHard PROC
;;;287    */
;;;288    static void bsp_InitKeyHard(void)
000000  b538              PUSH     {r3-r5,lr}
;;;289    {
;;;290    	GPIO_InitTypeDef GPIO_InitStructure;
;;;291    
;;;292    	/* 第1步：打开GPIO时钟 */
;;;293    	RCC_APB2PeriphClockCmd(RCC_ALL_KEY, ENABLE);
000002  2101              MOVS     r1,#1
000004  f44f709a          MOV      r0,#0x134
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;294    
;;;295    	/* 第2步：配置所有的按键GPIO为浮动输入模式(实际上CPU复位后就是输入状态) */
;;;296    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000c  2003              MOVS     r0,#3
00000e  f88d0002          STRB     r0,[sp,#2]
;;;297    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;	/* 输入浮空模式 */
000012  2004              MOVS     r0,#4
000014  f88d0003          STRB     r0,[sp,#3]
;;;298    	
;;;299    	/* 第3步：依次执行配置函数 */
;;;300    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K1;
000018  02c4              LSLS     r4,r0,#11
00001a  f8ad4000          STRH     r4,[sp,#0]
;;;301    	GPIO_Init(GPIO_PORT_K1, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  481a              LDR      r0,|L17.140|
000022  f7fffffe          BL       GPIO_Init
;;;302    
;;;303    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K2;
000026  2001              MOVS     r0,#1
000028  f8ad0000          STRH     r0,[sp,#0]
;;;304    	GPIO_Init(GPIO_PORT_K2, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4818              LDR      r0,|L17.144|
000030  f7fffffe          BL       GPIO_Init
;;;305    
;;;306    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K3;
000034  1160              ASRS     r0,r4,#5
;;;307    	GPIO_Init(GPIO_PORT_K3, &GPIO_InitStructure);
000036  4d17              LDR      r5,|L17.148|
000038  f8ad0000          STRH     r0,[sp,#0]            ;306
00003c  4669              MOV      r1,sp
00003e  4628              MOV      r0,r5
000040  f7fffffe          BL       GPIO_Init
;;;308    
;;;309    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K4;
000044  00a0              LSLS     r0,r4,#2
000046  f8ad0000          STRH     r0,[sp,#0]
;;;310    	GPIO_Init(GPIO_PORT_K4, &GPIO_InitStructure);
00004a  4669              MOV      r1,sp
00004c  4628              MOV      r0,r5
00004e  f7fffffe          BL       GPIO_Init
;;;311    
;;;312    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K5;
000052  2008              MOVS     r0,#8
000054  f8ad0000          STRH     r0,[sp,#0]
;;;313    	GPIO_Init(GPIO_PORT_K5, &GPIO_InitStructure);
000058  4669              MOV      r1,sp
00005a  480f              LDR      r0,|L17.152|
00005c  f7fffffe          BL       GPIO_Init
;;;314    
;;;315    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K6;
000060  0060              LSLS     r0,r4,#1
000062  f8ad0000          STRH     r0,[sp,#0]
;;;316    	GPIO_Init(GPIO_PORT_K6, &GPIO_InitStructure);
000066  4669              MOV      r1,sp
000068  4628              MOV      r0,r5
00006a  f7fffffe          BL       GPIO_Init
;;;317    
;;;318    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K7;
00006e  f8ad4000          STRH     r4,[sp,#0]
;;;319    	GPIO_Init(GPIO_PORT_K7, &GPIO_InitStructure);
000072  4669              MOV      r1,sp
000074  4628              MOV      r0,r5
000076  f7fffffe          BL       GPIO_Init
;;;320    
;;;321    	GPIO_InitStructure.GPIO_Pin = GPIO_PIN_K8;
00007a  2080              MOVS     r0,#0x80
00007c  f8ad0000          STRH     r0,[sp,#0]
;;;322    	GPIO_Init(GPIO_PORT_K8, &GPIO_InitStructure);
000080  4669              MOV      r1,sp
000082  4628              MOV      r0,r5
000084  f7fffffe          BL       GPIO_Init
;;;323    }
000088  bd38              POP      {r3-r5,pc}
;;;324    
                          ENDP

00008a  0000              DCW      0x0000
                  |L17.140|
                          DCD      0x40011000
                  |L17.144|
                          DCD      0x40010800
                  |L17.148|
                          DCD      0x40012000
                  |L17.152|
                          DCD      0x40011400

                          AREA ||i.bsp_InitKeyVar||, CODE, READONLY, ALIGN=2

                  bsp_InitKeyVar PROC
;;;332    */
;;;333    static void bsp_InitKeyVar(void)
000000  b530              PUSH     {r4,r5,lr}
;;;334    {
;;;335    	uint8_t i;
;;;336    
;;;337    	/* 对按键FIFO读写指针清零 */
;;;338    	s_tKey.Read = 0;
000002  481e              LDR      r0,|L18.124|
000004  2100              MOVS     r1,#0
;;;339    	s_tKey.Write = 0;
;;;340    	s_tKey.Read2 = 0;
;;;341    
;;;342    	/* 给每个按键结构体成员变量赋一组缺省值 */
;;;343    	for (i = 0; i < KEY_COUNT; i++)
;;;344    	{
;;;345    		s_tBtn[i].LongTime = KEY_LONG_TIME;			/* 长按时间 0 表示不检测长按键事件 */
000006  2364              MOVS     r3,#0x64
000008  7281              STRB     r1,[r0,#0xa]          ;338
00000a  72c1              STRB     r1,[r0,#0xb]          ;339
00000c  7301              STRB     r1,[r0,#0xc]          ;340
00000e  38a0              SUBS     r0,r0,#0xa0
000010  460a              MOV      r2,r1                 ;343
;;;346    		s_tBtn[i].Count = KEY_FILTER_TIME / 2;		/* 计数器设置为滤波时间的一半 */
000012  2502              MOVS     r5,#2
                  |L18.20|
000014  eb001402          ADD      r4,r0,r2,LSL #4       ;345
;;;347    		s_tBtn[i].State = 0;							/* 按键缺省状态，0为未按下 */
;;;348    		s_tBtn[i].RepeatSpeed = 0;						/* 按键连发的速度，0表示不支持连发 */
;;;349    		s_tBtn[i].RepeatCount = 0;						/* 连发计数器 */
000018  1c52              ADDS     r2,r2,#1
00001a  8123              STRH     r3,[r4,#8]            ;345
00001c  7125              STRB     r5,[r4,#4]            ;346
00001e  72a1              STRB     r1,[r4,#0xa]          ;347
000020  72e1              STRB     r1,[r4,#0xb]          ;348
000022  b2d2              UXTB     r2,r2                 ;343
000024  7321              STRB     r1,[r4,#0xc]
000026  2a0a              CMP      r2,#0xa               ;343
000028  d3f4              BCC      |L18.20|
;;;350    	}
;;;351    
;;;352    	/* 如果需要单独更改某个按键的参数，可以在此单独重新赋值 */
;;;353    	/* 比如，我们希望按键1按下超过1秒后，自动重发相同键值 */
;;;354    	s_tBtn[KID_JOY_U].LongTime = 100;
00002a  8703              STRH     r3,[r0,#0x38]
;;;355    	s_tBtn[KID_JOY_U].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
00002c  2105              MOVS     r1,#5
00002e  f880103b          STRB     r1,[r0,#0x3b]
;;;356    
;;;357    	s_tBtn[KID_JOY_D].LongTime = 100;
000032  f8a03048          STRH     r3,[r0,#0x48]
;;;358    	s_tBtn[KID_JOY_D].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
000036  f880104b          STRB     r1,[r0,#0x4b]
;;;359    
;;;360    	s_tBtn[KID_JOY_L].LongTime = 100;
00003a  f8a03058          STRH     r3,[r0,#0x58]
;;;361    	s_tBtn[KID_JOY_L].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
00003e  f880105b          STRB     r1,[r0,#0x5b]
;;;362    
;;;363    	s_tBtn[KID_JOY_R].LongTime = 100;
000042  f8a03068          STRH     r3,[r0,#0x68]
;;;364    	s_tBtn[KID_JOY_R].RepeatSpeed = 5;	/* 每隔50ms自动发送键值 */
000046  f880106b          STRB     r1,[r0,#0x6b]
;;;365    
;;;366    	/* 判断按键按下的函数 */
;;;367    	s_tBtn[0].IsKeyDownFunc = IsKeyDown1;
00004a  490d              LDR      r1,|L18.128|
00004c  f8401b2c          STR      r1,[r0],#0x2c  ; s_tBtn
;;;368    	s_tBtn[1].IsKeyDownFunc = IsKeyDown2;
000050  490c              LDR      r1,|L18.132|
000052  f8401c1c          STR      r1,[r0,#-0x1c]  ; s_tBtn
;;;369    	s_tBtn[2].IsKeyDownFunc = IsKeyDown3;
000056  490c              LDR      r1,|L18.136|
000058  f8401c0c          STR      r1,[r0,#-0xc]  ; s_tBtn
;;;370    	s_tBtn[3].IsKeyDownFunc = IsKeyDown4;
00005c  490b              LDR      r1,|L18.140|
;;;371    	s_tBtn[4].IsKeyDownFunc = IsKeyDown5;
00005e  6041              STR      r1,[r0,#4]  ; s_tBtn
000060  490b              LDR      r1,|L18.144|
;;;372    	s_tBtn[5].IsKeyDownFunc = IsKeyDown6;
000062  6141              STR      r1,[r0,#0x14]  ; s_tBtn
000064  490b              LDR      r1,|L18.148|
;;;373    	s_tBtn[6].IsKeyDownFunc = IsKeyDown7;
000066  6241              STR      r1,[r0,#0x24]  ; s_tBtn
000068  490b              LDR      r1,|L18.152|
;;;374    	s_tBtn[7].IsKeyDownFunc = IsKeyDown8;
00006a  6341              STR      r1,[r0,#0x34]  ; s_tBtn
00006c  490b              LDR      r1,|L18.156|
;;;375    
;;;376    	/* 组合键 */
;;;377    	s_tBtn[8].IsKeyDownFunc = IsKeyDown9;
00006e  6441              STR      r1,[r0,#0x44]  ; s_tBtn
000070  490b              LDR      r1,|L18.160|
;;;378    	s_tBtn[9].IsKeyDownFunc = IsKeyDown10;
000072  6541              STR      r1,[r0,#0x54]  ; s_tBtn
000074  490b              LDR      r1,|L18.164|
000076  6641              STR      r1,[r0,#0x64]  ; s_tBtn
;;;379    }
000078  bd30              POP      {r4,r5,pc}
;;;380    
                          ENDP

00007a  0000              DCW      0x0000
                  |L18.124|
                          DCD      ||.bss||+0xa0
                  |L18.128|
                          DCD      IsKeyDown1
                  |L18.132|
                          DCD      IsKeyDown2
                  |L18.136|
                          DCD      IsKeyDown3
                  |L18.140|
                          DCD      IsKeyDown4
                  |L18.144|
                          DCD      IsKeyDown5
                  |L18.148|
                          DCD      IsKeyDown6
                  |L18.152|
                          DCD      IsKeyDown7
                  |L18.156|
                          DCD      IsKeyDown8
                  |L18.160|
                          DCD      IsKeyDown9
                  |L18.164|
                          DCD      IsKeyDown10

                          AREA ||i.bsp_KeyScan||, CODE, READONLY, ALIGN=1

                  bsp_KeyScan PROC
;;;481    */
;;;482    void bsp_KeyScan(void)
000000  b510              PUSH     {r4,lr}
;;;483    {
;;;484    	uint8_t i;
;;;485    
;;;486    	for (i = 0; i < KEY_COUNT; i++)
000002  2400              MOVS     r4,#0
                  |L19.4|
;;;487    	{
;;;488    		bsp_DetectKey(i);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       bsp_DetectKey
00000a  1c64              ADDS     r4,r4,#1
00000c  b2e4              UXTB     r4,r4                 ;486
00000e  2c0a              CMP      r4,#0xa               ;486
000010  d3f8              BCC      |L19.4|
;;;489    	}
;;;490    }
000012  bd10              POP      {r4,pc}
;;;491    
                          ENDP


                          AREA ||i.bsp_PutKey||, CODE, READONLY, ALIGN=2

                  bsp_PutKey PROC
;;;170    */
;;;171    void bsp_PutKey(uint8_t _KeyCode)
000000  4905              LDR      r1,|L20.24|
;;;172    {
;;;173    	s_tKey.Buf[s_tKey.Write] = _KeyCode;
000002  7aca              LDRB     r2,[r1,#0xb]  ; s_tKey
000004  5488              STRB     r0,[r1,r2]
;;;174    
;;;175    	if (++s_tKey.Write  >= KEY_FIFO_SIZE)
000006  7ac8              LDRB     r0,[r1,#0xb]  ; s_tKey
000008  1c40              ADDS     r0,r0,#1
00000a  b2c0              UXTB     r0,r0
00000c  72c8              STRB     r0,[r1,#0xb]
00000e  280a              CMP      r0,#0xa
000010  d301              BCC      |L20.22|
;;;176    	{
;;;177    		s_tKey.Write = 0;
000012  2000              MOVS     r0,#0
000014  72c8              STRB     r0,[r1,#0xb]
                  |L20.22|
;;;178    	}
;;;179    }
000016  4770              BX       lr
;;;180    
                          ENDP

                  |L20.24|
                          DCD      ||.bss||+0xa0

                          AREA ||i.bsp_SetKeyParam||, CODE, READONLY, ALIGN=2

                  bsp_SetKeyParam PROC
;;;259    */
;;;260    void bsp_SetKeyParam(uint8_t _ucKeyID, uint16_t _LongTime, uint8_t  _RepeatSpeed)
000000  4b03              LDR      r3,|L21.16|
;;;261    {
;;;262    	s_tBtn[_ucKeyID].LongTime = _LongTime;			/* 长按时间 0 表示不检测长按键事件 */
000002  eb031000          ADD      r0,r3,r0,LSL #4
000006  8101              STRH     r1,[r0,#8]
;;;263    	s_tBtn[_ucKeyID].RepeatSpeed = _RepeatSpeed;	/* 按键连发的速度，0表示不支持连发 */
000008  72c2              STRB     r2,[r0,#0xb]
;;;264    	s_tBtn[_ucKeyID].RepeatCount = 0;				/* 连发计数器 */
00000a  2100              MOVS     r1,#0
00000c  7301              STRB     r1,[r0,#0xc]
;;;265    }
00000e  4770              BX       lr
;;;266    
                          ENDP

                  |L21.16|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  s_tBtn
                          %        160
                  s_tKey
                          %        13

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_key.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_dc6aca1d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___9_bsp_key_c_dc6aca1d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___9_bsp_key_c_dc6aca1d____REVSH|
#line 128
|__asm___9_bsp_key_c_dc6aca1d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
