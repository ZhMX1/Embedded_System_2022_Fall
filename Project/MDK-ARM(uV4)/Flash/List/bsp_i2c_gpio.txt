; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_i2c_gpio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_i2c_gpio.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_i2c_gpio.crf ..\..\User\bsp\src\bsp_i2c_gpio.c]
                          THUMB

                          AREA ||i.bsp_InitI2C||, CODE, READONLY, ALIGN=2

                  bsp_InitI2C PROC
;;;61     */
;;;62     void bsp_InitI2C(void)
000000  b538              PUSH     {r3-r5,lr}
;;;63     {
;;;64     	GPIO_InitTypeDef GPIO_InitStructure;
;;;65     
;;;66     	RCC_APB2PeriphClockCmd(RCC_I2C_PORT, ENABLE);	/* 打开GPIO时钟 */
000002  2101              MOVS     r1,#1
000004  2008              MOVS     r0,#8
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;67     
;;;68     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00000a  2003              MOVS     r0,#3
00000c  f88d0002          STRB     r0,[sp,#2]
;;;69     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;	/* 开漏输出模式 */
000010  2014              MOVS     r0,#0x14
000012  f88d0003          STRB     r0,[sp,#3]
;;;70     	
;;;71     	GPIO_InitStructure.GPIO_Pin = PIN_I2C_SCL;
000016  2040              MOVS     r0,#0x40
;;;72     	GPIO_Init(PORT_I2C_SCL, &GPIO_InitStructure);
000018  4c08              LDR      r4,|L1.60|
00001a  f8ad0000          STRH     r0,[sp,#0]            ;71
00001e  4669              MOV      r1,sp
000020  4620              MOV      r0,r4
000022  f7fffffe          BL       GPIO_Init
;;;73     
;;;74     	GPIO_InitStructure.GPIO_Pin = PIN_I2C_SDA;
000026  2080              MOVS     r0,#0x80
000028  f8ad0000          STRH     r0,[sp,#0]
;;;75     	GPIO_Init(PORT_I2C_SDA, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;76     
;;;77     	/* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;78     	i2c_Stop();
000034  f7fffffe          BL       i2c_Stop
;;;79     }
000038  bd38              POP      {r3-r5,pc}
;;;80     
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0x40010c00

                          AREA ||i.i2c_Ack||, CODE, READONLY, ALIGN=2

                  i2c_Ack PROC
;;;245    */
;;;246    void i2c_Ack(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;247    {
;;;248    	I2C_SDA_0();	/* CPU驱动SDA = 0 */
000004  4d07              LDR      r5,|L2.36|
000006  2480              MOVS     r4,#0x80
000008  602c              STR      r4,[r5,#0]
;;;249    	i2c_Delay();
00000a  f7fffffe          BL       i2c_Delay
;;;250    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000e  1f2f              SUBS     r7,r5,#4
000010  2640              MOVS     r6,#0x40
000012  603e              STR      r6,[r7,#0]
;;;251    	i2c_Delay();
000014  f7fffffe          BL       i2c_Delay
;;;252    	I2C_SCL_0();
000018  602e              STR      r6,[r5,#0]
;;;253    	i2c_Delay();
00001a  f7fffffe          BL       i2c_Delay
;;;254    	I2C_SDA_1();	/* CPU释放SDA总线 */
00001e  603c              STR      r4,[r7,#0]
;;;255    }
000020  e8bd81f0          POP      {r4-r8,pc}
;;;256    
                          ENDP

                  |L2.36|
                          DCD      0x40010c14

                          AREA ||i.i2c_CheckDevice||, CODE, READONLY, ALIGN=2

                  i2c_CheckDevice PROC
;;;282    */
;;;283    uint8_t i2c_CheckDevice(uint8_t _Address)
000000  b510              PUSH     {r4,lr}
;;;284    {
;;;285    	uint8_t ucAck;
;;;286    
;;;287    	if (I2C_SDA_READ() && I2C_SCL_READ())
000002  490b              LDR      r1,|L3.48|
000004  4604              MOV      r4,r0                 ;284
000006  6808              LDR      r0,[r1,#0]
000008  0600              LSLS     r0,r0,#24
00000a  d50e              BPL      |L3.42|
00000c  6808              LDR      r0,[r1,#0]
00000e  0640              LSLS     r0,r0,#25
000010  d50b              BPL      |L3.42|
;;;288    	{
;;;289    		i2c_Start();		/* 发送启动信号 */
000012  f7fffffe          BL       i2c_Start
;;;290    
;;;291    		/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;292    		i2c_SendByte(_Address | I2C_WR);
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       i2c_SendByte
;;;293    		ucAck = i2c_WaitAck();	/* 检测设备的ACK应答 */
00001c  f7fffffe          BL       i2c_WaitAck
000020  4604              MOV      r4,r0
;;;294    
;;;295    		i2c_Stop();			/* 发送停止信号 */
000022  f7fffffe          BL       i2c_Stop
;;;296    
;;;297    		return ucAck;
000026  4620              MOV      r0,r4
;;;298    	}
;;;299    	return 1;	/* I2C总线异常 */
;;;300    }
000028  bd10              POP      {r4,pc}
                  |L3.42|
00002a  2001              MOVS     r0,#1                 ;299
00002c  bd10              POP      {r4,pc}
;;;301    
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      0x40010c08

                          AREA ||i.i2c_Delay||, CODE, READONLY, ALIGN=1

                  i2c_Delay PROC
;;;88     */
;;;89     static void i2c_Delay(void)
000000  2000              MOVS     r0,#0
                  |L4.2|
;;;90     {
;;;91     	uint8_t i;
;;;92     
;;;93     	/*　
;;;94     		CPU主频72MHz时，在内部Flash运行, MDK工程不优化。用台式示波器观测波形。
;;;95     		循环次数为30时，SCL频率 = 440KHz， SCL高电平时间4us，SCL低电平时间8us
;;;96     
;;;97     		上拉电阻选择2.2K欧时，SCL上升沿时间约0.5us，如果选4.7K欧，则上升沿约1us
;;;98     
;;;99     		实际应用选择400KHz左右的速率即可
;;;100    	*/
;;;101    	for (i = 0; i < 8; i++);
000002  1c40              ADDS     r0,r0,#1
000004  b2c0              UXTB     r0,r0
000006  2808              CMP      r0,#8
000008  d3fb              BCC      |L4.2|
;;;102    }
00000a  4770              BX       lr
;;;103    
                          ENDP


                          AREA ||i.i2c_NAck||, CODE, READONLY, ALIGN=2

                  i2c_NAck PROC
;;;264    */
;;;265    void i2c_NAck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
;;;267    	I2C_SDA_1();	/* CPU驱动SDA = 1 */
000002  4c07              LDR      r4,|L5.32|
000004  2080              MOVS     r0,#0x80
000006  6020              STR      r0,[r4,#0]
;;;268    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;269    	I2C_SCL_1();	/* CPU产生1个时钟 */
00000c  2540              MOVS     r5,#0x40
00000e  6025              STR      r5,[r4,#0]
;;;270    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;271    	I2C_SCL_0();
000014  1d20              ADDS     r0,r4,#4
000016  6005              STR      r5,[r0,#0]
;;;272    	i2c_Delay();
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f7ffbffe          B.W      i2c_Delay
;;;273    }
;;;274    
                          ENDP

                  |L5.32|
                          DCD      0x40010c10

                          AREA ||i.i2c_ReadByte||, CODE, READONLY, ALIGN=2

                  i2c_ReadByte PROC
;;;186    */
;;;187    uint8_t i2c_ReadByte(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;188    {
;;;189    	uint8_t i;
;;;190    	uint8_t value;
;;;191    
;;;192    	/* 读到第1个bit为数据的bit7 */
;;;193    	value = 0;
000004  2400              MOVS     r4,#0
;;;194    	for (i = 0; i < 8; i++)
;;;195    	{
;;;196    		value <<= 1;
;;;197    		I2C_SCL_1();
000006  4f0f              LDR      r7,|L6.68|
;;;198    		i2c_Delay();
;;;199    		if (I2C_SDA_READ())
000008  f8df8038          LDR      r8,|L6.68|
00000c  4625              MOV      r5,r4                 ;194
00000e  f1a80808          SUB      r8,r8,#8
000012  2640              MOVS     r6,#0x40              ;197
;;;200    		{
;;;201    			value++;
;;;202    		}
;;;203    		I2C_SCL_0();
000014  f1070904          ADD      r9,r7,#4
                  |L6.24|
000018  0660              LSLS     r0,r4,#25             ;196
00001a  0e04              LSRS     r4,r0,#24             ;196
00001c  603e              STR      r6,[r7,#0]            ;197
00001e  f7fffffe          BL       i2c_Delay
000022  f8d80000          LDR      r0,[r8,#0]            ;199
000026  0600              LSLS     r0,r0,#24             ;199
000028  d501              BPL      |L6.46|
00002a  1c64              ADDS     r4,r4,#1              ;199
00002c  b2e4              UXTB     r4,r4                 ;201
                  |L6.46|
00002e  f8c96000          STR      r6,[r9,#0]
;;;204    		i2c_Delay();
000032  f7fffffe          BL       i2c_Delay
000036  1c6d              ADDS     r5,r5,#1
000038  b2ed              UXTB     r5,r5                 ;194
00003a  2d08              CMP      r5,#8                 ;194
00003c  d3ec              BCC      |L6.24|
;;;205    	}
;;;206    	return value;
00003e  4620              MOV      r0,r4
;;;207    }
000040  e8bd87f0          POP      {r4-r10,pc}
;;;208    
                          ENDP

                  |L6.68|
                          DCD      0x40010c10

                          AREA ||i.i2c_SendByte||, CODE, READONLY, ALIGN=2

                  i2c_SendByte PROC
;;;150    */
;;;151    void i2c_SendByte(uint8_t _ucByte)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;152    {
;;;153    	uint8_t i;
;;;154    
;;;155    	/* 先发送字节的高位bit7 */
;;;156    	for (i = 0; i < 8; i++)
;;;157    	{
;;;158    		if (_ucByte & 0x80)
;;;159    		{
;;;160    			I2C_SDA_1();
;;;161    		}
;;;162    		else
;;;163    		{
;;;164    			I2C_SDA_0();
000004  f8df9044          LDR      r9,|L7.76|
000008  2400              MOVS     r4,#0                 ;156
00000a  4605              MOV      r5,r0                 ;152
;;;165    		}
;;;166    		i2c_Delay();
;;;167    		I2C_SCL_1();
00000c  2740              MOVS     r7,#0x40
00000e  f04f0880          MOV      r8,#0x80              ;160
000012  f1a90604          SUB      r6,r9,#4              ;160
                  |L7.22|
000016  0628              LSLS     r0,r5,#24             ;158
000018  4640              MOV      r0,r8                 ;164
00001a  d501              BPL      |L7.32|
00001c  6030              STR      r0,[r6,#0]            ;160
00001e  e001              B        |L7.36|
                  |L7.32|
000020  f8c90000          STR      r0,[r9,#0]            ;164
                  |L7.36|
000024  f7fffffe          BL       i2c_Delay
000028  6037              STR      r7,[r6,#0]
;;;168    		i2c_Delay();
00002a  f7fffffe          BL       i2c_Delay
;;;169    		I2C_SCL_0();
00002e  f8c97000          STR      r7,[r9,#0]
;;;170    		if (i == 7)
000032  2c07              CMP      r4,#7
000034  d101              BNE      |L7.58|
;;;171    		{
;;;172    			 I2C_SDA_1(); // 释放总线
000036  f8c68000          STR      r8,[r6,#0]
                  |L7.58|
;;;173    		}
;;;174    		_ucByte <<= 1;	/* 左移一个bit */
00003a  0668              LSLS     r0,r5,#25
00003c  1c64              ADDS     r4,r4,#1
00003e  0e05              LSRS     r5,r0,#24
000040  b2e4              UXTB     r4,r4                 ;156
000042  2c08              CMP      r4,#8                 ;156
000044  d3e7              BCC      |L7.22|
;;;175    		//i2c_Delay();
;;;176    	}
;;;177    }
000046  e8bd87f0          POP      {r4-r10,pc}
;;;178    
                          ENDP

00004a  0000              DCW      0x0000
                  |L7.76|
                          DCD      0x40010c14

                          AREA ||i.i2c_Start||, CODE, READONLY, ALIGN=2

                  i2c_Start PROC
;;;111    */
;;;112    void i2c_Start(void)
000000  b570              PUSH     {r4-r6,lr}
;;;113    {
;;;114    	/* 当SCL高电平时，SDA出现一个下跳沿表示I2C总线启动信号 */
;;;115    	I2C_SDA_1();
000002  4808              LDR      r0,|L8.36|
000004  2580              MOVS     r5,#0x80
000006  6005              STR      r5,[r0,#0]
;;;116    	I2C_SCL_1();
000008  2440              MOVS     r4,#0x40
00000a  6004              STR      r4,[r0,#0]
;;;117    	i2c_Delay();
00000c  f7fffffe          BL       i2c_Delay
;;;118    	I2C_SDA_0();
000010  4e04              LDR      r6,|L8.36|
000012  1d36              ADDS     r6,r6,#4
000014  6035              STR      r5,[r6,#0]
;;;119    	i2c_Delay();
000016  f7fffffe          BL       i2c_Delay
;;;120    	
;;;121    	I2C_SCL_0();
00001a  6034              STR      r4,[r6,#0]
;;;122    	i2c_Delay();
00001c  e8bd4070          POP      {r4-r6,lr}
000020  f7ffbffe          B.W      i2c_Delay
;;;123    }
;;;124    
                          ENDP

                  |L8.36|
                          DCD      0x40010c10

                          AREA ||i.i2c_Stop||, CODE, READONLY, ALIGN=2

                  i2c_Stop PROC
;;;132    */
;;;133    void i2c_Stop(void)
000000  b570              PUSH     {r4-r6,lr}
;;;134    {
;;;135    	/* 当SCL高电平时，SDA出现一个上跳沿表示I2C总线停止信号 */
;;;136    	I2C_SDA_0();
000002  4807              LDR      r0,|L9.32|
000004  2480              MOVS     r4,#0x80
000006  6004              STR      r4,[r0,#0]
;;;137    	I2C_SCL_1();
000008  4d05              LDR      r5,|L9.32|
00000a  2040              MOVS     r0,#0x40
00000c  1f2d              SUBS     r5,r5,#4
00000e  6028              STR      r0,[r5,#0]
;;;138    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;139    	I2C_SDA_1();
000014  602c              STR      r4,[r5,#0]
;;;140    	i2c_Delay();
000016  e8bd4070          POP      {r4-r6,lr}
00001a  f7ffbffe          B.W      i2c_Delay
;;;141    }
;;;142    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      0x40010c14

                          AREA ||i.i2c_WaitAck||, CODE, READONLY, ALIGN=2

                  i2c_WaitAck PROC
;;;216    */
;;;217    uint8_t i2c_WaitAck(void)
000000  b570              PUSH     {r4-r6,lr}
;;;218    {
;;;219    	uint8_t re;
;;;220    
;;;221    	I2C_SDA_1();	/* CPU释放SDA总线 */
000002  4c0c              LDR      r4,|L10.52|
000004  2080              MOVS     r0,#0x80
000006  6020              STR      r0,[r4,#0]
;;;222    	i2c_Delay();
000008  f7fffffe          BL       i2c_Delay
;;;223    	I2C_SCL_1();	/* CPU驱动SCL = 1, 此时器件会返回ACK应答 */
00000c  2540              MOVS     r5,#0x40
00000e  6025              STR      r5,[r4,#0]
;;;224    	i2c_Delay();
000010  f7fffffe          BL       i2c_Delay
;;;225    	if (I2C_SDA_READ())	/* CPU读取SDA口线状态 */
000014  4807              LDR      r0,|L10.52|
000016  3808              SUBS     r0,r0,#8
000018  6800              LDR      r0,[r0,#0]
00001a  0600              LSLS     r0,r0,#24
00001c  d501              BPL      |L10.34|
;;;226    	{
;;;227    		re = 1;
00001e  2401              MOVS     r4,#1
000020  e000              B        |L10.36|
                  |L10.34|
;;;228    	}
;;;229    	else
;;;230    	{
;;;231    		re = 0;
000022  2400              MOVS     r4,#0
                  |L10.36|
;;;232    	}
;;;233    	I2C_SCL_0();
000024  4803              LDR      r0,|L10.52|
000026  1d00              ADDS     r0,r0,#4
000028  6005              STR      r5,[r0,#0]
;;;234    	i2c_Delay();
00002a  f7fffffe          BL       i2c_Delay
;;;235    	return re;
00002e  4620              MOV      r0,r4
;;;236    }
000030  bd70              POP      {r4-r6,pc}
;;;237    
                          ENDP

000032  0000              DCW      0x0000
                  |L10.52|
                          DCD      0x40010c10

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_i2c_gpio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_bsp_i2c_gpio_c_ec180c52____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH|
#line 128
|__asm___14_bsp_i2c_gpio_c_ec180c52____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
