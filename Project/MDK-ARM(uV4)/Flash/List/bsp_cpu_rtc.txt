; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_cpu_rtc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_cpu_rtc.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_cpu_rtc.crf ..\..\User\bsp\src\bsp_cpu_rtc.c]
                          THUMB

                          AREA ||i.Is_Leap_Year||, CODE, READONLY, ALIGN=1

                  Is_Leap_Year PROC
;;;140    */
;;;141    static uint8_t Is_Leap_Year(uint16_t _year)
000000  0781              LSLS     r1,r0,#30
;;;142    {                     
000002  d10c              BNE      |L1.30|
;;;143    	if (_year % 4 == 0) /* 必须能被4整除 */
;;;144    	{ 
;;;145    		if (_year % 100 == 0) 
000004  2164              MOVS     r1,#0x64
000006  fbb0f2f1          UDIV     r2,r0,r1
00000a  fb010112          MLS      r1,r1,r2,r0
00000e  b941              CBNZ     r1,|L1.34|
;;;146    		{ 
;;;147    			if (_year % 400 == 0)
000010  f44f71c8          MOV      r1,#0x190
000014  fbb0f2f1          UDIV     r2,r0,r1
000018  fb010012          MLS      r0,r1,r2,r0
00001c  b108              CBZ      r0,|L1.34|
                  |L1.30|
;;;148    			{
;;;149    				return 1;	/* 如果以00结尾,还要能被400整除 */
;;;150    			}
;;;151    			else 
;;;152    			{
;;;153    				return 0;   
;;;154    			}
;;;155    
;;;156    		}
;;;157    		else 
;;;158    		{
;;;159    			return 1;   
;;;160    		}
;;;161    	}
;;;162    	else 
;;;163    	{
;;;164    		return 0; 
00001e  2000              MOVS     r0,#0
;;;165    	}
;;;166    }      
000020  4770              BX       lr
                  |L1.34|
000022  2001              MOVS     r0,#1                 ;159
000024  4770              BX       lr
;;;167    
                          ENDP


                          AREA ||i.RTC_CalcWeek||, CODE, READONLY, ALIGN=1

                  RTC_CalcWeek PROC
;;;325    */
;;;326    uint8_t RTC_CalcWeek(uint16_t _year, uint8_t _mon, uint8_t _day)
000000  b510              PUSH     {r4,lr}
;;;327    {
;;;328    	/*
;;;329    	蔡勒（Zeller）公式
;;;330    		历史上的某一天是星期几？未来的某一天是星期几？关于这个问题，有很多计算公式（两个通用计算公式和
;;;331    	一些分段计算公式），其中最著名的是蔡勒（Zeller）公式。
;;;332    	    即w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1
;;;333    
;;;334    		公式中的符号含义如下，
;;;335    	     w：星期；
;;;336    	     c：年的高2位，即世纪-1
;;;337    	     y：年（两位数）；
;;;338    	     m：月（m大于等于3，小于等于14，即在蔡勒公式中，某年的1、2月要看作上一年的13、14月来计算，
;;;339    	  	    比如2003年1月1日要看作2002年的13月1日来计算）；
;;;340    	     d：日；
;;;341    	     [ ]代表取整，即只要整数部分。
;;;342    
;;;343    	    算出来的W除以7，余数是几就是星期几。如果余数是0，则为星期日。
;;;344            如果结果是负数，负数求余数则需要特殊处理：
;;;345                负数不能按习惯的余数的概念求余数，只能按数论中的余数的定义求余。为了方便
;;;346            计算，我们可以给它加上一个7的整数倍，使它变为一个正数，然后再求余数
;;;347    
;;;348    		以2049年10月1日（100周年国庆）为例，用蔡勒（Zeller）公式进行计算，过程如下：
;;;349    		蔡勒（Zeller）公式：w=y+[y/4]+[c/4]-2c+[26(m+1)/10]+d-1
;;;350    		=49+[49/4]+[20/4]-2×20+[26× (10+1)/10]+1-1
;;;351    		=49+[12.25]+5-40+[28.6]
;;;352    		=49+12+5-40+28
;;;353    		=54 (除以7余5)
;;;354    		即2049年10月1日（100周年国庆）是星期5。
;;;355    	*/
;;;356    	uint8_t y, c, m, d;
;;;357    	int16_t w;
;;;358    
;;;359    	if (_mon >= 3)
;;;360    	{
;;;361    		m = _mon;
;;;362    		y = _year % 100;
000002  2364              MOVS     r3,#0x64
000004  2903              CMP      r1,#3                 ;359
000006  d306              BCC      |L2.22|
000008  fbb0f4f3          UDIV     r4,r0,r3
00000c  fb030414          MLS      r4,r3,r4,r0
;;;363    		c = _year / 100;
000010  fbb0f0f3          UDIV     r0,r0,r3
;;;364    		d = _day;
000014  e009              B        |L2.42|
                  |L2.22|
000016  310c              ADDS     r1,r1,#0xc
;;;365    	}
;;;366    	else	/* 某年的1、2月要看作上一年的13、14月来计算 */
;;;367    	{
;;;368    		m = _mon + 12;
000018  1e40              SUBS     r0,r0,#1
;;;369    		y = (_year - 1) % 100;
00001a  fb90f4f3          SDIV     r4,r0,r3
00001e  fb030414          MLS      r4,r3,r4,r0
;;;370    		c = (_year - 1) / 100;
000022  fb90f0f3          SDIV     r0,r0,r3
000026  b2c9              UXTB     r1,r1                 ;368
000028  b2e4              UXTB     r4,r4                 ;369
                  |L2.42|
;;;371    		d = _day;
;;;372    	}
;;;373    
;;;374    	w = y + y / 4 +  c / 4 - 2 * c + ((uint16_t)26*(m+1))/10 + d - 1;
00002a  231a              MOVS     r3,#0x1a
00002c  1c49              ADDS     r1,r1,#1
00002e  4359              MULS     r1,r3,r1
000030  230a              MOVS     r3,#0xa
000032  fbb1f1f3          UDIV     r1,r1,r3
000036  b2c0              UXTB     r0,r0                 ;370
000038  eb040394          ADD      r3,r4,r4,LSR #2
00003c  eb030390          ADD      r3,r3,r0,LSR #2
000040  4240              RSBS     r0,r0,#0
000042  eb030040          ADD      r0,r3,r0,LSL #1
000046  4408              ADD      r0,r0,r1
000048  4410              ADD      r0,r0,r2
00004a  1e40              SUBS     r0,r0,#1
00004c  b200              SXTH     r0,r0
;;;375    	if (w == 0)
;;;376    	{
;;;377    		w = 7;	/* 表示周日 */
00004e  2107              MOVS     r1,#7
000050  2800              CMP      r0,#0                 ;375
000052  d00a              BEQ      |L2.106|
;;;378    	}
;;;379    	else if (w < 0)	/* 如果w是负数，则计算余数方式不同 */
000054  da0c              BGE      |L2.112|
;;;380    	{
;;;381    		w = 7 - (-w) % 7;
000056  f1c00000          RSB      r0,r0,#0
00005a  fb90f2f1          SDIV     r2,r0,r1
00005e  fb010012          MLS      r0,r1,r2,r0
000062  f1c00007          RSB      r0,r0,#7
000066  b200              SXTH     r0,r0
000068  e006              B        |L2.120|
                  |L2.106|
00006a  f04f0007          MOV      r0,#7                 ;377
00006e  e003              B        |L2.120|
                  |L2.112|
;;;382    	}
;;;383    	else
;;;384    	{
;;;385    		w = w % 7;
000070  fb90f2f1          SDIV     r2,r0,r1
000074  fb010012          MLS      r0,r1,r2,r0
                  |L2.120|
;;;386    	}
;;;387    	return w;
000078  b2c0              UXTB     r0,r0
;;;388    }
00007a  bd10              POP      {r4,pc}
;;;389    
                          ENDP


                          AREA ||i.RTC_ReadClock||, CODE, READONLY, ALIGN=2

                  RTC_ReadClock PROC
;;;236    */
;;;237    void RTC_ReadClock(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;238    {
;;;239    	static uint16_t daycnt = 0;
;;;240    	uint32_t timecount = 0; 
;;;241    	uint32_t temp = 0;
;;;242    	uint16_t temp1 = 0;
;;;243    
;;;244    	timecount = RTC_GetCounter();     
000004  f7fffffe          BL       RTC_GetCounter
;;;245    
;;;246    	temp = timecount / 86400;   /* 得到天数 */
000008  f8df80bc          LDR      r8,|L3.200|
00000c  4607              MOV      r7,r0                 ;244
00000e  fbb0f4f8          UDIV     r4,r0,r8
;;;247    
;;;248    	if (daycnt != temp)	/* 超过一天了 */
000012  482e              LDR      r0,|L3.204|
;;;249    	{       
;;;250    		daycnt = temp;
;;;251    		temp1 = 1970;  /* 从1970年开始 */
;;;252    
;;;253    		while (temp >= 365)
;;;254    		{                          
;;;255    			if (Is_Leap_Year(temp1))	/* 是闰年 */
;;;256    			{
;;;257    				if (temp >= 366)
;;;258    				{
;;;259    					temp -= 366;		/* 闰年的秒钟数 */
;;;260    				}
;;;261    				else
;;;262    				{
;;;263    					//temp1++;		/* armfly: 这里闰年处理错误，不能加1 */
;;;264    					break;
;;;265    				}  
;;;266                }
;;;267    			else 
;;;268    			{
;;;269    				temp -= 365;       /* 平年 */
;;;270    			}
;;;271    			temp1++;  
;;;272    		}   
;;;273    		g_tRTC.Year = temp1;	/* 得到年份 */
000014  1c85              ADDS     r5,r0,#2
000016  8801              LDRH     r1,[r0,#0]            ;248  ; daycnt
000018  42a1              CMP      r1,r4                 ;248
00001a  d02e              BEQ      |L3.122|
00001c  8004              STRH     r4,[r0,#0]            ;250
00001e  f24076b2          MOV      r6,#0x7b2             ;251
000022  f44f7ab7          MOV      r10,#0x16e            ;257
000026  f44f79b6          MOV      r9,#0x16c             ;253
00002a  e00c              B        |L3.70|
                  |L3.44|
00002c  4630              MOV      r0,r6                 ;255
00002e  f7fffffe          BL       Is_Leap_Year
000032  b120              CBZ      r0,|L3.62|
000034  4554              CMP      r4,r10                ;257
000036  d308              BCC      |L3.74|
000038  f5a474b7          SUB      r4,r4,#0x16e          ;257
00003c  e001              B        |L3.66|
                  |L3.62|
00003e  f2a4146d          SUB      r4,r4,#0x16d          ;259
                  |L3.66|
000042  1c76              ADDS     r6,r6,#1              ;259
000044  b2b6              UXTH     r6,r6                 ;271
                  |L3.70|
000046  454c              CMP      r4,r9                 ;253
000048  d8f0              BHI      |L3.44|
                  |L3.74|
00004a  802e              STRH     r6,[r5,#0]
;;;274    		
;;;275    		temp1 = 0;
00004c  2600              MOVS     r6,#0
;;;276    		while (temp >= 28)	/* 超过了一个月 */
;;;277    		{
;;;278    			if(Is_Leap_Year(g_tRTC.Year) && temp1 == 1)	/* 当年是不是闰年/2月份 */
;;;279    			{
;;;280    				if (temp >= 29)
;;;281    				{
;;;282    					temp -= 29;	/* 闰年的秒钟数 */
;;;283    				}
;;;284    				else
;;;285    				{
;;;286    					break; 
;;;287    				}
;;;288                }
;;;289                else 
;;;290    			{
;;;291    				if (temp >= mon_table[temp1])
00004e  f8df9080          LDR      r9,|L3.208|
000052  e00c              B        |L3.110|
                  |L3.84|
000054  8828              LDRH     r0,[r5,#0]            ;278  ; g_tRTC
000056  f7fffffe          BL       Is_Leap_Year
00005a  b108              CBZ      r0,|L3.96|
00005c  2e01              CMP      r6,#1                 ;278
00005e  d02e              BEQ      |L3.190|
                  |L3.96|
000060  f8190006          LDRB     r0,[r9,r6]
000064  42a0              CMP      r0,r4
000066  d804              BHI      |L3.114|
;;;292    				{
;;;293    					temp -= mon_table[temp1];	/* 平年 */
000068  1a24              SUBS     r4,r4,r0
                  |L3.106|
00006a  1c76              ADDS     r6,r6,#1
;;;294    				}
;;;295    				else 
;;;296    				{
;;;297    					break;
;;;298    				}
;;;299    			}
;;;300    			temp1++;  
00006c  b2b6              UXTH     r6,r6
                  |L3.110|
00006e  2c1c              CMP      r4,#0x1c              ;276
000070  d2f0              BCS      |L3.84|
                  |L3.114|
000072  1c76              ADDS     r6,r6,#1              ;276
;;;301    		}
;;;302    		g_tRTC.Mon = temp1 + 1;	/* 得到月份 */
000074  70ae              STRB     r6,[r5,#2]
000076  1c64              ADDS     r4,r4,#1
;;;303    		g_tRTC.Day = temp + 1;  /* 得到日期 */
000078  70ec              STRB     r4,[r5,#3]
                  |L3.122|
;;;304    	}
;;;305    
;;;306    	temp = timecount % 86400;    /* 得到秒钟数 */
00007a  fbb7f1f8          UDIV     r1,r7,r8
00007e  fb087011          MLS      r0,r8,r1,r7
;;;307    
;;;308    	g_tRTC.Hour = temp / 3600;	/* 小时 */
000082  f44f6161          MOV      r1,#0xe10
000086  fbb0f2f1          UDIV     r2,r0,r1
00008a  712a              STRB     r2,[r5,#4]
;;;309    
;;;310    	g_tRTC.Min = (temp % 3600) / 60; /* 分钟 */
00008c  fbb0f2f1          UDIV     r2,r0,r1
000090  fb010312          MLS      r3,r1,r2,r0
000094  223c              MOVS     r2,#0x3c
000096  fbb3f3f2          UDIV     r3,r3,r2
00009a  716b              STRB     r3,[r5,#5]
;;;311    
;;;312    	g_tRTC.Sec = (temp % 3600) % 60; /* 秒钟 */
00009c  fbb0f3f1          UDIV     r3,r0,r1
0000a0  fb010013          MLS      r0,r1,r3,r0
0000a4  fbb0f1f2          UDIV     r1,r0,r2
0000a8  fb020011          MLS      r0,r2,r1,r0
0000ac  71a8              STRB     r0,[r5,#6]
;;;313    
;;;314    	g_tRTC.Week = RTC_CalcWeek(g_tRTC.Year, g_tRTC.Mon, g_tRTC.Day);	/* 计算星期 */
0000ae  78ea              LDRB     r2,[r5,#3]  ; g_tRTC
0000b0  78a9              LDRB     r1,[r5,#2]  ; g_tRTC
0000b2  8828              LDRH     r0,[r5,#0]  ; g_tRTC
0000b4  f7fffffe          BL       RTC_CalcWeek
0000b8  71e8              STRB     r0,[r5,#7]
;;;315    }   
0000ba  e8bd87f0          POP      {r4-r10,pc}
                  |L3.190|
0000be  2c1d              CMP      r4,#0x1d              ;280
0000c0  d3d7              BCC      |L3.114|
0000c2  3c1d              SUBS     r4,r4,#0x1d           ;280
0000c4  e7d1              B        |L3.106|
;;;316    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L3.200|
                          DCD      0x00015180
                  |L3.204|
                          DCD      ||.data||
                  |L3.208|
                          DCD      ||.constdata||

                          AREA ||i.RTC_WriteClock||, CODE, READONLY, ALIGN=2

                  RTC_WriteClock PROC
;;;175    */
;;;176    uint8_t RTC_WriteClock(uint16_t _year, uint8_t _mon, uint8_t _day, uint8_t _hour, uint8_t _min, uint8_t _sec)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;177    {
000004  4606              MOV      r6,r0
;;;178    	uint16_t t;
;;;179    	uint32_t seccount=0;
000006  2400              MOVS     r4,#0
;;;180    
;;;181    	if (_year < 2000 || _year > 2099)
000008  f5a060fa          SUB      r0,r0,#0x7d0
00000c  469b              MOV      r11,r3                ;177
00000e  4692              MOV      r10,r2                ;177
000010  4689              MOV      r9,r1                 ;177
000012  2864              CMP      r0,#0x64
000014  d302              BCC      |L4.28|
;;;182    	{
;;;183    		return 0;	/* _year范围1970-2099，此处设置范围为2000-2099 */   
000016  2000              MOVS     r0,#0
                  |L4.24|
;;;184    	}		
;;;185    	
;;;186    	for (t = 1970; t < _year; t++) 	/* 把所有年份的秒钟相加 */
;;;187    	{
;;;188    		if (Is_Leap_Year(t))		/* 判断是否为闰年 */
;;;189    		{
;;;190    			seccount += 31622400;	/* 闰年的秒钟数 */
;;;191    		}
;;;192    		else
;;;193    		{
;;;194    			seccount += 31536000; 	/* 平年的秒钟数 */
;;;195    		}
;;;196    	}
;;;197    
;;;198    	_mon -= 1;
;;;199    
;;;200    	for (t = 0; t < _mon; t++)         /* 把前面月份的秒钟数相加 */
;;;201    	{
;;;202    		seccount += (uint32_t)mon_table[t] * 86400;	/* 月份秒钟数相加 */
;;;203    
;;;204    		if (Is_Leap_Year(_year) && t == 1)
;;;205    		{
;;;206    			seccount += 86400;	/* 闰年2月份增加一天的秒钟数 */
;;;207    		}			
;;;208    	}
;;;209    
;;;210    	seccount += (uint32_t)(_day - 1) * 86400;	/* 把前面日期的秒钟数相加 */
;;;211    
;;;212    	seccount += (uint32_t)_hour * 3600;		/* 小时秒钟数 */
;;;213    
;;;214    	seccount += (uint32_t)_min * 60;	/* 分钟秒钟数 */
;;;215    
;;;216    	seccount += _sec;	/* 最后的秒钟加上去 */
;;;217    																	
;;;218    	PWR_BackupAccessCmd(ENABLE);	/* 必须要 */
;;;219    
;;;220    	RTC_WaitForLastTask();
;;;221    
;;;222    	RTC_SetCounter(seccount);
;;;223    
;;;224    	RTC_WaitForLastTask();			/* 必须加 PWR_BackupAccessCmd(ENABLE); 不然进入死循环 */
;;;225    
;;;226    	return 1;      
;;;227    }
000018  e8bd9ff0          POP      {r4-r12,pc}
                  |L4.28|
00001c  f24075b2          MOV      r5,#0x7b2             ;186
000020  4f25              LDR      r7,|L4.184|
000022  f8df8098          LDR      r8,|L4.188|
000026  e008              B        |L4.58|
                  |L4.40|
000028  4628              MOV      r0,r5                 ;188
00002a  f7fffffe          BL       Is_Leap_Year
00002e  b108              CBZ      r0,|L4.52|
000030  443c              ADD      r4,r4,r7              ;190
000032  e000              B        |L4.54|
                  |L4.52|
000034  4444              ADD      r4,r4,r8              ;194
                  |L4.54|
000036  1c6d              ADDS     r5,r5,#1              ;194
000038  b2ad              UXTH     r5,r5                 ;186
                  |L4.58|
00003a  42b5              CMP      r5,r6                 ;186
00003c  d3f4              BCC      |L4.40|
00003e  f1a90001          SUB      r0,r9,#1              ;198
000042  b2c7              UXTB     r7,r0                 ;198
000044  2500              MOVS     r5,#0                 ;200
000046  f8df8078          LDR      r8,|L4.192|
00004a  f8df9078          LDR      r9,|L4.196|
00004e  e00f              B        |L4.112|
                  |L4.80|
000050  f8180005          LDRB     r0,[r8,r5]            ;202
000054  f24021a3          MOV      r1,#0x2a3             ;202
000058  4348              MULS     r0,r1,r0              ;202
00005a  eb0414c0          ADD      r4,r4,r0,LSL #7       ;202
00005e  4630              MOV      r0,r6                 ;204
000060  f7fffffe          BL       Is_Leap_Year
000064  b110              CBZ      r0,|L4.108|
000066  2d01              CMP      r5,#1                 ;204
000068  d100              BNE      |L4.108|
00006a  444c              ADD      r4,r4,r9              ;206
                  |L4.108|
00006c  1c6d              ADDS     r5,r5,#1              ;206
00006e  b2ad              UXTH     r5,r5                 ;200
                  |L4.112|
000070  42bd              CMP      r5,r7                 ;200
000072  d3ed              BCC      |L4.80|
000074  f24021a3          MOV      r1,#0x2a3             ;210
000078  fb0af001          MUL      r0,r10,r1             ;210
00007c  4911              LDR      r1,|L4.196|
00007e  eb0410c0          ADD      r0,r4,r0,LSL #7       ;210
000082  4249              RSBS     r1,r1,#0              ;210
000084  4408              ADD      r0,r0,r1              ;210
000086  ebcb124b          RSB      r2,r11,r11,LSL #5     ;212
00008a  ebc2210b          RSB      r1,r2,r11,LSL #8      ;212
00008e  eb001001          ADD      r0,r0,r1,LSL #4       ;212
000092  990a              LDR      r1,[sp,#0x28]         ;214
000094  ebc11101          RSB      r1,r1,r1,LSL #4       ;214
000098  eb000081          ADD      r0,r0,r1,LSL #2       ;214
00009c  990b              LDR      r1,[sp,#0x2c]         ;216
00009e  1844              ADDS     r4,r0,r1              ;216
0000a0  2001              MOVS     r0,#1                 ;218
0000a2  f7fffffe          BL       PWR_BackupAccessCmd
0000a6  f7fffffe          BL       RTC_WaitForLastTask
0000aa  4620              MOV      r0,r4                 ;222
0000ac  f7fffffe          BL       RTC_SetCounter
0000b0  f7fffffe          BL       RTC_WaitForLastTask
0000b4  2001              MOVS     r0,#1                 ;226
0000b6  e7af              B        |L4.24|
;;;228    
                          ENDP

                  |L4.184|
                          DCD      0x01e28500
                  |L4.188|
                          DCD      0x01e13380
                  |L4.192|
                          DCD      ||.constdata||
                  |L4.196|
                          DCD      0x00015180

                          AREA ||i.bsp_InitRTC||, CODE, READONLY, ALIGN=1

                  bsp_InitRTC PROC
;;;38     */
;;;39     void bsp_InitRTC(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;40     {
;;;41          uint16_t u16_WaitForOscSource;
;;;42     
;;;43     	/*
;;;44     		我们在BKP的后备寄存器1中，存了一个特殊字符0xA5A5, 第一次上电或后备电源掉电后，该寄存器数据丢失，
;;;45     		表明RTC数据丢失，需要重新配置
;;;46     	*/
;;;47         if (BKP_ReadBackupRegister(BKP_DR1) != 0xA5A5)
000002  2004              MOVS     r0,#4
000004  f7fffffe          BL       BKP_ReadBackupRegister
000008  4601              MOV      r1,r0
00000a  f24a54a5          MOV      r4,#0xa5a5
00000e  42a1              CMP      r1,r4
;;;48         {
;;;49     		//重新配置RTC
;;;50     		/* Enable PWR and BKP clocks */  /* PWR时钟（电源控制）与BKP时钟（RTC后备寄存器）使能 */  
;;;51     		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000010  f04f50c0          MOV      r0,#0x18000000
;;;52     		/* Allow access to BKP Domain */ /*使能RTC和后备寄存器访问 */  
;;;53     		PWR_BackupAccessCmd(ENABLE);
;;;54     		
;;;55     		/* Reset Backup Domain */  /* 将外设BKP的全部寄存器重设为缺省值 */   
;;;56     		BKP_DeInit();
;;;57     		/* Enable LSE */		
;;;58     		RCC_LSEConfig(RCC_LSE_ON);
;;;59     		
;;;60     		#if 0
;;;61     		for(u16_WaitForOscSource=0; u16_WaitForOscSource < 5000; u16_WaitForOscSource++)
;;;62     		{
;;;63     			;
;;;64     		}
;;;65     		#endif
;;;66     		
;;;67     		/* Wait till LSE is ready */ /* 等待外部晶振震荡稳定输出 */  
;;;68     		while (RCC_GetFlagStatus(RCC_FLAG_LSERDY) == RESET);
;;;69     		
;;;70     		/* Select LSE as RTC Clock Source */ /*使用外部32.768KHz晶振作为RTC时钟 */ 
;;;71     		RCC_RTCCLKConfig(RCC_RTCCLKSource_LSE);
;;;72     		
;;;73     		/* Enable RTC Clock */
;;;74     		RCC_RTCCLKCmd(ENABLE);
;;;75     		/* Wait for RTC registers synchronization */
;;;76     		RTC_WaitForSynchro();
;;;77     		/* Wait until last write operation on RTC registers has finished */
;;;78     		RTC_WaitForLastTask();
;;;79     		/* Enable the RTC Second */
;;;80     		RTC_ITConfig(RTC_IT_SEC, ENABLE);
;;;81     		/* Wait until last write operation on RTC registers has finished */
;;;82     		RTC_WaitForLastTask();
;;;83     		
;;;84     	//	RTC_EnterConfigMode();
;;;85     		
;;;86     		/* Set RTC prescaler: set RTC period to 1sec */   
;;;87     		/* 32.768KHz晶振预分频值是32767,如果对精度要求很高可以修改此分频值来校准晶振 */ 
;;;88     		RTC_SetPrescaler(32767); /* RTC period = RTCCLK/RTC_PR = (32.768 KHz)/(32767+1) */
;;;89     		
;;;90     		/* Wait until last write operation on RTC registers has finished */
;;;91     		RTC_WaitForLastTask();
;;;92     		
;;;93     		RTC_WriteClock(2015, 8, 8, 0, 0, 0);//默认时间
;;;94     		
;;;95             /* 配置完成后，向后备寄存器中写特殊字符0xA5A5 */
;;;96             BKP_WriteBackupRegister(BKP_DR1, 0xA5A5);
;;;97         }
;;;98         else
;;;99     	{
;;;100    		/* 若后备寄存器没有掉电，则无需重新配置RTC */
;;;101    		RCC_APB1PeriphClockCmd(RCC_APB1Periph_PWR | RCC_APB1Periph_BKP, ENABLE);
000014  f04f0101          MOV      r1,#1
000018  d035              BEQ      |L5.134|
00001a  f7fffffe          BL       RCC_APB1PeriphClockCmd
00001e  2001              MOVS     r0,#1                 ;53
000020  f7fffffe          BL       PWR_BackupAccessCmd
000024  f7fffffe          BL       BKP_DeInit
000028  2001              MOVS     r0,#1                 ;58
00002a  f7fffffe          BL       RCC_LSEConfig
                  |L5.46|
00002e  2041              MOVS     r0,#0x41              ;68
000030  f7fffffe          BL       RCC_GetFlagStatus
000034  2800              CMP      r0,#0                 ;68
000036  d0fa              BEQ      |L5.46|
000038  f44f7080          MOV      r0,#0x100             ;71
00003c  f7fffffe          BL       RCC_RTCCLKConfig
000040  2001              MOVS     r0,#1                 ;74
000042  f7fffffe          BL       RCC_RTCCLKCmd
000046  f7fffffe          BL       RTC_WaitForSynchro
00004a  f7fffffe          BL       RTC_WaitForLastTask
00004e  2101              MOVS     r1,#1                 ;80
000050  4608              MOV      r0,r1                 ;80
000052  f7fffffe          BL       RTC_ITConfig
000056  f7fffffe          BL       RTC_WaitForLastTask
00005a  f64770ff          MOV      r0,#0x7fff            ;88
00005e  f7fffffe          BL       RTC_SetPrescaler
000062  f7fffffe          BL       RTC_WaitForLastTask
000066  2000              MOVS     r0,#0                 ;93
000068  9000              STR      r0,[sp,#0]            ;93
00006a  4603              MOV      r3,r0                 ;93
00006c  2208              MOVS     r2,#8                 ;93
00006e  9001              STR      r0,[sp,#4]            ;93
000070  4611              MOV      r1,r2                 ;93
000072  f24070df          MOV      r0,#0x7df             ;93
000076  f7fffffe          BL       RTC_WriteClock
00007a  4621              MOV      r1,r4                 ;96
00007c  e8bd401c          POP      {r2-r4,lr}            ;96
000080  2004              MOVS     r0,#4                 ;96
000082  f7ffbffe          B.W      BKP_WriteBackupRegister
                  |L5.134|
000086  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;102    		
;;;103    		for (u16_WaitForOscSource = 0; u16_WaitForOscSource < 5000; u16_WaitForOscSource++)
00008a  2000              MOVS     r0,#0
00008c  f2413188          MOV      r1,#0x1388
                  |L5.144|
000090  1c40              ADDS     r0,r0,#1
000092  b280              UXTH     r0,r0
000094  4288              CMP      r0,r1
000096  d3fb              BCC      |L5.144|
;;;104    		{
;;;105    			;
;;;106    		}
;;;107            if (RCC_GetFlagStatus(RCC_FLAG_PORRST) != RESET)
000098  207b              MOVS     r0,#0x7b
00009a  f7fffffe          BL       RCC_GetFlagStatus
00009e  b910              CBNZ     r0,|L5.166|
;;;108            {
;;;109    			/* 上电复位 */
;;;110            }
;;;111            else if (RCC_GetFlagStatus(RCC_FLAG_PINRST) != RESET)
0000a0  207a              MOVS     r0,#0x7a
0000a2  f7fffffe          BL       RCC_GetFlagStatus
                  |L5.166|
;;;112            {
;;;113                /* 外部RST管脚复位 */
;;;114            }
;;;115            /* 清除RCC中复位标志 */
;;;116            RCC_ClearFlag();
0000a6  f7fffffe          BL       RCC_ClearFlag
;;;117            
;;;118    		//虽然RTC模块不需要重新配置，且掉电后依靠后备电池依然运行
;;;119            //但是每次上电后，还是要使能RTCCLK???????
;;;120            //RCC_RTCCLKCmd(ENABLE);
;;;121            //等待RTC时钟与APB1时钟同步
;;;122            //RTC_WaitForSynchro();
;;;123            
;;;124            //使能秒中断
;;;125            //RTC_ITConfig(RTC_IT_SEC, ENABLE);
;;;126            
;;;127            //等待操作完成
;;;128            RTC_WaitForLastTask();
0000aa  e8bd401c          POP      {r2-r4,lr}
0000ae  f7ffbffe          B.W      RTC_WaitForLastTask
;;;129        }
;;;130    	return;
;;;131    }
;;;132    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  mon_table
000000  1f1c1f1e          DCB      0x1f,0x1c,0x1f,0x1e
000004  1f1e1f1f          DCB      0x1f,0x1e,0x1f,0x1f
000008  1e1f1e1f          DCB      0x1e,0x1f,0x1e,0x1f

                          AREA ||.data||, DATA, ALIGN=1

                  daycnt
000000  0000              DCW      0x0000
                  g_tRTC
000002  0000              DCB      0x00,0x00
                          DCDU     0x00000000
000008  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_cpu_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_cpu_rtc_c_54b4358b____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_cpu_rtc_c_54b4358b____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_cpu_rtc_c_54b4358b____REVSH|
#line 128
|__asm___13_bsp_cpu_rtc_c_54b4358b____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
