; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ra8875_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ra8875_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_ra8875_flash.crf ..\..\User\bsp\src\bsp_ra8875_flash.c]
                          THUMB

                          AREA ||i.bsp_CfgSPIForW25||, CODE, READONLY, ALIGN=2

                  bsp_CfgSPIForW25 PROC
;;;142    */
;;;143    void bsp_CfgSPIForW25(void)
000000  b510              PUSH     {r4,lr}
;;;144    {
000002  b086              SUB      sp,sp,#0x18
;;;145    	SPI_InitTypeDef  SPI_InitStructure;
;;;146    
;;;147    	/* 配置SPI硬件参数 */
;;;148    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;149    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7182          MOV      r1,#0x104
00000e  f8ad1002          STRH     r1,[sp,#2]
;;;150    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  f8ad0004          STRH     r0,[sp,#4]
;;;151    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;152    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;153    	*/
;;;154    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000016  2102              MOVS     r1,#2
000018  f8ad1006          STRH     r1,[sp,#6]
;;;155    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001c  2101              MOVS     r1,#1
00001e  f8ad1008          STRH     r1,[sp,#8]
;;;156    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000022  0249              LSLS     r1,r1,#9
000024  f8ad100a          STRH     r1,[sp,#0xa]
;;;157    
;;;158    	/* 设置波特率预分频系数 */
;;;159    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_8;
000028  2110              MOVS     r1,#0x10
00002a  f8ad100c          STRH     r1,[sp,#0xc]
;;;160    
;;;161    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
00002e  f8ad000e          STRH     r0,[sp,#0xe]
;;;162    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000032  2007              MOVS     r0,#7
;;;163    	SPI_Init(SPI1, &SPI_InitStructure);
000034  4c08              LDR      r4,|L1.88|
000036  f8ad0010          STRH     r0,[sp,#0x10]         ;162
00003a  4669              MOV      r1,sp
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       SPI_Init
;;;164    
;;;165    	SPI_Cmd(SPI1, DISABLE);			/* 先禁止SPI  */
000042  2100              MOVS     r1,#0
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_Cmd
;;;166    
;;;167    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
00004a  2101              MOVS     r1,#1
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       SPI_Cmd
;;;168    }
000052  b006              ADD      sp,sp,#0x18
000054  bd10              POP      {r4,pc}
;;;169    
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x40013000

                          AREA ||i.bsp_InitRA8875Flash||, CODE, READONLY, ALIGN=2

                  bsp_InitRA8875Flash PROC
;;;90     */
;;;91     void bsp_InitRA8875Flash(void)
000000  b538              PUSH     {r3-r5,lr}
000002  2101              MOVS     r1,#1
000004  f44f7084          MOV      r0,#0x108
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       w25_SetCS
000012  2410              MOVS     r4,#0x10
000014  f88d4003          STRB     r4,[sp,#3]
000018  2503              MOVS     r5,#3
00001a  f88d5002          STRB     r5,[sp,#2]
00001e  01e0              LSLS     r0,r4,#7
000020  f8ad0000          STRH     r0,[sp,#0]
000024  4669              MOV      r1,sp
000026  480b              LDR      r0,|L2.84|
000028  f7fffffe          BL       GPIO_Init
00002c  f88d4003          STRB     r4,[sp,#3]
000030  f88d5002          STRB     r5,[sp,#2]
000034  2402              MOVS     r4,#2
000036  f8ad4000          STRH     r4,[sp,#0]
00003a  4669              MOV      r1,sp
00003c  4806              LDR      r0,|L2.88|
00003e  f7fffffe          BL       GPIO_Init
000042  4805              LDR      r0,|L2.88|
000044  3010              ADDS     r0,r0,#0x10
000046  6004              STR      r4,[r0,#0]
;;;92     {
;;;93     	w25_ConfigGPIO();
;;;94     
;;;95     	/* 配置SPI硬件参数用于访问串行Flash , 在 bsp_spi_bus.c 中配置*/
;;;96     	//bsp_CfgSPIForW25();
;;;97     
;;;98     	/* 识别串行FLASH型号 */
;;;99     	w25_CtrlByMCU();	/* (必须先执行w25_CtrlByMCU()设置PWM=1切换SPI控制权)  */
;;;100    	w25_ReadInfo();
000048  f7fffffe          BL       w25_ReadInfo
00004c  4802              LDR      r0,|L2.88|
00004e  3014              ADDS     r0,r0,#0x14
000050  6004              STR      r4,[r0,#0]
;;;101    	w25_CtrlByRA8875();
;;;102    }
000052  bd38              POP      {r3-r5,pc}
;;;103    
                          ENDP

                  |L2.84|
                          DCD      0x40012000
                  |L2.88|
                          DCD      0x40010c00

                          AREA ||i.w25_CtrlByMCU||, CODE, READONLY, ALIGN=2

                  w25_CtrlByMCU PROC
;;;212    */
;;;213    void w25_CtrlByMCU(void)
000000  4901              LDR      r1,|L3.8|
;;;214    {
;;;215    	/*
;;;216    		PWM口线置低选中
;;;217    		PWM = 1  这个模式支持STM32读写RA8875外挂的串行Flash
;;;218    		PWM = 0 这是正常工作模式，由RA8875 DMA读取外挂的串行Flash
;;;219    	*/
;;;220    	W25_PWM_1();
000002  2002              MOVS     r0,#2
000004  6008              STR      r0,[r1,#0]
;;;221    }
000006  4770              BX       lr
;;;222    
                          ENDP

                  |L3.8|
                          DCD      0x40010c10

                          AREA ||i.w25_CtrlByRA8875||, CODE, READONLY, ALIGN=2

                  w25_CtrlByRA8875 PROC
;;;230    */
;;;231    void w25_CtrlByRA8875(void)
000000  4901              LDR      r1,|L4.8|
;;;232    {
;;;233    	/*
;;;234    		PWM口线置低选中
;;;235    		PWM = 1  这个模式支持STM32读写RA8875外挂的串行Flash
;;;236    		PWM = 0 这是正常工作模式，由RA8875 DMA读取外挂的串行Flash
;;;237    	*/
;;;238    	W25_PWM_0();
000002  2002              MOVS     r0,#2
000004  6008              STR      r0,[r1,#0]
;;;239    }
000006  4770              BX       lr
;;;240    
                          ENDP

                  |L4.8|
                          DCD      0x40010c14

                          AREA ||i.w25_EraseChip||, CODE, READONLY, ALIGN=1

                  w25_EraseChip PROC
;;;311    */
;;;312    void w25_EraseChip(void)
000000  b510              PUSH     {r4,lr}
;;;313    {
;;;314    	w25_WriteEnable();								/* 发送写使能命令 */
000002  f7fffffe          BL       w25_WriteEnable
;;;315    
;;;316    	/* 擦除扇区操作 */
;;;317    	w25_SetCS(0);									/* 使能片选 */
000006  2000              MOVS     r0,#0
000008  f7fffffe          BL       w25_SetCS
;;;318    	bsp_spiWrite1(CMD_BE);							/* 发送整片擦除命令 */
00000c  20c7              MOVS     r0,#0xc7
00000e  f7fffffe          BL       bsp_spiWrite1
;;;319    	w25_SetCS(1);									/* 禁能片选 */
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       w25_SetCS
;;;320    
;;;321    	w25_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000018  e8bd4010          POP      {r4,lr}
00001c  f7ffbffe          B.W      w25_WaitForWriteEnd
;;;322    }
;;;323    
                          ENDP


                          AREA ||i.w25_EraseSector||, CODE, READONLY, ALIGN=1

                  w25_EraseSector PROC
;;;288    */
;;;289    void w25_EraseSector(uint32_t _uiSectorAddr)
000000  b510              PUSH     {r4,lr}
;;;290    {
000002  4604              MOV      r4,r0
;;;291    	w25_WriteEnable();								/* 发送写使能命令 */
000004  f7fffffe          BL       w25_WriteEnable
;;;292    
;;;293    	/* 擦除扇区操作 */
;;;294    	w25_SetCS(0);									/* 使能片选 */
000008  2000              MOVS     r0,#0
00000a  f7fffffe          BL       w25_SetCS
;;;295    	bsp_spiWrite1(CMD_SE);								/* 发送擦除命令 */
00000e  2020              MOVS     r0,#0x20
000010  f7fffffe          BL       bsp_spiWrite1
;;;296    	bsp_spiWrite1((_uiSectorAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000014  f3c44007          UBFX     r0,r4,#16,#8
000018  f7fffffe          BL       bsp_spiWrite1
;;;297    	bsp_spiWrite1((_uiSectorAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
00001c  f3c42007          UBFX     r0,r4,#8,#8
000020  f7fffffe          BL       bsp_spiWrite1
;;;298    	bsp_spiWrite1(_uiSectorAddr & 0xFF);				/* 发送扇区地址低8bit */
000024  b2e0              UXTB     r0,r4
000026  f7fffffe          BL       bsp_spiWrite1
;;;299    	w25_SetCS(1);									/* 禁能片选 */
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       w25_SetCS
;;;300    
;;;301    	w25_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000030  e8bd4010          POP      {r4,lr}
000034  f7ffbffe          B.W      w25_WaitForWriteEnd
;;;302    }
;;;303    
                          ENDP


                          AREA ||i.w25_ReadBuffer||, CODE, READONLY, ALIGN=2

                  w25_ReadBuffer PROC
;;;420    */
;;;421    void w25_ReadBuffer(uint8_t * _pBuf, uint32_t _uiReadAddr, uint32_t _uiSize)
000000  b570              PUSH     {r4-r6,lr}
;;;422    {
000002  0014              MOVS     r4,r2
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
000008  d021              BEQ      |L7.78|
;;;423    	/* 如果读取的数据长度为0或者超出串行Flash地址空间，则直接返回 */
;;;424    	if ((_uiSize == 0) ||(_uiReadAddr + _uiSize) > g_tW25.TotalSize)
00000a  4911              LDR      r1,|L7.80|
00000c  1928              ADDS     r0,r5,r4
00000e  6849              LDR      r1,[r1,#4]  ; g_tW25
000010  4288              CMP      r0,r1
000012  d81c              BHI      |L7.78|
;;;425    	{
;;;426    		return;
;;;427    	}
;;;428    
;;;429    	/* 擦除扇区操作 */
;;;430    	w25_SetCS(0);									/* 使能片选 */
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       w25_SetCS
;;;431    	bsp_spiWrite1(CMD_READ);							/* 发送读命令 */
00001a  2003              MOVS     r0,#3
00001c  f7fffffe          BL       bsp_spiWrite1
;;;432    	bsp_spiWrite1((_uiReadAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
000020  f3c54007          UBFX     r0,r5,#16,#8
000024  f7fffffe          BL       bsp_spiWrite1
;;;433    	bsp_spiWrite1((_uiReadAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
000028  f3c52007          UBFX     r0,r5,#8,#8
00002c  f7fffffe          BL       bsp_spiWrite1
;;;434    	bsp_spiWrite1(_uiReadAddr & 0xFF);				/* 发送扇区地址低8bit */
000030  b2e8              UXTB     r0,r5
000032  f7fffffe          BL       bsp_spiWrite1
;;;435    	while (_uiSize--)
000036  e003              B        |L7.64|
                  |L7.56|
;;;436    	{
;;;437    		*_pBuf++ = bsp_spiRead1();			/* 读一个字节并存储到pBuf，读完后指针自加1 */
000038  f7fffffe          BL       bsp_spiRead1
00003c  f8060b01          STRB     r0,[r6],#1
                  |L7.64|
000040  1e64              SUBS     r4,r4,#1
000042  d2f9              BCS      |L7.56|
;;;438    	}
;;;439    	w25_SetCS(1);									/* 禁能片选 */
000044  e8bd4070          POP      {r4-r6,lr}
000048  2001              MOVS     r0,#1
00004a  f7ffbffe          B.W      w25_SetCS
                  |L7.78|
;;;440    }
00004e  bd70              POP      {r4-r6,pc}
;;;441    
                          ENDP

                  |L7.80|
                          DCD      ||.bss||

                          AREA ||i.w25_ReadID||, CODE, READONLY, ALIGN=1

                  w25_ReadID PROC
;;;449    */
;;;450    uint32_t w25_ReadID(void)
000000  b570              PUSH     {r4-r6,lr}
;;;451    {
;;;452    	uint32_t uiID;
;;;453    	uint8_t id1, id2, id3;
;;;454    
;;;455    	w25_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       w25_SetCS
;;;456    	bsp_spiWrite1(CMD_RDID);								/* 发送读ID命令 */
000008  209f              MOVS     r0,#0x9f
00000a  f7fffffe          BL       bsp_spiWrite1
;;;457    	id1 = bsp_spiRead1();					/* 读ID的第1个字节 */
00000e  f7fffffe          BL       bsp_spiRead1
000012  4604              MOV      r4,r0
;;;458    	id2 = bsp_spiRead1();					/* 读ID的第2个字节 */
000014  f7fffffe          BL       bsp_spiRead1
000018  4605              MOV      r5,r0
;;;459    	id3 = bsp_spiRead1();					/* 读ID的第3个字节 */
00001a  f7fffffe          BL       bsp_spiRead1
00001e  4606              MOV      r6,r0
;;;460    	w25_SetCS(1);									/* 禁能片选 */
000020  2001              MOVS     r0,#1
000022  f7fffffe          BL       w25_SetCS
;;;461    
;;;462    	uiID = ((uint32_t)id1 << 16) | ((uint32_t)id2 << 8) | id3;
000026  0420              LSLS     r0,r4,#16
000028  ea402005          ORR      r0,r0,r5,LSL #8
00002c  4330              ORRS     r0,r0,r6
;;;463    
;;;464    	return uiID;
;;;465    }
00002e  bd70              POP      {r4-r6,pc}
;;;466    
                          ENDP


                          AREA ||i.w25_ReadInfo||, CODE, READONLY, ALIGN=2

                  w25_ReadInfo PROC
;;;474    */
;;;475    void w25_ReadInfo(void)
000000  b510              PUSH     {r4,lr}
;;;476    {
;;;477    	/* 自动识别串行Flash型号 */
;;;478    	{
;;;479    		g_tW25.ChipID = w25_ReadID();	/* 芯片ID */
000002  f7fffffe          BL       w25_ReadID
000006  490d              LDR      r1,|L9.60|
;;;480    
;;;481    		switch (g_tW25.ChipID)
000008  4a0d              LDR      r2,|L9.64|
00000a  1883              ADDS     r3,r0,r2
00000c  6008              STR      r0,[r1,#0]  ; g_tW25
;;;482    		{
;;;483    			case SST25VF016B:
;;;484    				g_tW25.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
00000e  f44f1200          MOV      r2,#0x200000
;;;485    				g_tW25.PageSize = 4 * 1024;			/* 页面大小 = 4K */
000012  f44f5080          MOV      r0,#0x1000
000016  d00d              BEQ      |L9.52|
000018  4c0a              LDR      r4,|L9.68|
00001a  191b              ADDS     r3,r3,r4              ;481
00001c  d00a              BEQ      |L9.52|
00001e  4c0a              LDR      r4,|L9.72|
000020  191b              ADDS     r3,r3,r4              ;481
000022  d002              BEQ      |L9.42|
000024  2b01              CMP      r3,#1                 ;481
000026  d105              BNE      |L9.52|
000028  e002              B        |L9.48|
                  |L9.42|
;;;486    				break;
;;;487    
;;;488    			case MX25L1606E:
;;;489    				g_tW25.TotalSize = 2 * 1024 * 1024;	/* 总容量 = 2M */
;;;490    				g_tW25.PageSize = 4 * 1024;			/* 页面大小 = 4K */
;;;491    				break;
;;;492    
;;;493    			case W25Q64BV:
;;;494    				g_tW25.TotalSize = 8 * 1024 * 1024;	/* 总容量 = 8M */
00002a  f44f0200          MOV      r2,#0x800000
;;;495    				g_tW25.PageSize = 4 * 1024;			/* 页面大小 = 4K */
;;;496    				break;
00002e  e001              B        |L9.52|
                  |L9.48|
;;;497    
;;;498    			case W25Q128:
;;;499    				g_tW25.TotalSize = 16 * 1024 * 1024;	/* 总容量 = 16M */
000030  f04f7280          MOV      r2,#0x1000000
                  |L9.52|
;;;500    				g_tW25.PageSize = 4 * 1024;			/* 页面大小 = 4K */
;;;501    				break;
;;;502    
;;;503    			default:		/* 集通字库不支持ID读取 */
;;;504    				g_tW25.TotalSize = 2 * 1024 * 1024;
;;;505    				g_tW25.PageSize = 4 * 1024;
000034  604a              STR      r2,[r1,#4]  ; g_tW25
000036  8108              STRH     r0,[r1,#8]
;;;506    				break;
;;;507    		}
;;;508    	}
;;;509    }
000038  bd10              POP      {r4,pc}
;;;510    
                          ENDP

00003a  0000              DCW      0x0000
                  |L9.60|
                          DCD      ||.bss||
                  |L9.64|
                          DCD      0xff40dabf
                  |L9.68|
                          DCD      0xfffd052c
                  |L9.72|
                          DCD      0xffd2dffe

                          AREA ||i.w25_SelectChip||, CODE, READONLY, ALIGN=2

                  w25_SelectChip PROC
;;;248    */
;;;249    void w25_SelectChip(uint8_t _idex)
000000  b510              PUSH     {r4,lr}
;;;250    {
000002  b368              CBZ      r0,|L10.96|
;;;251    	/*
;;;252    		PWM = 1, KOUT3 = 0 写字库芯片
;;;253    		PWM = 1, KOUT3 = 1 写图库芯片
;;;254    	*/
;;;255    	#if 1
;;;256    		if (_idex == FONT_CHIP)
;;;257    		{
;;;258    			RA8875_CtrlGPO(3, 0);	/* RA8875 的 KOUT3 = 0 */
;;;259    		}
;;;260    		else	/* BMP图片芯片 */
;;;261    		{
;;;262    			RA8875_CtrlGPO(3, 1);	/* RA8875 的 KOUT3 = 1 */
000004  2101              MOVS     r1,#1
                  |L10.6|
000006  2003              MOVS     r0,#3
000008  f7fffffe          BL       RA8875_CtrlGPO
;;;263    		}
;;;264    	#else
;;;265    		/* 对于1片 W25Q128的屏，不需要RA8875的KOUT 引脚 */
;;;266    		/* 对于外扩 图片阵列板的的屏，不需要RA8875的KOUT0 - KOUT3 四个引脚 */
;;;267    	#endif
;;;268    
;;;269    
;;;270    	w25_ReadInfo();				/* 自动识别芯片型号 */
00000c  f7fffffe          BL       w25_ReadInfo
;;;271    
;;;272    	w25_SetCS(0);				/* 软件方式，使能串行Flash片选 */
000010  2000              MOVS     r0,#0
000012  f7fffffe          BL       w25_SetCS
;;;273    	bsp_spiWrite1(CMD_DISWR);		/* 发送禁止写入的命令,即使能软件写保护 */
000016  2004              MOVS     r0,#4
000018  f7fffffe          BL       bsp_spiWrite1
;;;274    	w25_SetCS(1);				/* 软件方式，禁能串行Flash片选 */
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       w25_SetCS
;;;275    
;;;276    	w25_WaitForWriteEnd();		/* 等待串行Flash内部操作完成 */
000022  f7fffffe          BL       w25_WaitForWriteEnd
000026  480f              LDR      r0,|L10.100|
000028  490f              LDR      r1,|L10.104|
;;;277    
;;;278    	w25_WriteStatus(0);			/* 解除所有BLOCK的写保护 */
00002a  2400              MOVS     r4,#0
00002c  6800              LDR      r0,[r0,#0]  ; g_tW25
00002e  4288              CMP      r0,r1
000030  d108              BNE      |L10.68|
000032  2000              MOVS     r0,#0
000034  f7fffffe          BL       w25_SetCS
000038  2050              MOVS     r0,#0x50
00003a  f7fffffe          BL       bsp_spiWrite1
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       w25_SetCS
                  |L10.68|
000044  2000              MOVS     r0,#0
000046  f7fffffe          BL       w25_SetCS
00004a  2001              MOVS     r0,#1
00004c  f7fffffe          BL       bsp_spiWrite1
000050  4620              MOV      r0,r4
000052  f7fffffe          BL       bsp_spiWrite1
000056  e8bd4010          POP      {r4,lr}
00005a  2001              MOVS     r0,#1
00005c  f7ffbffe          B.W      w25_SetCS
                  |L10.96|
000060  2100              MOVS     r1,#0                 ;258
000062  e7d0              B        |L10.6|
;;;279    }
;;;280    
                          ENDP

                  |L10.100|
                          DCD      ||.bss||
                  |L10.104|
                          DCD      0x00bf2541

                          AREA ||i.w25_SetCS||, CODE, READONLY, ALIGN=2

                  w25_SetCS PROC
;;;178    */
;;;179    void w25_SetCS(uint8_t _level)
000000  b570              PUSH     {r4-r6,lr}
;;;180    {
;;;181    	if (_level == 0)
;;;182    	{
;;;183    		bsp_SpiBusEnter();	/* 占用SPI总线， 用于总线共享 */
;;;184    
;;;185    		#ifdef SOFT_SPI		/* 软件SPI */
;;;186    			bsp_SetSpiSck(1);
;;;187    			W25_CS_0();
;;;188    		#endif
;;;189    
;;;190    		#ifdef HARD_SPI		/* 硬件SPI */
;;;191    			bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
;;;192    				| SPI_CPOL_High | SPI_CPHA_2Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_8 | SPI_FirstBit_MSB);
;;;193    
;;;194    			W25_CS_0();
000002  4d08              LDR      r5,|L11.36|
000004  f44f6400          MOV      r4,#0x800
000008  b120              CBZ      r0,|L11.20|
;;;195    		#endif
;;;196    	}
;;;197    	else
;;;198    	{
;;;199    		W25_CS_1();
00000a  612c              STR      r4,[r5,#0x10]
;;;200    
;;;201    		bsp_SpiBusExit();	/* 释放SPI总线， 用于总线共享 */
00000c  e8bd4070          POP      {r4-r6,lr}
000010  f7ffbffe          B.W      bsp_SpiBusExit
                  |L11.20|
000014  f7fffffe          BL       bsp_SpiBusEnter
000018  f2403017          MOV      r0,#0x317             ;191
00001c  f7fffffe          BL       bsp_SPI_Init
000020  616c              STR      r4,[r5,#0x14]         ;194
;;;202    	}
;;;203    }
000022  bd70              POP      {r4-r6,pc}
;;;204    
                          ENDP

                  |L11.36|
                          DCD      0x40012000

                          AREA ||i.w25_WaitForWriteEnd||, CODE, READONLY, ALIGN=2

                  w25_WaitForWriteEnd PROC
;;;566    */
;;;567    static void w25_WaitForWriteEnd(void)
000000  b510              PUSH     {r4,lr}
;;;568    {
;;;569    	w25_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       w25_SetCS
;;;570    	bsp_spiWrite1(CMD_RDSR);							/* 发送命令， 读状态寄存器 */
000008  2005              MOVS     r0,#5
00000a  f7fffffe          BL       bsp_spiWrite1
;;;571    	while((bsp_spiRead1() & WIP_FLAG) == SET);	/* 判断状态寄存器的忙标志位 */
00000e  bf00              NOP      
                  |L12.16|
000010  f7fffffe          BL       bsp_spiRead1
000014  07c0              LSLS     r0,r0,#31
000016  d1fb              BNE      |L12.16|
;;;572    	w25_SetCS(1);									/* 禁能片选 */
000018  e8bd4010          POP      {r4,lr}
00001c  2001              MOVS     r0,#1
00001e  f7ffbffe          B.W      w25_SetCS
;;;573    }
;;;574    
                          ENDP


                          AREA ||i.w25_WriteEnable||, CODE, READONLY, ALIGN=1

                  w25_WriteEnable PROC
;;;518    */
;;;519    static void w25_WriteEnable(void)
000000  b510              PUSH     {r4,lr}
;;;520    {
;;;521    	w25_SetCS(0);									/* 使能片选 */
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       w25_SetCS
;;;522    	bsp_spiWrite1(CMD_WREN);								/* 发送命令 */
000008  2006              MOVS     r0,#6
00000a  f7fffffe          BL       bsp_spiWrite1
;;;523    	w25_SetCS(1);									/* 禁能片选 */
00000e  e8bd4010          POP      {r4,lr}
000012  2001              MOVS     r0,#1
000014  f7ffbffe          B.W      w25_SetCS
;;;524    }
;;;525    
                          ENDP


                          AREA ||i.w25_WritePage||, CODE, READONLY, ALIGN=2

                  w25_WritePage PROC
;;;333    */
;;;334    void w25_WritePage(uint8_t * _pBuf, uint32_t _uiWriteAddr, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;335    {
000004  4604              MOV      r4,r0
;;;336    	uint32_t i, j;
;;;337    
;;;338    	if (g_tW25.ChipID == SST25VF016B)
000006  483f              LDR      r0,|L14.260|
000008  460d              MOV      r5,r1                 ;335
00000a  493f              LDR      r1,|L14.264|
00000c  6800              LDR      r0,[r0,#0]  ; g_tW25
00000e  4616              MOV      r6,r2                 ;335
000010  4288              CMP      r0,r1
000012  d13d              BNE      |L14.144|
;;;339    	{
;;;340    		/* AAI指令要求传入的数据个数是偶数 */
;;;341    		if ((_usSize < 2) && (_usSize % 2))
000014  2e02              CMP      r6,#2
000016  d201              BCS      |L14.28|
000018  07f0              LSLS     r0,r6,#31
00001a  d171              BNE      |L14.256|
                  |L14.28|
;;;342    		{
;;;343    			return ;
;;;344    		}
;;;345    
;;;346    		w25_WriteEnable();								/* 发送写使能命令 */
00001c  f7fffffe          BL       w25_WriteEnable
;;;347    
;;;348    		w25_SetCS(0);									/* 使能片选 */
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       w25_SetCS
;;;349    		bsp_spiWrite1(CMD_AAI);							/* 发送AAI命令(地址自动增加编程) */
000026  20ad              MOVS     r0,#0xad
000028  f7fffffe          BL       bsp_spiWrite1
;;;350    		bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
00002c  f3c54007          UBFX     r0,r5,#16,#8
000030  f7fffffe          BL       bsp_spiWrite1
;;;351    		bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
000034  f3c52007          UBFX     r0,r5,#8,#8
000038  f7fffffe          BL       bsp_spiWrite1
;;;352    		bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
00003c  b2e8              UXTB     r0,r5
00003e  f7fffffe          BL       bsp_spiWrite1
;;;353    		bsp_spiWrite1(*_pBuf++);							/* 发送第1个数据 */
000042  7820              LDRB     r0,[r4,#0]
000044  f7fffffe          BL       bsp_spiWrite1
;;;354    		bsp_spiWrite1(*_pBuf++);							/* 发送第2个数据 */
000048  7860              LDRB     r0,[r4,#1]
00004a  1ca4              ADDS     r4,r4,#2
00004c  f7fffffe          BL       bsp_spiWrite1
;;;355    		w25_SetCS(1);									/* 禁能片选 */
000050  2001              MOVS     r0,#1
000052  f7fffffe          BL       w25_SetCS
;;;356    
;;;357    		w25_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
000056  f7fffffe          BL       w25_WaitForWriteEnd
00005a  1eb6              SUBS     r6,r6,#2
;;;358    
;;;359    		_usSize -= 2;									/* 计算剩余字节数 */
00005c  b2b6              UXTH     r6,r6
;;;360    
;;;361    		for (i = 0; i < _usSize / 2; i++)
00005e  2500              MOVS     r5,#0
000060  e012              B        |L14.136|
                  |L14.98|
;;;362    		{
;;;363    			w25_SetCS(0);								/* 使能片选 */
000062  2000              MOVS     r0,#0
000064  f7fffffe          BL       w25_SetCS
;;;364    			bsp_spiWrite1(CMD_AAI);						/* 发送AAI命令(地址自动增加编程) */
000068  20ad              MOVS     r0,#0xad
00006a  f7fffffe          BL       bsp_spiWrite1
;;;365    			bsp_spiWrite1(*_pBuf++);						/* 发送数据 */
00006e  7820              LDRB     r0,[r4,#0]
000070  f7fffffe          BL       bsp_spiWrite1
;;;366    			bsp_spiWrite1(*_pBuf++);						/* 发送数据 */
000074  7860              LDRB     r0,[r4,#1]
000076  1ca4              ADDS     r4,r4,#2
000078  f7fffffe          BL       bsp_spiWrite1
;;;367    			w25_SetCS(1);								/* 禁能片选 */
00007c  2001              MOVS     r0,#1
00007e  f7fffffe          BL       w25_SetCS
;;;368    			w25_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
000082  f7fffffe          BL       w25_WaitForWriteEnd
000086  1c6d              ADDS     r5,r5,#1
                  |L14.136|
000088  ebb50f56          CMP      r5,r6,LSR #1          ;361
00008c  d3e9              BCC      |L14.98|
00008e  e02a              B        |L14.230|
                  |L14.144|
;;;369    		}
;;;370    
;;;371    		/* 进入写保护状态 */
;;;372    		w25_SetCS(0);
;;;373    		bsp_spiWrite1(CMD_DISWR);
;;;374    		w25_SetCS(1);
;;;375    
;;;376    		w25_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
;;;377    	}
;;;378    	else	/* for MX25L1606E 、 W25Q64BV */
;;;379    	{
;;;380    		for (j = 0; j < _usSize / 256; j++)
000090  f04f0800          MOV      r8,#0
000094  e024              B        |L14.224|
;;;381    		{
;;;382    			w25_WriteEnable();								/* 发送写使能命令 */
000096  bf00              NOP      
                  |L14.152|
000098  f7fffffe          BL       w25_WriteEnable
;;;383    
;;;384    			w25_SetCS(0);									/* 使能片选 */
00009c  2000              MOVS     r0,#0
00009e  f7fffffe          BL       w25_SetCS
;;;385    			bsp_spiWrite1(0x02);								/* 发送AAI命令(地址自动增加编程) */
0000a2  2002              MOVS     r0,#2
0000a4  f7fffffe          BL       bsp_spiWrite1
;;;386    			bsp_spiWrite1((_uiWriteAddr & 0xFF0000) >> 16);	/* 发送扇区地址的高8bit */
0000a8  f3c54007          UBFX     r0,r5,#16,#8
0000ac  f7fffffe          BL       bsp_spiWrite1
;;;387    			bsp_spiWrite1((_uiWriteAddr & 0xFF00) >> 8);		/* 发送扇区地址中间8bit */
0000b0  f3c52007          UBFX     r0,r5,#8,#8
0000b4  f7fffffe          BL       bsp_spiWrite1
;;;388    			bsp_spiWrite1(_uiWriteAddr & 0xFF);				/* 发送扇区地址低8bit */
0000b8  b2e8              UXTB     r0,r5
0000ba  f7fffffe          BL       bsp_spiWrite1
;;;389    
;;;390    			for (i = 0; i < 256; i++)
0000be  2700              MOVS     r7,#0
                  |L14.192|
;;;391    			{
;;;392    				bsp_spiWrite1(*_pBuf++);					/* 发送数据 */
0000c0  f8140b01          LDRB     r0,[r4],#1
0000c4  f7fffffe          BL       bsp_spiWrite1
0000c8  1c7f              ADDS     r7,r7,#1
0000ca  2fff              CMP      r7,#0xff              ;390
0000cc  d9f8              BLS      |L14.192|
;;;393    			}
;;;394    
;;;395    			w25_SetCS(1);								/* 禁止片选 */
0000ce  2001              MOVS     r0,#1
0000d0  f7fffffe          BL       w25_SetCS
;;;396    
;;;397    			w25_WaitForWriteEnd();						/* 等待串行Flash内部写操作完成 */
0000d4  f7fffffe          BL       w25_WaitForWriteEnd
0000d8  f1080801          ADD      r8,r8,#1              ;380
0000dc  f5057580          ADD      r5,r5,#0x100          ;380
                  |L14.224|
0000e0  ebb82f16          CMP      r8,r6,LSR #8          ;380
0000e4  d3d8              BCC      |L14.152|
                  |L14.230|
;;;398    
;;;399    			_uiWriteAddr += 256;
;;;400    		}
;;;401    
;;;402    		/* 进入写保护状态 */
;;;403    		w25_SetCS(0);
0000e6  2000              MOVS     r0,#0
0000e8  f7fffffe          BL       w25_SetCS
;;;404    		bsp_spiWrite1(CMD_DISWR);
0000ec  2004              MOVS     r0,#4
0000ee  f7fffffe          BL       bsp_spiWrite1
;;;405    		w25_SetCS(1);
0000f2  2001              MOVS     r0,#1
0000f4  f7fffffe          BL       w25_SetCS
;;;406    
;;;407    		w25_WaitForWriteEnd();							/* 等待串行Flash内部写操作完成 */
0000f8  e8bd41f0          POP      {r4-r8,lr}
0000fc  f7ffbffe          B.W      w25_WaitForWriteEnd
                  |L14.256|
;;;408    	}
;;;409    }
000100  e8bd81f0          POP      {r4-r8,pc}
;;;410    
                          ENDP

                  |L14.260|
                          DCD      ||.bss||
                  |L14.264|
                          DCD      0x00bf2541

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  g_tW25
                          %        12

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_ra8875_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_bsp_ra8875_flash_c_92090982____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___18_bsp_ra8875_flash_c_92090982____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_bsp_ra8875_flash_c_92090982____REVSH|
#line 128
|__asm___18_bsp_ra8875_flash_c_92090982____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
