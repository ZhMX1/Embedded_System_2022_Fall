; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_oled.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_oled.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_oled.crf ..\..\User\bsp\src\bsp_oled.c]
                          THUMB

                          AREA ||i.OLED_BufToPanel||, CODE, READONLY, ALIGN=2

                  OLED_BufToPanel PROC
;;;293    */
;;;294    static void OLED_BufToPanel(void)
000000  b530              PUSH     {r4,r5,lr}
000002  4a0c              LDR      r2,|L1.52|
;;;295    {
;;;296    	uint8_t i,j;
;;;297    
;;;298    	for (i = 0 ; i< 8; i++)
;;;299    	{
;;;300    		OLED_WriteCmd (0xB0 + i);	/* 设置页地址（0~7） */
;;;301    		OLED_WriteCmd (0x00);		/* 设置列地址的低地址 */
;;;302    		OLED_WriteCmd (0x10);		/* 设置列地址的高地址 */
;;;303    
;;;304    		for (j = 0 ; j < 128; j++)
;;;305    		{
;;;306    			OLED_WriteData(s_ucGRAM[i][j]);
000004  4b0c              LDR      r3,|L1.56|
000006  2000              MOVS     r0,#0                 ;298
                  |L1.8|
000008  f10001b0          ADD      r1,r0,#0xb0           ;300
00000c  b2c9              UXTB     r1,r1                 ;300
00000e  8011              STRH     r1,[r2,#0]            ;300
000010  2100              MOVS     r1,#0                 ;301
000012  8011              STRH     r1,[r2,#0]            ;301
000014  2110              MOVS     r1,#0x10              ;302
000016  8011              STRH     r1,[r2,#0]            ;302
000018  2100              MOVS     r1,#0                 ;304
00001a  eb0314c0          ADD      r4,r3,r0,LSL #7
                  |L1.30|
00001e  5c65              LDRB     r5,[r4,r1]
000020  8055              STRH     r5,[r2,#2]
000022  1c49              ADDS     r1,r1,#1
000024  b2c9              UXTB     r1,r1                 ;304
000026  2980              CMP      r1,#0x80              ;304
000028  d3f9              BCC      |L1.30|
00002a  1c40              ADDS     r0,r0,#1              ;304
00002c  b2c0              UXTB     r0,r0                 ;298
00002e  2808              CMP      r0,#8                 ;298
000030  d3ea              BCC      |L1.8|
;;;307    		}
;;;308    	}
;;;309    }
000032  bd30              POP      {r4,r5,pc}
;;;310    
                          ENDP

                  |L1.52|
                          DCD      0x6c200000
                  |L1.56|
                          DCD      ||.bss||

                          AREA ||i.OLED_ClrScr||, CODE, READONLY, ALIGN=2

                  OLED_ClrScr PROC
;;;267    */
;;;268    void OLED_ClrScr(uint8_t _ucMode)
000000  b430              PUSH     {r4,r5}
;;;269    {
;;;270    	uint8_t i,j;
;;;271    
;;;272    	for (i = 0 ; i < 8; i++)
;;;273    	{
;;;274    		for (j = 0 ; j < 128; j++)
;;;275    		{
;;;276    			s_ucGRAM[i][j] = _ucMode;
000002  4c0b              LDR      r4,|L2.48|
000004  2200              MOVS     r2,#0                 ;272
                  |L2.6|
000006  2100              MOVS     r1,#0                 ;274
000008  eb0413c2          ADD      r3,r4,r2,LSL #7
                  |L2.12|
00000c  5458              STRB     r0,[r3,r1]
00000e  1c49              ADDS     r1,r1,#1
000010  b2c9              UXTB     r1,r1                 ;274
000012  2980              CMP      r1,#0x80              ;274
000014  d3fa              BCC      |L2.12|
000016  1c52              ADDS     r2,r2,#1              ;274
000018  b2d2              UXTB     r2,r2                 ;272
00001a  2a08              CMP      r2,#8                 ;272
00001c  d3f3              BCC      |L2.6|
;;;277    		}
;;;278    	}
;;;279    
;;;280    	if (s_ucUpdateEn == 1)
00001e  4805              LDR      r0,|L2.52|
000020  7800              LDRB     r0,[r0,#0]  ; s_ucUpdateEn
000022  2801              CMP      r0,#1
000024  d102              BNE      |L2.44|
;;;281    	{
;;;282    		OLED_BufToPanel();
000026  bc30              POP      {r4,r5}
000028  f7ffbffe          B.W      OLED_BufToPanel
                  |L2.44|
;;;283    	}
;;;284    }
00002c  bc30              POP      {r4,r5}
00002e  4770              BX       lr
;;;285    
                          ENDP

                  |L2.48|
                          DCD      ||.bss||
                  |L2.52|
                          DCD      ||.data||

                          AREA ||i.OLED_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  OLED_ConfigGPIO PROC
;;;740    */
;;;741    static void OLED_ConfigGPIO(void)
000000  b530              PUSH     {r4,r5,lr}
;;;742    {
;;;743    	/* 12.配置GPIO */
;;;744    	{
;;;745    		GPIO_InitTypeDef GPIO_InitStructure;
;;;746    
;;;747    		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  b097              SUB      sp,sp,#0x5c           ;742
000006  0208              LSLS     r0,r1,#8
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;748    
;;;749    		/* 使能 FSMC, GPIOD, GPIOE, GPIOF, GPIOG 和 AFIO 时钟 */
;;;750    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE |
00000c  2101              MOVS     r1,#1
00000e  f24010e1          MOV      r0,#0x1e1
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;751    							 RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG |
;;;752    							 RCC_APB2Periph_AFIO, ENABLE);
;;;753    
;;;754    		/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;755    		 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;756    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
000016  f24c7033          MOV      r0,#0xc733
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;757    									GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;758    									GPIO_Pin_15;
;;;759    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001e  2003              MOVS     r0,#3
000020  f88d0002          STRB     r0,[sp,#2]
;;;760    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000024  2018              MOVS     r0,#0x18
000026  f88d0003          STRB     r0,[sp,#3]
;;;761    		GPIO_Init(GPIOD, &GPIO_InitStructure);
00002a  4669              MOV      r1,sp
00002c  481e              LDR      r0,|L3.168|
00002e  f7fffffe          BL       GPIO_Init
;;;762    
;;;763    		/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;764    		 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;765    		/* PE3,PE4 用于A19, A20, STM32F103ZE-EK(REV 1.0)必须使能 */
;;;766    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
000032  f64f7098          MOV      r0,#0xff98
000036  f8ad0000          STRH     r0,[sp,#0]
;;;767    									GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;768    									GPIO_Pin_15 | GPIO_Pin_3 | GPIO_Pin_4;
;;;769    		GPIO_Init(GPIOE, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  481b              LDR      r0,|L3.172|
00003e  f7fffffe          BL       GPIO_Init
;;;770    
;;;771    		/* 设置 PF.00(A0 (RS))  为复用推挽输出 */
;;;772    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
000042  2501              MOVS     r5,#1
000044  f8ad5000          STRH     r5,[sp,#0]
;;;773    		GPIO_Init(GPIOF, &GPIO_InitStructure);
000048  4669              MOV      r1,sp
00004a  4819              LDR      r0,|L3.176|
00004c  f7fffffe          BL       GPIO_Init
;;;774    
;;;775    		/* 设置 PG.12(NE4 (LCD/CS)) 为复用推挽输出 */
;;;776    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
000050  032c              LSLS     r4,r5,#12
000052  f8ad4000          STRH     r4,[sp,#0]
;;;777    		GPIO_Init(GPIOG, &GPIO_InitStructure);
000056  4669              MOV      r1,sp
000058  4816              LDR      r0,|L3.180|
00005a  f7fffffe          BL       GPIO_Init
;;;778    	}
;;;779    
;;;780    	/* 2.配置FSMC总线参数 */
;;;781    	{
;;;782    		FSMC_NORSRAMInitTypeDef  init;
;;;783    		FSMC_NORSRAMTimingInitTypeDef  timing;
;;;784    
;;;785    		/*-- FSMC Configuration ------------------------------------------------------*/
;;;786    		/*----------------------- SRAM Bank 4 ----------------------------------------*/
;;;787    		/* FSMC_Bank1_NORSRAM4 configuration */
;;;788    		timing.FSMC_AddressSetupTime = 1;
;;;789    		timing.FSMC_AddressHoldTime = 0;
00005e  2000              MOVS     r0,#0
;;;790    		timing.FSMC_DataSetupTime = 2;
000060  2102              MOVS     r1,#2
000062  e9cd0110          STRD     r0,r1,[sp,#0x40]
;;;791    		timing.FSMC_BusTurnAroundDuration = 0;
;;;792    		timing.FSMC_CLKDivision = 0;
;;;793    		timing.FSMC_DataLatency = 0;
;;;794    		timing.FSMC_AccessMode = FSMC_AccessMode_A;
000066  9014              STR      r0,[sp,#0x50]
;;;795    
;;;796    		/*
;;;797    		 LCD configured as follow:
;;;798    			- Data/Address MUX = Disable
;;;799    			- Memory Type = SRAM
;;;800    			- Data Width = 16bit
;;;801    			- Write Operation = Enable
;;;802    			- Extended Mode = Enable
;;;803    			- Asynchronous Wait = Disable
;;;804    		*/
;;;805    		init.FSMC_Bank = FSMC_Bank1_NORSRAM4;
000068  2106              MOVS     r1,#6
00006a  9015              STR      r0,[sp,#0x54]
00006c  e9cd1000          STRD     r1,r0,[sp,#0]
000070  9012              STR      r0,[sp,#0x48]         ;792
;;;806    		init.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;807    		init.FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;808    		init.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
000072  2110              MOVS     r1,#0x10
000074  e9cd0102          STRD     r0,r1,[sp,#8]
000078  9013              STR      r0,[sp,#0x4c]         ;793
;;;809    		init.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;810    		init.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;	/* 注意旧库无这个成员 */
00007a  9004              STR      r0,[sp,#0x10]
;;;811    		init.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
;;;812    		init.FSMC_WrapMode = FSMC_WrapMode_Disable;
00007c  e9cd0408          STRD     r0,r4,[sp,#0x20]
000080  9005              STR      r0,[sp,#0x14]         ;811
000082  9006              STR      r0,[sp,#0x18]
000084  9007              STR      r0,[sp,#0x1c]
;;;813    		init.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;814    		init.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
;;;815    		init.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;816    		init.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000086  900a              STR      r0,[sp,#0x28]
;;;817    		init.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000088  900b              STR      r0,[sp,#0x2c]
;;;818    
;;;819    		init.FSMC_ReadWriteTimingStruct = &timing;
00008a  900c              STR      r0,[sp,#0x30]
00008c  a80f              ADD      r0,sp,#0x3c
00008e  e9cd050e          STRD     r0,r5,[sp,#0x38]
000092  900d              STR      r0,[sp,#0x34]
;;;820    		init.FSMC_WriteTimingStruct = &timing;
;;;821    
;;;822    		FSMC_NORSRAMInit(&init);
000094  4668              MOV      r0,sp
000096  f7fffffe          BL       FSMC_NORSRAMInit
;;;823    
;;;824    		/* - BANK 3 (of NOR/SRAM Bank 1~4) is enabled */
;;;825    		FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);
00009a  2101              MOVS     r1,#1
00009c  2006              MOVS     r0,#6
00009e  f7fffffe          BL       FSMC_NORSRAMCmd
;;;826    	}
;;;827    }
0000a2  b017              ADD      sp,sp,#0x5c
0000a4  bd30              POP      {r4,r5,pc}
;;;828    
                          ENDP

0000a6  0000              DCW      0x0000
                  |L3.168|
                          DCD      0x40011400
                  |L3.172|
                          DCD      0x40011800
                  |L3.176|
                          DCD      0x40011c00
                  |L3.180|
                          DCD      0x40012000

                          AREA ||i.OLED_DispOff||, CODE, READONLY, ALIGN=2

                  OLED_DispOff PROC
;;;189    */
;;;190    void OLED_DispOff(void)
000000  4803              LDR      r0,|L4.16|
;;;191    {
;;;192    	OLED_WriteCmd(0x8D);	/* 设置充电泵（和下个命令结合使用）*/
000002  218d              MOVS     r1,#0x8d
000004  8001              STRH     r1,[r0,#0]
;;;193    	OLED_WriteCmd(0x10);	/* 0x14 使能充电泵，0x10 是关闭 */
000006  2110              MOVS     r1,#0x10
000008  8001              STRH     r1,[r0,#0]
;;;194    	OLED_WriteCmd(0xAE);	/* 打开OLED面板 */
00000a  21ae              MOVS     r1,#0xae
00000c  8001              STRH     r1,[r0,#0]
;;;195    }
00000e  4770              BX       lr
;;;196    
                          ENDP

                  |L4.16|
                          DCD      0x6c200000

                          AREA ||i.OLED_DispOn||, CODE, READONLY, ALIGN=2

                  OLED_DispOn PROC
;;;174    */
;;;175    void OLED_DispOn(void)
000000  4803              LDR      r0,|L5.16|
;;;176    {
;;;177    	OLED_WriteCmd(0x8D);	/* 设置充电泵（和下个命令结合使用） */
000002  218d              MOVS     r1,#0x8d
000004  8001              STRH     r1,[r0,#0]
;;;178    	OLED_WriteCmd(0x14);	/* 0x14 使能充电泵， 0x10 是关闭 */
000006  2114              MOVS     r1,#0x14
000008  8001              STRH     r1,[r0,#0]
;;;179    	OLED_WriteCmd(0xAF);	/* 打开OLED面板 */
00000a  21af              MOVS     r1,#0xaf
00000c  8001              STRH     r1,[r0,#0]
;;;180    }
00000e  4770              BX       lr
;;;181    
                          ENDP

                  |L5.16|
                          DCD      0x6c200000

                          AREA ||i.OLED_DispStr||, CODE, READONLY, ALIGN=2

                  OLED_DispStr PROC
;;;322    */
;;;323    void OLED_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr, FONT_T *_tFont)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;324    {
000004  b0ad              SUB      sp,sp,#0xb4
;;;325    	uint32_t i;
;;;326    	uint8_t code1;
;;;327    	uint8_t code2;
;;;328    	uint32_t address = 0;
000006  2000              MOVS     r0,#0
;;;329    	uint8_t buf[32 * 32 / 8];	/* 最大支持32点阵汉字 */
;;;330    	uint8_t m, width;
;;;331    	uint8_t font_width,font_height, font_bytes;
;;;332    	uint16_t x, y;
;;;333    	const uint8_t *pAscDot;	
;;;334    
;;;335    #ifdef USE_SMALL_FONT		
;;;336    	const uint8_t *pHzDot;
;;;337    #else	
;;;338    	uint32_t AddrHZK;
;;;339    #endif	
;;;340    
;;;341    	/* 如果字体结构为空指针，则缺省按16点阵 */
;;;342    	if (_tFont->FontCode == FC_ST_12)
000008  9025              STR      r0,[sp,#0x94]
00000a  9830              LDR      r0,[sp,#0xc0]
00000c  4692              MOV      r10,r2                ;324
00000e  7800              LDRB     r0,[r0,#0]
000010  b148              CBZ      r0,|L6.38|
;;;343    	{
;;;344    		font_height = 12;
;;;345    		font_width = 12;
;;;346    		font_bytes = 24;
;;;347    		pAscDot = g_Ascii12;
;;;348    	#ifdef USE_SMALL_FONT		
;;;349    		pHzDot = g_Hz12;
;;;350    	#else		
;;;351    		AddrHZK = HZK12_ADDR;
;;;352    	#endif		
;;;353    	}
;;;354    	else
;;;355    	{
;;;356    		/* 缺省是16点阵 */
;;;357    		font_height = 16;
;;;358    		font_width = 16;
;;;359    		font_bytes = 32;
000012  2020              MOVS     r0,#0x20
;;;360    		pAscDot = g_Ascii16;
000014  9021              STR      r0,[sp,#0x84]
000016  4844              LDR      r0,|L6.296|
;;;361    	#ifdef USE_SMALL_FONT		
;;;362    		pHzDot = g_Hz16;
;;;363    	#else
;;;364    		AddrHZK = HZK16_ADDR;
000018  9026              STR      r0,[sp,#0x98]
00001a  f04f0810          MOV      r8,#0x10              ;357
00001e  4843              LDR      r0,|L6.300|
000020  46c1              MOV      r9,r8                 ;358
                  |L6.34|
000022  9024              STR      r0,[sp,#0x90]         ;351
000024  e078              B        |L6.280|
                  |L6.38|
000026  2018              MOVS     r0,#0x18              ;346
000028  9021              STR      r0,[sp,#0x84]         ;347
00002a  4841              LDR      r0,|L6.304|
00002c  f04f080c          MOV      r8,#0xc               ;344
000030  9026              STR      r0,[sp,#0x98]         ;351
000032  46c1              MOV      r9,r8                 ;345
000034  f04f40c8          MOV      r0,#0x64000000        ;351
000038  e7f3              B        |L6.34|
                  |L6.58|
;;;365    	#endif
;;;366    	}
;;;367    
;;;368    	/* 开始循环处理字符 */
;;;369    	while (*_ptr != 0)
;;;370    	{
;;;371    		code1 = *_ptr;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
;;;372    		if (code1 < 0x80)
00003a  2880              CMP      r0,#0x80
00003c  d20a              BCS      |L6.84|
;;;373    		{
;;;374    			/* 将ascii字符点阵复制到buf */
;;;375    			memcpy(buf, &pAscDot[code1 * (font_bytes / 2)], (font_bytes / 2));
00003e  9921              LDR      r1,[sp,#0x84]
000040  084a              LSRS     r2,r1,#1
000042  9926              LDR      r1,[sp,#0x98]
000044  fb001102          MLA      r1,r0,r2,r1
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       __aeabi_memcpy
;;;376    			width = font_width / 2;
00004e  ea4f0659          LSR      r6,r9,#1
000052  e02b              B        |L6.172|
                  |L6.84|
;;;377    		}
;;;378    		else
;;;379    		{
;;;380    			code2 = *++_ptr;
000054  f81a2f01          LDRB     r2,[r10,#1]!
;;;381    			if (code2 == 0)
000058  2a00              CMP      r2,#0
00005a  d061              BEQ      |L6.288|
;;;382    			{
;;;383    				break;
;;;384    			}
;;;385    
;;;386    			/* 计算16点阵汉字点阵地址
;;;387    				ADDRESS = [(code1-0xa1) * 94 + (code2-0xa1)] * 32
;;;388    				;
;;;389    			*/
;;;390    			#ifdef USE_SMALL_FONT
;;;391    				m = 0;
;;;392    				while(1)
;;;393    				{
;;;394    					address = m * (font_bytes + 2);
;;;395    					m++;
;;;396    					if ((code1 == pHzDot[address + 0]) && (code2 == pHzDot[address + 1]))
;;;397    					{
;;;398    						address += 2;
;;;399    						memcpy(buf, &pHzDot[address], font_bytes);
;;;400    						break;
;;;401    					}
;;;402    					else if ((pHzDot[address + 0] == 0xFF) && (pHzDot[address + 1] == 0xFF))
;;;403    					{
;;;404    						/* 字库搜索完毕，未找到，则填充全FF */
;;;405    						memset(buf, 0xFF, font_bytes);
;;;406    						break;
;;;407    					}
;;;408    				}
;;;409    			#else	/* 用全字库 */
;;;410    				/* 此处需要根据字库文件存放位置进行修改 */
;;;411    				if (code1 >=0xA1 && code1 <= 0xA9 && code2 >=0xA1)
00005c  f1a001a1          SUB      r1,r0,#0xa1
000060  2908              CMP      r1,#8
000062  d80b              BHI      |L6.124|
000064  2aa1              CMP      r2,#0xa1
000066  d309              BCC      |L6.124|
;;;412    				{
;;;413    					address = ((code1 - 0xA1) * 94 + (code2 - 0xA1)) * font_bytes + AddrHZK;
000068  ebc11001          RSB      r0,r1,r1,LSL #4
00006c  eb001041          ADD      r0,r0,r1,LSL #5
000070  eb020040          ADD      r0,r2,r0,LSL #1
000074  38a1              SUBS     r0,r0,#0xa1
000076  9a24              LDR      r2,[sp,#0x90]
000078  9921              LDR      r1,[sp,#0x84]
00007a  e00e              B        |L6.154|
                  |L6.124|
00007c  38b0              SUBS     r0,r0,#0xb0
;;;414    				}
;;;415    				else if (code1 >=0xB0 && code1 <= 0xF7 && code2 >=0xA1)
00007e  2847              CMP      r0,#0x47
000080  d80e              BHI      |L6.160|
000082  2aa1              CMP      r2,#0xa1
000084  d30c              BCC      |L6.160|
;;;416    				{
;;;417    					address = ((code1 - 0xB0) * 94 + (code2 - 0xA1) + 846) * font_bytes + AddrHZK;
000086  ebc01100          RSB      r1,r0,r0,LSL #4
00008a  eb011040          ADD      r0,r1,r0,LSL #5
00008e  eb020040          ADD      r0,r2,r0,LSL #1
000092  9a24              LDR      r2,[sp,#0x90]
000094  9921              LDR      r1,[sp,#0x84]
000096  f20020ad          ADD      r0,r0,#0x2ad
                  |L6.154|
00009a  fb002001          MLA      r0,r0,r1,r2
00009e  9025              STR      r0,[sp,#0x94]
                  |L6.160|
;;;418    				}
;;;419    				memcpy(buf, (const uint8_t *)address, font_bytes);
0000a0  4668              MOV      r0,sp
0000a2  9a21              LDR      r2,[sp,#0x84]
0000a4  9925              LDR      r1,[sp,#0x94]
0000a6  f7fffffe          BL       __aeabi_memcpy
;;;420    			#endif
;;;421    
;;;422    				width = font_width;
0000aa  464e              MOV      r6,r9
                  |L6.172|
;;;423    		}
;;;424    
;;;425    		y = _usY;
0000ac  982e              LDR      r0,[sp,#0xb8]
;;;426    		/* 开始刷LCD */
;;;427    		for (m = 0; m < font_height; m++)	/* 字符高度 */
0000ae  2500              MOVS     r5,#0
0000b0  9022              STR      r0,[sp,#0x88]
0000b2  e026              B        |L6.258|
                  |L6.180|
;;;428    		{
;;;429    			x = _usX;
;;;430    			for (i = 0; i < width; i++)	/* 字符宽度 */
0000b4  2400              MOVS     r4,#0
;;;431    			{
;;;432    				if ((buf[m * ((2 * width) / font_width) + i / 8] & (0x80 >> (i % 8 ))) != 0x00)
0000b6  ea4f0b46          LSL      r11,r6,#1
0000ba  9f2d              LDR      r7,[sp,#0xb4]         ;430
0000bc  e019              B        |L6.242|
0000be  bf00              NOP      
                  |L6.192|
0000c0  fbbbf0f9          UDIV     r0,r11,r9
0000c4  4669              MOV      r1,sp
0000c6  4368              MULS     r0,r5,r0
0000c8  eb0101d4          ADD      r1,r1,r4,LSR #3
0000cc  f0040207          AND      r2,r4,#7
0000d0  5c41              LDRB     r1,[r0,r1]
0000d2  2080              MOVS     r0,#0x80
0000d4  40d0              LSRS     r0,r0,r2
0000d6  4201              TST      r1,r0
0000d8  9830              LDR      r0,[sp,#0xc0]
0000da  d001              BEQ      |L6.224|
;;;433    				{
;;;434    					OLED_PutPixel(x, y, _tFont->FrontColor);	/* 设置像素颜色为文字色 */
0000dc  7880              LDRB     r0,[r0,#2]
0000de  e000              B        |L6.226|
                  |L6.224|
;;;435    				}
;;;436    				else
;;;437    				{
;;;438    					OLED_PutPixel(x, y, _tFont->BackColor);	/* 设置像素颜色为文字背景色 */
0000e0  7900              LDRB     r0,[r0,#4]
                  |L6.226|
0000e2  9922              LDR      r1,[sp,#0x88]
0000e4  b2c2              UXTB     r2,r0
0000e6  4638              MOV      r0,r7
0000e8  f7fffffe          BL       OLED_PutPixel
0000ec  1c7f              ADDS     r7,r7,#1
;;;439    				}
;;;440    
;;;441    				x++;
0000ee  b2bf              UXTH     r7,r7
0000f0  1c64              ADDS     r4,r4,#1
                  |L6.242|
0000f2  42b4              CMP      r4,r6                 ;430
0000f4  d3e4              BCC      |L6.192|
;;;442    			}
;;;443    			y++;
0000f6  9822              LDR      r0,[sp,#0x88]
0000f8  1c40              ADDS     r0,r0,#1
0000fa  b280              UXTH     r0,r0
0000fc  1c6d              ADDS     r5,r5,#1
0000fe  b2ed              UXTB     r5,r5                 ;427
000100  9022              STR      r0,[sp,#0x88]         ;427
                  |L6.258|
000102  4545              CMP      r5,r8                 ;427
000104  d3d6              BCC      |L6.180|
;;;444    		}
;;;445    
;;;446    		if (_tFont->Space > 0)
;;;447    		{
;;;448    			/* 如果文字底色按_tFont->usBackColor，并且字间距大于点阵的宽度，那么需要在文字之间填充(暂时未实现) */
;;;449    		}
;;;450    		_usX += width + _tFont->Space;	/* 列地址递增 */
000106  9830              LDR      r0,[sp,#0xc0]
;;;451    		_ptr++;			/* 指向下一个字符 */
000108  f10a0a01          ADD      r10,r10,#1
00010c  88c1              LDRH     r1,[r0,#6]            ;450
00010e  982d              LDR      r0,[sp,#0xb4]         ;450
000110  4430              ADD      r0,r0,r6              ;450
000112  4408              ADD      r0,r0,r1              ;450
000114  b280              UXTH     r0,r0                 ;450
000116  902d              STR      r0,[sp,#0xb4]
                  |L6.280|
000118  f89a0000          LDRB     r0,[r10,#0]           ;369
00011c  2800              CMP      r0,#0                 ;369
00011e  d18c              BNE      |L6.58|
                  |L6.288|
;;;452    	}
;;;453    }
000120  b031              ADD      sp,sp,#0xc4
000122  e8bd8ff0          POP      {r4-r11,pc}
;;;454    
                          ENDP

000126  0000              DCW      0x0000
                  |L6.296|
                          DCD      g_Ascii16
                  |L6.300|
                          DCD      0x6402c9d0
                  |L6.304|
                          DCD      g_Ascii12

                          AREA ||i.OLED_DrawBMP||, CODE, READONLY, ALIGN=1

                  OLED_DrawBMP PROC
;;;719    */
;;;720    void OLED_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t *_ptr)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;721    {
000004  4698              MOV      r8,r3
000006  4616              MOV      r6,r2
000008  4689              MOV      r9,r1
00000a  4683              MOV      r11,r0
;;;722    	uint16_t x, y;
;;;723    
;;;724    	for (x = 0; x < _usWidth; x++)
00000c  2500              MOVS     r5,#0
00000e  f8dda024          LDR      r10,[sp,#0x24]        ;721
000012  e011              B        |L7.56|
                  |L7.20|
;;;725    	{
;;;726    		for (y = 0; y < _usHeight; y++)
000014  2400              MOVS     r4,#0
;;;727    		{
;;;728    			OLED_PutPixel(_usX + x, _usY + y, *_ptr);
000016  eb0b0705          ADD      r7,r11,r5
00001a  e009              B        |L7.48|
                  |L7.28|
00001c  eb090004          ADD      r0,r9,r4
000020  b281              UXTH     r1,r0
000022  f89a2000          LDRB     r2,[r10,#0]
000026  b2b8              UXTH     r0,r7
000028  f7fffffe          BL       OLED_PutPixel
00002c  1c64              ADDS     r4,r4,#1
00002e  b2a4              UXTH     r4,r4                 ;726
                  |L7.48|
000030  42b4              CMP      r4,r6                 ;726
000032  d3f3              BCC      |L7.28|
000034  1c6d              ADDS     r5,r5,#1              ;726
000036  b2ad              UXTH     r5,r5                 ;724
                  |L7.56|
000038  4545              CMP      r5,r8                 ;724
00003a  d3eb              BCC      |L7.20|
;;;729    		}
;;;730    	}
;;;731    }
00003c  e8bd8ff0          POP      {r4-r11,pc}
;;;732    
                          ENDP


                          AREA ||i.OLED_DrawCircle||, CODE, READONLY, ALIGN=1

                  OLED_DrawCircle PROC
;;;673    */
;;;674    void OLED_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint8_t _ucColor)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;675    {
000004  4680              MOV      r8,r0
;;;676    	int32_t  D;			/* Decision Variable */
;;;677    	uint32_t  CurX;		/* 当前 X 值 */
;;;678    	uint32_t  CurY;		/* 当前 Y 值 */
;;;679    
;;;680    	D = 3 - (_usRadius << 1);
000006  2003              MOVS     r0,#3
000008  460f              MOV      r7,r1                 ;675
00000a  eba00642          SUB      r6,r0,r2,LSL #1
;;;681    	CurX = 0;
00000e  2500              MOVS     r5,#0
;;;682    	CurY = _usRadius;
000010  4614              MOV      r4,r2
000012  e053              B        |L8.188|
                  |L8.20|
;;;683    
;;;684    	while (CurX <= CurY)
;;;685    	{
;;;686    		OLED_PutPixel(_usX + CurX, _usY + CurY, _ucColor);
000014  eb070b04          ADD      r11,r7,r4
000018  eb080905          ADD      r9,r8,r5
00001c  fa1ff18b          UXTH     r1,r11
000020  fa1ff089          UXTH     r0,r9
000024  9a03              LDR      r2,[sp,#0xc]
000026  f7fffffe          BL       OLED_PutPixel
;;;687    		OLED_PutPixel(_usX + CurX, _usY - CurY, _ucColor);
00002a  eba70a04          SUB      r10,r7,r4
00002e  fa1ff18a          UXTH     r1,r10
000032  fa1ff089          UXTH     r0,r9
000036  9a03              LDR      r2,[sp,#0xc]
000038  f7fffffe          BL       OLED_PutPixel
;;;688    		OLED_PutPixel(_usX - CurX, _usY + CurY, _ucColor);
00003c  eba80905          SUB      r9,r8,r5
000040  fa1ff18b          UXTH     r1,r11
000044  fa1ff089          UXTH     r0,r9
000048  9a03              LDR      r2,[sp,#0xc]
00004a  f7fffffe          BL       OLED_PutPixel
;;;689    		OLED_PutPixel(_usX - CurX, _usY - CurY, _ucColor);
00004e  fa1ff18a          UXTH     r1,r10
000052  fa1ff089          UXTH     r0,r9
000056  9a03              LDR      r2,[sp,#0xc]
000058  f7fffffe          BL       OLED_PutPixel
;;;690    		OLED_PutPixel(_usX + CurY, _usY + CurX, _ucColor);
00005c  eb070b05          ADD      r11,r7,r5
000060  eb080904          ADD      r9,r8,r4
000064  fa1ff18b          UXTH     r1,r11
000068  fa1ff089          UXTH     r0,r9
00006c  9a03              LDR      r2,[sp,#0xc]
00006e  f7fffffe          BL       OLED_PutPixel
;;;691    		OLED_PutPixel(_usX + CurY, _usY - CurX, _ucColor);
000072  eba70a05          SUB      r10,r7,r5
000076  fa1ff18a          UXTH     r1,r10
00007a  fa1ff089          UXTH     r0,r9
00007e  9a03              LDR      r2,[sp,#0xc]
000080  f7fffffe          BL       OLED_PutPixel
;;;692    		OLED_PutPixel(_usX - CurY, _usY + CurX, _ucColor);
000084  eba80904          SUB      r9,r8,r4
000088  fa1ff18b          UXTH     r1,r11
00008c  fa1ff089          UXTH     r0,r9
000090  9a03              LDR      r2,[sp,#0xc]
000092  f7fffffe          BL       OLED_PutPixel
;;;693    		OLED_PutPixel(_usX - CurY, _usY - CurX, _ucColor);
000096  fa1ff18a          UXTH     r1,r10
00009a  fa1ff089          UXTH     r0,r9
00009e  9a03              LDR      r2,[sp,#0xc]
0000a0  f7fffffe          BL       OLED_PutPixel
;;;694    
;;;695    		if (D < 0)
0000a4  2e00              CMP      r6,#0
0000a6  da03              BGE      |L8.176|
;;;696    		{
;;;697    			D += (CurX << 2) + 6;
0000a8  eb060685          ADD      r6,r6,r5,LSL #2
0000ac  1db6              ADDS     r6,r6,#6
0000ae  e004              B        |L8.186|
                  |L8.176|
;;;698    		}
;;;699    		else
;;;700    		{
;;;701    			D += ((CurX - CurY) << 2) + 10;
0000b0  1b28              SUBS     r0,r5,r4
0000b2  eb060680          ADD      r6,r6,r0,LSL #2
0000b6  1e64              SUBS     r4,r4,#1
0000b8  360a              ADDS     r6,r6,#0xa
                  |L8.186|
0000ba  1c6d              ADDS     r5,r5,#1
                  |L8.188|
0000bc  42a5              CMP      r5,r4                 ;684
0000be  d9a9              BLS      |L8.20|
;;;702    			CurY--;
;;;703    		}
;;;704    		CurX++;
;;;705    	}
;;;706    }
0000c0  e8bd8fff          POP      {r0-r11,pc}
;;;707    
                          ENDP


                          AREA ||i.OLED_DrawLine||, CODE, READONLY, ALIGN=1

                  OLED_DrawLine PROC
;;;536    */
;;;537    void OLED_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint8_t _ucColor)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;538    {
000004  4616              MOV      r6,r2
000006  461f              MOV      r7,r3
000008  460d              MOV      r5,r1
00000a  4604              MOV      r4,r0
;;;539    	int32_t dx , dy ;
;;;540    	int32_t tx , ty ;
;;;541    	int32_t inc1 , inc2 ;
;;;542    	int32_t d , iTag ;
;;;543    	int32_t x , y ;
;;;544    
;;;545    	/* 采用 Bresenham 算法，在2点间画一条直线 */
;;;546    
;;;547    	OLED_PutPixel(_usX1 , _usY1 , _ucColor);
00000c  9a0a              LDR      r2,[sp,#0x28]
00000e  f7fffffe          BL       OLED_PutPixel
;;;548    
;;;549    	/* 如果两点重合，结束后面的动作。*/
;;;550    	if ( _usX1 == _usX2 && _usY1 == _usY2 )
000012  42b4              CMP      r4,r6
000014  d101              BNE      |L9.26|
000016  42bd              CMP      r5,r7
000018  d041              BEQ      |L9.158|
                  |L9.26|
;;;551    	{
;;;552    		return;
;;;553    	}
;;;554    
;;;555    	iTag = 0 ;
00001a  f04f0800          MOV      r8,#0
;;;556    	/* dx = abs ( _usX2 - _usX1 ); */
;;;557    	if (_usX2 >= _usX1)
00001e  42a6              CMP      r6,r4
000020  d301              BCC      |L9.38|
;;;558    	{
;;;559    		dx = _usX2 - _usX1;
000022  1b31              SUBS     r1,r6,r4
000024  e000              B        |L9.40|
                  |L9.38|
;;;560    	}
;;;561    	else
;;;562    	{
;;;563    		dx = _usX1 - _usX2;
000026  1ba1              SUBS     r1,r4,r6
                  |L9.40|
;;;564    	}
;;;565    
;;;566    	/* dy = abs ( _usY2 - _usY1 ); */
;;;567    	if (_usY2 >= _usY1)
000028  42af              CMP      r7,r5
00002a  d301              BCC      |L9.48|
;;;568    	{
;;;569    		dy = _usY2 - _usY1;
00002c  1b78              SUBS     r0,r7,r5
00002e  e000              B        |L9.50|
                  |L9.48|
;;;570    	}
;;;571    	else
;;;572    	{
;;;573    		dy = _usY1 - _usY2;
000030  1be8              SUBS     r0,r5,r7
                  |L9.50|
;;;574    	}
;;;575    
;;;576    	if ( dx < dy )   /*如果dy为计长方向，则交换纵横坐标。*/
000032  4281              CMP      r1,r0
000034  da0a              BGE      |L9.76|
;;;577    	{
;;;578    		uint16_t temp;
;;;579    
;;;580    		iTag = 1 ;
;;;581    		temp = _usX1; _usX1 = _usY1; _usY1 = temp;
000036  4622              MOV      r2,r4
000038  462c              MOV      r4,r5
00003a  4615              MOV      r5,r2
;;;582    		temp = _usX2; _usX2 = _usY2; _usY2 = temp;
00003c  4632              MOV      r2,r6
00003e  463e              MOV      r6,r7
000040  4617              MOV      r7,r2
;;;583    		temp = dx; dx = dy; dy = temp;
000042  b28a              UXTH     r2,r1
000044  4601              MOV      r1,r0
000046  f04f0801          MOV      r8,#1                 ;580
00004a  4610              MOV      r0,r2
                  |L9.76|
;;;584    	}
;;;585    	tx = _usX2 > _usX1 ? 1 : -1 ;    /* 确定是增1还是减1 */
00004c  f04f32ff          MOV      r2,#0xffffffff
000050  42a6              CMP      r6,r4
000052  d901              BLS      |L9.88|
000054  2301              MOVS     r3,#1
000056  e000              B        |L9.90|
                  |L9.88|
000058  4613              MOV      r3,r2
                  |L9.90|
00005a  469a              MOV      r10,r3
;;;586    	ty = _usY2 > _usY1 ? 1 : -1 ;
00005c  42af              CMP      r7,r5
00005e  d900              BLS      |L9.98|
000060  2201              MOVS     r2,#1
                  |L9.98|
;;;587    	x = _usX1 ;
;;;588    	y = _usY1 ;
;;;589    	inc1 = 2 * dy ;
000062  ea4f0940          LSL      r9,r0,#1
;;;590    	inc2 = 2 * ( dy - dx );
000066  1a40              SUBS     r0,r0,r1
000068  0040              LSLS     r0,r0,#1
00006a  4693              MOV      r11,r2                ;586
;;;591    	d = inc1 - dx ;
00006c  eba90701          SUB      r7,r9,r1
;;;592    	while ( x != _usX2 )     /* 循环画点 */
000070  9000              STR      r0,[sp,#0]
000072  e012              B        |L9.154|
                  |L9.116|
;;;593    	{
;;;594    		if ( d < 0 )
000074  2f00              CMP      r7,#0
000076  da01              BGE      |L9.124|
;;;595    		{
;;;596    			d += inc1 ;
000078  444f              ADD      r7,r7,r9
00007a  e002              B        |L9.130|
                  |L9.124|
;;;597    		}
;;;598    		else
;;;599    		{
;;;600    			y += ty ;
;;;601    			d += inc2 ;
00007c  9800              LDR      r0,[sp,#0]
00007e  445d              ADD      r5,r5,r11             ;600
000080  4407              ADD      r7,r7,r0
                  |L9.130|
;;;602    		}
;;;603    		if ( iTag )
000082  f1b80f00          CMP      r8,#0
000086  d002              BEQ      |L9.142|
;;;604    		{
;;;605    			OLED_PutPixel ( y , x , _ucColor) ;
000088  b2a1              UXTH     r1,r4
00008a  b2a8              UXTH     r0,r5
00008c  e001              B        |L9.146|
                  |L9.142|
;;;606    		}
;;;607    		else
;;;608    		{
;;;609    			OLED_PutPixel ( x , y , _ucColor) ;
00008e  b2a9              UXTH     r1,r5
000090  b2a0              UXTH     r0,r4
                  |L9.146|
000092  9a0a              LDR      r2,[sp,#0x28]
000094  f7fffffe          BL       OLED_PutPixel
;;;610    		}
;;;611    		x += tx ;
000098  4454              ADD      r4,r4,r10
                  |L9.154|
00009a  42b4              CMP      r4,r6                 ;592
00009c  d1ea              BNE      |L9.116|
                  |L9.158|
;;;612    	}
;;;613    }
00009e  e8bd8ff8          POP      {r3-r11,pc}
;;;614    
                          ENDP


                          AREA ||i.OLED_DrawPoints||, CODE, READONLY, ALIGN=1

                  OLED_DrawPoints PROC
;;;624    */
;;;625    void OLED_DrawPoints(uint16_t *x, uint16_t *y, uint16_t _usSize, uint8_t _ucColor)
000000  e92d41f8          PUSH     {r3-r8,lr}
;;;626    {
;;;627    	uint16_t i;
;;;628    
;;;629    	for (i = 0 ; i < _usSize - 1; i++)
000004  2400              MOVS     r4,#0
000006  4698              MOV      r8,r3                 ;626
000008  460e              MOV      r6,r1                 ;626
00000a  4607              MOV      r7,r0                 ;626
00000c  1e55              SUBS     r5,r2,#1
00000e  e00f              B        |L10.48|
                  |L10.16|
;;;630    	{
;;;631    		OLED_DrawLine(x[i], y[i], x[i + 1], y[i + 1], _ucColor);
000010  eb060044          ADD      r0,r6,r4,LSL #1
000014  f8cd8000          STR      r8,[sp,#0]
000018  8843              LDRH     r3,[r0,#2]
00001a  eb070044          ADD      r0,r7,r4,LSL #1
00001e  f8361014          LDRH     r1,[r6,r4,LSL #1]
000022  8842              LDRH     r2,[r0,#2]
000024  f8370014          LDRH     r0,[r7,r4,LSL #1]
000028  f7fffffe          BL       OLED_DrawLine
00002c  1c64              ADDS     r4,r4,#1
00002e  b2a4              UXTH     r4,r4                 ;629
                  |L10.48|
000030  42ac              CMP      r4,r5                 ;629
000032  dbed              BLT      |L10.16|
;;;632    	}
;;;633    }
000034  e8bd81f8          POP      {r3-r8,pc}
;;;634    
                          ENDP


                          AREA ||i.OLED_DrawRect||, CODE, READONLY, ALIGN=1

                  OLED_DrawRect PROC
;;;645    */
;;;646    void OLED_DrawRect(uint16_t _usX, uint16_t _usY, uint8_t _usHeight, uint16_t _usWidth, uint8_t _ucColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;647    {
;;;648    	/*
;;;649    	 ---------------->---
;;;650    	|(_usX，_usY)        |
;;;651    	V                    V  _usHeight
;;;652    	|                    |
;;;653    	 ---------------->---
;;;654    		  _usWidth
;;;655    	*/
;;;656    
;;;657    	OLED_DrawLine(_usX, _usY, _usX + _usWidth - 1, _usY, _ucColor);	/* 顶 */
000004  18c5              ADDS     r5,r0,r3
000006  4614              MOV      r4,r2                 ;647
000008  9e08              LDR      r6,[sp,#0x20]
00000a  1e6d              SUBS     r5,r5,#1
00000c  4688              MOV      r8,r1                 ;647
00000e  4607              MOV      r7,r0                 ;647
000010  b2aa              UXTH     r2,r5
000012  460b              MOV      r3,r1
000014  9600              STR      r6,[sp,#0]
000016  f7fffffe          BL       OLED_DrawLine
;;;658    	OLED_DrawLine(_usX, _usY + _usHeight - 1, _usX + _usWidth - 1, _usY + _usHeight - 1, _ucColor);	/* 底 */
00001a  eb080904          ADD      r9,r8,r4
00001e  f1a90401          SUB      r4,r9,#1
000022  b2a3              UXTH     r3,r4
000024  b2aa              UXTH     r2,r5
000026  b2a1              UXTH     r1,r4
000028  4638              MOV      r0,r7
00002a  9600              STR      r6,[sp,#0]
00002c  f7fffffe          BL       OLED_DrawLine
;;;659    
;;;660    	OLED_DrawLine(_usX, _usY, _usX, _usY + _usHeight - 1, _ucColor);	/* 左 */
000030  463a              MOV      r2,r7
000032  b2a3              UXTH     r3,r4
000034  4641              MOV      r1,r8
000036  4610              MOV      r0,r2
000038  9600              STR      r6,[sp,#0]
00003a  f7fffffe          BL       OLED_DrawLine
;;;661    	OLED_DrawLine(_usX + _usWidth - 1, _usY, _usX + _usWidth - 1, _usY + _usHeight, _ucColor);	/* 右 */
00003e  fa1ff389          UXTH     r3,r9
000042  b2aa              UXTH     r2,r5
000044  b2a8              UXTH     r0,r5
000046  4641              MOV      r1,r8
000048  9600              STR      r6,[sp,#0]
00004a  f7fffffe          BL       OLED_DrawLine
;;;662    }
00004e  e8bd83f8          POP      {r3-r9,pc}
;;;663    
                          ENDP


                          AREA ||i.OLED_EndDraw||, CODE, READONLY, ALIGN=2

                  OLED_EndDraw PROC
;;;253    */
;;;254    void OLED_EndDraw(void)
000000  4902              LDR      r1,|L12.12|
;;;255    {
;;;256    	s_ucUpdateEn = 1;
000002  2001              MOVS     r0,#1
000004  7008              STRB     r0,[r1,#0]
;;;257    	OLED_BufToPanel();
000006  f7ffbffe          B.W      OLED_BufToPanel
;;;258    }
;;;259    
                          ENDP

00000a  0000              DCW      0x0000
                  |L12.12|
                          DCD      ||.data||

                          AREA ||i.OLED_GetPixel||, CODE, READONLY, ALIGN=2

                  OLED_GetPixel PROC
;;;505    */
;;;506    uint8_t OLED_GetPixel(uint16_t _usX, uint16_t _usY)
000000  4b05              LDR      r3,|L13.24|
;;;507    {
;;;508    	uint8_t ucValue;
;;;509    	uint8_t ucPageAddr;
;;;510    	uint8_t ucColAddr;
;;;511    
;;;512    	ucPageAddr = _usY / 8;
000002  f3c102c7          UBFX     r2,r1,#3,#8
;;;513    	ucColAddr = _usX;
000006  b2c0              UXTB     r0,r0
;;;514    
;;;515    	ucValue = s_ucGRAM[ucPageAddr][ucColAddr];
000008  eb0312c2          ADD      r2,r3,r2,LSL #7
00000c  5c10              LDRB     r0,[r2,r0]
;;;516    	if (ucValue & (_usY % 8))
00000e  4008              ANDS     r0,r0,r1
000010  0740              LSLS     r0,r0,#29
000012  d000              BEQ      |L13.22|
;;;517    	{
;;;518    		return 1;
000014  2001              MOVS     r0,#1
                  |L13.22|
;;;519    	}
;;;520    	else
;;;521    	{
;;;522    		return 0;
;;;523    	}
;;;524    }
000016  4770              BX       lr
;;;525    
                          ENDP

                  |L13.24|
                          DCD      ||.bss||

                          AREA ||i.OLED_InitHard||, CODE, READONLY, ALIGN=2

                  OLED_InitHard PROC
;;;115    */
;;;116    void OLED_InitHard(void)
000000  b510              PUSH     {r4,lr}
;;;117    {
;;;118    	OLED_ConfigGPIO();
000002  f7fffffe          BL       OLED_ConfigGPIO
;;;119    
;;;120    	/* 上电延迟 */
;;;121    	bsp_DelayMS(50);
000006  2032              MOVS     r0,#0x32
000008  f7fffffe          BL       bsp_DelayMS
00000c  4818              LDR      r0,|L14.112|
;;;122    
;;;123    	 /* 模块厂家提供初始化代码 */
;;;124    	OLED_WriteCmd(0xAE);	/* 关闭OLED面板显示(休眠) */
00000e  21ae              MOVS     r1,#0xae
000010  8001              STRH     r1,[r0,#0]
;;;125    	OLED_WriteCmd(0x00);	/* 设置列地址低4bit */
000012  2100              MOVS     r1,#0
000014  8001              STRH     r1,[r0,#0]
;;;126    	OLED_WriteCmd(0x10);	/* 设置列地址高4bit */
000016  2110              MOVS     r1,#0x10
000018  8001              STRH     r1,[r0,#0]
;;;127    	OLED_WriteCmd(0x40);	/* 设置起始行地址（低5bit 0-63）， 硬件相关*/
00001a  2140              MOVS     r1,#0x40
00001c  8001              STRH     r1,[r0,#0]
;;;128    
;;;129    	OLED_WriteCmd(0x81);	/* 设置对比度命令(双字节命令），第1个字节是命令，第2个字节是对比度参数0-255 */
00001e  2181              MOVS     r1,#0x81
000020  8001              STRH     r1,[r0,#0]
;;;130    	OLED_WriteCmd(0xCF);	/* 设置对比度参数,缺省CF */
000022  21cf              MOVS     r1,#0xcf
000024  8001              STRH     r1,[r0,#0]
;;;131    
;;;132    #ifdef DIR_NORMAL
;;;133    	OLED_WriteCmd(0xA0);	/* A0 ：列地址0映射到SEG0; A1 ：列地址127映射到SEG0 */
000026  21a0              MOVS     r1,#0xa0
000028  8001              STRH     r1,[r0,#0]
;;;134    	OLED_WriteCmd(0xC0);	/* C0 ：正常扫描,从COM0到COM63;  C8 : 反向扫描, 从 COM63至 COM0 */
00002a  21c0              MOVS     r1,#0xc0
00002c  8001              STRH     r1,[r0,#0]
;;;135    #endif
;;;136    
;;;137    #ifdef DIR_180
;;;138    	OLED_WriteCmd(0xA1);	/* A0 ：列地址0映射到SEG0; A1 ：列地址127映射到SEG0 */
;;;139    	OLED_WriteCmd(0xC8);	/* C0 ：正常扫描,从COM0到COM63;  C8 : 反向扫描, 从 COM63至 COM0 */
;;;140    #endif
;;;141    
;;;142    	OLED_WriteCmd(0xA6);	/* A6 : 设置正常显示模式; A7 : 设置为反显模式 */
00002e  21a6              MOVS     r1,#0xa6
000030  8001              STRH     r1,[r0,#0]
;;;143    
;;;144    	OLED_WriteCmd(0xA8);	/* 设置COM路数 */
000032  21a8              MOVS     r1,#0xa8
000034  8001              STRH     r1,[r0,#0]
;;;145    	OLED_WriteCmd(0x3F);	/* 1 ->（63+1）路 */
000036  213f              MOVS     r1,#0x3f
000038  8001              STRH     r1,[r0,#0]
;;;146    
;;;147    	OLED_WriteCmd(0xD3);	/* 设置显示偏移（双字节命令）*/
00003a  21d3              MOVS     r1,#0xd3
00003c  8001              STRH     r1,[r0,#0]
;;;148    	OLED_WriteCmd(0x00);	/* 无偏移 */
00003e  2100              MOVS     r1,#0
000040  8001              STRH     r1,[r0,#0]
;;;149    
;;;150    	OLED_WriteCmd(0xD5);	/* 设置显示时钟分频系数/振荡频率 */
000042  21d5              MOVS     r1,#0xd5
000044  8001              STRH     r1,[r0,#0]
;;;151    	OLED_WriteCmd(0x80);	/* 设置分频系数,高4bit是分频系数，低4bit是振荡频率 */
000046  2180              MOVS     r1,#0x80
000048  8001              STRH     r1,[r0,#0]
;;;152    
;;;153    	OLED_WriteCmd(0xD9);	/* 设置预充电周期 */
00004a  21d9              MOVS     r1,#0xd9
00004c  8001              STRH     r1,[r0,#0]
;;;154    	OLED_WriteCmd(0xF1);	/* [3:0],PHASE 1; [7:4],PHASE 2; */
00004e  21f1              MOVS     r1,#0xf1
000050  8001              STRH     r1,[r0,#0]
;;;155    
;;;156    	OLED_WriteCmd(0xDA);	/* 设置COM脚硬件接线方式 */
000052  21da              MOVS     r1,#0xda
000054  8001              STRH     r1,[r0,#0]
;;;157    	OLED_WriteCmd(0x12);
000056  2112              MOVS     r1,#0x12
000058  8001              STRH     r1,[r0,#0]
;;;158    
;;;159    	OLED_WriteCmd(0xDB);	/* 设置 vcomh 电压倍率 */
00005a  21db              MOVS     r1,#0xdb
00005c  8001              STRH     r1,[r0,#0]
;;;160    	OLED_WriteCmd(0x40);	/* [6:4] 000 = 0.65 x VCC; 0.77 x VCC (RESET); 0.83 x VCC  */
00005e  2140              MOVS     r1,#0x40
000060  8001              STRH     r1,[r0,#0]
;;;161    
;;;162    	OLED_WriteCmd(0x8D);	/* 设置充电泵（和下个命令结合使用） */
000062  218d              MOVS     r1,#0x8d
000064  8001              STRH     r1,[r0,#0]
;;;163    	OLED_WriteCmd(0x14);	/* 0x14 使能充电泵， 0x10 是关闭 */
000066  2114              MOVS     r1,#0x14
000068  8001              STRH     r1,[r0,#0]
;;;164    	OLED_WriteCmd(0xAF);	/* 打开OLED面板 */
00006a  21af              MOVS     r1,#0xaf
00006c  8001              STRH     r1,[r0,#0]
;;;165    }
00006e  bd10              POP      {r4,pc}
;;;166    
                          ENDP

                  |L14.112|
                          DCD      0x6c200000

                          AREA ||i.OLED_PutPixel||, CODE, READONLY, ALIGN=2

                  OLED_PutPixel PROC
;;;464    */
;;;465    void OLED_PutPixel(uint16_t _usX, uint16_t _usY, uint8_t _ucColor)
000000  b57f              PUSH     {r0-r6,lr}
;;;466    {
;;;467    	uint8_t ucValue;
;;;468    	uint8_t ucPageAddr;
;;;469    	uint8_t ucColAddr;
;;;470    
;;;471    	const uint8_t aOrTab[8]  = {0x01, 0x02, 0x04, 0x08,0x10,0x20,0x40,0x80};
000002  a416              ADR      r4,|L15.92|
000004  e9d43400          LDRD     r3,r4,[r4,#0]
000008  e9cd3400          STRD     r3,r4,[sp,#0]
;;;472    	const uint8_t aAndTab[8] = {0xFE, 0xFD, 0xFB, 0xF7,0xEF,0xDF,0xBF,0x7F};
00000c  a415              ADR      r4,|L15.100|
00000e  e9d43400          LDRD     r3,r4,[r4,#0]
000012  e9cd3402          STRD     r3,r4,[sp,#8]
;;;473    
;;;474    	ucPageAddr = _usY / 8;
;;;475    	ucColAddr = _usX;
000016  b2c3              UXTB     r3,r0
;;;476    
;;;477    	ucValue = s_ucGRAM[ucPageAddr][ucColAddr];
000018  4814              LDR      r0,|L15.108|
00001a  f3c104c7          UBFX     r4,r1,#3,#8           ;474
00001e  eb0016c4          ADD      r6,r0,r4,LSL #7
;;;478    	if (_ucColor == 0)
;;;479    	{
;;;480    		ucValue &= aAndTab[_usY % 8];
000022  f0010007          AND      r0,r1,#7
000026  5cf5              LDRB     r5,[r6,r3]            ;477
000028  b1a2              CBZ      r2,|L15.84|
;;;481    	}
;;;482    	else
;;;483    	{
;;;484    		ucValue |= aOrTab[_usY % 8];
00002a  f81d0000          LDRB     r0,[sp,r0]
00002e  4328              ORRS     r0,r0,r5
                  |L15.48|
;;;485    	}
;;;486    	s_ucGRAM[ucPageAddr][ucColAddr] = ucValue;
;;;487    
;;;488    	if (s_ucUpdateEn == 1)
000030  490f              LDR      r1,|L15.112|
000032  54f0              STRB     r0,[r6,r3]            ;486
000034  7809              LDRB     r1,[r1,#0]  ; s_ucUpdateEn
000036  2901              CMP      r1,#1
000038  d10b              BNE      |L15.82|
00003a  490e              LDR      r1,|L15.116|
00003c  34b0              ADDS     r4,r4,#0xb0
;;;489    	{
;;;490    		OLED_WriteCmd (0xB0 + ucPageAddr);					/* 设置页地址（0~7） */
00003e  b2e2              UXTB     r2,r4
000040  800a              STRH     r2,[r1,#0]
;;;491    		OLED_WriteCmd (0x00 + (ucColAddr & 0x0F));			/* 设置列地址的低地址 */
000042  f003020f          AND      r2,r3,#0xf
000046  800a              STRH     r2,[r1,#0]
;;;492    		OLED_WriteCmd (0x10 + ((ucColAddr >> 4) & 0x0F));	/* 设置列地址的高地址 */
000048  2210              MOVS     r2,#0x10
00004a  eb021213          ADD      r2,r2,r3,LSR #4
00004e  800a              STRH     r2,[r1,#0]
000050  8048              STRH     r0,[r1,#2]
                  |L15.82|
;;;493    		OLED_WriteData(ucValue);
;;;494    	}
;;;495    }
000052  bd7f              POP      {r0-r6,pc}
                  |L15.84|
000054  a902              ADD      r1,sp,#8              ;480
000056  5c08              LDRB     r0,[r1,r0]            ;480
000058  4028              ANDS     r0,r0,r5              ;480
00005a  e7e9              B        |L15.48|
;;;496    
                          ENDP

                  |L15.92|
00005c  01020408          DCB      1,2,4,"\b",16," @",128
000060  10204080
                  |L15.100|
000064  fefdfbf7          DCB      254,253,251,247,239,223,191,127
000068  efdfbf7f
                  |L15.108|
                          DCD      ||.bss||
                  |L15.112|
                          DCD      ||.data||
                  |L15.116|
                          DCD      0x6c200000

                          AREA ||i.OLED_SetContrast||, CODE, READONLY, ALIGN=2

                  OLED_SetContrast PROC
;;;226    */
;;;227    void OLED_SetContrast(uint8_t ucValue)
000000  4902              LDR      r1,|L16.12|
;;;228    {
;;;229    	OLED_WriteCmd(0x81);	/* 设置对比度命令(双字节命令），第1个字节是命令，第2个字节是对比度参数0-255 */
000002  2281              MOVS     r2,#0x81
000004  800a              STRH     r2,[r1,#0]
000006  8008              STRH     r0,[r1,#0]
;;;230    	OLED_WriteCmd(ucValue);	/* 设置对比度参数,缺省CF */
;;;231    }
000008  4770              BX       lr
;;;232    
                          ENDP

00000a  0000              DCW      0x0000
                  |L16.12|
                          DCD      0x6c200000

                          AREA ||i.OLED_SetDir||, CODE, READONLY, ALIGN=2

                  OLED_SetDir PROC
;;;204    */
;;;205    void OLED_SetDir(uint8_t _ucDir)
000000  4905              LDR      r1,|L17.24|
;;;206    {
000002  b120              CBZ      r0,|L17.14|
;;;207    	if (_ucDir == 0)
;;;208    	{
;;;209           	OLED_WriteCmd(0xA0);	/* A0 ：列地址0映射到SEG0; A1 ：列地址127映射到SEG0 */
;;;210    		OLED_WriteCmd(0xC0);	/* C0 ：正常扫描,从COM0到COM63;  C8 : 反向扫描, 从 COM63至 COM0 */
;;;211    	}
;;;212    	else
;;;213    	{
;;;214    		OLED_WriteCmd(0xA1);	/* A0 ：列地址0映射到SEG0; A1 ：列地址127映射到SEG0 */
000004  20a1              MOVS     r0,#0xa1
000006  8008              STRH     r0,[r1,#0]
;;;215    		OLED_WriteCmd(0xC8);	/* C0 ：正常扫描,从COM0到COM63;  C8 : 反向扫描, 从 COM63至 COM0 */
000008  20c8              MOVS     r0,#0xc8
                  |L17.10|
00000a  8008              STRH     r0,[r1,#0]
;;;216    	}
;;;217    }
00000c  4770              BX       lr
                  |L17.14|
00000e  20a0              MOVS     r0,#0xa0              ;209
000010  8008              STRH     r0,[r1,#0]            ;209
000012  20c0              MOVS     r0,#0xc0              ;210
000014  e7f9              B        |L17.10|
;;;218    
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      0x6c200000

                          AREA ||i.OLED_StartDraw||, CODE, READONLY, ALIGN=2

                  OLED_StartDraw PROC
;;;240    */
;;;241    void OLED_StartDraw(void)
000000  4901              LDR      r1,|L18.8|
;;;242    {
;;;243    	s_ucUpdateEn = 0;
000002  2000              MOVS     r0,#0
000004  7008              STRB     r0,[r1,#0]
;;;244    }
000006  4770              BX       lr
;;;245    
                          ENDP

                  |L18.8|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  s_ucGRAM
                          %        1024

                          AREA ||.data||, DATA, ALIGN=0

                  s_ucUpdateEn
000000  01                DCB      0x01

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_oled.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_bsp_oled_c_b3d4fdae____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_bsp_oled_c_b3d4fdae____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_bsp_oled_c_b3d4fdae____REVSH|
#line 128
|__asm___10_bsp_oled_c_b3d4fdae____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
