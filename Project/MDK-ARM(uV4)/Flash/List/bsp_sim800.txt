; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_sim800.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_sim800.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_sim800.crf ..\..\User\bsp\src\bsp_sim800.c]
                          THUMB

                          AREA ||i.SIM800_AnswerIncall||, CODE, READONLY, ALIGN=2

                  SIM800_AnswerIncall PROC
;;;450    */
;;;451    void SIM800_AnswerIncall(void)
000000  a001              ADR      r0,|L1.8|
;;;452    {
;;;453    	SIM800_SendAT("ATA");
000002  f7ffbffe          B.W      SIM800_SendAT
;;;454    }
;;;455    
                          ENDP

000006  0000              DCW      0x0000
                  |L1.8|
000008  41544100          DCB      "ATA",0

                          AREA ||i.SIM800_DialTel||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  SIM800_DialTel PROC
;;;421    */
;;;422    void SIM800_DialTel(char *_pTel)
000000  b500              PUSH     {lr}
;;;423    {
000002  b089              SUB      sp,sp,#0x24
;;;424    	char CmdBuf[32];
;;;425    
;;;426    	sprintf(CmdBuf, "ATD%s;", _pTel);
000004  4602              MOV      r2,r0
000006  a104              ADR      r1,|L2.24|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __2sprintf
;;;427    	SIM800_SendAT(CmdBuf);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       SIM800_SendAT
;;;428    }
000014  b009              ADD      sp,sp,#0x24
000016  bd00              POP      {pc}
;;;429    
                          ENDP

                  |L2.24|
000018  41544425          DCB      "ATD%s;",0
00001c  733b00  
00001f  00                DCB      0

                          AREA ||i.SIM800_GetHardInfo||, CODE, READONLY, ALIGN=2

                  SIM800_GetHardInfo PROC
;;;463    */
;;;464    uint8_t SIM800_GetHardInfo(SIM800_INFO_T *_pInfo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;465    {
000004  4605              MOV      r5,r0
000006  b090              SUB      sp,sp,#0x40
;;;466    	/*
;;;467    	ATI
;;;468    	SIM800 R13.08
;;;469    
;;;470    	OK
;;;471    	
;;;472    	AT+GSV
;;;473    	SIMCOM_Ltd
;;;474    	SIMCOM_SIM800
;;;475    	Revision:1308B05SIM800M32
;;;476    	*/	
;;;477    	char buf[64];
;;;478    	uint16_t len;
;;;479    	char *p1, *p2;
;;;480    	
;;;481    	SIM800_SendAT("ATI");		/* 发送 ATI 命令 */	
000008  a021              ADR      r0,|L3.144|
00000a  f7fffffe          BL       SIM800_SendAT
;;;482    	len = SIM800_ReadResponse(buf, sizeof(buf), 300);	/* 超时 300ms */
00000e  f44f7296          MOV      r2,#0x12c
000012  2140              MOVS     r1,#0x40
000014  4668              MOV      r0,sp
000016  f7fffffe          BL       SIM800_ReadResponse
;;;483    	if (len == 0)
00001a  2800              CMP      r0,#0
00001c  d035              BEQ      |L3.138|
;;;484    	{
;;;485    		return 0;		
;;;486    	}
;;;487    	
;;;488    	/* 制造商信息规定填写 SIMCOM_Ltd */
;;;489    	sprintf(_pInfo->Manfacture, "SIMCOM_Ltd");	
00001e  a11d              ADR      r1,|L3.148|
000020  4628              MOV      r0,r5
000022  f7fffffe          BL       __2sprintf
;;;490    	_pInfo->Model[0] = 0;
000026  f04f0800          MOV      r8,#0
00002a  f885800c          STRB     r8,[r5,#0xc]
;;;491    	_pInfo->Revision[0] = 0;
00002e  f8858018          STRB     r8,[r5,#0x18]
;;;492    
;;;493    	/* 应答数据前2个字符是 \r\n */
;;;494    	p1 = buf;
000032  4668              MOV      r0,sp
;;;495    	p2 = strchr(p1, '\n');
000034  210a              MOVS     r1,#0xa
000036  f7fffffe          BL       strchr
00003a  1c40              ADDS     r0,r0,#1
;;;496    	
;;;497    	/* 解析型号 */
;;;498    	p1 = p2 + 1;
00003c  4606              MOV      r6,r0
;;;499    	p2 = strchr(p1, ' ');
00003e  2120              MOVS     r1,#0x20
000040  f7fffffe          BL       strchr
000044  4604              MOV      r4,r0
;;;500    	len = p2 - p1;
000046  1b80              SUBS     r0,r0,r6
000048  b287              UXTH     r7,r0
;;;501    	if (len >= sizeof(_pInfo->Model))
00004a  2f0c              CMP      r7,#0xc
00004c  d300              BCC      |L3.80|
;;;502    	{
;;;503    		len = sizeof(_pInfo->Model) - 1;
00004e  270b              MOVS     r7,#0xb
                  |L3.80|
;;;504    	}		
;;;505    	memcpy(_pInfo->Model, p1, len);
000050  463a              MOV      r2,r7
000052  4631              MOV      r1,r6
000054  f105000c          ADD      r0,r5,#0xc
000058  f7fffffe          BL       __aeabi_memcpy
;;;506    	_pInfo->Model[len] = 0;
00005c  19e8              ADDS     r0,r5,r7
;;;507    
;;;508    	/* 解析型号 */
;;;509    	p1 = p2 + 1;
00005e  1c67              ADDS     r7,r4,#1
000060  f880800c          STRB     r8,[r0,#0xc]          ;506
000064  4646              MOV      r6,r8                 ;506
;;;510    	p2 = strchr(p1, '\r');
000066  210d              MOVS     r1,#0xd
000068  4638              MOV      r0,r7
00006a  f7fffffe          BL       strchr
;;;511    	len = p2 - p1;
00006e  1bc0              SUBS     r0,r0,r7
000070  b284              UXTH     r4,r0
;;;512    	if (len >= sizeof(_pInfo->Revision))
000072  2c10              CMP      r4,#0x10
000074  d300              BCC      |L3.120|
;;;513    	{
;;;514    		len = sizeof(_pInfo->Revision) - 1;
000076  240f              MOVS     r4,#0xf
                  |L3.120|
;;;515    	}				
;;;516    	memcpy(_pInfo->Revision, p1, len);
000078  4622              MOV      r2,r4
00007a  4639              MOV      r1,r7
00007c  f1050018          ADD      r0,r5,#0x18
000080  f7fffffe          BL       __aeabi_memcpy
;;;517    	_pInfo->Revision[len] = 0;	
000084  1928              ADDS     r0,r5,r4
000086  7606              STRB     r6,[r0,#0x18]
;;;518    	
;;;519    	return 1;
000088  2001              MOVS     r0,#1
                  |L3.138|
;;;520    }
00008a  b010              ADD      sp,sp,#0x40
00008c  e8bd81f0          POP      {r4-r8,pc}
;;;521    
                          ENDP

                  |L3.144|
000090  41544900          DCB      "ATI",0
                  |L3.148|
000094  53494d43          DCB      "SIMCOM_Ltd",0
000098  4f4d5f4c
00009c  746400  
00009f  00                DCB      0

                          AREA ||i.SIM800_GetNetStatus||, CODE, READONLY, ALIGN=2

                  SIM800_GetNetStatus PROC
;;;529    */
;;;530    uint8_t SIM800_GetNetStatus(void)
000000  b510              PUSH     {r4,lr}
;;;531    {
000002  b0a0              SUB      sp,sp,#0x80
;;;532    	/*
;;;533    		AT+CREG?
;;;534    		+CREG: 0,1
;;;535    		
;;;536    		OK				
;;;537    	*/	
;;;538    	char buf[128];
;;;539    	uint16_t len, i;
;;;540    	uint8_t status = 0;
000004  2400              MOVS     r4,#0
;;;541    	
;;;542    	SIM800_SendAT("AT+CREG?");	/* 发送 AT 命令 */
000006  a00e              ADR      r0,|L4.64|
000008  f7fffffe          BL       SIM800_SendAT
;;;543    	
;;;544    	len = SIM800_ReadResponse(buf, sizeof(buf), 200);	/* 超时 200ms */
00000c  22c8              MOVS     r2,#0xc8
00000e  2180              MOVS     r1,#0x80
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       SIM800_ReadResponse
;;;545    	if (len == 0)
000016  2800              CMP      r0,#0
000018  d00b              BEQ      |L4.50|
;;;546    	{
;;;547    		return 0;		
;;;548    	}
;;;549    	
;;;550    	for (i = 2; i < len; i++)
00001a  2102              MOVS     r1,#2
00001c  466a              MOV      r2,sp                 ;538
00001e  e005              B        |L4.44|
                  |L4.32|
;;;551    	{
;;;552    		if (buf[i] == ',')
000020  5c53              LDRB     r3,[r2,r1]
000022  f1010101          ADD      r1,r1,#1
000026  2b2c              CMP      r3,#0x2c
000028  d005              BEQ      |L4.54|
00002a  b289              UXTH     r1,r1                 ;550
                  |L4.44|
00002c  4281              CMP      r1,r0                 ;550
00002e  d3f7              BCC      |L4.32|
                  |L4.48|
;;;553    		{
;;;554    			i++;
;;;555    			
;;;556    			status = buf[i] - '0';
;;;557    			break;
;;;558    		}
;;;559    	}
;;;560    	return status;
000030  4620              MOV      r0,r4
                  |L4.50|
;;;561    }
000032  b020              ADD      sp,sp,#0x80
000034  bd10              POP      {r4,pc}
                  |L4.54|
000036  b288              UXTH     r0,r1                 ;554
000038  5c10              LDRB     r0,[r2,r0]            ;556
00003a  3830              SUBS     r0,r0,#0x30           ;556
00003c  b2c4              UXTB     r4,r0                 ;556
00003e  e7f7              B        |L4.48|
;;;562    
                          ENDP

                  |L4.64|
000040  41542b43          DCB      "AT+CREG?",0
000044  5245473f
000048  00      
000049  00                DCB      0
00004a  00                DCB      0
00004b  00                DCB      0

                          AREA ||i.SIM800_Hangup||, CODE, READONLY, ALIGN=2

                  SIM800_Hangup PROC
;;;437    */
;;;438    void SIM800_Hangup(void)
000000  a001              ADR      r0,|L5.8|
;;;439    {
;;;440    	SIM800_SendAT("ATH");
000002  f7ffbffe          B.W      SIM800_SendAT
;;;441    }
;;;442    
                          ENDP

000006  0000              DCW      0x0000
                  |L5.8|
000008  41544800          DCB      "ATH",0

                          AREA ||i.SIM800_PowerOff||, CODE, READONLY, ALIGN=2

                  SIM800_PowerOff PROC
;;;176    */
;;;177    void SIM800_PowerOff(void)
000000  b510              PUSH     {r4,lr}
;;;178    {
;;;179    	/*
;;;180    	用户可以通过把PWRKEY 信号拉低1.5秒用来关机,拉低时间超过33秒模块会重新开机。
;;;181    	
;;;182    	关机过程中，模块首先从网络上注销，让内部软件进入安全状态并且保存相关数据，最后关闭内部电
;;;183    	源。在最后断电前模块的串口将发送以下字符：
;;;184    	NORMAL POWER DOWN
;;;185    	这之后模块将不会执行AT命令。模块进入关机模式，仅RTC处于激活状态。关机模式可以通过
;;;186    	VDD_EXT引脚来检测，在关机模式下此引脚输出为低电平。
;;;187    	*/
;;;188    	
;;;189    	/* 硬件关机 */
;;;190    	PWRKEY_0();
000002  4c07              LDR      r4,|L6.32|
000004  2110              MOVS     r1,#0x10
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_SetBits
;;;191    	bsp_DelayMS(1500);
00000c  f24050dc          MOV      r0,#0x5dc
000010  f7fffffe          BL       bsp_DelayMS
;;;192    	PWRKEY_1();	
000014  4620              MOV      r0,r4
000016  e8bd4010          POP      {r4,lr}
00001a  2110              MOVS     r1,#0x10
00001c  f7ffbffe          B.W      GPIO_ResetBits
;;;193    		
;;;194    }
;;;195    
                          ENDP

                  |L6.32|
                          DCD      0x40010c00

                          AREA ||i.SIM800_PowerOn||, CODE, READONLY, ALIGN=2

                  SIM800_PowerOn PROC
;;;124    */
;;;125    uint8_t SIM800_PowerOn(void)
000000  b570              PUSH     {r4-r6,lr}
;;;126    {
;;;127    	uint8_t ret_value = 0;
000002  2500              MOVS     r5,#0
;;;128    	uint8_t i;
;;;129    	
;;;130    	/* 判断是否开机 */
;;;131    	for (i = 0; i < 5; i++)
000004  462c              MOV      r4,r5
                  |L7.6|
;;;132    	{
;;;133    		SIM800_SendAT("AT");
000006  a017              ADR      r0,|L7.100|
000008  f7fffffe          BL       SIM800_SendAT
;;;134    		if (SIM800_WaitResponse("OK", 100))
00000c  2164              MOVS     r1,#0x64
00000e  a016              ADR      r0,|L7.104|
000010  f7fffffe          BL       SIM800_WaitResponse
000014  b108              CBZ      r0,|L7.26|
;;;135    		{
;;;136    			return 1;
000016  2001              MOVS     r0,#1
;;;137    		}
;;;138    	}
;;;139    	
;;;140    	comClearRxFifo(COM_SIM800);	/* 清零串口接收缓冲区 */
;;;141    
;;;142    	/*  通过拉低 PWRKEY 引脚至少 1.2 秒然后释放，使模块开机。*/
;;;143    	PWRKEY_0();
;;;144    	bsp_DelayMS(2000);
;;;145    	PWRKEY_1();
;;;146    
;;;147    	/* 等待模块完成上电，如果是自动波特率则收不到RDT */
;;;148    	//if (SIM800_WaitResponse("RDY", 5000) == 0)
;;;149    	{	
;;;150    		/* 开始同步波特率: 主机发送AT，只到接收到正确的OK 
;;;151    		  当模块开机后建议延迟 2 至 3 秒后再发送同步字符，用户可发送“ AT” (大写、小写均可)来和模块
;;;152    		  同步波特率，当主机收到模块返回“ OK”，			
;;;153    		*/
;;;154    		for (i = 0; i < 50; i++)
;;;155    		{
;;;156    			SIM800_SendAT("OK");
;;;157    			if (SIM800_WaitResponse("OK", 100))
;;;158    			{
;;;159    				ret_value = 1;
;;;160    				break;			/* 模块上电成功 */
;;;161    			}
;;;162    		}		
;;;163    	}
;;;164    	
;;;165    	return ret_value;
;;;166    }
000018  bd70              POP      {r4-r6,pc}
                  |L7.26|
00001a  1c64              ADDS     r4,r4,#1
00001c  b2e4              UXTB     r4,r4                 ;131
00001e  2c05              CMP      r4,#5                 ;131
000020  d3f1              BCC      |L7.6|
000022  2001              MOVS     r0,#1                 ;140
000024  f7fffffe          BL       comClearRxFifo
000028  4c10              LDR      r4,|L7.108|
00002a  2110              MOVS     r1,#0x10              ;143
00002c  4620              MOV      r0,r4                 ;143
00002e  f7fffffe          BL       GPIO_SetBits
000032  f44f60fa          MOV      r0,#0x7d0             ;144
000036  f7fffffe          BL       bsp_DelayMS
00003a  2110              MOVS     r1,#0x10              ;145
00003c  4620              MOV      r0,r4                 ;145
00003e  f7fffffe          BL       GPIO_ResetBits
000042  2400              MOVS     r4,#0                 ;154
                  |L7.68|
000044  a008              ADR      r0,|L7.104|
000046  f7fffffe          BL       SIM800_SendAT
00004a  2164              MOVS     r1,#0x64              ;157
00004c  a006              ADR      r0,|L7.104|
00004e  f7fffffe          BL       SIM800_WaitResponse
000052  b108              CBZ      r0,|L7.88|
000054  2501              MOVS     r5,#1                 ;159
000056  e003              B        |L7.96|
                  |L7.88|
000058  1c64              ADDS     r4,r4,#1              ;160
00005a  b2e4              UXTB     r4,r4                 ;154
00005c  2c32              CMP      r4,#0x32              ;154
00005e  d3f1              BCC      |L7.68|
                  |L7.96|
000060  4628              MOV      r0,r5                 ;165
000062  bd70              POP      {r4-r6,pc}
;;;167    
                          ENDP

                  |L7.100|
000064  415400            DCB      "AT",0
000067  00                DCB      0
                  |L7.104|
000068  4f4b00            DCB      "OK",0
00006b  00                DCB      0
                  |L7.108|
                          DCD      0x40010c00

                          AREA ||i.SIM800_PrintRxData||, CODE, READONLY, ALIGN=1

                  SIM800_PrintRxData PROC
;;;109    */
;;;110    void SIM800_PrintRxData(uint8_t _ch)
000000  4601              MOV      r1,r0
;;;111    {
;;;112    	#ifdef SIM800_TO_COM1_EN
;;;113    		comSendChar(COM1, _ch);		/* 将接收到数据打印到调试串口1 */
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      comSendChar
;;;114    	#endif
;;;115    }
;;;116    
                          ENDP


                          AREA ||i.SIM800_ReadResponse||, CODE, READONLY, ALIGN=1

                  SIM800_ReadResponse PROC
;;;285    */
;;;286    uint16_t SIM800_ReadResponse(char *_pBuf, uint16_t _usBufSize, uint16_t _usTimeOut)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;287    {
;;;288    	uint8_t ucData;
;;;289    	uint16_t pos = 0;
000004  f04f0400          MOV      r4,#0
000008  4688              MOV      r8,r1                 ;287
00000a  4607              MOV      r7,r0                 ;287
00000c  0016              MOVS     r6,r2                 ;287
;;;290    	uint8_t ret;
;;;291    	uint8_t status = 0;		/* 接收状态 */
00000e  4625              MOV      r5,r4
000010  d00b              BEQ      |L9.42|
;;;292    
;;;293    	/* _usTimeOut == 0 表示无限等待 */
;;;294    	if (_usTimeOut > 0)
;;;295    	{
;;;296    		bsp_StartTimer(SIM800_TMR_ID, _usTimeOut);		/* 使用软件定时器作为超时控制 */
000012  4611              MOV      r1,r2
000014  2003              MOVS     r0,#3
000016  f7fffffe          BL       bsp_StartTimer
;;;297    	}
;;;298    	while (1)
;;;299    	{
;;;300    		bsp_Idle();				/* CPU空闲执行的操作， 见 bsp.c 和 bsp.h 文件 */
00001a  f7fffffe          BL       bsp_Idle
00001e  e011              B        |L9.68|
                  |L9.32|
000020  f7fffffe          BL       bsp_Idle
;;;301    
;;;302    		if (status == 2)		/* 正在接收有效应答阶段，通过字符间超时判断数据接收完毕 */
000024  2d02              CMP      r5,#2
000026  d003              BEQ      |L9.48|
000028  e00b              B        |L9.66|
                  |L9.42|
00002a  f7fffffe          BL       bsp_Idle
00002e  e00f              B        |L9.80|
                  |L9.48|
;;;303    		{
;;;304    			if (bsp_CheckTimer(SIM800_TMR_ID))
000030  2003              MOVS     r0,#3
000032  f7fffffe          BL       bsp_CheckTimer
000036  b158              CBZ      r0,|L9.80|
;;;305    			{
;;;306    				_pBuf[pos]	 = 0;	/* 结尾加0， 便于函数调用者识别字符串结束 */
000038  2000              MOVS     r0,#0
00003a  5538              STRB     r0,[r7,r4]
;;;307    				ret = pos;		/* 成功。 返回数据长度 */
00003c  b2e0              UXTB     r0,r4
                  |L9.62|
;;;308    				break;
;;;309    			}
;;;310    		}
;;;311    		else
;;;312    		{
;;;313    			if (_usTimeOut > 0)
;;;314    			{
;;;315    				if (bsp_CheckTimer(SIM800_TMR_ID))
;;;316    				{
;;;317    					ret = 0;	/* 超时 */
;;;318    					break;
;;;319    				}
;;;320    			}
;;;321    		}
;;;322    		
;;;323    		if (comGetChar(COM_SIM800, &ucData))
;;;324    		{			
;;;325    			SIM800_PrintRxData(ucData);		/* 将接收到数据打印到调试串口1 */
;;;326    
;;;327    			switch (status)
;;;328    			{
;;;329    				case 0:			/* 首字符 */
;;;330    					if (ucData == AT_CR)		/* 如果首字符是回车，表示 AT命令不会显 */
;;;331    					{
;;;332    						_pBuf[pos++] = ucData;		/* 保存接收到的数据 */
;;;333    						status = 2;	 /* 认为收到模块应答结果 */
;;;334    					}
;;;335    					else	/* 首字符是 A 表示 AT命令回显 */
;;;336    					{
;;;337    						status = 1;	 /* 这是主机发送的AT命令字符串，不保存应答数据，直到遇到 CR字符 */
;;;338    					}
;;;339    					break;
;;;340    					
;;;341    				case 1:			/* AT命令回显阶段, 不保存数据. 继续等待 */
;;;342    					if (ucData == AT_CR)
;;;343    					{
;;;344    						status = 2;
;;;345    					}
;;;346    					break;
;;;347    					
;;;348    				case 2:			/* 开始接收模块应答结果 */
;;;349    					/* 只要收到模块的应答字符，则采用字符间超时判断结束，此时命令总超时不起作用 */
;;;350    					bsp_StartTimer(SIM800_TMR_ID, 5);
;;;351    					if (pos < _usBufSize - 1)
;;;352    					{
;;;353    						_pBuf[pos++] = ucData;		/* 保存接收到的数据 */
;;;354    					}
;;;355    					break;
;;;356    			}
;;;357    		}
;;;358    	}
;;;359    	return ret;
;;;360    }
00003e  e8bd83f8          POP      {r3-r9,pc}
                  |L9.66|
000042  b12e              CBZ      r6,|L9.80|
                  |L9.68|
000044  2003              MOVS     r0,#3                 ;315
000046  f7fffffe          BL       bsp_CheckTimer
00004a  b108              CBZ      r0,|L9.80|
00004c  2000              MOVS     r0,#0                 ;317
00004e  e7f6              B        |L9.62|
                  |L9.80|
000050  4669              MOV      r1,sp                 ;323
000052  2001              MOVS     r0,#1                 ;323
000054  f7fffffe          BL       comGetChar
000058  2800              CMP      r0,#0                 ;323
00005a  d0e1              BEQ      |L9.32|
00005c  f89d0000          LDRB     r0,[sp,#0]            ;325
000060  f7fffffe          BL       SIM800_PrintRxData
000064  b18d              CBZ      r5,|L9.138|
000066  2d01              CMP      r5,#1                 ;327
000068  d01b              BEQ      |L9.162|
00006a  2d02              CMP      r5,#2                 ;327
00006c  d1d8              BNE      |L9.32|
00006e  2105              MOVS     r1,#5                 ;350
000070  2003              MOVS     r0,#3                 ;350
000072  f7fffffe          BL       bsp_StartTimer
000076  f1a80001          SUB      r0,r8,#1              ;351
00007a  4284              CMP      r4,r0                 ;351
00007c  dad0              BGE      |L9.32|
00007e  f89d0000          LDRB     r0,[sp,#0]            ;353
000082  5538              STRB     r0,[r7,r4]            ;353
000084  1c64              ADDS     r4,r4,#1              ;353
000086  b2a4              UXTH     r4,r4                 ;353
000088  e7ca              B        |L9.32|
                  |L9.138|
00008a  f89d0000          LDRB     r0,[sp,#0]            ;330
00008e  280d              CMP      r0,#0xd               ;330
000090  d003              BEQ      |L9.154|
000092  2501              MOVS     r5,#1                 ;337
000094  f7fffffe          BL       bsp_Idle
000098  e7d3              B        |L9.66|
                  |L9.154|
00009a  5538              STRB     r0,[r7,r4]            ;332
00009c  1c64              ADDS     r4,r4,#1              ;332
00009e  b2a4              UXTH     r4,r4                 ;332
0000a0  e003              B        |L9.170|
                  |L9.162|
0000a2  f89d0000          LDRB     r0,[sp,#0]            ;342
0000a6  280d              CMP      r0,#0xd               ;342
0000a8  d1ba              BNE      |L9.32|
                  |L9.170|
0000aa  2502              MOVS     r5,#2                 ;344
0000ac  f7fffffe          BL       bsp_Idle
0000b0  e7be              B        |L9.48|
;;;361    
                          ENDP


                          AREA ||i.SIM800_SendAT||, CODE, READONLY, ALIGN=2

                  SIM800_SendAT PROC
;;;369    */
;;;370    void SIM800_SendAT(char *_Cmd)
000000  b510              PUSH     {r4,lr}
;;;371    {
000002  4604              MOV      r4,r0
;;;372    	comClearRxFifo(COM_SIM800);	/* 清零串口接收缓冲区 */	
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       comClearRxFifo
;;;373    	
;;;374    	comSendBuf(COM_SIM800, (uint8_t *)_Cmd, strlen(_Cmd));
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       strlen
000010  b282              UXTH     r2,r0
000012  4621              MOV      r1,r4
000014  2001              MOVS     r0,#1
000016  f7fffffe          BL       comSendBuf
;;;375    	comSendBuf(COM_SIM800, "\r", 1);
00001a  2201              MOVS     r2,#1
00001c  e8bd4010          POP      {r4,lr}
000020  a101              ADR      r1,|L10.40|
000022  4610              MOV      r0,r2
000024  f7ffbffe          B.W      comSendBuf
;;;376    }
;;;377    
                          ENDP

                  |L10.40|
000028  0d00              DCB      "\r",0
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.SIM800_SetEarVolume||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  SIM800_SetEarVolume PROC
;;;385    */
;;;386    void SIM800_SetEarVolume(uint8_t _ucVolume)
000000  b500              PUSH     {lr}
;;;387    {
000002  b089              SUB      sp,sp,#0x24
;;;388    	char CmdBuf[32];
;;;389    
;;;390    	sprintf(CmdBuf, "AT+CLVL=%d", _ucVolume);
000004  4602              MOV      r2,r0
000006  a104              ADR      r1,|L11.24|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __2sprintf
;;;391    	SIM800_SendAT(CmdBuf);
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       SIM800_SendAT
;;;392    }
000014  b009              ADD      sp,sp,#0x24
000016  bd00              POP      {pc}
;;;393    
                          ENDP

                  |L11.24|
000018  41542b43          DCB      "AT+CLVL=%d",0
00001c  4c564c3d
000020  256400  
000023  00                DCB      0

                          AREA ||i.SIM800_SetMicGain||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  SIM800_SetMicGain PROC
;;;402    */
;;;403    void SIM800_SetMicGain(uint16_t _Channel, uint16_t _iGain)
000000  b500              PUSH     {lr}
;;;404    {
000002  b089              SUB      sp,sp,#0x24
;;;405    	char CmdBuf[32];
;;;406    		
;;;407    	sprintf(CmdBuf, "AT+CMIC=%d,%d", _Channel, _iGain);
000004  460b              MOV      r3,r1
000006  4602              MOV      r2,r0
000008  a104              ADR      r1,|L12.28|
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       __2sprintf
;;;408    	SIM800_SendAT(CmdBuf);
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       SIM800_SendAT
;;;409    	
;;;410    	
;;;411    }
000016  b009              ADD      sp,sp,#0x24
000018  bd00              POP      {pc}
;;;412    
                          ENDP

00001a  0000              DCW      0x0000
                  |L12.28|
00001c  41542b43          DCB      "AT+CMIC=%d,%d",0
000020  4d49433d
000024  25642c25
000028  6400    
00002a  00                DCB      0
00002b  00                DCB      0

                          AREA ||i.SIM800_WaitResponse||, CODE, READONLY, ALIGN=2

                  SIM800_WaitResponse PROC
;;;204    */
;;;205    uint8_t SIM800_WaitResponse(char *_pAckStr, uint16_t _usTimeOut)
000000  b5f0              PUSH     {r4-r7,lr}
;;;206    {
000002  b0c1              SUB      sp,sp,#0x104
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;207    	uint8_t ucData;
;;;208    	uint8_t ucRxBuf[256];
;;;209    	uint16_t pos = 0;
000008  2400              MOVS     r4,#0
;;;210    	uint32_t len;
;;;211    	uint8_t ret;
;;;212    
;;;213    	len = strlen(_pAckStr);
00000a  f7fffffe          BL       strlen
00000e  4605              MOV      r5,r0
;;;214    	if (len > 255)
000010  28ff              CMP      r0,#0xff
000012  d80c              BHI      |L13.46|
;;;215    	{
;;;216    		return 0;
;;;217    	}
;;;218    
;;;219    	/* _usTimeOut == 0 表示无限等待 */
;;;220    	if (_usTimeOut > 0)
000014  b176              CBZ      r6,|L13.52|
;;;221    	{
;;;222    		bsp_StartTimer(SIM800_TMR_ID, _usTimeOut);		/* 使用软件定时器3，作为超时控制 */
000016  4631              MOV      r1,r6
000018  2003              MOVS     r0,#3
00001a  f7fffffe          BL       bsp_StartTimer
;;;223    	}
;;;224    	while (1)
;;;225    	{
;;;226    		bsp_Idle();				/* CPU空闲执行的操作， 见 bsp.c 和 bsp.h 文件 */
00001e  bf00              NOP      
                  |L13.32|
000020  f7fffffe          BL       bsp_Idle
;;;227    
;;;228    		if (_usTimeOut > 0)
000024  b146              CBZ      r6,|L13.56|
;;;229    		{
;;;230    			if (bsp_CheckTimer(SIM800_TMR_ID))
000026  2003              MOVS     r0,#3
000028  f7fffffe          BL       bsp_CheckTimer
00002c  b120              CBZ      r0,|L13.56|
                  |L13.46|
;;;231    			{
;;;232    				ret = 0;	/* 超时 */
00002e  2000              MOVS     r0,#0
                  |L13.48|
;;;233    				break;
;;;234    			}
;;;235    		}
;;;236    
;;;237    		if (comGetChar(COM_SIM800, &ucData))
;;;238    		{
;;;239    			SIM800_PrintRxData(ucData);		/* 将接收到数据打印到调试串口1 */
;;;240    
;;;241    			if (ucData == '\n')
;;;242    			{
;;;243    				if (pos > 0)	/* 第2次收到回车换行 */
;;;244    				{
;;;245    					if (memcmp(ucRxBuf, _pAckStr,  len) == 0)
;;;246    					{
;;;247    						ret = 1;	/* 收到指定的应答数据，返回成功 */
;;;248    						break;
;;;249    					}
;;;250    					else
;;;251    					{
;;;252    						pos = 0;
;;;253    					}
;;;254    				}
;;;255    				else
;;;256    				{
;;;257    					pos = 0;
;;;258    				}
;;;259    			}
;;;260    			else
;;;261    			{
;;;262    				if (pos < sizeof(ucRxBuf))
;;;263    				{
;;;264    					/* 只保存可见字符 */
;;;265    					if (ucData >= ' ')
;;;266    					{
;;;267    						ucRxBuf[pos++] = ucData;
;;;268    					}
;;;269    				}
;;;270    			}
;;;271    		}
;;;272    	}
;;;273    	return ret;
;;;274    }
000030  b041              ADD      sp,sp,#0x104
000032  bdf0              POP      {r4-r7,pc}
                  |L13.52|
000034  f7fffffe          BL       bsp_Idle
                  |L13.56|
000038  a940              ADD      r1,sp,#0x100          ;237
00003a  2001              MOVS     r0,#1                 ;237
00003c  f7fffffe          BL       comGetChar
000040  2800              CMP      r0,#0                 ;237
000042  d0ed              BEQ      |L13.32|
000044  f89d0100          LDRB     r0,[sp,#0x100]        ;239
000048  f7fffffe          BL       SIM800_PrintRxData
00004c  f89d0100          LDRB     r0,[sp,#0x100]        ;241
000050  280a              CMP      r0,#0xa               ;241
000052  d008              BEQ      |L13.102|
000054  2cff              CMP      r4,#0xff              ;262
000056  d8e3              BHI      |L13.32|
000058  2820              CMP      r0,#0x20              ;265
00005a  d3e1              BCC      |L13.32|
00005c  f80d0004          STRB     r0,[sp,r4]            ;267
000060  1c64              ADDS     r4,r4,#1              ;267
000062  b2a4              UXTH     r4,r4                 ;267
000064  e7dc              B        |L13.32|
                  |L13.102|
000066  2c00              CMP      r4,#0                 ;243
000068  d0da              BEQ      |L13.32|
00006a  462a              MOV      r2,r5                 ;245
00006c  4639              MOV      r1,r7                 ;245
00006e  4668              MOV      r0,sp                 ;245
000070  f7fffffe          BL       memcmp
000074  b108              CBZ      r0,|L13.122|
000076  2400              MOVS     r4,#0                 ;252
000078  e7d2              B        |L13.32|
                  |L13.122|
00007a  2001              MOVS     r0,#1                 ;247
00007c  e7d8              B        |L13.48|
;;;275    
                          ENDP


                          AREA ||i.bsp_InitSIM800||, CODE, READONLY, ALIGN=2

                  bsp_InitSIM800 PROC
;;;72     */
;;;73     void bsp_InitSIM800(void)
000000  b538              PUSH     {r3-r5,lr}
;;;74     {
;;;75     	GPIO_InitTypeDef GPIO_InitStructure;
;;;76     
;;;77     	/* 打开GPIO时钟 */
;;;78     	RCC_APB2PeriphClockCmd(RCC_TERM_ON | RCC_RESET, ENABLE);
000002  2101              MOVS     r1,#1
000004  2018              MOVS     r0,#0x18
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;79     
;;;80     	
;;;81     	/* Disable the Serial Wire Jtag Debug Port SWJ-DP 
;;;82     		JTAG-DP Disabled and SW-DP Enabled 
;;;83     	 PB4/TRST/GPRS_TERM_ON 缺省用于JTAG信号，需要重新映射为	
;;;84     	*/
;;;85         GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  480d              LDR      r0,|L14.68|
00000e  f7fffffe          BL       GPIO_PinRemapConfig
;;;86     	
;;;87     	PWRKEY_1();
000012  4c0d              LDR      r4,|L14.72|
000014  2110              MOVS     r1,#0x10
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GPIO_ResetBits
;;;88     	
;;;89     	/* 配置几个推完输出IO */
;;;90     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0002          STRB     r0,[sp,#2]
;;;91     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000022  2110              MOVS     r1,#0x10
000024  f88d1003          STRB     r1,[sp,#3]
;;;92     
;;;93     	GPIO_InitStructure.GPIO_Pin = PIN_TERM_ON;
000028  f8ad1000          STRH     r1,[sp,#0]
;;;94     	GPIO_Init(PORT_TERM_ON, &GPIO_InitStructure);
00002c  4669              MOV      r1,sp
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;95     
;;;96     	GPIO_InitStructure.GPIO_Pin = PIN_RESET;
000034  2004              MOVS     r0,#4
000036  f8ad0000          STRH     r0,[sp,#0]
;;;97     	GPIO_Init(PORT_RESET, &GPIO_InitStructure);
00003a  4669              MOV      r1,sp
00003c  4803              LDR      r0,|L14.76|
00003e  f7fffffe          BL       GPIO_Init
;;;98     
;;;99     	/* CPU的串口配置已经由 bsp_uart_fifo.c 中的 bsp_InitUart() 做了 */
;;;100    }
000042  bd38              POP      {r3-r5,pc}
;;;101    
                          ENDP

                  |L14.68|
                          DCD      0x00300200
                  |L14.72|
                          DCD      0x40010c00
                  |L14.76|
                          DCD      0x40011000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_sim800.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_sim800_c_30d7c11d____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_sim800_c_30d7c11d____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_sim800_c_30d7c11d____REVSH|
#line 128
|__asm___12_bsp_sim800_c_30d7c11d____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
