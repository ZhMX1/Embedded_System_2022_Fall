; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\uip_arp.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\uip_arp.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\uip_arp.crf ..\..\User\uIP\uip\uip_arp.c]
                          THUMB

                          AREA ||i.uip_arp_arpin||, CODE, READONLY, ALIGN=2

                  uip_arp_arpin PROC
;;;277    void
;;;278    uip_arp_arpin(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;279    {
;;;280    
;;;281      if(uip_len < sizeof(struct arp_hdr)) {
000004  4e24              LDR      r6,|L1.152|
000006  2000              MOVS     r0,#0
000008  8831              LDRH     r1,[r6,#0]  ; uip_len
00000a  292a              CMP      r1,#0x2a
00000c  d202              BCS      |L1.20|
                  |L1.14|
;;;282        uip_len = 0;
00000e  8030              STRH     r0,[r6,#0]
                  |L1.16|
;;;283        return;
;;;284      }
;;;285      uip_len = 0;
;;;286    
;;;287      switch(BUF->opcode) {
;;;288      case HTONS(ARP_REQUEST):
;;;289        /* ARP request. If it asked for our address, we send out a
;;;290           reply. */
;;;291        if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
;;;292    
;;;293          /* First, we register the one who made the request in our ARP
;;;294    	 table, since it is likely that we will do more communication
;;;295    	 with this host in the future. */
;;;296          uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
;;;297    
;;;298          /* The reply opcode is 2. */
;;;299          BUF->opcode = HTONS(2);
;;;300    
;;;301          memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
;;;302          memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
;;;303          memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
;;;304          memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
;;;305    
;;;306          BUF->dipaddr[0] = BUF->sipaddr[0];
;;;307          BUF->dipaddr[1] = BUF->sipaddr[1];
;;;308          BUF->sipaddr[0] = uip_hostaddr[0];
;;;309          BUF->sipaddr[1] = uip_hostaddr[1];
;;;310    
;;;311          BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
;;;312          uip_len = sizeof(struct arp_hdr);
;;;313        }
;;;314        break;
;;;315      case HTONS(ARP_REPLY):
;;;316        /* ARP reply. We insert or update the ARP table if it was meant
;;;317           for us. */
;;;318        if(uip_ipaddr_cmp(BUF->dipaddr, uip_hostaddr)) {
;;;319          uip_arp_update(BUF->sipaddr, &BUF->shwaddr);
;;;320        }
;;;321        break;
;;;322      }
;;;323    
;;;324      return;
;;;325    }
000010  e8bd87f0          POP      {r4-r10,pc}
                  |L1.20|
000014  4c21              LDR      r4,|L1.156|
000016  8030              STRH     r0,[r6,#0]            ;285
000018  4622              MOV      r2,r4                 ;287
00001a  4d21              LDR      r5,|L1.160|
00001c  f1020116          ADD      r1,r2,#0x16           ;296
000020  f8b48014          LDRH     r8,[r4,#0x14]         ;287  ; uip_buf
000024  f8b2c026          LDRH     r12,[r2,#0x26]        ;291
000028  8d13              LDRH     r3,[r2,#0x28]         ;291
00002a  1d88              ADDS     r0,r1,#6              ;296
00002c  882f              LDRH     r7,[r5,#0]            ;291
00002e  886a              LDRH     r2,[r5,#2]            ;291
000030  f44f7900          MOV      r9,#0x200             ;287
000034  f5b87f80          CMP      r8,#0x100             ;287
000038  d009              BEQ      |L1.78|
00003a  45c8              CMP      r8,r9                 ;287
00003c  d1e8              BNE      |L1.16|
00003e  45bc              CMP      r12,r7                ;318
000040  d1e6              BNE      |L1.16|
000042  4293              CMP      r3,r2                 ;318
000044  d1e4              BNE      |L1.16|
000046  e8bd47f0          POP      {r4-r10,lr}           ;319
00004a  f7ffbffe          B.W      uip_arp_update
                  |L1.78|
00004e  45bc              CMP      r12,r7                ;291
000050  d1de              BNE      |L1.16|
000052  4293              CMP      r3,r2                 ;291
000054  d1dc              BNE      |L1.16|
000056  f7fffffe          BL       uip_arp_update
00005a  f8a49014          STRH     r9,[r4,#0x14]         ;299
00005e  f8d40016          LDR      r0,[r4,#0x16]         ;301  ; uip_buf
000062  6220              STR      r0,[r4,#0x20]         ;301  ; uip_buf
000064  490f              LDR      r1,|L1.164|
000066  8b62              LDRH     r2,[r4,#0x1a]         ;301  ; uip_buf
000068  84a2              STRH     r2,[r4,#0x24]         ;301
00006a  680b              LDR      r3,[r1,#0]            ;302  ; uip_ethaddr
00006c  f8c43016          STR      r3,[r4,#0x16]         ;302  ; uip_buf
000070  8889              LDRH     r1,[r1,#4]            ;302  ; uip_ethaddr
000072  8361              STRH     r1,[r4,#0x1a]         ;302
000074  f8c43006          STR      r3,[r4,#6]            ;303  ; uip_buf
000078  8161              STRH     r1,[r4,#0xa]          ;303
00007a  6020              STR      r0,[r4,#0]            ;304  ; uip_buf
00007c  80a2              STRH     r2,[r4,#4]            ;304
00007e  8ba0              LDRH     r0,[r4,#0x1c]         ;306  ; uip_buf
000080  84e0              STRH     r0,[r4,#0x26]         ;306
000082  8be0              LDRH     r0,[r4,#0x1e]         ;307  ; uip_buf
000084  8520              STRH     r0,[r4,#0x28]         ;307
000086  8828              LDRH     r0,[r5,#0]            ;308  ; uip_hostaddr
000088  83a0              STRH     r0,[r4,#0x1c]         ;308
00008a  8868              LDRH     r0,[r5,#2]            ;309  ; uip_hostaddr
00008c  83e0              STRH     r0,[r4,#0x1e]         ;309
00008e  f44f60c1          MOV      r0,#0x608             ;311
000092  81a0              STRH     r0,[r4,#0xc]          ;311
000094  202a              MOVS     r0,#0x2a              ;312
000096  e7ba              B        |L1.14|
;;;326    /*-----------------------------------------------------------------------------------*/
                          ENDP

                  |L1.152|
                          DCD      uip_len
                  |L1.156|
                          DCD      uip_buf
                  |L1.160|
                          DCD      uip_hostaddr
                  |L1.164|
                          DCD      uip_ethaddr

                          AREA ||i.uip_arp_init||, CODE, READONLY, ALIGN=2

                  uip_arp_init PROC
;;;124    void
;;;125    uip_arp_init(void)
000000  b510              PUSH     {r4,lr}
;;;126    {
;;;127      for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
000002  4808              LDR      r0,|L2.36|
000004  2200              MOVS     r2,#0
;;;128        memset(arp_table[i].ipaddr, 0, 4);
000006  4c08              LDR      r4,|L2.40|
000008  7002              STRB     r2,[r0,#0]            ;127
                  |L2.10|
00000a  7801              LDRB     r1,[r0,#0]  ; i
00000c  eb010341          ADD      r3,r1,r1,LSL #1
000010  eb040383          ADD      r3,r4,r3,LSL #2
000014  1c49              ADDS     r1,r1,#1
000016  b2c9              UXTB     r1,r1                 ;127
000018  601a              STR      r2,[r3,#0]
00001a  7001              STRB     r1,[r0,#0]            ;127
00001c  2908              CMP      r1,#8                 ;127
00001e  d3f4              BCC      |L2.10|
;;;129      }
;;;130    }
000020  bd10              POP      {r4,pc}
;;;131    /*-----------------------------------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L2.36|
                          DCD      ||.data||
                  |L2.40|
                          DCD      ||.bss||

                          AREA ||i.uip_arp_out||, CODE, READONLY, ALIGN=2

                  uip_arp_out PROC
;;;354    void
;;;355    uip_arp_out(void)
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;356    {
;;;357      struct arp_entry *tabptr;
;;;358    
;;;359      /* Find the destination IP address in the ARP table and construct
;;;360         the Ethernet header. If the destination IP addres isn't on the
;;;361         local network, we use the default router's IP address instead.
;;;362    
;;;363         If not ARP table entry is found, we overwrite the original IP
;;;364         packet with an ARP request for the IP address. */
;;;365    
;;;366      /* First check if destination is a local broadcast. */
;;;367      if(uip_ipaddr_cmp(IPBUF->destipaddr, broadcast_ipaddr)) {
000004  4947              LDR      r1,|L3.292|
;;;368        memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
;;;369      } else {
;;;370        /* Check if the destination address is on the local network. */
;;;371        if(!uip_ipaddr_maskcmp(IPBUF->destipaddr, uip_hostaddr, uip_netmask)) {
;;;372          /* Destination address was not on the local network, so we need to
;;;373    	 use the default router's IP address instead of the destination
;;;374    	 address when determining the MAC address. */
;;;375          uip_ipaddr_copy(ipaddr, uip_draddr);
;;;376        } else {
;;;377          /* Else, we use the destination IP address. */
;;;378          uip_ipaddr_copy(ipaddr, IPBUF->destipaddr);
;;;379        }
;;;380    
;;;381        for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
;;;382          tabptr = &arp_table[i];
;;;383          if(uip_ipaddr_cmp(ipaddr, tabptr->ipaddr)) {
;;;384    	break;
;;;385          }
;;;386        }
;;;387    
;;;388        if(i == UIP_ARPTAB_SIZE) {
;;;389          /* The destination address was not in our ARP table, so we
;;;390    	 overwrite the IP packet with an ARP request. */
;;;391    
;;;392          memset(BUF->ethhdr.dest.addr, 0xff, 6);
;;;393          memset(BUF->dhwaddr.addr, 0x00, 6);
;;;394          memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
000006  4c48              LDR      r4,|L3.296|
000008  460a              MOV      r2,r1                 ;367
00000a  8bcb              LDRH     r3,[r1,#0x1e]         ;367  ; uip_buf
00000c  88a5              LDRH     r5,[r4,#4]
00000e  f64f70ff          MOV      r0,#0xffff            ;367
000012  8c12              LDRH     r2,[r2,#0x20]         ;367
000014  6824              LDR      r4,[r4,#0]
000016  4283              CMP      r3,r0                 ;367
000018  d106              BNE      |L3.40|
00001a  4282              CMP      r2,r0                 ;367
00001c  d104              BNE      |L3.40|
00001e  4843              LDR      r0,|L3.300|
000020  6802              LDR      r2,[r0,#0]            ;368  ; broadcast_ethaddr
000022  600a              STR      r2,[r1,#0]            ;368  ; uip_buf
000024  8880              LDRH     r0,[r0,#4]            ;368  ; broadcast_ethaddr
000026  e03f              B        |L3.168|
                  |L3.40|
000028  4f41              LDR      r7,|L3.304|
00002a  4e42              LDR      r6,|L3.308|
00002c  468b              MOV      r11,r1                ;371
00002e  8838              LDRH     r0,[r7,#0]            ;371  ; uip_netmask
000030  f8b6c000          LDRH     r12,[r6,#0]           ;371  ; uip_hostaddr
000034  ea030800          AND      r8,r3,r0              ;371
000038  46e2              MOV      r10,r12               ;371
00003a  ea0c0c00          AND      r12,r12,r0            ;371
00003e  4630              MOV      r0,r6                 ;371
000040  45e0              CMP      r8,r12                ;371
000042  8846              LDRH     r6,[r0,#2]            ;371
000044  483c              LDR      r0,|L3.312|
000046  d107              BNE      |L3.88|
000048  f8b78002          LDRH     r8,[r7,#2]            ;371  ; uip_netmask
00004c  ea020c08          AND      r12,r2,r8             ;371
000050  ea060708          AND      r7,r6,r8              ;371
000054  45bc              CMP      r12,r7                ;371
000056  d004              BEQ      |L3.98|
                  |L3.88|
000058  4a38              LDR      r2,|L3.316|
00005a  8813              LDRH     r3,[r2,#0]            ;375  ; uip_draddr
00005c  8003              STRH     r3,[r0,#0]            ;375
00005e  8852              LDRH     r2,[r2,#2]            ;375  ; uip_draddr
000060  e000              B        |L3.100|
                  |L3.98|
000062  8003              STRH     r3,[r0,#0]            ;378
                  |L3.100|
000064  8042              STRH     r2,[r0,#2]            ;378
000066  4a34              LDR      r2,|L3.312|
000068  2300              MOVS     r3,#0                 ;381
00006a  1f12              SUBS     r2,r2,#4              ;381
00006c  f8dfe0d0          LDR      lr,|L3.320|
000070  7013              STRB     r3,[r2,#0]            ;381
000072  8807              LDRH     r7,[r0,#0]            ;375
000074  f8b09002          LDRH     r9,[r0,#2]            ;375
                  |L3.120|
000078  b2db              UXTB     r3,r3                 ;382
00007a  eb030c43          ADD      r12,r3,r3,LSL #1      ;382
00007e  eb0e008c          ADD      r0,lr,r12,LSL #2      ;382
000082  f8b0c000          LDRH     r12,[r0,#0]           ;383
000086  4567              CMP      r7,r12                ;383
000088  d103              BNE      |L3.146|
00008a  f8b08002          LDRH     r8,[r0,#2]            ;383
00008e  45c1              CMP      r9,r8                 ;383
000090  d004              BEQ      |L3.156|
                  |L3.146|
000092  1c5b              ADDS     r3,r3,#1              ;383
000094  b2db              UXTB     r3,r3                 ;381
000096  7013              STRB     r3,[r2,#0]            ;381
000098  2b08              CMP      r3,#8                 ;381
00009a  d3ed              BCC      |L3.120|
                  |L3.156|
00009c  b2da              UXTB     r2,r3                 ;388
00009e  2a08              CMP      r2,#8                 ;388
0000a0  d00c              BEQ      |L3.188|
;;;395          memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
;;;396    
;;;397          uip_ipaddr_copy(BUF->dipaddr, ipaddr);
;;;398          uip_ipaddr_copy(BUF->sipaddr, uip_hostaddr);
;;;399          BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
;;;400          BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
;;;401          BUF->protocol = HTONS(UIP_ETHTYPE_IP);
;;;402          BUF->hwlen = 6;
;;;403          BUF->protolen = 4;
;;;404          BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
;;;405    
;;;406          uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
;;;407    
;;;408          uip_len = sizeof(struct arp_hdr);
;;;409          return;
;;;410        }
;;;411    
;;;412        /* Build an ethernet header. */
;;;413        memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
0000a2  6842              LDR      r2,[r0,#4]
0000a4  600a              STR      r2,[r1,#0]  ; uip_buf
0000a6  8900              LDRH     r0,[r0,#8]
                  |L3.168|
0000a8  8088              STRH     r0,[r1,#4]
;;;414      }
;;;415      memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
0000aa  f8c14006          STR      r4,[r1,#6]  ; uip_buf
0000ae  814d              STRH     r5,[r1,#0xa]
;;;416    
;;;417      IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
0000b0  2008              MOVS     r0,#8
0000b2  8188              STRH     r0,[r1,#0xc]
;;;418    
;;;419      uip_len += sizeof(struct uip_eth_hdr);
0000b4  4823              LDR      r0,|L3.324|
0000b6  8801              LDRH     r1,[r0,#0]  ; uip_len
0000b8  310e              ADDS     r1,r1,#0xe
0000ba  e030              B        |L3.286|
                  |L3.188|
0000bc  22ff              MOVS     r2,#0xff              ;392
0000be  2106              MOVS     r1,#6                 ;392
0000c0  4818              LDR      r0,|L3.292|
0000c2  f7fffffe          BL       __aeabi_memset
0000c6  2100              MOVS     r1,#0                 ;393
0000c8  f8cb1020          STR      r1,[r11,#0x20]        ;393  ; uip_buf
0000cc  f8ab1024          STRH     r1,[r11,#0x24]        ;393
0000d0  f8cb4006          STR      r4,[r11,#6]           ;394  ; uip_buf
0000d4  f8ab500a          STRH     r5,[r11,#0xa]         ;394
0000d8  f8cb4016          STR      r4,[r11,#0x16]        ;395  ; uip_buf
0000dc  f8ab501a          STRH     r5,[r11,#0x1a]        ;395
0000e0  f8ab7026          STRH     r7,[r11,#0x26]        ;397
0000e4  f8ab9028          STRH     r9,[r11,#0x28]        ;397
0000e8  f8aba01c          STRH     r10,[r11,#0x1c]       ;398
0000ec  f8ab601e          STRH     r6,[r11,#0x1e]        ;398
0000f0  f44f7180          MOV      r1,#0x100             ;399
0000f4  f8ab1014          STRH     r1,[r11,#0x14]        ;399
0000f8  f8ab100e          STRH     r1,[r11,#0xe]         ;400
0000fc  2108              MOVS     r1,#8                 ;401
0000fe  4658              MOV      r0,r11                ;393
000100  f8ab1010          STRH     r1,[r11,#0x10]        ;401
000104  2106              MOVS     r1,#6                 ;402
000106  7481              STRB     r1,[r0,#0x12]         ;402
000108  2104              MOVS     r1,#4                 ;403
00010a  74c1              STRB     r1,[r0,#0x13]         ;403
00010c  f44f61c1          MOV      r1,#0x608             ;404
000110  8181              STRH     r1,[r0,#0xc]          ;404
000112  4804              LDR      r0,|L3.292|
000114  490c              LDR      r1,|L3.328|
000116  3036              ADDS     r0,r0,#0x36           ;406
000118  6008              STR      r0,[r1,#0]            ;408  ; uip_appdata
00011a  480a              LDR      r0,|L3.324|
00011c  212a              MOVS     r1,#0x2a              ;408
                  |L3.286|
00011e  8001              STRH     r1,[r0,#0]
;;;420    }
000120  e8bd9ff0          POP      {r4-r12,pc}
;;;421    /*-----------------------------------------------------------------------------------*/
                          ENDP

                  |L3.292|
                          DCD      uip_buf
                  |L3.296|
                          DCD      uip_ethaddr
                  |L3.300|
                          DCD      ||.constdata||
                  |L3.304|
                          DCD      uip_netmask
                  |L3.308|
                          DCD      uip_hostaddr
                  |L3.312|
                          DCD      ||.data||+0x4
                  |L3.316|
                          DCD      uip_draddr
                  |L3.320|
                          DCD      ||.bss||
                  |L3.324|
                          DCD      uip_len
                  |L3.328|
                          DCD      uip_appdata

                          AREA ||i.uip_arp_timer||, CODE, READONLY, ALIGN=2

                  uip_arp_timer PROC
;;;141    void
;;;142    uip_arp_timer(void)
000000  b5f0              PUSH     {r4-r7,lr}
;;;143    {
;;;144      struct arp_entry *tabptr;
;;;145    
;;;146      ++arptime;
000002  490e              LDR      r1,|L4.60|
;;;147      for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
;;;148        tabptr = &arp_table[i];
000004  4d0e              LDR      r5,|L4.64|
000006  7888              LDRB     r0,[r1,#2]            ;146  ; arptime
000008  1c40              ADDS     r0,r0,#1              ;146
00000a  b2c2              UXTB     r2,r0                 ;146
00000c  708a              STRB     r2,[r1,#2]            ;146
00000e  2300              MOVS     r3,#0                 ;147
000010  700b              STRB     r3,[r1,#0]            ;147
                  |L4.18|
000012  780c              LDRB     r4,[r1,#0]  ; i
000014  eb040044          ADD      r0,r4,r4,LSL #1
000018  eb050080          ADD      r0,r5,r0,LSL #2
;;;149        if((tabptr->ipaddr[0] | tabptr->ipaddr[1]) != 0 &&
00001c  8806              LDRH     r6,[r0,#0]
00001e  8847              LDRH     r7,[r0,#2]
000020  433e              ORRS     r6,r6,r7
000022  d004              BEQ      |L4.46|
;;;150           arptime - tabptr->time >= UIP_ARP_MAXAGE) {
000024  7a86              LDRB     r6,[r0,#0xa]
000026  1b96              SUBS     r6,r2,r6
000028  2e78              CMP      r6,#0x78
00002a  db00              BLT      |L4.46|
;;;151          memset(tabptr->ipaddr, 0, 4);
00002c  6003              STR      r3,[r0,#0]
                  |L4.46|
00002e  1c64              ADDS     r4,r4,#1
000030  b2e0              UXTB     r0,r4                 ;147
000032  7008              STRB     r0,[r1,#0]            ;147
000034  2808              CMP      r0,#8                 ;147
000036  d3ec              BCC      |L4.18|
;;;152        }
;;;153      }
;;;154    
;;;155    }
000038  bdf0              POP      {r4-r7,pc}
;;;156    /*-----------------------------------------------------------------------------------*/
                          ENDP

00003a  0000              DCW      0x0000
                  |L4.60|
                          DCD      ||.data||
                  |L4.64|
                          DCD      ||.bss||

                          AREA ||i.uip_arp_update||, CODE, READONLY, ALIGN=2

                  uip_arp_update PROC
;;;157    static void
;;;158    uip_arp_update(u16_t *ipaddr, struct uip_eth_addr *ethaddr)
000000  b5f0              PUSH     {r4-r7,lr}
;;;159    {
;;;160      register struct arp_entry *tabptr;
;;;161      /* Walk through the ARP mapping table and try to find an entry to
;;;162         update. If none is found, the IP -> MAC address mapping is
;;;163         inserted in the ARP table. */
;;;164      for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
000002  4a2a              LDR      r2,|L5.172|
000004  2400              MOVS     r4,#0
;;;165    
;;;166        tabptr = &arp_table[i];
000006  4b2a              LDR      r3,|L5.176|
000008  7014              STRB     r4,[r2,#0]            ;164
                  |L5.10|
00000a  7816              LDRB     r6,[r2,#0]  ; i
00000c  eb060546          ADD      r5,r6,r6,LSL #1
000010  eb030585          ADD      r5,r3,r5,LSL #2
;;;167        /* Only check those entries that are actually in use. */
;;;168        if(tabptr->ipaddr[0] != 0 &&
000014  f8b5c000          LDRH     r12,[r5,#0]
000018  f1bc0f00          CMP      r12,#0
00001c  d010              BEQ      |L5.64|
;;;169           tabptr->ipaddr[1] != 0) {
00001e  886f              LDRH     r7,[r5,#2]
000020  b177              CBZ      r7,|L5.64|
;;;170    
;;;171          /* Check if the source IP address of the incoming packet matches
;;;172             the IP address in this ARP table entry. */
;;;173          if(ipaddr[0] == tabptr->ipaddr[0] &&
000022  f8b0e000          LDRH     lr,[r0,#0]
000026  45e6              CMP      lr,r12
000028  d10a              BNE      |L5.64|
;;;174    	 ipaddr[1] == tabptr->ipaddr[1]) {
00002a  f8b0c002          LDRH     r12,[r0,#2]
00002e  45bc              CMP      r12,r7
000030  d106              BNE      |L5.64|
                  |L5.50|
;;;175    
;;;176    	/* An old entry found, update this and return. */
;;;177    	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
000032  6808              LDR      r0,[r1,#0]
000034  6068              STR      r0,[r5,#4]
000036  8888              LDRH     r0,[r1,#4]
000038  8128              STRH     r0,[r5,#8]
;;;178    	tabptr->time = arptime;
00003a  7890              LDRB     r0,[r2,#2]  ; arptime
00003c  72a8              STRB     r0,[r5,#0xa]
;;;179    
;;;180    	return;
;;;181          }
;;;182        }
;;;183      }
;;;184    
;;;185      /* If we get here, no existing ARP table entry was found, so we
;;;186         create one. */
;;;187    
;;;188      /* First, we try to find an unused entry in the ARP table. */
;;;189      for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
;;;190        tabptr = &arp_table[i];
;;;191        if(tabptr->ipaddr[0] == 0 &&
;;;192           tabptr->ipaddr[1] == 0) {
;;;193          break;
;;;194        }
;;;195      }
;;;196    
;;;197      /* If no unused entry is found, we try to find the oldest entry and
;;;198         throw it away. */
;;;199      if(i == UIP_ARPTAB_SIZE) {
;;;200        tmpage = 0;
;;;201        c = 0;
;;;202        for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
;;;203          tabptr = &arp_table[i];
;;;204          if(arptime - tabptr->time > tmpage) {
;;;205    	tmpage = arptime - tabptr->time;
;;;206    	c = i;
;;;207          }
;;;208        }
;;;209        i = c;
;;;210        tabptr = &arp_table[i];
;;;211      }
;;;212    
;;;213      /* Now, i is the ARP table entry which we will fill with the new
;;;214         information. */
;;;215      memcpy(tabptr->ipaddr, ipaddr, 4);
;;;216      memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
;;;217      tabptr->time = arptime;
;;;218    }
00003e  bdf0              POP      {r4-r7,pc}
                  |L5.64|
000040  1c76              ADDS     r6,r6,#1
000042  b2f5              UXTB     r5,r6                 ;164
000044  7015              STRB     r5,[r2,#0]            ;164
000046  2d08              CMP      r5,#8                 ;164
000048  d3df              BCC      |L5.10|
00004a  7014              STRB     r4,[r2,#0]            ;189
                  |L5.76|
00004c  7816              LDRB     r6,[r2,#0]            ;190  ; i
00004e  eb060546          ADD      r5,r6,r6,LSL #1       ;190
000052  eb030585          ADD      r5,r3,r5,LSL #2       ;190
000056  882f              LDRH     r7,[r5,#0]            ;191
000058  b90f              CBNZ     r7,|L5.94|
00005a  886f              LDRH     r7,[r5,#2]            ;192
00005c  b127              CBZ      r7,|L5.104|
                  |L5.94|
00005e  1c76              ADDS     r6,r6,#1              ;192
000060  b2f6              UXTB     r6,r6                 ;189
000062  7016              STRB     r6,[r2,#0]            ;189
000064  2e08              CMP      r6,#8                 ;189
000066  d3f1              BCC      |L5.76|
                  |L5.104|
000068  b2f6              UXTB     r6,r6                 ;199
00006a  2e08              CMP      r6,#8                 ;199
00006c  d11a              BNE      |L5.164|
00006e  70d4              STRB     r4,[r2,#3]            ;200
000070  7054              STRB     r4,[r2,#1]            ;201
000072  7014              STRB     r4,[r2,#0]            ;202
000074  7895              LDRB     r5,[r2,#2]            ;205  ; arptime
                  |L5.118|
000076  b2e4              UXTB     r4,r4                 ;203
000078  eb040644          ADD      r6,r4,r4,LSL #1       ;203
00007c  eb030686          ADD      r6,r3,r6,LSL #2       ;203
000080  78d7              LDRB     r7,[r2,#3]            ;204  ; tmpage
000082  7ab6              LDRB     r6,[r6,#0xa]          ;204
000084  1bae              SUBS     r6,r5,r6              ;204
000086  42be              CMP      r6,r7                 ;204
000088  dd01              BLE      |L5.142|
00008a  70d6              STRB     r6,[r2,#3]            ;205
00008c  7054              STRB     r4,[r2,#1]            ;206
                  |L5.142|
00008e  1c64              ADDS     r4,r4,#1              ;206
000090  b2e4              UXTB     r4,r4                 ;202
000092  7014              STRB     r4,[r2,#0]            ;202
000094  2c08              CMP      r4,#8                 ;202
000096  d3ee              BCC      |L5.118|
000098  7854              LDRB     r4,[r2,#1]            ;209  ; c
00009a  7014              STRB     r4,[r2,#0]            ;209
00009c  eb040444          ADD      r4,r4,r4,LSL #1       ;210
0000a0  eb030584          ADD      r5,r3,r4,LSL #2       ;210
                  |L5.164|
0000a4  6800              LDR      r0,[r0,#0]            ;215
0000a6  6028              STR      r0,[r5,#0]            ;215
0000a8  e7c3              B        |L5.50|
;;;219    /*-----------------------------------------------------------------------------------*/
                          ENDP

0000aa  0000              DCW      0x0000
                  |L5.172|
                          DCD      ||.data||
                  |L5.176|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  arp_table
                          %        96

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  broadcast_ethaddr
000000  ffffffff          DCB      0xff,0xff,0xff,0xff
000004  ffff              DCB      0xff,0xff

                          AREA ||area_number.10||, DATA, READONLY, ALIGN=1

                          EXPORTAS ||area_number.10||, ||.constdata||
                  broadcast_ipaddr
000000  ffffffff          DCW      0xffff,0xffff

                          AREA ||.data||, DATA, ALIGN=1

                  i
000000  00                DCB      0x00
                  c
000001  00                DCB      0x00
                  arptime
000002  00                DCB      0x00
                  tmpage
000003  00                DCB      0x00
                  ipaddr
                          DCDU     0x00000000
