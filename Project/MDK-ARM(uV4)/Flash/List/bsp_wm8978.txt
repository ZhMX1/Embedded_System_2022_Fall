; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_wm8978.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_wm8978.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_wm8978.crf ..\..\User\bsp\src\bsp_wm8978.c]
                          THUMB

                          AREA ||i.I2S_CODEC_Init||, CODE, READONLY, ALIGN=2

                  I2S_CODEC_Init PROC
;;;935    */
;;;936    void I2S_CODEC_Init(void)
000000  b538              PUSH     {r3-r5,lr}
000002  2024              MOVS     r0,#0x24
000004  f88d0000          STRB     r0,[sp,#0]
000008  2000              MOVS     r0,#0
00000a  f88d0001          STRB     r0,[sp,#1]
00000e  f88d0002          STRB     r0,[sp,#2]
000012  2001              MOVS     r0,#1
000014  f88d0003          STRB     r0,[sp,#3]
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       NVIC_Init
00001e  2101              MOVS     r1,#1
000020  2019              MOVS     r0,#0x19
000022  f7fffffe          BL       RCC_APB2PeriphClockCmd
000026  f44f4030          MOV      r0,#0xb000
00002a  f8ad0000          STRH     r0,[sp,#0]
00002e  2003              MOVS     r0,#3
000030  f88d0002          STRB     r0,[sp,#2]
000034  2018              MOVS     r0,#0x18
000036  f88d0003          STRB     r0,[sp,#3]
00003a  4669              MOV      r1,sp
00003c  480b              LDR      r0,|L1.108|
00003e  f7fffffe          BL       GPIO_Init
000042  2040              MOVS     r0,#0x40
000044  f8ad0000          STRH     r0,[sp,#0]
000048  4669              MOV      r1,sp
00004a  4809              LDR      r0,|L1.112|
00004c  f7fffffe          BL       GPIO_Init
;;;937    {
;;;938    	/* 配置I2S中断通道 */
;;;939    	I2S_NVIC_Config();
;;;940    
;;;941    	/* 配置I2S2 GPIO口线 */
;;;942    	I2S_GPIO_Config();
;;;943    
;;;944    	/* 禁止I2S2 TXE中断(发送缓冲区空)，需要时再打开 */
;;;945    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, DISABLE);
000050  4c08              LDR      r4,|L1.116|
000052  2200              MOVS     r2,#0
000054  2171              MOVS     r1,#0x71
000056  4620              MOV      r0,r4
000058  f7fffffe          BL       SPI_I2S_ITConfig
;;;946    
;;;947    	/* 禁止I2S2 RXNE中断(接收不空)，需要时再打开 */
;;;948    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_RXNE, DISABLE);
00005c  4620              MOV      r0,r4
00005e  e8bd4038          POP      {r3-r5,lr}
000062  2200              MOVS     r2,#0
000064  2160              MOVS     r1,#0x60
000066  f7ffbffe          B.W      SPI_I2S_ITConfig
;;;949    }
;;;950    
                          ENDP

00006a  0000              DCW      0x0000
                  |L1.108|
                          DCD      0x40010c00
                  |L1.112|
                          DCD      0x40011000
                  |L1.116|
                          DCD      0x40003800

                          AREA ||i.I2S_Mode_Config||, CODE, READONLY, ALIGN=2

                  I2S_Mode_Config PROC
;;;1063   */
;;;1064   static void I2S_Mode_Config(uint16_t _usStandard, uint16_t _usWordLen, uint32_t _uiAudioFreq, uint16_t _usMode)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1065   {
000004  460e              MOV      r6,r1
000006  4607              MOV      r7,r0
;;;1066   	I2S_InitTypeDef I2S_InitStructure;
;;;1067   
;;;1068   	if ((_usMode == I2S_Mode_SlaveTx) && (_usMode == I2S_Mode_SlaveRx))
;;;1069   	{
;;;1070   		/* 安富莱开发板不支持这2种模式 */
;;;1071   		return;
;;;1072   	}
;;;1073   
;;;1074   	/* 打开 I2S2 APB1 时钟 */
;;;1075   	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
000008  2101              MOVS     r1,#1
00000a  461c              MOV      r4,r3                 ;1065
00000c  4615              MOV      r5,r2                 ;1065
00000e  0388              LSLS     r0,r1,#14
000010  f7fffffe          BL       RCC_APB1PeriphClockCmd
;;;1076   
;;;1077   	/* 复位 SPI2 外设到缺省状态 */
;;;1078   	SPI_I2S_DeInit(SPI2); 
000014  f8df8060          LDR      r8,|L2.120|
000018  4640              MOV      r0,r8
00001a  f7fffffe          BL       SPI_I2S_DeInit
;;;1079   
;;;1080   	/* I2S2 外设配置 */
;;;1081   	if (_usMode == I2S_Mode_MasterTx)
00001e  f44f7000          MOV      r0,#0x200
000022  2100              MOVS     r1,#0
000024  4284              CMP      r4,r0
000026  d102              BNE      |L2.46|
;;;1082   	{
;;;1083   		I2S_InitStructure.I2S_Mode = I2S_Mode_MasterTx;			/* 配置I2S工作模式 */
000028  f8ad0000          STRH     r0,[sp,#0]
;;;1084   		I2S_InitStructure.I2S_Standard = _usStandard;			/* 接口标准 */
;;;1085   		I2S_InitStructure.I2S_DataFormat = _usWordLen;			/* 数据格式，16bit */
;;;1086   		I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Enable;	/* 主时钟模式 */
;;;1087   		I2S_InitStructure.I2S_AudioFreq = _uiAudioFreq;			/* 音频采样频率 */
;;;1088   		I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;  			
;;;1089   		I2S_Init(SPI2, &I2S_InitStructure);
00002c  e005              B        |L2.58|
                  |L2.46|
;;;1090   	}
;;;1091   	else if (_usMode == I2S_Mode_MasterRx)
00002e  f44f7240          MOV      r2,#0x300
000032  4294              CMP      r4,r2
000034  d10e              BNE      |L2.84|
;;;1092   	{
;;;1093   		I2S_InitStructure.I2S_Mode = I2S_Mode_MasterRx;			/* 配置I2S工作模式 */
000036  f8ad2000          STRH     r2,[sp,#0]
                  |L2.58|
;;;1094   		I2S_InitStructure.I2S_Standard = _usStandard;			/* 接口标准 */
;;;1095   		I2S_InitStructure.I2S_DataFormat = _usWordLen;			/* 数据格式，16bit */
00003a  f8ad6004          STRH     r6,[sp,#4]
;;;1096   		I2S_InitStructure.I2S_MCLKOutput = I2S_MCLKOutput_Enable;	/* 主时钟模式 */
00003e  f8ad0006          STRH     r0,[sp,#6]
;;;1097   		I2S_InitStructure.I2S_AudioFreq = _uiAudioFreq;			/* 音频采样频率 */
;;;1098   		I2S_InitStructure.I2S_CPOL = I2S_CPOL_Low;  			
000042  f8ad100c          STRH     r1,[sp,#0xc]
000046  f8ad7002          STRH     r7,[sp,#2]            ;1094
00004a  9502              STR      r5,[sp,#8]
;;;1099   		I2S_Init(SPI2, &I2S_InitStructure);
00004c  4669              MOV      r1,sp
00004e  4640              MOV      r0,r8
000050  f7fffffe          BL       I2S_Init
                  |L2.84|
;;;1100   	}
;;;1101   
;;;1102   	/* 禁止I2S2 TXE中断(发送缓冲区空)，需要时再打开 */
;;;1103   	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, DISABLE);
000054  2200              MOVS     r2,#0
000056  2171              MOVS     r1,#0x71
000058  4644              MOV      r4,r8
00005a  4640              MOV      r0,r8
00005c  f7fffffe          BL       SPI_I2S_ITConfig
;;;1104   
;;;1105   	/* 禁止I2S2 RXNE中断(接收不空)，需要时再打开 */
;;;1106   	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_RXNE, DISABLE);
000060  2200              MOVS     r2,#0
000062  2160              MOVS     r1,#0x60
000064  4620              MOV      r0,r4
000066  f7fffffe          BL       SPI_I2S_ITConfig
;;;1107   
;;;1108   	/* 使能 SPI2/I2S2 外设 */
;;;1109   	I2S_Cmd(SPI2, ENABLE);	
00006a  2101              MOVS     r1,#1
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       I2S_Cmd
;;;1110   }
000072  e8bd81ff          POP      {r0-r8,pc}
;;;1111   
                          ENDP

000076  0000              DCW      0x0000
                  |L2.120|
                          DCD      0x40003800

                          AREA ||i.I2S_StartPlay||, CODE, READONLY, ALIGN=2

                  I2S_StartPlay PROC
;;;961    */
;;;962    void I2S_StartPlay(uint16_t _usStandard, uint16_t _usWordLen,  uint32_t _uiAudioFreq)
000000  b510              PUSH     {r4,lr}
;;;963    {
;;;964    	/* 配置I2S为主发送模式，即STM32提供主时钟，I2S数据口是发送方向(放音) */
;;;965    	I2S_Mode_Config(_usStandard, _usWordLen, _uiAudioFreq, I2S_Mode_MasterTx);
000002  f44f7300          MOV      r3,#0x200
000006  f7fffffe          BL       I2S_Mode_Config
;;;966    
;;;967    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, ENABLE);		/* 使能发送中断 */
00000a  4c06              LDR      r4,|L3.36|
00000c  2201              MOVS     r2,#1
00000e  2171              MOVS     r1,#0x71
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SPI_I2S_ITConfig
;;;968    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_RXNE, DISABLE);	/* 禁止接收中断 */
000016  4620              MOV      r0,r4
000018  2200              MOVS     r2,#0
00001a  e8bd4010          POP      {r4,lr}
00001e  2160              MOVS     r1,#0x60
000020  f7ffbffe          B.W      SPI_I2S_ITConfig
;;;969    }
;;;970    
                          ENDP

                  |L3.36|
                          DCD      0x40003800

                          AREA ||i.I2S_StartRecord||, CODE, READONLY, ALIGN=2

                  I2S_StartRecord PROC
;;;981    */
;;;982    void I2S_StartRecord(uint16_t _usStandard, uint16_t _usWordLen, uint32_t _uiAudioFreq)
000000  b510              PUSH     {r4,lr}
;;;983    {
;;;984    	/* 配置I2S为主发送模式，即STM32提供主时钟，I2S数据口是发送方向(放音) */
;;;985    	I2S_Mode_Config(_usStandard, _usWordLen, _uiAudioFreq, I2S_Mode_MasterRx);
000002  f44f7340          MOV      r3,#0x300
000006  f7fffffe          BL       I2S_Mode_Config
;;;986    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_RXNE, ENABLE);		/* 使能接收中断 */
00000a  4c06              LDR      r4,|L4.36|
00000c  2201              MOVS     r2,#1
00000e  2160              MOVS     r1,#0x60
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       SPI_I2S_ITConfig
;;;987    
;;;988    	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, DISABLE);		/* 禁止发送中断 */
000016  4620              MOV      r0,r4
000018  2200              MOVS     r2,#0
00001a  e8bd4010          POP      {r4,lr}
00001e  2171              MOVS     r1,#0x71
000020  f7ffbffe          B.W      SPI_I2S_ITConfig
;;;989    }
;;;990    
                          ENDP

                  |L4.36|
                          DCD      0x40003800

                          AREA ||i.I2S_Stop||, CODE, READONLY, ALIGN=2

                  I2S_Stop PROC
;;;998    */
;;;999    void I2S_Stop(void)
000000  b510              PUSH     {r4,lr}
;;;1000   {
;;;1001   	/* 禁止I2S2 TXE中断(发送缓冲区空)，需要时再打开 */
;;;1002   	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_TXE, DISABLE);
000002  4c0a              LDR      r4,|L5.44|
000004  2200              MOVS     r2,#0
000006  2171              MOVS     r1,#0x71
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_ITConfig
;;;1003   
;;;1004   	/* 禁止I2S2 RXNE中断(接收不空)，需要时再打开 */
;;;1005   	SPI_I2S_ITConfig(SPI2, SPI_I2S_IT_RXNE, DISABLE);
00000e  2200              MOVS     r2,#0
000010  2160              MOVS     r1,#0x60
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       SPI_I2S_ITConfig
;;;1006   
;;;1007   	/* 禁能 SPI2/I2S2 外设 */
;;;1008   	I2S_Cmd(SPI2, DISABLE);
000018  2100              MOVS     r1,#0
00001a  4620              MOV      r0,r4
00001c  f7fffffe          BL       I2S_Cmd
;;;1009   
;;;1010   	/* 关闭 I2S2 APB1 时钟 */
;;;1011   	RCC_APB1PeriphClockCmd(RCC_APB1Periph_SPI2, ENABLE);
000020  2101              MOVS     r1,#1
000022  e8bd4010          POP      {r4,lr}
000026  0388              LSLS     r0,r1,#14
000028  f7ffbffe          B.W      RCC_APB1PeriphClockCmd
;;;1012   }
;;;1013   
                          ENDP

                  |L5.44|
                          DCD      0x40003800

                          AREA ||i.wm8978_CfgAudioIF||, CODE, READONLY, ALIGN=1

                  wm8978_CfgAudioIF PROC
;;;324    */
;;;325    void wm8978_CfgAudioIF(uint16_t _usStandard, uint8_t _ucWordLen, uint16_t _usMode)
000000  b510              PUSH     {r4,lr}
;;;326    {
000002  460b              MOV      r3,r1
000004  4614              MOV      r4,r2
;;;327    	uint16_t usReg;
;;;328    
;;;329    	/* pdf 67页，寄存器列表 */
;;;330    
;;;331    	/*	REG R4, 音频接口控制寄存器
;;;332    		B8		BCP	 = X, BCLK极性，0表示正常，1表示反相
;;;333    		B7		LRCP = x, LRC时钟极性，0表示正常，1表示反相
;;;334    		B6:5	WL = x， 字长，00=16bit，01=20bit，10=24bit，11=32bit （右对齐模式只能操作在最大24bit)
;;;335    		B4:3	FMT = x，音频数据格式，00=右对齐，01=左对齐，10=I2S格式，11=PCM
;;;336    		B2		DACLRSWAP = x, 控制DAC数据出现在LRC时钟的左边还是右边
;;;337    		B1 		ADCLRSWAP = x，控制ADC数据出现在LRC时钟的左边还是右边
;;;338    		B0		MONO	= 0，0表示立体声，1表示单声道，仅左声道有效
;;;339    	*/
;;;340    	usReg = 0;
000006  2100              MOVS     r1,#0
000008  b148              CBZ      r0,|L6.30|
;;;341    	if (_usStandard == I2S_Standard_Phillips)	/* I2S飞利浦标准 */
;;;342    	{
;;;343    		usReg |= (2 << 3);
;;;344    	}
;;;345    	else if (_usStandard == I2S_Standard_MSB)	/* MSB对齐标准(左对齐) */
00000a  2810              CMP      r0,#0x10
00000c  d009              BEQ      |L6.34|
;;;346    	{
;;;347    		usReg |= (1 << 3);
;;;348    	}
;;;349    	else if (_usStandard == I2S_Standard_LSB)	/* LSB对齐标准(右对齐) */
00000e  2820              CMP      r0,#0x20
000010  d000              BEQ      |L6.20|
;;;350    	{
;;;351    		usReg |= (0 << 3);
;;;352    	}
;;;353    	else	/* PCM标准(16位通道帧上带长或短帧同步或者16位数据帧扩展为32位通道帧) */
;;;354    	{
;;;355    		usReg |= (3 << 3);;
000012  2118              MOVS     r1,#0x18
                  |L6.20|
;;;356    	}
;;;357    
;;;358    	if (_ucWordLen == 24)
000014  2b18              CMP      r3,#0x18
000016  d006              BEQ      |L6.38|
;;;359    	{
;;;360    		usReg |= (2 << 5);
;;;361    	}
;;;362    	else if (_ucWordLen == 32)
000018  2b20              CMP      r3,#0x20
00001a  d007              BEQ      |L6.44|
00001c  e008              B        |L6.48|
                  |L6.30|
00001e  2110              MOVS     r1,#0x10              ;343
000020  e7f8              B        |L6.20|
                  |L6.34|
000022  2108              MOVS     r1,#8                 ;347
000024  e7f6              B        |L6.20|
                  |L6.38|
000026  f0410140          ORR      r1,r1,#0x40           ;360
00002a  e001              B        |L6.48|
                  |L6.44|
;;;363    	{
;;;364    		usReg |= (3 << 5);
00002c  f0410160          ORR      r1,r1,#0x60
                  |L6.48|
;;;365    	}
;;;366    	else
;;;367    	{
;;;368    		usReg |= (0 << 5);		/* 16bit */
;;;369    	}
;;;370    	wm8978_WriteReg(4, usReg);
000030  2004              MOVS     r0,#4
000032  f7fffffe          BL       wm8978_WriteReg
;;;371    
;;;372    	/* R5  pdf 57页 */
;;;373    
;;;374    
;;;375    	/*
;;;376    		R6，时钟产生控制寄存器
;;;377    		MS = 0,  WM8978被动时钟，由MCU提供MCLK时钟
;;;378    	*/
;;;379    	wm8978_WriteReg(6, 0x000);
000036  2100              MOVS     r1,#0
000038  2006              MOVS     r0,#6
00003a  f7fffffe          BL       wm8978_WriteReg
;;;380    
;;;381    	/* 如果是放音则需要设置  WM_GPIO1 = 1 ,如果是录音则需要设置WM_GPIO1 = 0 */
;;;382    	if (_usMode == I2S_Mode_MasterTx)
00003e  f5b47f00          CMP      r4,#0x200
000042  d004              BEQ      |L6.78|
;;;383    	{
;;;384    		wm8978_CtrlGPIO1(1);	/* 驱动WM8978的GPIO1引脚输出1, 用于放音 */		
;;;385    	}
;;;386    	else
;;;387    	{
;;;388    		wm8978_CtrlGPIO1(0);	/* 驱动WM8978的GPIO1引脚输出0, 用于录音 */		
000044  2000              MOVS     r0,#0
                  |L6.70|
000046  e8bd4010          POP      {r4,lr}
00004a  f7ffbffe          B.W      wm8978_CtrlGPIO1
                  |L6.78|
00004e  2001              MOVS     r0,#1                 ;384
000050  e7f9              B        |L6.70|
;;;389    	}	
;;;390    }
;;;391    
                          ENDP


                          AREA ||i.wm8978_CfgAudioPath||, CODE, READONLY, ALIGN=1

                  wm8978_CfgAudioPath PROC
;;;467    */
;;;468    void wm8978_CfgAudioPath(uint16_t _InPath, uint16_t _OutPath)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;469    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;470    	uint16_t usReg;
;;;471    
;;;472    	/* 查看WM8978数据手册的 REGISTER MAP 章节， 第67页 */
;;;473    
;;;474    	if ((_InPath == IN_PATH_OFF) && (_OutPath == OUT_PATH_OFF))
000008  4328              ORRS     r0,r0,r5
00000a  d04f              BEQ      |L7.172|
;;;475    	{
;;;476    		wm8978_PowerDown();
;;;477    		return;
;;;478    	}
;;;479    
;;;480    	/* --------------------------- 第1步：根据输入通道参数配置寄存器 -----------------------*/
;;;481    	/*
;;;482    		R1 寄存器 Power manage 1
;;;483    		Bit8    BUFDCOPEN,  Output stage 1.5xAVDD/2 driver enable
;;;484     		Bit7    OUT4MIXEN, OUT4 mixer enable
;;;485    		Bit6    OUT3MIXEN, OUT3 mixer enable
;;;486    		Bit5    PLLEN	.不用
;;;487    		Bit4    MICBEN	,Microphone Bias Enable (MIC偏置电路使能)
;;;488    		Bit3    BIASEN	,Analogue amplifier bias control 必须设置为1模拟放大器才工作
;;;489    		Bit2    BUFIOEN , Unused input/output tie off buffer enable
;;;490    		Bit1:0  VMIDSEL, 必须设置为非00值模拟放大器才工作
;;;491    	*/
;;;492    	usReg = (1 << 3) | (3 << 0);
00000c  210b              MOVS     r1,#0xb
;;;493    	if (_OutPath & OUT3_4_ON) 	/* OUT3和OUT4使能输出到GSM模块 */
00000e  0728              LSLS     r0,r5,#28
000010  d500              BPL      |L7.20|
;;;494    	{
;;;495    		usReg |= ((1 << 7) | (1 << 6));
000012  21cb              MOVS     r1,#0xcb
                  |L7.20|
;;;496    	}
;;;497    	if ((_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
000014  07a0              LSLS     r0,r4,#30
000016  d001              BEQ      |L7.28|
;;;498    	{
;;;499    		usReg |= (1 << 4);
000018  f0410110          ORR      r1,r1,#0x10
                  |L7.28|
;;;500    	}
;;;501    	wm8978_WriteReg(1, usReg);	/* 写寄存器 */
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       wm8978_WriteReg
;;;502    
;;;503    	/*
;;;504    		R2 寄存器 Power manage 2
;;;505    		Bit8	ROUT1EN,	ROUT1 output enable 耳机右声道输出使能
;;;506    		Bit7	LOUT1EN,	LOUT1 output enable 耳机左声道输出使能
;;;507    		Bit6	SLEEP, 		0 = Normal device operation   1 = Residual current reduced in device standby mode
;;;508    		Bit5	BOOSTENR,	Right channel Input BOOST enable 输入通道自举电路使能. 用到PGA放大功能时必须使能
;;;509    		Bit4	BOOSTENL,	Left channel Input BOOST enable
;;;510    		Bit3	INPGAENR,	Right channel input PGA enable 右声道输入PGA使能
;;;511    		Bit2	INPGAENL,	Left channel input PGA enable
;;;512    		Bit1	ADCENR,		Enable ADC right channel
;;;513    		Bit0	ADCENL,		Enable ADC left channel
;;;514    	*/
;;;515    	usReg = 0;
000022  2100              MOVS     r1,#0
;;;516    	if (_OutPath & EAR_LEFT_ON)
000024  07e8              LSLS     r0,r5,#31
000026  d000              BEQ      |L7.42|
;;;517    	{
;;;518    		usReg |= (1 << 7);
000028  2180              MOVS     r1,#0x80
                  |L7.42|
;;;519    	}
;;;520    	if (_OutPath & EAR_RIGHT_ON)
00002a  07a8              LSLS     r0,r5,#30
00002c  d501              BPL      |L7.50|
;;;521    	{
;;;522    		usReg |= (1 << 8);
00002e  f4417180          ORR      r1,r1,#0x100
                  |L7.50|
;;;523    	}
;;;524    	if (_InPath & MIC_LEFT_ON)
000032  07e0              LSLS     r0,r4,#31
000034  d001              BEQ      |L7.58|
;;;525    	{
;;;526    		usReg |= ((1 << 4) | (1 << 2));
000036  f0410114          ORR      r1,r1,#0x14
                  |L7.58|
;;;527    	}
;;;528    	if (_InPath & MIC_RIGHT_ON)
00003a  07a0              LSLS     r0,r4,#30
00003c  d501              BPL      |L7.66|
;;;529    	{
;;;530    		usReg |= ((1 << 5) | (1 << 3));
00003e  f0410128          ORR      r1,r1,#0x28
                  |L7.66|
;;;531    	}
;;;532    	if (_InPath & LINE_ON)
000042  0760              LSLS     r0,r4,#29
000044  d501              BPL      |L7.74|
;;;533    	{
;;;534    		usReg |= ((1 << 4) | (1 << 5));
000046  f0410130          ORR      r1,r1,#0x30
                  |L7.74|
;;;535    	}
;;;536    	if (_InPath & MIC_RIGHT_ON)
00004a  07a0              LSLS     r0,r4,#30
00004c  d501              BPL      |L7.82|
;;;537    	{
;;;538    		usReg |= ((1 << 5) | (1 << 3));
00004e  f0410128          ORR      r1,r1,#0x28
                  |L7.82|
;;;539    	}
;;;540    	if (_InPath & ADC_ON)
000052  06a0              LSLS     r0,r4,#26
000054  d501              BPL      |L7.90|
;;;541    	{
;;;542    		usReg |= ((1 << 1) | (1 << 0));
000056  f0410103          ORR      r1,r1,#3
                  |L7.90|
;;;543    	}
;;;544    	wm8978_WriteReg(2, usReg);	/* 写寄存器 */
00005a  2002              MOVS     r0,#2
00005c  f7fffffe          BL       wm8978_WriteReg
;;;545    
;;;546    	/*
;;;547    		R3 寄存器 Power manage 3
;;;548    		Bit8	OUT4EN,		OUT4 enable
;;;549    		Bit7	OUT3EN,		OUT3 enable
;;;550    		Bit6	LOUT2EN,	LOUT2 output enable
;;;551    		Bit5	ROUT2EN,	ROUT2 output enable
;;;552    		Bit4	0,
;;;553    		Bit3	RMIXEN,		Right mixer enable
;;;554    		Bit2	LMIXEN,		Left mixer enable
;;;555    		Bit1	DACENR,		Right channel DAC enable
;;;556    		Bit0	DACENL,		Left channel DAC enable
;;;557    	*/
;;;558    	usReg = 0;
000060  2100              MOVS     r1,#0
;;;559    	if (_OutPath & OUT3_4_ON)
000062  0728              LSLS     r0,r5,#28
000064  d501              BPL      |L7.106|
;;;560    	{
;;;561    		usReg |= ((1 << 8) | (1 << 7));
000066  f44f71c0          MOV      r1,#0x180
                  |L7.106|
;;;562    	}
;;;563    	if (_OutPath & SPK_ON)
00006a  0768              LSLS     r0,r5,#29
00006c  d501              BPL      |L7.114|
;;;564    	{
;;;565    		usReg |= ((1 << 6) | (1 << 5));
00006e  f0410160          ORR      r1,r1,#0x60
                  |L7.114|
;;;566    	}
;;;567    	if (_OutPath != OUT_PATH_OFF)
000072  b10d              CBZ      r5,|L7.120|
;;;568    	{
;;;569    		usReg |= ((1 << 3) | (1 << 2));
000074  f041010c          ORR      r1,r1,#0xc
                  |L7.120|
;;;570    	}
;;;571    	if (_InPath & DAC_ON)
000078  06e0              LSLS     r0,r4,#27
00007a  d501              BPL      |L7.128|
;;;572    	{
;;;573    		usReg |= ((1 << 1) | (1 << 0));
00007c  f0410103          ORR      r1,r1,#3
                  |L7.128|
;;;574    	}
;;;575    	wm8978_WriteReg(3, usReg);	/* 写寄存器 */
000080  2003              MOVS     r0,#3
000082  f7fffffe          BL       wm8978_WriteReg
;;;576    
;;;577    	/*
;;;578    		R44 寄存器 Input ctrl
;;;579    
;;;580    		Bit8	MBVSEL, 		Microphone Bias Voltage Control   0 = 0.9 * AVDD   1 = 0.6 * AVDD
;;;581    		Bit7	0
;;;582    		Bit6	R2_2INPPGA,		Connect R2 pin to right channel input PGA positive terminal
;;;583    		Bit5	RIN2INPPGA,		Connect RIN pin to right channel input PGA negative terminal
;;;584    		Bit4	RIP2INPPGA,		Connect RIP pin to right channel input PGA amplifier positive terminal
;;;585    		Bit3	0
;;;586    		Bit2	L2_2INPPGA,		Connect L2 pin to left channel input PGA positive terminal
;;;587    		Bit1	LIN2INPPGA,		Connect LIN pin to left channel input PGA negative terminal
;;;588    		Bit0	LIP2INPPGA,		Connect LIP pin to left channel input PGA amplifier positive terminal
;;;589    	*/
;;;590    	usReg = 0 << 8;
000086  2100              MOVS     r1,#0
;;;591    	if (_InPath & LINE_ON)
000088  0760              LSLS     r0,r4,#29
00008a  d500              BPL      |L7.142|
;;;592    	{
;;;593    		usReg |= ((1 << 6) | (1 << 2));
00008c  2144              MOVS     r1,#0x44
                  |L7.142|
;;;594    	}
;;;595    	if (_InPath & MIC_RIGHT_ON)
00008e  07a0              LSLS     r0,r4,#30
000090  d501              BPL      |L7.150|
;;;596    	{
;;;597    		usReg |= ((1 << 5) | (1 << 4));
000092  f0410130          ORR      r1,r1,#0x30
                  |L7.150|
;;;598    	}
;;;599    	if (_InPath & MIC_LEFT_ON)
000096  07e0              LSLS     r0,r4,#31
000098  d001              BEQ      |L7.158|
;;;600    	{
;;;601    		usReg |= ((1 << 1) | (1 << 0));
00009a  f0410103          ORR      r1,r1,#3
                  |L7.158|
;;;602    	}
;;;603    	wm8978_WriteReg(44, usReg);	/* 写寄存器 */
00009e  202c              MOVS     r0,#0x2c
0000a0  f7fffffe          BL       wm8978_WriteReg
;;;604    
;;;605    
;;;606    	/*
;;;607    		R14 寄存器 ADC Control
;;;608    		设置高通滤波器（可选的） pdf 24、25页,
;;;609    		Bit8 	HPFEN,	High Pass Filter Enable高通滤波器使能，0表示禁止，1表示使能
;;;610    		BIt7 	HPFAPP,	Select audio mode or application mode 选择音频模式或应用模式，0表示音频模式，
;;;611    		Bit6:4	HPFCUT，Application mode cut-off frequency  000-111选择应用模式的截止频率
;;;612    		Bit3 	ADCOSR,	ADC oversample rate select: 0=64x (lower power) 1=128x (best performance)
;;;613    		Bit2   	0
;;;614    		Bit1 	ADC right channel polarity adjust:  0=normal  1=inverted
;;;615    		Bit0 	ADC left channel polarity adjust:  0=normal 1=inverted
;;;616    	*/
;;;617    	if (_InPath & ADC_ON)
0000a4  06a0              LSLS     r0,r4,#26
0000a6  d505              BPL      |L7.180|
;;;618    	{
;;;619    		usReg = (1 << 3) | (0 << 8) | (4 << 0);		/* 禁止ADC高通滤波器, 设置截至频率 */
0000a8  210c              MOVS     r1,#0xc
0000aa  e004              B        |L7.182|
                  |L7.172|
0000ac  e8bd41f0          POP      {r4-r8,lr}
0000b0  f7ffbffe          B.W      wm8978_Reset
                  |L7.180|
;;;620    	}
;;;621    	else
;;;622    	{
;;;623    		usReg = 0;
0000b4  2100              MOVS     r1,#0
                  |L7.182|
;;;624    	}
;;;625    	wm8978_WriteReg(14, usReg);	/* 写寄存器 */
0000b6  200e              MOVS     r0,#0xe
0000b8  f7fffffe          BL       wm8978_WriteReg
;;;626    
;;;627    	/* 设置陷波滤波器（notch filter），主要用于抑制话筒声波正反馈，避免啸叫.  暂时关闭
;;;628    		R27，R28，R29，R30 用于控制限波滤波器，pdf 26页
;;;629    		R7的 Bit7 NFEN = 0 表示禁止，1表示使能
;;;630    	*/
;;;631    	if (_InPath & ADC_ON)
0000bc  06a0              LSLS     r0,r4,#26
0000be  d510              BPL      |L7.226|
;;;632    	{
;;;633    		usReg = (0 << 7);
0000c0  2600              MOVS     r6,#0
;;;634    		wm8978_WriteReg(27, usReg);	/* 写寄存器 */
0000c2  4631              MOV      r1,r6
0000c4  201b              MOVS     r0,#0x1b
0000c6  f7fffffe          BL       wm8978_WriteReg
;;;635    		usReg = 0;
;;;636    		wm8978_WriteReg(28, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
0000ca  4631              MOV      r1,r6
0000cc  201c              MOVS     r0,#0x1c
0000ce  f7fffffe          BL       wm8978_WriteReg
;;;637    		wm8978_WriteReg(29, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
0000d2  4631              MOV      r1,r6
0000d4  201d              MOVS     r0,#0x1d
0000d6  f7fffffe          BL       wm8978_WriteReg
;;;638    		wm8978_WriteReg(30, usReg);	/* 写寄存器,填0，因为已经禁止，所以也可不做 */
0000da  4631              MOV      r1,r6
0000dc  201e              MOVS     r0,#0x1e
0000de  f7fffffe          BL       wm8978_WriteReg
                  |L7.226|
;;;639    	}
;;;640    
;;;641    	/* 自动增益控制 ALC, R32  - 34  pdf 19页 */
;;;642    	{
;;;643    		usReg = 0;		/* 禁止自动增益控制 */
0000e2  2600              MOVS     r6,#0
;;;644    		wm8978_WriteReg(32, usReg);
0000e4  4631              MOV      r1,r6
0000e6  2020              MOVS     r0,#0x20
0000e8  f7fffffe          BL       wm8978_WriteReg
;;;645    		wm8978_WriteReg(33, usReg);
0000ec  4631              MOV      r1,r6
0000ee  2021              MOVS     r0,#0x21
0000f0  f7fffffe          BL       wm8978_WriteReg
;;;646    		wm8978_WriteReg(34, usReg);
0000f4  4631              MOV      r1,r6
0000f6  2022              MOVS     r0,#0x22
0000f8  f7fffffe          BL       wm8978_WriteReg
;;;647    	}
;;;648    
;;;649    	/*  R35  ALC Noise Gate Control
;;;650    		Bit3	NGATEN, Noise gate function enable
;;;651    		Bit2:0	Noise gate threshold:
;;;652    	*/
;;;653    	usReg = (3 << 1) | (7 << 0);		/* 禁止自动增益控制 */
0000fc  2107              MOVS     r1,#7
;;;654    	wm8978_WriteReg(35, usReg);
0000fe  2023              MOVS     r0,#0x23
000100  f7fffffe          BL       wm8978_WriteReg
;;;655    
;;;656    	/*
;;;657    		Mic 输入信道的增益由 PGABOOSTL 和 PGABOOSTR 控制
;;;658    		Aux 输入信道的输入增益由 AUXL2BOOSTVO[2:0] 和 AUXR2BOOSTVO[2:0] 控制
;;;659    		Line 输入信道的增益由 LIP2BOOSTVOL[2:0] 和 RIP2BOOSTVOL[2:0] 控制
;;;660    	*/
;;;661    	/*	pdf 21页，R47（左声道），R48（右声道）, MIC 增益控制寄存器
;;;662    		R47 (R48定义与此相同)
;;;663    		B8		PGABOOSTL	= 1,   0表示MIC信号直通无增益，1表示MIC信号+20dB增益（通过自举电路）
;;;664    		B7		= 0， 保留
;;;665    		B6:4	L2_2BOOSTVOL = x， 0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;666    		B3		= 0， 保留
;;;667    		B2:0`	AUXL2BOOSTVOL = x，0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;668    	*/
;;;669    	usReg = 0;
;;;670    	if ((_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
000104  07a0              LSLS     r0,r4,#30
;;;671    	{
;;;672    		usReg |= (1 << 8);	/* MIC增益取+20dB */
000106  f44f7880          MOV      r8,#0x100
00010a  d000              BEQ      |L7.270|
00010c  4646              MOV      r6,r8
                  |L7.270|
;;;673    	}
;;;674    	if (_InPath & AUX_ON)
00010e  0720              LSLS     r0,r4,#28
000110  d501              BPL      |L7.278|
;;;675    	{
;;;676    		usReg |= (3 << 0);	/* Aux增益固定取3，用户可以自行调整 */
000112  f0460603          ORR      r6,r6,#3
                  |L7.278|
;;;677    	}
;;;678    	if (_InPath & LINE_ON)
000116  0760              LSLS     r0,r4,#29
000118  d501              BPL      |L7.286|
;;;679    	{
;;;680    		usReg |= (3 << 4);	/* Line增益固定取3，用户可以自行调整 */
00011a  f0460630          ORR      r6,r6,#0x30
                  |L7.286|
;;;681    	}
;;;682    	wm8978_WriteReg(47, usReg);	/* 写左声道输入增益控制寄存器 */
00011e  4631              MOV      r1,r6
000120  202f              MOVS     r0,#0x2f
000122  f7fffffe          BL       wm8978_WriteReg
;;;683    	wm8978_WriteReg(48, usReg);	/* 写右声道输入增益控制寄存器 */
000126  4631              MOV      r1,r6
000128  2030              MOVS     r0,#0x30
00012a  f7fffffe          BL       wm8978_WriteReg
;;;684    
;;;685    	/* 数字ADC音量控制，pdf 27页
;;;686    		R15 控制左声道ADC音量，R16控制右声道ADC音量
;;;687    		Bit8 	ADCVU  = 1 时才更新，用于同步更新左右声道的ADC音量
;;;688    		Bit7:0 	增益选择； 0000 0000 = 静音
;;;689    						   0000 0001 = -127dB
;;;690    						   0000 0010 = -12.5dB  （0.5dB 步长）
;;;691    						   1111 1111 = 0dB  （不衰减）
;;;692    	*/
;;;693    	usReg = 0xFF;
00012e  21ff              MOVS     r1,#0xff
;;;694    	wm8978_WriteReg(15, usReg);	/* 选择0dB，先缓存左声道 */
000130  200f              MOVS     r0,#0xf
000132  f7fffffe          BL       wm8978_WriteReg
;;;695    	usReg = 0x1FF;
000136  f24017ff          MOV      r7,#0x1ff
00013a  4639              MOV      r1,r7
;;;696    	wm8978_WriteReg(16, usReg);	/* 同步更新左右声道 */
00013c  2010              MOVS     r0,#0x10
00013e  f7fffffe          BL       wm8978_WriteReg
;;;697    
;;;698    	/* 通过 wm8978_SetMicGain 函数设置mic PGA增益 */
;;;699    
;;;700    	/*	R43 寄存器  AUXR C ROUT2 BEEP Mixer Function
;;;701    		B8:6 = 0
;;;702    
;;;703    		B5	 MUTERPGA2INV,	Mute input to INVROUT2 mixer
;;;704    		B4	 INVROUT2,  Invert ROUT2 output 用于扬声器推挽输出
;;;705    		B3:1 BEEPVOL = 7;	AUXR input to ROUT2 inverter gain
;;;706    		B0	 BEEPEN = 1;	Enable AUXR beep input
;;;707    
;;;708    	*/
;;;709    	usReg = 0;
000142  2100              MOVS     r1,#0
;;;710    	if (_OutPath & SPK_ON)
000144  0768              LSLS     r0,r5,#29
000146  d500              BPL      |L7.330|
;;;711    	{
;;;712    		usReg |= (1 << 4);	/* ROUT2 反相, 用于驱动扬声器 */
000148  2110              MOVS     r1,#0x10
                  |L7.330|
;;;713    	}
;;;714    	if (_InPath & AUX_ON)
00014a  0720              LSLS     r0,r4,#28
00014c  d501              BPL      |L7.338|
;;;715    	{
;;;716    		usReg |= ((7 << 1) | (1 << 0));
00014e  f041010f          ORR      r1,r1,#0xf
                  |L7.338|
;;;717    	}
;;;718    	wm8978_WriteReg(43, usReg);
000152  202b              MOVS     r0,#0x2b
000154  f7fffffe          BL       wm8978_WriteReg
;;;719    
;;;720    	/* R49  Output ctrl
;;;721    		B8:7	0
;;;722    		B6		DACL2RMIX,	Left DAC output to right output mixer
;;;723    		B5		DACR2LMIX,	Right DAC output to left output
;;;724    		B4		OUT4BOOST,	0 = OUT4 output gain = -1; DC = AVDD / 2；1 = OUT4 output gain = +1.5；DC = 1.5 x AVDD / 2
;;;725    		B3		OUT3BOOST,	0 = OUT3 output gain = -1; DC = AVDD / 2；1 = OUT3 output gain = +1.5；DC = 1.5 x AVDD / 2
;;;726    		B2		SPKBOOST,	0 = Speaker gain = -1;  DC = AVDD / 2 ; 1 = Speaker gain = +1.5; DC = 1.5 x AVDD / 2
;;;727    		B1		TSDEN,   Thermal Shutdown Enable  扬声器热保护使能（缺省1）
;;;728    		B0		VROI,	Disabled Outputs to VREF Resistance
;;;729    	*/
;;;730    	usReg = 0;
000158  2100              MOVS     r1,#0
;;;731    	if (_InPath & DAC_ON)
00015a  06e0              LSLS     r0,r4,#27
00015c  d500              BPL      |L7.352|
;;;732    	{
;;;733    		usReg |= ((1 << 6) | (1 << 5));
00015e  2160              MOVS     r1,#0x60
                  |L7.352|
;;;734    	}
;;;735    	if (_OutPath & SPK_ON)
000160  0768              LSLS     r0,r5,#29
000162  d501              BPL      |L7.360|
;;;736    	{
;;;737    		usReg |=  ((1 << 2) | (1 << 1));	/* SPK 1.5x增益,  热保护使能 */
000164  f0410106          ORR      r1,r1,#6
                  |L7.360|
;;;738    	}
;;;739    	if (_OutPath & OUT3_4_ON)
000168  0728              LSLS     r0,r5,#28
00016a  d501              BPL      |L7.368|
;;;740    	{
;;;741    		usReg |=  ((1 << 4) | (1 << 3));	/* BOOT3  BOOT4  1.5x增益 */
00016c  f0410118          ORR      r1,r1,#0x18
                  |L7.368|
;;;742    	}
;;;743    	wm8978_WriteReg(49, usReg);
000170  2031              MOVS     r0,#0x31
000172  f7fffffe          BL       wm8978_WriteReg
;;;744    
;;;745    	/*	REG 50    (50是左声道，51是右声道，配置寄存器功能一致) pdf 40页
;;;746    		B8:6	AUXLMIXVOL = 111	AUX用于FM收音机信号输入
;;;747    		B5		AUXL2LMIX = 1		Left Auxilliary input to left channel
;;;748    		B4:2	BYPLMIXVOL			音量
;;;749    		B1		BYPL2LMIX = 0;		Left bypass path (from the left channel input boost output) to left output mixer
;;;750    		B0		DACL2LMIX = 1;		Left DAC output to left output mixer
;;;751    	*/
;;;752    	usReg = 0;
000176  2600              MOVS     r6,#0
;;;753    	if (_InPath & AUX_ON)
000178  0720              LSLS     r0,r4,#28
00017a  d501              BPL      |L7.384|
;;;754    	{
;;;755    		usReg |= ((7 << 6) | (1 << 5));
00017c  f44f76f0          MOV      r6,#0x1e0
                  |L7.384|
;;;756    	}
;;;757    	if ((_InPath & LINE_ON) || (_InPath & MIC_LEFT_ON) || (_InPath & MIC_RIGHT_ON))
000180  f0140f05          TST      r4,#5
000184  d101              BNE      |L7.394|
000186  07a0              LSLS     r0,r4,#30
000188  d501              BPL      |L7.398|
                  |L7.394|
;;;758    	{
;;;759    		usReg |= ((7 << 2) | (1 << 1));
00018a  f046061e          ORR      r6,r6,#0x1e
                  |L7.398|
;;;760    	}
;;;761    	if (_InPath & DAC_ON)
00018e  06e0              LSLS     r0,r4,#27
000190  d501              BPL      |L7.406|
;;;762    	{
;;;763    		usReg |= (1 << 0);
000192  f0460601          ORR      r6,r6,#1
                  |L7.406|
;;;764    	}
;;;765    	wm8978_WriteReg(50, usReg);
000196  4631              MOV      r1,r6
000198  2032              MOVS     r0,#0x32
00019a  f7fffffe          BL       wm8978_WriteReg
;;;766    	wm8978_WriteReg(51, usReg);
00019e  4631              MOV      r1,r6
0001a0  2033              MOVS     r0,#0x33
0001a2  f7fffffe          BL       wm8978_WriteReg
;;;767    
;;;768    	/*	R56 寄存器   OUT3 mixer ctrl
;;;769    		B8:7	0
;;;770    		B6		OUT3MUTE,  	0 = Output stage outputs OUT3 mixer;  1 = Output stage muted C drives out VMID.
;;;771    		B5:4	0
;;;772    		B3		BYPL2OUT3,	OUT4 mixer output to OUT3  (反相)
;;;773    		B4		0
;;;774    		B2		LMIX2OUT3,	Left ADC input to OUT3
;;;775    		B1		LDAC2OUT3,	Left DAC mixer to OUT3
;;;776    		B0		LDAC2OUT3,	Left DAC output to OUT3
;;;777    	*/
;;;778    	usReg = 0;
0001a6  2100              MOVS     r1,#0
;;;779    	if (_OutPath & OUT3_4_ON)
0001a8  0728              LSLS     r0,r5,#28
0001aa  d500              BPL      |L7.430|
;;;780    	{
;;;781    		usReg |= (1 << 3);
0001ac  2108              MOVS     r1,#8
                  |L7.430|
;;;782    	}
;;;783    	wm8978_WriteReg(56, usReg);
0001ae  2038              MOVS     r0,#0x38
0001b0  f7fffffe          BL       wm8978_WriteReg
;;;784    
;;;785    	/* R57 寄存器		OUT4 (MONO) mixer ctrl
;;;786    		B8:7	0
;;;787    		B6		OUT4MUTE,	0 = Output stage outputs OUT4 mixer  1 = Output stage muted C drives outVMID.
;;;788    		B5		HALFSIG,	0 = OUT4 normal output	1 = OUT4 attenuated by 6dB
;;;789    		B4		LMIX2OUT4,	Left DAC mixer to OUT4
;;;790    		B3		LDAC2UT4,	Left DAC to OUT4
;;;791    		B2		BYPR2OUT4,	Right ADC input to OUT4
;;;792    		B1		RMIX2OUT4,	Right DAC mixer to OUT4
;;;793    		B0		RDAC2OUT4,	Right DAC output to OUT4
;;;794    	*/
;;;795    	usReg = 0;
0001b4  2100              MOVS     r1,#0
;;;796    	if (_OutPath & OUT3_4_ON)
0001b6  0728              LSLS     r0,r5,#28
0001b8  d500              BPL      |L7.444|
;;;797    	{
;;;798    		usReg |= ((1 << 4) |  (1 << 1));
0001ba  2112              MOVS     r1,#0x12
                  |L7.444|
;;;799    	}
;;;800    	wm8978_WriteReg(57, usReg);
0001bc  2039              MOVS     r0,#0x39
0001be  f7fffffe          BL       wm8978_WriteReg
;;;801    
;;;802    
;;;803    	/* R11, 12 寄存器 DAC数字音量
;;;804    		R11		Left DAC Digital Volume
;;;805    		R12		Right DAC Digital Volume
;;;806    	*/
;;;807    	if (_InPath & DAC_ON)
0001c2  06e0              LSLS     r0,r4,#27
0001c4  d50a              BPL      |L7.476|
;;;808    	{
;;;809    		wm8978_WriteReg(11, 255);
0001c6  21ff              MOVS     r1,#0xff
0001c8  200b              MOVS     r0,#0xb
0001ca  f7fffffe          BL       wm8978_WriteReg
;;;810    		wm8978_WriteReg(12, 255 | 0x100);
0001ce  4639              MOV      r1,r7
0001d0  200c              MOVS     r0,#0xc
0001d2  f7fffffe          BL       wm8978_WriteReg
;;;811    	}
;;;812    	else
;;;813    	{
;;;814    		wm8978_WriteReg(11, 0);
;;;815    		wm8978_WriteReg(12, 0 | 0x100);
;;;816    	}
;;;817    
;;;818    	/*	R10 寄存器 DAC Control
;;;819    		B8	0
;;;820    		B7	0
;;;821    		B6	SOFTMUTE,	Softmute enable:
;;;822    		B5	0
;;;823    		B4	0
;;;824    		B3	DACOSR128,	DAC oversampling rate: 0=64x (lowest power) 1=128x (best performance)
;;;825    		B2	AMUTE,		Automute enable
;;;826    		B1	DACPOLR,	Right DAC output polarity
;;;827    		B0	DACPOLL,	Left DAC output polarity:
;;;828    	*/
;;;829    	if (_InPath & DAC_ON)
;;;830    	{
;;;831    		wm8978_WriteReg(10, 0);
0001d6  2100              MOVS     r1,#0
0001d8  200a              MOVS     r0,#0xa
0001da  e005              B        |L7.488|
                  |L7.476|
0001dc  2100              MOVS     r1,#0                 ;814
0001de  200b              MOVS     r0,#0xb               ;814
0001e0  f7fffffe          BL       wm8978_WriteReg
0001e4  4641              MOV      r1,r8                 ;815
0001e6  200c              MOVS     r0,#0xc               ;815
                  |L7.488|
0001e8  e8bd41f0          POP      {r4-r8,lr}            ;815
0001ec  f7ffbffe          B.W      wm8978_WriteReg
;;;832    	}
;;;833    	;
;;;834    }
;;;835    
                          ENDP


                          AREA ||i.wm8978_CtrlGPIO1||, CODE, READONLY, ALIGN=1

                  wm8978_CtrlGPIO1 PROC
;;;874    */
;;;875    void wm8978_CtrlGPIO1(uint8_t _ucValue)
000000  b118              CBZ      r0,|L8.10|
;;;876    {
;;;877    	uint16_t usRegValue;
;;;878    
;;;879    	/* R8， pdf 62页 */
;;;880    	if (_ucValue == 0) /* 输出0 */
;;;881    	{
;;;882    		usRegValue = 6; /* B2:0 = 110 */
;;;883    	}
;;;884    	else
;;;885    	{
;;;886    		usRegValue = 7; /* B2:0 = 111 */
000002  2107              MOVS     r1,#7
                  |L8.4|
;;;887    	}
;;;888    	wm8978_WriteReg(8, usRegValue);
000004  2008              MOVS     r0,#8
000006  f7ffbffe          B.W      wm8978_WriteReg
                  |L8.10|
00000a  2106              MOVS     r1,#6                 ;882
00000c  e7fa              B        |L8.4|
;;;889    }
;;;890    
                          ENDP


                          AREA ||i.wm8978_Init||, CODE, READONLY, ALIGN=1

                  wm8978_Init PROC
;;;72     */
;;;73     uint8_t wm8978_Init(void)
000000  b510              PUSH     {r4,lr}
;;;74     {
;;;75     	uint8_t re;
;;;76     
;;;77     	if (i2c_CheckDevice(WM8978_SLAVE_ADDRESS) == 0)	/* 这个函数会配置STM32的GPIO用于软件模拟I2C时序 */
000002  2034              MOVS     r0,#0x34
000004  f7fffffe          BL       i2c_CheckDevice
000008  b138              CBZ      r0,|L9.26|
;;;78     	{
;;;79     		re = 1;
;;;80     	}
;;;81     	else
;;;82     	{
;;;83     		re = 0;
00000a  2400              MOVS     r4,#0
                  |L9.12|
;;;84     	}
;;;85     	wm8978_Reset();			/* 硬件复位WM8978所有寄存器到缺省状态 */
00000c  f7fffffe          BL       wm8978_Reset
;;;86     	wm8978_CtrlGPIO1(1);	/* WM8978的GPIO1引脚输出1，表示缺省是放音(仅针对安富莱开发板硬件需要) */	
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       wm8978_CtrlGPIO1
;;;87     	return re;
000016  4620              MOV      r0,r4
;;;88     }
000018  bd10              POP      {r4,pc}
                  |L9.26|
00001a  2401              MOVS     r4,#1                 ;79
00001c  e7f6              B        |L9.12|
;;;89     
                          ENDP


                          AREA ||i.wm8978_NotchFilter||, CODE, READONLY, ALIGN=1

                  wm8978_NotchFilter PROC
;;;843    */
;;;844    void wm8978_NotchFilter(uint16_t _NFA0, uint16_t _NFA1)
000000  b570              PUSH     {r4-r6,lr}
;;;845    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;846    	uint16_t usReg;
;;;847    
;;;848    	/*  page 26
;;;849    		A programmable notch filter is provided. This filter has a variable centre frequency and bandwidth,
;;;850    		programmable via two coefficients, a0 and a1. a0 and a1 are represented by the register bits
;;;851    		NFA0[13:0] and NFA1[13:0]. Because these coefficient values require four register writes to setup
;;;852    		there is an NFU (Notch Filter Update) flag which should be set only when all four registers are setup.
;;;853    	*/
;;;854    	usReg = (1 << 7) | (_NFA0 & 0x3F);
000006  f000003f          AND      r0,r0,#0x3f
00000a  f0400180          ORR      r1,r0,#0x80
;;;855    	wm8978_WriteReg(27, usReg);	/* 写寄存器 */
00000e  201b              MOVS     r0,#0x1b
000010  f7fffffe          BL       wm8978_WriteReg
;;;856    
;;;857    	usReg = ((_NFA0 >> 7) & 0x3F);
000014  f3c511c5          UBFX     r1,r5,#7,#6
;;;858    	wm8978_WriteReg(28, usReg);	/* 写寄存器 */
000018  201c              MOVS     r0,#0x1c
00001a  f7fffffe          BL       wm8978_WriteReg
;;;859    
;;;860    	usReg = (_NFA1 & 0x3F);
00001e  f004013f          AND      r1,r4,#0x3f
;;;861    	wm8978_WriteReg(29, usReg);	/* 写寄存器 */
000022  201d              MOVS     r0,#0x1d
000024  f7fffffe          BL       wm8978_WriteReg
;;;862    
;;;863    	usReg = (1 << 8) | ((_NFA1 >> 7) & 0x3F);
000028  f3c410c5          UBFX     r0,r4,#7,#6
;;;864    	wm8978_WriteReg(30, usReg);	/* 写寄存器 */
00002c  e8bd4070          POP      {r4-r6,lr}
000030  f4407180          ORR      r1,r0,#0x100          ;863
000034  201e              MOVS     r0,#0x1e
000036  f7ffbffe          B.W      wm8978_WriteReg
;;;865    }
;;;866    
                          ENDP


                          AREA ||i.wm8978_OutMute||, CODE, READONLY, ALIGN=2

                  wm8978_OutMute PROC
;;;189    */
;;;190    void wm8978_OutMute(uint8_t _ucMute)
000000  b510              PUSH     {r4,lr}
000002  4c1a              LDR      r4,|L11.108|
;;;191    {
;;;192    	uint16_t usRegValue;
;;;193    
;;;194    	if (_ucMute == 1) /* 静音 */
000004  2801              CMP      r0,#1
000006  f8b41068          LDRH     r1,[r4,#0x68]
00000a  d019              BEQ      |L11.64|
;;;195    	{
;;;196    		usRegValue = wm8978_ReadReg(52); /* Left Mixer Control */
;;;197    		usRegValue |= (1u << 6);
;;;198    		wm8978_WriteReg(52, usRegValue);
;;;199    
;;;200    		usRegValue = wm8978_ReadReg(53); /* Left Mixer Control */
;;;201    		usRegValue |= (1u << 6);
;;;202    		wm8978_WriteReg(53, usRegValue);
;;;203    
;;;204    		usRegValue = wm8978_ReadReg(54); /* Right Mixer Control */
;;;205    		usRegValue |= (1u << 6);
;;;206    		wm8978_WriteReg(54, usRegValue);
;;;207    
;;;208    		usRegValue = wm8978_ReadReg(55); /* Right Mixer Control */
;;;209    		usRegValue |= (1u << 6);
;;;210    		wm8978_WriteReg(55, usRegValue);
;;;211    	}
;;;212    	else	/* 取消静音 */
;;;213    	{
;;;214    		usRegValue = wm8978_ReadReg(52);
;;;215    		usRegValue &= ~(1u << 6);
00000c  f0210140          BIC      r1,r1,#0x40
;;;216    		wm8978_WriteReg(52, usRegValue);
000010  2034              MOVS     r0,#0x34
000012  f7fffffe          BL       wm8978_WriteReg
000016  f8340f6a          LDRH     r0,[r4,#0x6a]!
;;;217    
;;;218    		usRegValue = wm8978_ReadReg(53); /* Left Mixer Control */
;;;219    		usRegValue &= ~(1u << 6);
00001a  f0200140          BIC      r1,r0,#0x40
;;;220    		wm8978_WriteReg(53, usRegValue);
00001e  2035              MOVS     r0,#0x35
000020  f7fffffe          BL       wm8978_WriteReg
000024  8860              LDRH     r0,[r4,#2]
;;;221    
;;;222    		usRegValue = wm8978_ReadReg(54);
;;;223    		usRegValue &= ~(1u << 6);
000026  f0200140          BIC      r1,r0,#0x40
;;;224    		wm8978_WriteReg(54, usRegValue);
00002a  2036              MOVS     r0,#0x36
00002c  f7fffffe          BL       wm8978_WriteReg
000030  88a0              LDRH     r0,[r4,#4]
;;;225    
;;;226    		usRegValue = wm8978_ReadReg(55); /* Left Mixer Control */
;;;227    		usRegValue &= ~(1u << 6);
000032  f0200140          BIC      r1,r0,#0x40
                  |L11.54|
;;;228    		wm8978_WriteReg(55, usRegValue);
000036  e8bd4010          POP      {r4,lr}
00003a  2037              MOVS     r0,#0x37
00003c  f7ffbffe          B.W      wm8978_WriteReg
                  |L11.64|
000040  f0410140          ORR      r1,r1,#0x40           ;197
000044  2034              MOVS     r0,#0x34              ;198
000046  f7fffffe          BL       wm8978_WriteReg
00004a  f8340f6a          LDRH     r0,[r4,#0x6a]!        ;198
00004e  f0400140          ORR      r1,r0,#0x40           ;201
000052  2035              MOVS     r0,#0x35              ;202
000054  f7fffffe          BL       wm8978_WriteReg
000058  8860              LDRH     r0,[r4,#2]            ;202
00005a  f0400140          ORR      r1,r0,#0x40           ;205
00005e  2036              MOVS     r0,#0x36              ;206
000060  f7fffffe          BL       wm8978_WriteReg
000064  88a0              LDRH     r0,[r4,#4]            ;206
000066  f0400140          ORR      r1,r0,#0x40           ;209
00006a  e7e4              B        |L11.54|
;;;229    	}
;;;230    }
;;;231    
                          ENDP

                  |L11.108|
                          DCD      ||.data||

                          AREA ||i.wm8978_PowerDown||, CODE, READONLY, ALIGN=1

                  wm8978_PowerDown PROC
;;;306    */
;;;307    void wm8978_PowerDown(void)
000000  f7ffbffe          B.W      wm8978_Reset
;;;308    {
;;;309    	wm8978_Reset();			/* 硬件复位WM8978所有寄存器到缺省状态 */
;;;310    }
;;;311    
                          ENDP


                          AREA ||i.wm8978_ReadEarVolume||, CODE, READONLY, ALIGN=2

                  wm8978_ReadEarVolume PROC
;;;163    */
;;;164    uint8_t wm8978_ReadEarVolume(void)
000000  4802              LDR      r0,|L13.12|
000002  f8900068          LDRB     r0,[r0,#0x68]
;;;165    {
;;;166    	return (uint8_t)(wm8978_ReadReg(52) & 0x3F );
000006  f000003f          AND      r0,r0,#0x3f
;;;167    }
00000a  4770              BX       lr
;;;168    
                          ENDP

                  |L13.12|
                          DCD      ||.data||

                          AREA ||i.wm8978_ReadSpkVolume||, CODE, READONLY, ALIGN=2

                  wm8978_ReadSpkVolume PROC
;;;176    */
;;;177    uint8_t wm8978_ReadSpkVolume(void)
000000  4802              LDR      r0,|L14.12|
000002  f890006c          LDRB     r0,[r0,#0x6c]
;;;178    {
;;;179    	return (uint8_t)(wm8978_ReadReg(54) & 0x3F );
000006  f000003f          AND      r0,r0,#0x3f
;;;180    }
00000a  4770              BX       lr
;;;181    
                          ENDP

                  |L14.12|
                          DCD      ||.data||

                          AREA ||i.wm8978_Reset||, CODE, READONLY, ALIGN=2

                  wm8978_Reset PROC
;;;898    */
;;;899    static void wm8978_Reset(void)
000000  b500              PUSH     {lr}
;;;900    {
000002  b09d              SUB      sp,sp,#0x74
;;;901    	/* wm8978寄存器缺省值 */
;;;902    	const uint16_t reg_default[] = {
000004  2274              MOVS     r2,#0x74
000006  490a              LDR      r1,|L15.48|
000008  4668              MOV      r0,sp
00000a  f7fffffe          BL       __aeabi_memcpy4
;;;903    	0x000, 0x000, 0x000, 0x000, 0x050, 0x000, 0x140, 0x000,
;;;904    	0x000, 0x000, 0x000, 0x0FF, 0x0FF, 0x000, 0x100, 0x0FF,
;;;905    	0x0FF, 0x000, 0x12C, 0x02C, 0x02C, 0x02C, 0x02C, 0x000,
;;;906    	0x032, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000, 0x000,
;;;907    	0x038, 0x00B, 0x032, 0x000, 0x008, 0x00C, 0x093, 0x0E9,
;;;908    	0x000, 0x000, 0x000, 0x000, 0x003, 0x010, 0x010, 0x100,
;;;909    	0x100, 0x002, 0x001, 0x001, 0x039, 0x039, 0x039, 0x039,
;;;910    	0x001, 0x001
;;;911    	};
;;;912    	uint8_t i;
;;;913    
;;;914    	wm8978_WriteReg(0x00, 0);
00000e  2100              MOVS     r1,#0
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       wm8978_WriteReg
;;;915    
;;;916    	for (i = 0; i < sizeof(reg_default) / 2; i++)
;;;917    	{
;;;918    		wm8978_RegCash[i] = reg_default[i];
000016  4907              LDR      r1,|L15.52|
000018  2000              MOVS     r0,#0                 ;916
00001a  466a              MOV      r2,sp                 ;902
                  |L15.28|
00001c  f8323010          LDRH     r3,[r2,r0,LSL #1]
000020  f8213010          STRH     r3,[r1,r0,LSL #1]
000024  1c40              ADDS     r0,r0,#1
000026  b2c0              UXTB     r0,r0                 ;916
000028  283a              CMP      r0,#0x3a              ;916
00002a  d3f7              BCC      |L15.28|
;;;919    	}
;;;920    }
00002c  b01d              ADD      sp,sp,#0x74
00002e  bd00              POP      {pc}
;;;921    
                          ENDP

                  |L15.48|
                          DCD      ||.constdata||
                  |L15.52|
                          DCD      ||.data||

                          AREA ||i.wm8978_SetEarVolume||, CODE, READONLY, ALIGN=1

                  wm8978_SetEarVolume PROC
;;;98     */
;;;99     void wm8978_SetEarVolume(uint8_t _ucVolume)
000000  b510              PUSH     {r4,lr}
;;;100    {
;;;101    	uint16_t regL;
;;;102    	uint16_t regR;
;;;103    
;;;104    	if (_ucVolume > 0x3F)
000002  283f              CMP      r0,#0x3f
000004  d900              BLS      |L16.8|
;;;105    	{
;;;106    		_ucVolume = 0x3F;
000006  203f              MOVS     r0,#0x3f
                  |L16.8|
;;;107    	}
;;;108    
;;;109    	regL = _ucVolume;
000008  4601              MOV      r1,r0
;;;110    	regR = _ucVolume;
00000a  460c              MOV      r4,r1
;;;111    
;;;112    	/*
;;;113    		R52	LOUT1 Volume control
;;;114    		R53	ROUT1 Volume control
;;;115    	*/
;;;116    	/* 先更新左声道缓存值 */
;;;117    	wm8978_WriteReg(52, regL | 0x00);
00000c  2034              MOVS     r0,#0x34
00000e  f7fffffe          BL       wm8978_WriteReg
;;;118    
;;;119    	/* 再同步更新左右声道的音量 */
;;;120    	wm8978_WriteReg(53, regR | 0x100);	/* 0x180表示 在音量为0时再更新，避免调节音量出现的“嘎哒”声 */
000012  f4447180          ORR      r1,r4,#0x100
000016  e8bd4010          POP      {r4,lr}
00001a  2035              MOVS     r0,#0x35
00001c  f7ffbffe          B.W      wm8978_WriteReg
;;;121    }
;;;122    
                          ENDP


                          AREA ||i.wm8978_SetLineGain||, CODE, READONLY, ALIGN=2

                  wm8978_SetLineGain PROC
;;;264    */
;;;265    void wm8978_SetLineGain(uint8_t _ucGain)
000000  b570              PUSH     {r4-r6,lr}
;;;266    {
000002  4604              MOV      r4,r0
;;;267    	uint16_t usRegValue;
;;;268    
;;;269    	if (_ucGain > 7)
000004  2807              CMP      r0,#7
000006  d900              BLS      |L17.10|
;;;270    	{
;;;271    		_ucGain = 7;
000008  2407              MOVS     r4,#7
                  |L17.10|
00000a  4d0a              LDR      r5,|L17.52|
00000c  f8150f5e          LDRB     r0,[r5,#0x5e]!
;;;272    	}
;;;273    
;;;274    	/*
;;;275    		Mic 输入信道的增益由 PGABOOSTL 和 PGABOOSTR 控制
;;;276    		Aux 输入信道的输入增益由 AUXL2BOOSTVO[2:0] 和 AUXR2BOOSTVO[2:0] 控制
;;;277    		Line 输入信道的增益由 LIP2BOOSTVOL[2:0] 和 RIP2BOOSTVOL[2:0] 控制
;;;278    	*/
;;;279    	/*	pdf 21页，R47（左声道），R48（右声道）, MIC 增益控制寄存器
;;;280    		R47 (R48定义与此相同)
;;;281    		B8		PGABOOSTL	= 1,   0表示MIC信号直通无增益，1表示MIC信号+20dB增益（通过自举电路）
;;;282    		B7		= 0， 保留
;;;283    		B6:4	L2_2BOOSTVOL = x， 0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;284    		B3		= 0， 保留
;;;285    		B2:0`	AUXL2BOOSTVOL = x，0表示禁止，1-7表示增益-12dB ~ +6dB  （可以衰减也可以放大）
;;;286    	*/
;;;287    
;;;288    	usRegValue = wm8978_ReadReg(47);
;;;289    	usRegValue &= 0x8F;/* 将Bit6:4清0   1000 1111*/
000010  f000008f          AND      r0,r0,#0x8f
;;;290    	usRegValue |= (_ucGain << 4);
000014  ea401104          ORR      r1,r0,r4,LSL #4
;;;291    	wm8978_WriteReg(47, usRegValue);	/* 写左声道输入增益控制寄存器 */
000018  202f              MOVS     r0,#0x2f
00001a  f7fffffe          BL       wm8978_WriteReg
00001e  78a8              LDRB     r0,[r5,#2]
;;;292    
;;;293    	usRegValue = wm8978_ReadReg(48);
;;;294    	usRegValue &= 0x8F;/* 将Bit6:4清0   1000 1111*/
000020  f000008f          AND      r0,r0,#0x8f
;;;295    	usRegValue |= (_ucGain << 4);
000024  ea401104          ORR      r1,r0,r4,LSL #4
;;;296    	wm8978_WriteReg(48, usRegValue);	/* 写右声道输入增益控制寄存器 */
000028  e8bd4070          POP      {r4-r6,lr}
00002c  2030              MOVS     r0,#0x30
00002e  f7ffbffe          B.W      wm8978_WriteReg
;;;297    }
;;;298    
                          ENDP

000032  0000              DCW      0x0000
                  |L17.52|
                          DCD      ||.data||

                          AREA ||i.wm8978_SetMicGain||, CODE, READONLY, ALIGN=1

                  wm8978_SetMicGain PROC
;;;239    */
;;;240    void wm8978_SetMicGain(uint8_t _ucGain)
000000  b510              PUSH     {r4,lr}
;;;241    {
000002  4604              MOV      r4,r0
;;;242    	if (_ucGain > GAIN_MAX)
000004  283f              CMP      r0,#0x3f
000006  d900              BLS      |L18.10|
;;;243    	{
;;;244    		_ucGain = GAIN_MAX;
000008  243f              MOVS     r4,#0x3f
                  |L18.10|
;;;245    	}
;;;246    
;;;247    	/* PGA 音量控制  R45， R46   pdf 19页
;;;248    		Bit8	INPPGAUPDATE
;;;249    		Bit7	INPPGAZCL		过零再更改
;;;250    		Bit6	INPPGAMUTEL		PGA静音
;;;251    		Bit5:0	增益值，010000是0dB
;;;252    	*/
;;;253    	wm8978_WriteReg(45, _ucGain);
00000a  4621              MOV      r1,r4
00000c  202d              MOVS     r0,#0x2d
00000e  f7fffffe          BL       wm8978_WriteReg
;;;254    	wm8978_WriteReg(46, _ucGain | (1 << 8));
000012  f4447180          ORR      r1,r4,#0x100
000016  e8bd4010          POP      {r4,lr}
00001a  202e              MOVS     r0,#0x2e
00001c  f7ffbffe          B.W      wm8978_WriteReg
;;;255    }
;;;256    
                          ENDP


                          AREA ||i.wm8978_SetSpkVolume||, CODE, READONLY, ALIGN=1

                  wm8978_SetSpkVolume PROC
;;;131    */
;;;132    void wm8978_SetSpkVolume(uint8_t _ucVolume)
000000  b510              PUSH     {r4,lr}
;;;133    {
;;;134    	uint16_t regL;
;;;135    	uint16_t regR;
;;;136    
;;;137    	if (_ucVolume > 0x3F)
000002  283f              CMP      r0,#0x3f
000004  d900              BLS      |L19.8|
;;;138    	{
;;;139    		_ucVolume = 0x3F;
000006  203f              MOVS     r0,#0x3f
                  |L19.8|
;;;140    	}
;;;141    
;;;142    	regL = _ucVolume;
000008  4601              MOV      r1,r0
;;;143    	regR = _ucVolume;
00000a  460c              MOV      r4,r1
;;;144    
;;;145    	/*
;;;146    		R54	LOUT2 (SPK) Volume control
;;;147    		R55	ROUT2 (SPK) Volume control
;;;148    	*/
;;;149    	/* 先更新左声道缓存值 */
;;;150    	wm8978_WriteReg(54, regL | 0x00);
00000c  2036              MOVS     r0,#0x36
00000e  f7fffffe          BL       wm8978_WriteReg
;;;151    
;;;152    	/* 再同步更新左右声道的音量 */
;;;153    	wm8978_WriteReg(55, regR | 0x100);	/* 在音量为0时再更新，避免调节音量出现的“嘎哒”声 */
000012  f4447180          ORR      r1,r4,#0x100
000016  e8bd4010          POP      {r4,lr}
00001a  2037              MOVS     r0,#0x37
00001c  f7ffbffe          B.W      wm8978_WriteReg
;;;154    }
;;;155    
                          ENDP


                          AREA ||i.wm8978_WriteReg||, CODE, READONLY, ALIGN=2

                  wm8978_WriteReg PROC
;;;413    */
;;;414    static uint8_t wm8978_WriteReg(uint8_t _ucRegAddr, uint16_t _usValue)
000000  b570              PUSH     {r4-r6,lr}
;;;415    {
000002  460c              MOV      r4,r1
000004  4605              MOV      r5,r0
;;;416    	uint8_t ucAck;
;;;417    
;;;418    	/* 发送起始位 */
;;;419    	i2c_Start();
000006  f7fffffe          BL       i2c_Start
;;;420    
;;;421    	/* 发送设备地址+读写控制bit（0 = w， 1 = r) bit7 先传 */
;;;422    	i2c_SendByte(WM8978_SLAVE_ADDRESS | I2C_WR);
00000a  2034              MOVS     r0,#0x34
00000c  f7fffffe          BL       i2c_SendByte
;;;423    
;;;424    	/* 检测ACK */
;;;425    	ucAck = i2c_WaitAck();
000010  f7fffffe          BL       i2c_WaitAck
;;;426    	if (ucAck == 1)
000014  2801              CMP      r0,#1
000016  d018              BEQ      |L20.74|
;;;427    	{
;;;428    		return 0;
;;;429    	}
;;;430    
;;;431    	/* 发送控制字节1 */
;;;432    	i2c_SendByte(((_ucRegAddr << 1) & 0xFE) | ((_usValue >> 8) & 0x1));
000018  0668              LSLS     r0,r5,#25
00001a  f3c42100          UBFX     r1,r4,#8,#1
00001e  ea416010          ORR      r0,r1,r0,LSR #24
000022  f7fffffe          BL       i2c_SendByte
;;;433    
;;;434    	/* 检测ACK */
;;;435    	ucAck = i2c_WaitAck();
000026  f7fffffe          BL       i2c_WaitAck
;;;436    	if (ucAck == 1)
00002a  2801              CMP      r0,#1
00002c  d00d              BEQ      |L20.74|
;;;437    	{
;;;438    		return 0;
;;;439    	}
;;;440    
;;;441    	/* 发送控制字节2 */
;;;442    	i2c_SendByte(_usValue & 0xFF);
00002e  b2e0              UXTB     r0,r4
000030  f7fffffe          BL       i2c_SendByte
;;;443    
;;;444    	/* 检测ACK */
;;;445    	ucAck = i2c_WaitAck();
000034  f7fffffe          BL       i2c_WaitAck
;;;446    	if (ucAck == 1)
000038  2801              CMP      r0,#1
00003a  d006              BEQ      |L20.74|
;;;447    	{
;;;448    		return 0;
;;;449    	}
;;;450    
;;;451    	/* 发送STOP */
;;;452    	i2c_Stop();
00003c  f7fffffe          BL       i2c_Stop
;;;453    
;;;454    	wm8978_RegCash[_ucRegAddr] = _usValue;
000040  4803              LDR      r0,|L20.80|
000042  f8204015          STRH     r4,[r0,r5,LSL #1]
;;;455    	return 1;
000046  2001              MOVS     r0,#1
;;;456    }
000048  bd70              POP      {r4-r6,pc}
                  |L20.74|
00004a  2000              MOVS     r0,#0                 ;448
00004c  bd70              POP      {r4-r6,pc}
;;;457    
                          ENDP

00004e  0000              DCW      0x0000
                  |L20.80|
                          DCD      ||.data||

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

000000  00000000          DCW      0x0000,0x0000
000004  00000000          DCW      0x0000,0x0000
000008  00500000          DCW      0x0050,0x0000
00000c  01400000          DCW      0x0140,0x0000
000010  00000000          DCW      0x0000,0x0000
000014  000000ff          DCW      0x0000,0x00ff
000018  00ff0000          DCW      0x00ff,0x0000
00001c  010000ff          DCW      0x0100,0x00ff
000020  00ff0000          DCW      0x00ff,0x0000
000024  012c002c          DCW      0x012c,0x002c
000028  002c002c          DCW      0x002c,0x002c
00002c  002c0000          DCW      0x002c,0x0000
000030  00320000          DCW      0x0032,0x0000
000034  00000000          DCW      0x0000,0x0000
000038  00000000          DCW      0x0000,0x0000
00003c  00000000          DCW      0x0000,0x0000
000040  0038000b          DCW      0x0038,0x000b
000044  00320000          DCW      0x0032,0x0000
000048  0008000c          DCW      0x0008,0x000c
00004c  009300e9          DCW      0x0093,0x00e9
000050  00000000          DCW      0x0000,0x0000
000054  00000000          DCW      0x0000,0x0000
000058  00030010          DCW      0x0003,0x0010
00005c  00100100          DCW      0x0010,0x0100
000060  01000002          DCW      0x0100,0x0002
000064  00010001          DCW      0x0001,0x0001
000068  00390039          DCW      0x0039,0x0039
00006c  00390039          DCW      0x0039,0x0039
000070  00010001          DCW      0x0001,0x0001

                          AREA ||.data||, DATA, ALIGN=1

                  wm8978_RegCash
000000  00000000          DCW      0x0000,0x0000
000004  00000000          DCW      0x0000,0x0000
000008  00500000          DCW      0x0050,0x0000
00000c  01400000          DCW      0x0140,0x0000
000010  00000000          DCW      0x0000,0x0000
000014  000000ff          DCW      0x0000,0x00ff
000018  00ff0000          DCW      0x00ff,0x0000
00001c  010000ff          DCW      0x0100,0x00ff
000020  00ff0000          DCW      0x00ff,0x0000
000024  012c002c          DCW      0x012c,0x002c
000028  002c002c          DCW      0x002c,0x002c
00002c  002c0000          DCW      0x002c,0x0000
000030  00320000          DCW      0x0032,0x0000
000034  00000000          DCW      0x0000,0x0000
000038  00000000          DCW      0x0000,0x0000
00003c  00000000          DCW      0x0000,0x0000
000040  0038000b          DCW      0x0038,0x000b
000044  00320000          DCW      0x0032,0x0000
000048  0008000c          DCW      0x0008,0x000c
00004c  009300e9          DCW      0x0093,0x00e9
000050  00000000          DCW      0x0000,0x0000
000054  00000000          DCW      0x0000,0x0000
000058  00030010          DCW      0x0003,0x0010
00005c  00100100          DCW      0x0010,0x0100
000060  01000002          DCW      0x0100,0x0002
000064  00010001          DCW      0x0001,0x0001
000068  00390039          DCW      0x0039,0x0039
00006c  00390039          DCW      0x0039,0x0039
000070  00010001          DCW      0x0001,0x0001

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_wm8978.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_wm8978_c_ef408190____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_wm8978_c_ef408190____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_wm8978_c_ef408190____REVSH|
#line 128
|__asm___12_bsp_wm8978_c_ef408190____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
