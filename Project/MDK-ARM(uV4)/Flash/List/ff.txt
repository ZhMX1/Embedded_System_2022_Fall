; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\ff.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\ff.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\ff.crf ..\..\User\FatFS\src\ff.c]
                          THUMB

                          AREA ||i.check_fs||, CODE, READONLY, ALIGN=2

                  check_fs PROC
;;;2135   static
;;;2136   BYTE check_fs (	/* 0:FAT boor sector, 1:Valid boor sector but not FAT, 2:Not a boot sector, 3:Disk error */
000000  b510              PUSH     {r4,lr}
;;;2137   	FATFS* fs,	/* File system object */
;;;2138   	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
;;;2139   )
;;;2140   {
000002  4604              MOV      r4,r0
;;;2141   	fs->wflag = 0; fs->winsect = 0xFFFFFFFF;	/* Invaidate window */
000004  2000              MOVS     r0,#0
000006  7120              STRB     r0,[r4,#4]
000008  1e40              SUBS     r0,r0,#1
;;;2142   	if (move_window(fs, sect) != FR_OK)			/* Load boot record */
00000a  62e0              STR      r0,[r4,#0x2c]
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       move_window
000012  b108              CBZ      r0,|L1.24|
;;;2143   		return 3;
000014  2003              MOVS     r0,#3
;;;2144   
;;;2145   	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)	/* Check boot record signature (always placed at offset 510 even if the sector size is >512) */
;;;2146   		return 2;
;;;2147   
;;;2148   	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)		/* Check "FAT" string */
;;;2149   		return 0;
;;;2150   	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
;;;2151   		return 0;
;;;2152   
;;;2153   	return 1;
;;;2154   }
000016  bd10              POP      {r4,pc}
                  |L1.24|
000018  f8b4022e          LDRH     r0,[r4,#0x22e]        ;2145
00001c  f5a0412a          SUB      r1,r0,#0xaa00         ;2145
000020  3955              SUBS     r1,r1,#0x55           ;2145
000022  d001              BEQ      |L1.40|
000024  2002              MOVS     r0,#2                 ;2146
000026  bd10              POP      {r4,pc}
                  |L1.40|
000028  f8940066          LDRB     r0,[r4,#0x66]         ;2148
00002c  f8b41067          LDRH     r1,[r4,#0x67]         ;2148
000030  ea402101          ORR      r1,r0,r1,LSL #8       ;2148
000034  4808              LDR      r0,|L1.88|
000036  ebb02f01          CMP      r0,r1,LSL #8          ;2148
00003a  d008              BEQ      |L1.78|
00003c  f8941082          LDRB     r1,[r4,#0x82]         ;2150
000040  f8b42083          LDRH     r2,[r4,#0x83]         ;2150
000044  ea412102          ORR      r1,r1,r2,LSL #8       ;2150
000048  ebb02f01          CMP      r0,r1,LSL #8          ;2150
00004c  d101              BNE      |L1.82|
                  |L1.78|
00004e  2000              MOVS     r0,#0                 ;2151
000050  bd10              POP      {r4,pc}
                  |L1.82|
000052  2001              MOVS     r0,#1                 ;2153
000054  bd10              POP      {r4,pc}
;;;2155   
                          ENDP

000056  0000              DCW      0x0000
                  |L1.88|
                          DCD      0x54414600

                          AREA ||i.chk_chr||, CODE, READONLY, ALIGN=1

                  chk_chr PROC
;;;597    static
;;;598    int chk_chr (const char* str, int chr) {
000000  e000              B        |L2.4|
                  |L2.2|
;;;599    	while (*str && *str != chr) str++;
000002  1c40              ADDS     r0,r0,#1
                  |L2.4|
000004  7802              LDRB     r2,[r0,#0]
000006  b10a              CBZ      r2,|L2.12|
000008  428a              CMP      r2,r1
00000a  d1fa              BNE      |L2.2|
                  |L2.12|
;;;600    	return *str;
00000c  b2d0              UXTB     r0,r2
;;;601    }
00000e  4770              BX       lr
;;;602    
                          ENDP


                          AREA ||i.chk_lock||, CODE, READONLY, ALIGN=2

                  chk_lock PROC
;;;643    static
;;;644    FRESULT chk_lock (	/* Check if the file can be accessed */
000000  b5f0              PUSH     {r4-r7,lr}
;;;645    	DIR* dp,		/* Directory object pointing the file to be checked */
;;;646    	int acc			/* Desired access type (0:Read, 1:Write, 2:Delete/Rename) */
;;;647    )
;;;648    {
;;;649    	UINT i, be;
;;;650    
;;;651    	/* Search file semaphore table */
;;;652    	for (i = be = 0; i < _FS_LOCK; i++) {
000002  2200              MOVS     r2,#0
;;;653    		if (Files[i].fs) {	/* Existing entry */
000004  4b16              LDR      r3,|L3.96|
000006  4614              MOV      r4,r2                 ;652
                  |L3.8|
000008  eb020642          ADD      r6,r2,r2,LSL #1
00000c  f8535026          LDR      r5,[r3,r6,LSL #2]
000010  b16d              CBZ      r5,|L3.46|
;;;654    			if (Files[i].fs == dp->fs &&	 	/* Check if the object matched with an open object */
000012  6807              LDR      r7,[r0,#0]
000014  42bd              CMP      r5,r7
000016  d10b              BNE      |L3.48|
;;;655    				Files[i].clu == dp->sclust &&
000018  eb030586          ADD      r5,r3,r6,LSL #2
00001c  6886              LDR      r6,[r0,#8]
00001e  686f              LDR      r7,[r5,#4]
000020  42b7              CMP      r7,r6
000022  d105              BNE      |L3.48|
;;;656    				Files[i].idx == dp->index) break;
000024  892d              LDRH     r5,[r5,#8]
000026  88c6              LDRH     r6,[r0,#6]
000028  42b5              CMP      r5,r6
00002a  d004              BEQ      |L3.54|
00002c  e000              B        |L3.48|
                  |L3.46|
;;;657    		} else {			/* Blank entry */
;;;658    			be = 1;
00002e  2401              MOVS     r4,#1
                  |L3.48|
000030  1c52              ADDS     r2,r2,#1
000032  2a03              CMP      r2,#3                 ;652
000034  d3e8              BCC      |L3.8|
                  |L3.54|
;;;659    		}
;;;660    	}
;;;661    	if (i == _FS_LOCK)	/* The object is not opened */
000036  2a03              CMP      r2,#3
000038  d001              BEQ      |L3.62|
;;;662    		return (be || acc == 2) ? FR_OK : FR_TOO_MANY_OPEN_FILES;	/* Is there a blank entry for new object? */
;;;663    
;;;664    	/* The object has been opened. Reject any open against writing file and all write mode open */
;;;665    	return (acc || Files[i].ctr == 0x100) ? FR_LOCKED : FR_OK;
00003a  b979              CBNZ     r1,|L3.92|
00003c  e004              B        |L3.72|
                  |L3.62|
00003e  b95c              CBNZ     r4,|L3.88|
000040  2902              CMP      r1,#2                 ;662
000042  d009              BEQ      |L3.88|
000044  2012              MOVS     r0,#0x12              ;662
;;;666    }
000046  bdf0              POP      {r4-r7,pc}
                  |L3.72|
000048  eb020042          ADD      r0,r2,r2,LSL #1       ;665
00004c  eb030080          ADD      r0,r3,r0,LSL #2       ;665
000050  8940              LDRH     r0,[r0,#0xa]          ;665
000052  f5b07f80          CMP      r0,#0x100             ;665
000056  d001              BEQ      |L3.92|
                  |L3.88|
000058  2000              MOVS     r0,#0                 ;665
00005a  bdf0              POP      {r4-r7,pc}
                  |L3.92|
00005c  2010              MOVS     r0,#0x10              ;665
00005e  bdf0              POP      {r4-r7,pc}
;;;667    
                          ENDP

                  |L3.96|
                          DCD      ||.bss||+0xc

                          AREA ||i.clear_lock||, CODE, READONLY, ALIGN=2

                  clear_lock PROC
;;;734    static
;;;735    void clear_lock (	/* Clear lock entries of the volume */
000000  b530              PUSH     {r4,r5,lr}
;;;736    	FATFS *fs
;;;737    )
;;;738    {
;;;739    	UINT i;
;;;740    
;;;741    	for (i = 0; i < _FS_LOCK; i++) {
000002  2100              MOVS     r1,#0
;;;742    		if (Files[i].fs == fs) Files[i].fs = 0;
000004  4a06              LDR      r2,|L4.32|
000006  460c              MOV      r4,r1                 ;741
                  |L4.8|
000008  eb010341          ADD      r3,r1,r1,LSL #1
00000c  f8525023          LDR      r5,[r2,r3,LSL #2]
000010  4285              CMP      r5,r0
000012  d101              BNE      |L4.24|
000014  f8424023          STR      r4,[r2,r3,LSL #2]
                  |L4.24|
000018  1c49              ADDS     r1,r1,#1
00001a  2903              CMP      r1,#3                 ;741
00001c  d3f4              BCC      |L4.8|
;;;743    	}
;;;744    }
00001e  bd30              POP      {r4,r5,pc}
;;;745    #endif
                          ENDP

                  |L4.32|
                          DCD      ||.bss||+0xc

                          AREA ||i.clust2sect||, CODE, READONLY, ALIGN=1

                  clust2sect PROC
;;;846    
;;;847    DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
000000  6942              LDR      r2,[r0,#0x14]
;;;848    	FATFS* fs,		/* File system object */
;;;849    	DWORD clst		/* Cluster# to be converted */
;;;850    )
;;;851    {
;;;852    	clst -= 2;
;;;853    	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
000002  1e89              SUBS     r1,r1,#2
000004  1e92              SUBS     r2,r2,#2
000006  428a              CMP      r2,r1
000008  d801              BHI      |L5.14|
00000a  2000              MOVS     r0,#0
;;;854    	return clst * fs->csize + fs->database;
;;;855    }
00000c  4770              BX       lr
                  |L5.14|
00000e  6a82              LDR      r2,[r0,#0x28]         ;854
000010  7880              LDRB     r0,[r0,#2]            ;854
000012  fb012000          MLA      r0,r1,r0,r2           ;854
000016  4770              BX       lr
;;;856    
                          ENDP


                          AREA ||i.create_chain||, CODE, READONLY, ALIGN=1

                  create_chain PROC
;;;1026   static
;;;1027   DWORD create_chain (	/* 0:No free cluster, 1:Internal error, 0xFFFFFFFF:Disk error, >=2:New cluster# */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1028   	FATFS* fs,			/* File system object */
;;;1029   	DWORD clst			/* Cluster# to stretch. 0 means create a new chain. */
;;;1030   )
;;;1031   {
000004  000f              MOVS     r7,r1
000006  4605              MOV      r5,r0
000008  d006              BEQ      |L6.24|
;;;1032   	DWORD cs, ncl, scl;
;;;1033   	FRESULT res;
;;;1034   
;;;1035   
;;;1036   	if (clst == 0) {		/* Create a new chain */
;;;1037   		scl = fs->last_clust;			/* Get suggested start point */
;;;1038   		if (!scl || scl >= fs->n_fatent) scl = 1;
;;;1039   	}
;;;1040   	else {					/* Stretch the current chain */
;;;1041   		cs = get_fat(fs, clst);			/* Check the cluster status */
00000a  f7fffffe          BL       get_fat
;;;1042   		if (cs < 2) return 1;			/* Invalid value */
00000e  2802              CMP      r0,#2
000010  d209              BCS      |L6.38|
000012  2001              MOVS     r0,#1
                  |L6.20|
;;;1043   		if (cs == 0xFFFFFFFF) return cs;	/* A disk error occurred */
;;;1044   		if (cs < fs->n_fatent) return cs;	/* It is already followed by next cluster */
;;;1045   		scl = clst;
;;;1046   	}
;;;1047   
;;;1048   	ncl = scl;				/* Start cluster */
;;;1049   	for (;;) {
;;;1050   		ncl++;							/* Next cluster */
;;;1051   		if (ncl >= fs->n_fatent) {		/* Check wrap around */
;;;1052   			ncl = 2;
;;;1053   			if (ncl > scl) return 0;	/* No free cluster */
;;;1054   		}
;;;1055   		cs = get_fat(fs, ncl);			/* Get the cluster status */
;;;1056   		if (cs == 0) break;				/* Found a free cluster */
;;;1057   		if (cs == 0xFFFFFFFF || cs == 1)/* An error occurred */
;;;1058   			return cs;
;;;1059   		if (ncl == scl) return 0;		/* No free cluster */
;;;1060   	}
;;;1061   
;;;1062   	res = put_fat(fs, ncl, 0x0FFFFFFF);	/* Mark the new cluster "last link" */
;;;1063   	if (res == FR_OK && clst != 0) {
;;;1064   		res = put_fat(fs, clst, ncl);	/* Link it to the previous one if needed */
;;;1065   	}
;;;1066   	if (res == FR_OK) {
;;;1067   		fs->last_clust = ncl;			/* Update FSINFO */
;;;1068   		if (fs->free_clust != 0xFFFFFFFF) {
;;;1069   			fs->free_clust--;
;;;1070   			fs->fsi_flag |= 1;
;;;1071   		}
;;;1072   	} else {
;;;1073   		ncl = (res == FR_DISK_ERR) ? 0xFFFFFFFF : 1;
;;;1074   	}
;;;1075   
;;;1076   	return ncl;		/* Return new cluster number or error code */
;;;1077   }
000014  e8bd81f0          POP      {r4-r8,pc}
                  |L6.24|
000018  68ee              LDR      r6,[r5,#0xc]          ;1038
00001a  b116              CBZ      r6,|L6.34|
00001c  6968              LDR      r0,[r5,#0x14]         ;1038
00001e  42b0              CMP      r0,r6                 ;1038
000020  d807              BHI      |L6.50|
                  |L6.34|
000022  2601              MOVS     r6,#1                 ;1038
000024  e005              B        |L6.50|
                  |L6.38|
000026  1c41              ADDS     r1,r0,#1              ;1043
000028  d0f4              BEQ      |L6.20|
00002a  6969              LDR      r1,[r5,#0x14]         ;1044
00002c  4281              CMP      r1,r0                 ;1044
00002e  d8f1              BHI      |L6.20|
000030  463e              MOV      r6,r7                 ;1045
                  |L6.50|
000032  4634              MOV      r4,r6                 ;1048
                  |L6.52|
000034  6968              LDR      r0,[r5,#0x14]         ;1051
000036  1c64              ADDS     r4,r4,#1              ;1051
000038  42a0              CMP      r0,r4                 ;1051
00003a  d802              BHI      |L6.66|
00003c  2402              MOVS     r4,#2                 ;1052
00003e  2e02              CMP      r6,#2                 ;1053
000040  d30a              BCC      |L6.88|
                  |L6.66|
000042  4621              MOV      r1,r4                 ;1055
000044  4628              MOV      r0,r5                 ;1055
000046  f7fffffe          BL       get_fat
00004a  b138              CBZ      r0,|L6.92|
00004c  1c41              ADDS     r1,r0,#1              ;1057
00004e  d0e1              BEQ      |L6.20|
000050  2801              CMP      r0,#1                 ;1057
000052  d0df              BEQ      |L6.20|
000054  42b4              CMP      r4,r6                 ;1059
000056  d1ed              BNE      |L6.52|
                  |L6.88|
000058  2000              MOVS     r0,#0                 ;1059
00005a  e7db              B        |L6.20|
                  |L6.92|
00005c  f06f4270          MVN      r2,#0xf0000000        ;1062
000060  4621              MOV      r1,r4                 ;1062
000062  4628              MOV      r0,r5                 ;1062
000064  f7fffffe          BL       put_fat
000068  b930              CBNZ     r0,|L6.120|
00006a  b157              CBZ      r7,|L6.130|
00006c  4622              MOV      r2,r4                 ;1064
00006e  4639              MOV      r1,r7                 ;1064
000070  4628              MOV      r0,r5                 ;1064
000072  f7fffffe          BL       put_fat
000076  b120              CBZ      r0,|L6.130|
                  |L6.120|
000078  2801              CMP      r0,#1                 ;1073
00007a  d00d              BEQ      |L6.152|
00007c  2401              MOVS     r4,#1                 ;1073
                  |L6.126|
00007e  4620              MOV      r0,r4                 ;1076
000080  e7c8              B        |L6.20|
                  |L6.130|
000082  60ec              STR      r4,[r5,#0xc]          ;1068
000084  6928              LDR      r0,[r5,#0x10]         ;1068
000086  1c41              ADDS     r1,r0,#1              ;1068
000088  d0f9              BEQ      |L6.126|
00008a  1e40              SUBS     r0,r0,#1              ;1068
00008c  6128              STR      r0,[r5,#0x10]         ;1070
00008e  7968              LDRB     r0,[r5,#5]            ;1070
000090  f0400001          ORR      r0,r0,#1              ;1070
000094  7168              STRB     r0,[r5,#5]            ;1070
000096  e7f2              B        |L6.126|
                  |L6.152|
000098  f04f34ff          MOV      r4,#0xffffffff        ;1073
00009c  e7ef              B        |L6.126|
;;;1078   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.create_name||, CODE, READONLY, ALIGN=2

                  create_name PROC
;;;1804   static
;;;1805   FRESULT create_name (
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;1806   	DIR* dp,			/* Pointer to the directory object */
;;;1807   	const TCHAR** path	/* Pointer to pointer to the segment in the path string */
;;;1808   )
;;;1809   {
000004  4688              MOV      r8,r1
000006  4682              MOV      r10,r0
000008  680f              LDR      r7,[r1,#0]
00000a  e000              B        |L7.14|
                  |L7.12|
00000c  1c7f              ADDS     r7,r7,#1
                  |L7.14|
;;;1810   #if _USE_LFN	/* LFN configuration */
;;;1811   	BYTE b, cf;
;;;1812   	WCHAR w, *lfn;
;;;1813   	UINT i, ni, si, di;
;;;1814   	const TCHAR *p;
;;;1815   
;;;1816   	/* Create LFN in Unicode */
;;;1817   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
00000e  7838              LDRB     r0,[r7,#0]
000010  282f              CMP      r0,#0x2f
000012  d0fb              BEQ      |L7.12|
000014  285c              CMP      r0,#0x5c
000016  d0f9              BEQ      |L7.12|
;;;1818   	lfn = dp->lfn;
;;;1819   	si = di = 0;
000018  2400              MOVS     r4,#0
00001a  f8da6020          LDR      r6,[r10,#0x20]
00001e  4625              MOV      r5,r4
                  |L7.32|
;;;1820   	for (;;) {
;;;1821   		w = p[si++];					/* Get a character */
000020  5d78              LDRB     r0,[r7,r5]
000022  1c6d              ADDS     r5,r5,#1
;;;1822   		if (w < ' ' || w == '/' || w == '\\') break;	/* Break on end of segment */
000024  2820              CMP      r0,#0x20
000026  d327              BCC      |L7.120|
000028  282f              CMP      r0,#0x2f
00002a  d025              BEQ      |L7.120|
00002c  285c              CMP      r0,#0x5c
00002e  d023              BEQ      |L7.120|
;;;1823   		if (di >= _MAX_LFN)				/* Reject too long name */
000030  2cff              CMP      r4,#0xff
000032  d242              BCS      |L7.186|
;;;1824   			return FR_INVALID_NAME;
;;;1825   #if !_LFN_UNICODE
;;;1826   		w &= 0xFF;
;;;1827   		if (IsDBCS1(w)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
000034  f1a00181          SUB      r1,r0,#0x81
000038  297d              CMP      r1,#0x7d
00003a  d80b              BHI      |L7.84|
;;;1828   			b = (BYTE)p[si++];			/* Get 2nd byte */
00003c  5d79              LDRB     r1,[r7,r5]
;;;1829   			if (!IsDBCS2(b))
00003e  1c6d              ADDS     r5,r5,#1
000040  f1a10240          SUB      r2,r1,#0x40
000044  2a3f              CMP      r2,#0x3f
000046  d302              BCC      |L7.78|
000048  3a40              SUBS     r2,r2,#0x40
00004a  2a7f              CMP      r2,#0x7f
00004c  d235              BCS      |L7.186|
                  |L7.78|
;;;1830   				return FR_INVALID_NAME;	/* Reject invalid sequence */
;;;1831   			w = (w << 8) + b;			/* Create a DBC */
00004e  eb012000          ADD      r0,r1,r0,LSL #8
000052  b280              UXTH     r0,r0
                  |L7.84|
;;;1832   		}
;;;1833   		w = ff_convert(w, 1);			/* Convert ANSI/OEM to Unicode */
000054  2101              MOVS     r1,#1
000056  f7fffffe          BL       ff_convert
00005a  ea5f0900          MOVS     r9,r0
;;;1834   		if (!w) return FR_INVALID_NAME;	/* Reject invalid code */
00005e  d02c              BEQ      |L7.186|
;;;1835   #endif
;;;1836   		if (w < 0x80 && chk_chr("\"*:<>\?|\x7F", w)) /* Reject illegal characters for LFN */
000060  f1b90f80          CMP      r9,#0x80
000064  d204              BCS      |L7.112|
000066  4601              MOV      r1,r0
000068  a071              ADR      r0,|L7.560|
00006a  f7fffffe          BL       chk_chr
00006e  bb20              CBNZ     r0,|L7.186|
                  |L7.112|
;;;1837   			return FR_INVALID_NAME;
;;;1838   		lfn[di++] = w;					/* Store the Unicode character */
000070  f8269014          STRH     r9,[r6,r4,LSL #1]
000074  1c64              ADDS     r4,r4,#1
000076  e7d3              B        |L7.32|
                  |L7.120|
;;;1839   	}
;;;1840   	*path = &p[si];						/* Return pointer to the next segment */
000078  197a              ADDS     r2,r7,r5
;;;1841   	cf = (w < ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
00007a  f8c82000          STR      r2,[r8,#0]
00007e  2820              CMP      r0,#0x20
000080  d201              BCS      |L7.134|
000082  2504              MOVS     r5,#4
000084  e017              B        |L7.182|
                  |L7.134|
000086  2500              MOVS     r5,#0
000088  e015              B        |L7.182|
;;;1842   #if _FS_RPATH
;;;1843   	if ((di == 1 && lfn[di-1] == '.') || /* Is this a dot entry? */
;;;1844   		(di == 2 && lfn[di-1] == '.' && lfn[di-2] == '.')) {
;;;1845   		lfn[di] = 0;
;;;1846   		for (i = 0; i < 11; i++)
;;;1847   			dp->fn[i] = (i < di) ? '.' : ' ';
;;;1848   		dp->fn[i] = cf | NS_DOT;		/* This is a dot entry */
;;;1849   		return FR_OK;
;;;1850   	}
;;;1851   #endif
;;;1852   	while (di) {						/* Strip trailing spaces and dots */
;;;1853   		w = lfn[di-1];
00008a  bf00              NOP      
                  |L7.140|
00008c  eb060044          ADD      r0,r6,r4,LSL #1
000090  f8300c02          LDRH     r0,[r0,#-2]
;;;1854   		if (w != ' ' && w != '.') break;
000094  2820              CMP      r0,#0x20
000096  d00d              BEQ      |L7.180|
000098  282e              CMP      r0,#0x2e
00009a  d00b              BEQ      |L7.180|
;;;1855   		di--;
;;;1856   	}
;;;1857   	if (!di) return FR_INVALID_NAME;	/* Reject nul string */
00009c  b16c              CBZ      r4,|L7.186|
;;;1858   
;;;1859   	lfn[di] = 0;						/* LFN is created */
00009e  2000              MOVS     r0,#0
0000a0  f8260014          STRH     r0,[r6,r4,LSL #1]
;;;1860   
;;;1861   	/* Create SFN in directory form */
;;;1862   	mem_set(dp->fn, ' ', 11);
0000a4  220b              MOVS     r2,#0xb
0000a6  2120              MOVS     r1,#0x20
0000a8  f8da0018          LDR      r0,[r10,#0x18]
0000ac  f7fffffe          BL       mem_set
;;;1863   	for (si = 0; lfn[si] == ' ' || lfn[si] == '.'; si++) ;	/* Strip leading spaces and dots */
0000b0  2700              MOVS     r7,#0
0000b2  e006              B        |L7.194|
                  |L7.180|
0000b4  1e64              SUBS     r4,r4,#1
                  |L7.182|
0000b6  2c00              CMP      r4,#0                 ;1852
0000b8  d1e8              BNE      |L7.140|
                  |L7.186|
0000ba  2006              MOVS     r0,#6                 ;1857
                  |L7.188|
;;;1864   	if (si) cf |= NS_LOSS | NS_LFN;
;;;1865   	while (di && lfn[di - 1] != '.') di--;	/* Find extension (di<=si: no extension) */
;;;1866   
;;;1867   	b = i = 0; ni = 8;
;;;1868   	for (;;) {
;;;1869   		w = lfn[si++];					/* Get an LFN character */
;;;1870   		if (!w) break;					/* Break on end of the LFN */
;;;1871   		if (w == ' ' || (w == '.' && si != di)) {	/* Remove spaces and dots */
;;;1872   			cf |= NS_LOSS | NS_LFN; continue;
;;;1873   		}
;;;1874   
;;;1875   		if (i >= ni || si == di) {		/* Extension or end of SFN */
;;;1876   			if (ni == 11) {				/* Long extension */
;;;1877   				cf |= NS_LOSS | NS_LFN; break;
;;;1878   			}
;;;1879   			if (si != di) cf |= NS_LOSS | NS_LFN;	/* Out of 8.3 format */
;;;1880   			if (si > di) break;			/* No extension */
;;;1881   			si = di; i = 8; ni = 11;	/* Enter extension section */
;;;1882   			b <<= 2; continue;
;;;1883   		}
;;;1884   
;;;1885   		if (w >= 0x80) {				/* Non ASCII character */
;;;1886   #ifdef _EXCVT
;;;1887   			w = ff_convert(w, 0);		/* Unicode -> OEM code */
;;;1888   			if (w) w = ExCvt[w - 0x80];	/* Convert extended character to upper (SBCS) */
;;;1889   #else
;;;1890   			w = ff_convert(ff_wtoupper(w), 0);	/* Upper converted Unicode -> OEM code */
;;;1891   #endif
;;;1892   			cf |= NS_LFN;				/* Force create LFN entry */
;;;1893   		}
;;;1894   
;;;1895   		if (_DF1S && w >= 0x100) {		/* Double byte character (always false on SBCS cfg) */
;;;1896   			if (i >= ni - 1) {
;;;1897   				cf |= NS_LOSS | NS_LFN; i = ni; continue;
;;;1898   			}
;;;1899   			dp->fn[i++] = (BYTE)(w >> 8);
;;;1900   		} else {						/* Single byte character */
;;;1901   			if (!w || chk_chr("+,;=[]", w)) {	/* Replace illegal characters for SFN */
;;;1902   				w = '_'; cf |= NS_LOSS | NS_LFN;/* Lossy conversion */
;;;1903   			} else {
;;;1904   				if (IsUpper(w)) {		/* ASCII large capital */
;;;1905   					b |= 2;
;;;1906   				} else {
;;;1907   					if (IsLower(w)) {	/* ASCII small capital */
;;;1908   						b |= 1; w -= 0x20;
;;;1909   					}
;;;1910   				}
;;;1911   			}
;;;1912   		}
;;;1913   		dp->fn[i++] = (BYTE)w;
;;;1914   	}
;;;1915   
;;;1916   	if (dp->fn[0] == DDE) dp->fn[0] = NDDE;	/* If the first character collides with deleted mark, replace it with 0x05 */
;;;1917   
;;;1918   	if (ni == 8) b <<= 2;
;;;1919   	if ((b & 0x0C) == 0x0C || (b & 0x03) == 0x03)	/* Create LFN entry when there are composite capitals */
;;;1920   		cf |= NS_LFN;
;;;1921   	if (!(cf & NS_LFN)) {						/* When LFN is in 8.3 format without extended character, NT flags are created */
;;;1922   		if ((b & 0x03) == 0x01) cf |= NS_EXT;	/* NT flag (Extension has only small capital) */
;;;1923   		if ((b & 0x0C) == 0x04) cf |= NS_BODY;	/* NT flag (Filename has only small capital) */
;;;1924   	}
;;;1925   
;;;1926   	dp->fn[NS] = cf;	/* SFN is created */
;;;1927   
;;;1928   	return FR_OK;
;;;1929   
;;;1930   
;;;1931   #else	/* Non-LFN configuration */
;;;1932   	BYTE b, c, d, *sfn;
;;;1933   	UINT ni, si, i;
;;;1934   	const char *p;
;;;1935   
;;;1936   	/* Create file name in directory form */
;;;1937   	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
;;;1938   	sfn = dp->fn;
;;;1939   	mem_set(sfn, ' ', 11);
;;;1940   	si = i = b = 0; ni = 8;
;;;1941   #if _FS_RPATH
;;;1942   	if (p[si] == '.') { /* Is this a dot entry? */
;;;1943   		for (;;) {
;;;1944   			c = (BYTE)p[si++];
;;;1945   			if (c != '.' || si >= 3) break;
;;;1946   			sfn[i++] = c;
;;;1947   		}
;;;1948   		if (c != '/' && c != '\\' && c > ' ') return FR_INVALID_NAME;
;;;1949   		*path = &p[si];									/* Return pointer to the next segment */
;;;1950   		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
;;;1951   		return FR_OK;
;;;1952   	}
;;;1953   #endif
;;;1954   	for (;;) {
;;;1955   		c = (BYTE)p[si++];
;;;1956   		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
;;;1957   		if (c == '.' || i >= ni) {
;;;1958   			if (ni != 8 || c != '.') return FR_INVALID_NAME;
;;;1959   			i = 8; ni = 11;
;;;1960   			b <<= 2; continue;
;;;1961   		}
;;;1962   		if (c >= 0x80) {				/* Extended character? */
;;;1963   			b |= 3;						/* Eliminate NT flag */
;;;1964   #ifdef _EXCVT
;;;1965   			c = ExCvt[c - 0x80];		/* To upper extended characters (SBCS cfg) */
;;;1966   #else
;;;1967   #if !_DF1S
;;;1968   			return FR_INVALID_NAME;		/* Reject extended characters (ASCII cfg) */
;;;1969   #endif
;;;1970   #endif
;;;1971   		}
;;;1972   		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
;;;1973   			d = (BYTE)p[si++];			/* Get 2nd byte */
;;;1974   			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
;;;1975   				return FR_INVALID_NAME;
;;;1976   			sfn[i++] = c;
;;;1977   			sfn[i++] = d;
;;;1978   		} else {						/* Single byte code */
;;;1979   			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
;;;1980   				return FR_INVALID_NAME;
;;;1981   			if (IsUpper(c)) {			/* ASCII large capital? */
;;;1982   				b |= 2;
;;;1983   			} else {
;;;1984   				if (IsLower(c)) {		/* ASCII small capital? */
;;;1985   					b |= 1; c -= 0x20;
;;;1986   				}
;;;1987   			}
;;;1988   			sfn[i++] = c;
;;;1989   		}
;;;1990   	}
;;;1991   	*path = &p[si];						/* Return pointer to the next segment */
;;;1992   	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
;;;1993   
;;;1994   	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
;;;1995   	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first character collides with DDE, replace it with 0x05 */
;;;1996   
;;;1997   	if (ni == 8) b <<= 2;
;;;1998   	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
;;;1999   	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
;;;2000   
;;;2001   	sfn[NS] = c;		/* Store NT flag, File name is created */
;;;2002   
;;;2003   	return FR_OK;
;;;2004   #endif
;;;2005   }
0000bc  e8bd8ff8          POP      {r3-r11,pc}
                  |L7.192|
0000c0  1c7f              ADDS     r7,r7,#1
                  |L7.194|
0000c2  f8360017          LDRH     r0,[r6,r7,LSL #1]     ;1863
0000c6  2820              CMP      r0,#0x20              ;1863
0000c8  d0fa              BEQ      |L7.192|
0000ca  282e              CMP      r0,#0x2e              ;1863
0000cc  d0f8              BEQ      |L7.192|
0000ce  b11f              CBZ      r7,|L7.216|
0000d0  f0450503          ORR      r5,r5,#3              ;1864
0000d4  e000              B        |L7.216|
                  |L7.214|
0000d6  1e64              SUBS     r4,r4,#1              ;1864
                  |L7.216|
0000d8  b12c              CBZ      r4,|L7.230|
0000da  eb060044          ADD      r0,r6,r4,LSL #1       ;1865
0000de  f8300c02          LDRH     r0,[r0,#-2]           ;1865
0000e2  282e              CMP      r0,#0x2e              ;1865
0000e4  d1f7              BNE      |L7.214|
                  |L7.230|
0000e6  2000              MOVS     r0,#0                 ;1867
0000e8  4681              MOV      r9,r0                 ;1867
0000ea  f04f0b08          MOV      r11,#8                ;1867
0000ee  9000              STR      r0,[sp,#0]            ;1867
                  |L7.240|
0000f0  f8360017          LDRH     r0,[r6,r7,LSL #1]     ;1869
0000f4  f1070701          ADD      r7,r7,#1              ;1869
0000f8  ea5f0800          MOVS     r8,r0                 ;1869
0000fc  d024              BEQ      |L7.328|
0000fe  f1b80f20          CMP      r8,#0x20              ;1871
000102  d004              BEQ      |L7.270|
000104  f1b80f2e          CMP      r8,#0x2e              ;1871
000108  d104              BNE      |L7.276|
00010a  42a7              CMP      r7,r4                 ;1871
00010c  d002              BEQ      |L7.276|
                  |L7.270|
00010e  f0450503          ORR      r5,r5,#3              ;1872
000112  e7ed              B        |L7.240|
                  |L7.276|
000114  9800              LDR      r0,[sp,#0]            ;1875
000116  4558              CMP      r0,r11                ;1875
000118  d201              BCS      |L7.286|
00011a  42a7              CMP      r7,r4                 ;1875
00011c  d11a              BNE      |L7.340|
                  |L7.286|
00011e  f1bb0f0b          CMP      r11,#0xb              ;1876
000122  d00f              BEQ      |L7.324|
000124  42a7              CMP      r7,r4                 ;1879
000126  d001              BEQ      |L7.300|
000128  f0450503          ORR      r5,r5,#3              ;1879
                  |L7.300|
00012c  d80c              BHI      |L7.328|
00012e  f04f0008          MOV      r0,#8                 ;1881
000132  9000              STR      r0,[sp,#0]            ;1881
000134  ea4f6089          LSL      r0,r9,#26             ;1881
000138  4627              MOV      r7,r4                 ;1881
00013a  f04f0b0b          MOV      r11,#0xb              ;1881
00013e  ea4f6910          LSR      r9,r0,#24             ;1882
000142  e7d5              B        |L7.240|
                  |L7.324|
000144  f0450503          ORR      r5,r5,#3              ;1877
                  |L7.328|
000148  f8da0018          LDR      r0,[r10,#0x18]        ;1916
00014c  7801              LDRB     r1,[r0,#0]            ;1916
00014e  29e5              CMP      r1,#0xe5              ;1916
000150  d049              BEQ      |L7.486|
000152  e04a              B        |L7.490|
                  |L7.340|
000154  4640              MOV      r0,r8                 ;1885
000156  f1b80f80          CMP      r8,#0x80              ;1885
00015a  d307              BCC      |L7.364|
00015c  f7fffffe          BL       ff_wtoupper
000160  2100              MOVS     r1,#0                 ;1890
000162  f7fffffe          BL       ff_convert
000166  4680              MOV      r8,r0                 ;1890
000168  f0450502          ORR      r5,r5,#2              ;1892
                  |L7.364|
00016c  f1b80fff          CMP      r8,#0xff              ;1895
000170  d913              BLS      |L7.410|
000172  9900              LDR      r1,[sp,#0]            ;1896
000174  f1ab0001          SUB      r0,r11,#1             ;1896
000178  4281              CMP      r1,r0                 ;1896
00017a  d304              BCC      |L7.390|
00017c  f0450503          ORR      r5,r5,#3              ;1897
000180  f8cdb000          STR      r11,[sp,#0]           ;1897
000184  e7b4              B        |L7.240|
                  |L7.390|
000186  f8da2018          LDR      r2,[r10,#0x18]        ;1899
00018a  9800              LDR      r0,[sp,#0]            ;1899
00018c  ea4f2118          LSR      r1,r8,#8              ;1899
000190  5411              STRB     r1,[r2,r0]            ;1899
000192  9800              LDR      r0,[sp,#0]            ;1899
000194  1c40              ADDS     r0,r0,#1              ;1899
000196  9000              STR      r0,[sp,#0]            ;1899
000198  e01c              B        |L7.468|
                  |L7.410|
00019a  f1b80f00          CMP      r8,#0                 ;1901
00019e  d004              BEQ      |L7.426|
0001a0  4601              MOV      r1,r0                 ;1901
0001a2  a026              ADR      r0,|L7.572|
0001a4  f7fffffe          BL       chk_chr
0001a8  b120              CBZ      r0,|L7.436|
                  |L7.426|
0001aa  f04f085f          MOV      r8,#0x5f              ;1902
0001ae  f0450503          ORR      r5,r5,#3              ;1902
0001b2  e00f              B        |L7.468|
                  |L7.436|
0001b4  f1a80041          SUB      r0,r8,#0x41           ;1904
0001b8  2819              CMP      r0,#0x19              ;1904
0001ba  d802              BHI      |L7.450|
0001bc  f0490902          ORR      r9,r9,#2              ;1905
0001c0  e008              B        |L7.468|
                  |L7.450|
0001c2  f1a80061          SUB      r0,r8,#0x61           ;1907
0001c6  2819              CMP      r0,#0x19              ;1907
0001c8  d804              BHI      |L7.468|
0001ca  3041              ADDS     r0,r0,#0x41           ;1908
0001cc  f0490901          ORR      r9,r9,#1              ;1908
0001d0  fa1ff880          UXTH     r8,r0                 ;1908
                  |L7.468|
0001d4  f8da2018          LDR      r2,[r10,#0x18]        ;1913
0001d8  9900              LDR      r1,[sp,#0]            ;1913
0001da  f8028001          STRB     r8,[r2,r1]            ;1913
0001de  9800              LDR      r0,[sp,#0]            ;1913
0001e0  1c40              ADDS     r0,r0,#1              ;1913
0001e2  9000              STR      r0,[sp,#0]            ;1872
0001e4  e784              B        |L7.240|
                  |L7.486|
0001e6  2105              MOVS     r1,#5                 ;1916
0001e8  7001              STRB     r1,[r0,#0]            ;1916
                  |L7.490|
0001ea  f1bb0f08          CMP      r11,#8                ;1918
0001ee  d103              BNE      |L7.504|
0001f0  ea4f6089          LSL      r0,r9,#26             ;1918
0001f4  ea4f6910          LSR      r9,r0,#24             ;1918
                  |L7.504|
0001f8  f3c90081          UBFX     r0,r9,#2,#2           ;1919
0001fc  2803              CMP      r0,#3                 ;1919
0001fe  d003              BEQ      |L7.520|
000200  ea6f0109          MVN      r1,r9                 ;1919
000204  0789              LSLS     r1,r1,#30             ;1919
000206  d101              BNE      |L7.524|
                  |L7.520|
000208  f0450502          ORR      r5,r5,#2              ;1920
                  |L7.524|
00020c  07a9              LSLS     r1,r5,#30             ;1921
00020e  d409              BMI      |L7.548|
000210  f0090103          AND      r1,r9,#3              ;1922
000214  2901              CMP      r1,#1                 ;1922
000216  d101              BNE      |L7.540|
000218  f0450510          ORR      r5,r5,#0x10           ;1922
                  |L7.540|
00021c  2801              CMP      r0,#1                 ;1923
00021e  d101              BNE      |L7.548|
000220  f0450508          ORR      r5,r5,#8              ;1923
                  |L7.548|
000224  f8da0018          LDR      r0,[r10,#0x18]        ;1926
000228  72c5              STRB     r5,[r0,#0xb]          ;1926
00022a  2000              MOVS     r0,#0                 ;1928
00022c  e746              B        |L7.188|
;;;2006   
                          ENDP

00022e  0000              DCW      0x0000
                  |L7.560|
000230  222a3a3c          DCB      """*:<>?|",127,0
000234  3e3f7c7f
000238  00      
000239  00                DCB      0
00023a  00                DCB      0
00023b  00                DCB      0
                  |L7.572|
00023c  2b2c3b3d          DCB      "+,;=[]",0
000240  5b5d00  
000243  00                DCB      0

                          AREA ||i.dec_lock||, CODE, READONLY, ALIGN=2

                  dec_lock PROC
;;;711    static
;;;712    FRESULT dec_lock (	/* Decrement object open counter */
000000  1e40              SUBS     r0,r0,#1
;;;713    	UINT i			/* Semaphore index (1..) */
;;;714    )
;;;715    {
;;;716    	WORD n;
;;;717    	FRESULT res;
;;;718    
;;;719    
;;;720    	if (--i < _FS_LOCK) {	/* Shift index number origin from 0 */
000002  2803              CMP      r0,#3
000004  d215              BCS      |L8.50|
;;;721    		n = Files[i].ctr;
000006  4b0c              LDR      r3,|L8.56|
000008  eb000240          ADD      r2,r0,r0,LSL #1
00000c  eb030182          ADD      r1,r3,r2,LSL #2
000010  8948              LDRH     r0,[r1,#0xa]
;;;722    		if (n == 0x100) n = 0;		/* If write mode open, delete the entry */
000012  f5b07f80          CMP      r0,#0x100
000016  d005              BEQ      |L8.36|
;;;723    		if (n) n--;					/* Decrement read mode open count */
000018  b108              CBZ      r0,|L8.30|
00001a  1e40              SUBS     r0,r0,#1
00001c  b280              UXTH     r0,r0
                  |L8.30|
;;;724    		Files[i].ctr = n;
00001e  8148              STRH     r0,[r1,#0xa]
;;;725    		if (!n) Files[i].fs = 0;	/* Delete the entry if open count gets zero */
000020  b110              CBZ      r0,|L8.40|
000022  e004              B        |L8.46|
                  |L8.36|
000024  2000              MOVS     r0,#0                 ;722
000026  e7fa              B        |L8.30|
                  |L8.40|
000028  2000              MOVS     r0,#0
00002a  f8430022          STR      r0,[r3,r2,LSL #2]
                  |L8.46|
;;;726    		res = FR_OK;
00002e  2000              MOVS     r0,#0
;;;727    	} else {
;;;728    		res = FR_INT_ERR;			/* Invalid index nunber */
;;;729    	}
;;;730    	return res;
;;;731    }
000030  4770              BX       lr
                  |L8.50|
000032  2002              MOVS     r0,#2                 ;728
000034  4770              BX       lr
;;;732    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      ||.bss||+0xc

                          AREA ||i.dir_find||, CODE, READONLY, ALIGN=2

                  dir_find PROC
;;;1489   static
;;;1490   FRESULT dir_find (
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;1491   	DIR* dp			/* Pointer to the directory object linked to the file name */
;;;1492   )
;;;1493   {
000004  4605              MOV      r5,r0
;;;1494   	FRESULT res;
;;;1495   	BYTE c, *dir;
;;;1496   #if _USE_LFN
;;;1497   	BYTE a, ord, sum;
;;;1498   #endif
;;;1499   
;;;1500   	res = dir_sdi(dp, 0);			/* Rewind directory object */
000006  2100              MOVS     r1,#0
000008  f7fffffe          BL       dir_sdi
;;;1501   	if (res != FR_OK) return res;
00000c  2800              CMP      r0,#0
00000e  d177              BNE      |L9.256|
;;;1502   
;;;1503   #if _USE_LFN
;;;1504   	ord = sum = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
000010  20ff              MOVS     r0,#0xff
000012  f64f7aff          MOV      r10,#0xffff
000016  9000              STR      r0,[sp,#0]
000018  4681              MOV      r9,r0
00001a  f8a5a024          STRH     r10,[r5,#0x24]
                  |L9.30|
;;;1505   #endif
;;;1506   	do {
;;;1507   		res = move_window(dp->fs, dp->sect);
00001e  6929              LDR      r1,[r5,#0x10]
000020  6828              LDR      r0,[r5,#0]
000022  f7fffffe          BL       move_window
000026  0006              MOVS     r6,r0
;;;1508   		if (res != FR_OK) break;
000028  d10d              BNE      |L9.70|
;;;1509   		dir = dp->dir;					/* Ptr to the directory entry of current index */
;;;1510   		c = dir[DIR_Name];
00002a  696c              LDR      r4,[r5,#0x14]
00002c  7820              LDRB     r0,[r4,#0]
;;;1511   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
00002e  b148              CBZ      r0,|L9.68|
;;;1512   #if _USE_LFN	/* LFN configuration */
;;;1513   		a = dir[DIR_Attr] & AM_MASK;
000030  7ae1              LDRB     r1,[r4,#0xb]
;;;1514   		if (c == DDE || ((a & AM_VOL) && a != AM_LFN)) {	/* An entry without valid data */
000032  28e5              CMP      r0,#0xe5
000034  f001013f          AND      r1,r1,#0x3f           ;1513
000038  d06d              BEQ      |L9.278|
00003a  070a              LSLS     r2,r1,#28
00003c  d504              BPL      |L9.72|
00003e  290f              CMP      r1,#0xf
000040  d169              BNE      |L9.278|
000042  e007              B        |L9.84|
                  |L9.68|
000044  2604              MOVS     r6,#4                 ;1511
                  |L9.70|
000046  e071              B        |L9.300|
                  |L9.72|
;;;1515   			ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1516   		} else {
;;;1517   			if (a == AM_LFN) {			/* An LFN entry is found */
000048  290f              CMP      r1,#0xf
00004a  d003              BEQ      |L9.84|
;;;1518   				if (dp->lfn) {
;;;1519   					if (c & LLE) {		/* Is it start of LFN sequence? */
;;;1520   						sum = dir[LDIR_Chksum];
;;;1521   						c &= ~LLE; ord = c;	/* LFN start order */
;;;1522   						dp->lfn_idx = dp->index;	/* Start index of LFN */
;;;1523   					}
;;;1524   					/* Check validity of the LFN entry and compare it with given name */
;;;1525   					ord = (c == ord && sum == dir[LDIR_Chksum] && cmp_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1526   				}
;;;1527   			} else {					/* An SFN entry is found */
;;;1528   				if (!ord && sum == sum_sfn(dir)) break;	/* LFN matched? */
00004c  f1b90f00          CMP      r9,#0
000050  d04a              BEQ      |L9.232|
000052  e04f              B        |L9.244|
                  |L9.84|
000054  6a29              LDR      r1,[r5,#0x20]         ;1518
000056  b389              CBZ      r1,|L9.188|
000058  0642              LSLS     r2,r0,#25             ;1519
00005a  d506              BPL      |L9.106|
00005c  7b62              LDRB     r2,[r4,#0xd]          ;1520
00005e  9200              STR      r2,[sp,#0]            ;1522
000060  f0200040          BIC      r0,r0,#0x40           ;1521
000064  88ea              LDRH     r2,[r5,#6]            ;1522
000066  4681              MOV      r9,r0                 ;1521
000068  84aa              STRH     r2,[r5,#0x24]         ;1522
                  |L9.106|
00006a  4548              CMP      r0,r9                 ;1525
00006c  d135              BNE      |L9.218|
00006e  7b62              LDRB     r2,[r4,#0xd]          ;1525
000070  9800              LDR      r0,[sp,#0]            ;1525
000072  4282              CMP      r2,r0                 ;1525
000074  d131              BNE      |L9.218|
000076  9101              STR      r1,[sp,#4]            ;1525
000078  7820              LDRB     r0,[r4,#0]            ;1525
00007a  46a0              MOV      r8,r4                 ;1525
00007c  f0200040          BIC      r0,r0,#0x40           ;1525
000080  1e40              SUBS     r0,r0,#1              ;1525
000082  eb000180          ADD      r1,r0,r0,LSL #2       ;1525
000086  2700              MOVS     r7,#0                 ;1525
000088  f8dfb0a8          LDR      r11,|L9.308|
00008c  eb0106c0          ADD      r6,r1,r0,LSL #3       ;1525
000090  2401              MOVS     r4,#1                 ;1525
000092  bf00              NOP                            ;1525
                  |L9.148|
000094  f81b1007          LDRB     r1,[r11,r7]           ;1525
000098  eb010008          ADD      r0,r1,r8              ;1525
00009c  8800              LDRH     r0,[r0,#0]            ;1525
00009e  b174              CBZ      r4,|L9.190|
0000a0  f7fffffe          BL       ff_wtoupper
0000a4  4604              MOV      r4,r0                 ;1525
0000a6  2eff              CMP      r6,#0xff              ;1525
0000a8  d217              BCS      |L9.218|
0000aa  9801              LDR      r0,[sp,#4]            ;1525
0000ac  f8300016          LDRH     r0,[r0,r6,LSL #1]     ;1525
0000b0  1c76              ADDS     r6,r6,#1              ;1525
0000b2  f7fffffe          BL       ff_wtoupper
0000b6  42a0              CMP      r0,r4                 ;1525
0000b8  d10f              BNE      |L9.218|
0000ba  e002              B        |L9.194|
                  |L9.188|
0000bc  e02f              B        |L9.286|
                  |L9.190|
0000be  4550              CMP      r0,r10                ;1525
0000c0  d10b              BNE      |L9.218|
                  |L9.194|
0000c2  1c7f              ADDS     r7,r7,#1              ;1525
0000c4  2f0d              CMP      r7,#0xd               ;1525
0000c6  d3e5              BCC      |L9.148|
0000c8  f8980000          LDRB     r0,[r8,#0]            ;1525
0000cc  0640              LSLS     r0,r0,#25             ;1525
0000ce  d508              BPL      |L9.226|
0000d0  b13c              CBZ      r4,|L9.226|
0000d2  9801              LDR      r0,[sp,#4]            ;1525
0000d4  f8300016          LDRH     r0,[r0,r6,LSL #1]     ;1525
0000d8  b118              CBZ      r0,|L9.226|
                  |L9.218|
0000da  20ff              MOVS     r0,#0xff              ;1525
                  |L9.220|
0000dc  f00009ff          AND      r9,r0,#0xff           ;1525
0000e0  e01d              B        |L9.286|
                  |L9.226|
0000e2  f1a90001          SUB      r0,r9,#1              ;1525
0000e6  e7f9              B        |L9.220|
                  |L9.232|
0000e8  4620              MOV      r0,r4
0000ea  f7fffffe          BL       sum_sfn
0000ee  9900              LDR      r1,[sp,#0]
0000f0  4288              CMP      r0,r1
0000f2  d01b              BEQ      |L9.300|
                  |L9.244|
;;;1529   				if (!(dp->fn[NS] & NS_LOSS) && !mem_cmp(dir, dp->fn, 11)) break;	/* SFN matched? */
0000f4  69a8              LDR      r0,[r5,#0x18]
0000f6  7ac1              LDRB     r1,[r0,#0xb]
0000f8  07c9              LSLS     r1,r1,#31
0000fa  d10c              BNE      |L9.278|
;;;1530   				ord = 0xFF; dp->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
;;;1531   			}
;;;1532   		}
;;;1533   #else		/* Non LFN configuration */
;;;1534   		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dp->fn, 11)) /* Is it a valid entry? */
;;;1535   			break;
;;;1536   #endif
;;;1537   		res = dir_next(dp, 0);		/* Next entry */
;;;1538   	} while (res == FR_OK);
;;;1539   
;;;1540   	return res;
;;;1541   }
0000fc  210a              MOVS     r1,#0xa
0000fe  e002              B        |L9.262|
                  |L9.256|
000100  e015              B        |L9.302|
                  |L9.258|
000102  1e49              SUBS     r1,r1,#1
000104  d306              BCC      |L9.276|
                  |L9.262|
000106  f8142b01          LDRB     r2,[r4],#1
00010a  f8103b01          LDRB     r3,[r0],#1
00010e  1ad2              SUBS     r2,r2,r3
000110  d0f7              BEQ      |L9.258|
000112  e000              B        |L9.278|
                  |L9.276|
000114  b152              CBZ      r2,|L9.300|
                  |L9.278|
000116  f04f09ff          MOV      r9,#0xff              ;1530
00011a  f8a5a024          STRH     r10,[r5,#0x24]        ;1530
                  |L9.286|
00011e  2100              MOVS     r1,#0                 ;1537
000120  4628              MOV      r0,r5                 ;1537
000122  f7fffffe          BL       dir_next
000126  0006              MOVS     r6,r0                 ;1537
000128  f43faf79          BEQ      |L9.30|
                  |L9.300|
00012c  4630              MOV      r0,r6                 ;1540
                  |L9.302|
00012e  e8bd9ffc          POP      {r2-r12,pc}
;;;1542   
                          ENDP

000132  0000              DCW      0x0000
                  |L9.308|
                          DCD      ||.constdata||

                          AREA ||i.dir_next||, CODE, READONLY, ALIGN=1

                  dir_next PROC
;;;1164   static
;;;1165   FRESULT dir_next (	/* FR_OK:Succeeded, FR_NO_FILE:End of table, FR_DENIED:Could not stretch */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1166   	DIR* dp,		/* Pointer to the directory object */
;;;1167   	int stretch		/* 0: Do not stretch table, 1: Stretch table if needed */
;;;1168   )
;;;1169   {
;;;1170   	DWORD clst;
;;;1171   	UINT i;
;;;1172   
;;;1173   
;;;1174   	i = dp->index + 1;
000004  88c6              LDRH     r6,[r0,#6]
000006  4604              MOV      r4,r0                 ;1169
000008  1c76              ADDS     r6,r6,#1
;;;1175   	if (!(i & 0xFFFF) || !dp->sect)	/* Report EOT when index has reached 65535 */
00000a  0430              LSLS     r0,r6,#16
00000c  460f              MOV      r7,r1                 ;1169
00000e  0c00              LSRS     r0,r0,#16
000010  d02c              BEQ      |L10.108|
000012  6920              LDR      r0,[r4,#0x10]
000014  b350              CBZ      r0,|L10.108|
;;;1176   		return FR_NO_FILE;
;;;1177   
;;;1178   	if (!(i % (SS(dp->fs) / SZ_DIR))) {	/* Sector changed? */
000016  0731              LSLS     r1,r6,#28
000018  d15a              BNE      |L10.208|
00001a  1c40              ADDS     r0,r0,#1
;;;1179   		dp->sect++;					/* Next sector */
;;;1180   
;;;1181   		if (!dp->clust) {		/* Static table */
00001c  6120              STR      r0,[r4,#0x10]
00001e  68e1              LDR      r1,[r4,#0xc]
000020  6820              LDR      r0,[r4,#0]
000022  b129              CBZ      r1,|L10.48|
;;;1182   			if (i >= dp->fs->n_rootdir)	/* Report EOT if it reached end of static table */
;;;1183   				return FR_NO_FILE;
;;;1184   		}
;;;1185   		else {					/* Dynamic table */
;;;1186   			if (((i / (SS(dp->fs) / SZ_DIR)) & (dp->fs->csize - 1)) == 0) {	/* Cluster changed? */
000024  7882              LDRB     r2,[r0,#2]
000026  1e52              SUBS     r2,r2,#1
000028  ea121f16          TST      r2,r6,LSR #4
00002c  d004              BEQ      |L10.56|
00002e  e04f              B        |L10.208|
                  |L10.48|
000030  8900              LDRH     r0,[r0,#8]            ;1182
000032  42b0              CMP      r0,r6                 ;1182
000034  d91a              BLS      |L10.108|
000036  e04b              B        |L10.208|
                  |L10.56|
;;;1187   				clst = get_fat(dp->fs, dp->clust);				/* Get next cluster */
000038  f7fffffe          BL       get_fat
00003c  4605              MOV      r5,r0
;;;1188   				if (clst <= 1) return FR_INT_ERR;
00003e  2801              CMP      r0,#1
000040  d919              BLS      |L10.118|
;;;1189   				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
000042  1c68              ADDS     r0,r5,#1
000044  d030              BEQ      |L10.168|
;;;1190   				if (clst >= dp->fs->n_fatent) {					/* If it reached end of dynamic table, */
000046  6820              LDR      r0,[r4,#0]
000048  6941              LDR      r1,[r0,#0x14]
00004a  42a9              CMP      r1,r5
00004c  d83a              BHI      |L10.196|
;;;1191   #if !_FS_READONLY
;;;1192   					UINT c;
;;;1193   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT */
00004e  b16f              CBZ      r7,|L10.108|
;;;1194   					clst = create_chain(dp->fs, dp->clust);		/* Stretch cluster chain */
000050  68e1              LDR      r1,[r4,#0xc]
000052  f7fffffe          BL       create_chain
000056  0005              MOVS     r5,r0
;;;1195   					if (clst == 0) return FR_DENIED;			/* No free cluster */
000058  d00b              BEQ      |L10.114|
;;;1196   					if (clst == 1) return FR_INT_ERR;
00005a  2d01              CMP      r5,#1
00005c  d00b              BEQ      |L10.118|
;;;1197   					if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
00005e  1c68              ADDS     r0,r5,#1
000060  d022              BEQ      |L10.168|
;;;1198   					/* Clean-up stretched table */
;;;1199   					if (sync_window(dp->fs)) return FR_DISK_ERR;/* Flush disk access window */
000062  6820              LDR      r0,[r4,#0]
000064  f7fffffe          BL       sync_window
000068  b9f0              CBNZ     r0,|L10.168|
00006a  e006              B        |L10.122|
                  |L10.108|
00006c  2004              MOVS     r0,#4                 ;1193
                  |L10.110|
;;;1200   					mem_set(dp->fs->win, 0, SS(dp->fs));		/* Clear window buffer */
;;;1201   					dp->fs->winsect = clust2sect(dp->fs, clst);	/* Cluster start sector */
;;;1202   					for (c = 0; c < dp->fs->csize; c++) {		/* Fill the new cluster with 0 */
;;;1203   						dp->fs->wflag = 1;
;;;1204   						if (sync_window(dp->fs)) return FR_DISK_ERR;
;;;1205   						dp->fs->winsect++;
;;;1206   					}
;;;1207   					dp->fs->winsect -= c;						/* Rewind window offset */
;;;1208   #else
;;;1209   					if (!stretch) return FR_NO_FILE;			/* If do not stretch, report EOT (this is to suppress warning) */
;;;1210   					return FR_NO_FILE;							/* Report EOT */
;;;1211   #endif
;;;1212   				}
;;;1213   				dp->clust = clst;				/* Initialize data for new cluster */
;;;1214   				dp->sect = clust2sect(dp->fs, clst);
;;;1215   			}
;;;1216   		}
;;;1217   	}
;;;1218   
;;;1219   	dp->index = (WORD)i;	/* Current index */
;;;1220   	dp->dir = dp->fs->win + (i % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Current entry in the window */
;;;1221   
;;;1222   	return FR_OK;
;;;1223   }
00006e  e8bd81f0          POP      {r4-r8,pc}
                  |L10.114|
000072  2007              MOVS     r0,#7                 ;1195
000074  e7fb              B        |L10.110|
                  |L10.118|
000076  2002              MOVS     r0,#2                 ;1196
000078  e7f9              B        |L10.110|
                  |L10.122|
00007a  6820              LDR      r0,[r4,#0]            ;1200
00007c  f44f7200          MOV      r2,#0x200             ;1200
000080  2100              MOVS     r1,#0                 ;1200
000082  3030              ADDS     r0,r0,#0x30           ;1200
000084  f7fffffe          BL       mem_set
000088  4629              MOV      r1,r5                 ;1201
00008a  6820              LDR      r0,[r4,#0]            ;1201
00008c  f7fffffe          BL       clust2sect
000090  6821              LDR      r1,[r4,#0]            ;1201
000092  2700              MOVS     r7,#0                 ;1202
000094  f04f0801          MOV      r8,#1                 ;1189
000098  62c8              STR      r0,[r1,#0x2c]         ;1202
00009a  e00c              B        |L10.182|
                  |L10.156|
00009c  f8808004          STRB     r8,[r0,#4]            ;1203
0000a0  6820              LDR      r0,[r4,#0]            ;1204
0000a2  f7fffffe          BL       sync_window
0000a6  b108              CBZ      r0,|L10.172|
                  |L10.168|
0000a8  2001              MOVS     r0,#1                 ;1204
0000aa  e7e0              B        |L10.110|
                  |L10.172|
0000ac  6820              LDR      r0,[r4,#0]            ;1205
0000ae  6ac1              LDR      r1,[r0,#0x2c]         ;1205
0000b0  1c49              ADDS     r1,r1,#1              ;1205
0000b2  1c7f              ADDS     r7,r7,#1              ;1205
0000b4  62c1              STR      r1,[r0,#0x2c]         ;1205
                  |L10.182|
0000b6  6820              LDR      r0,[r4,#0]            ;1202
0000b8  7881              LDRB     r1,[r0,#2]            ;1202
0000ba  42b9              CMP      r1,r7                 ;1202
0000bc  d8ee              BHI      |L10.156|
0000be  6ac1              LDR      r1,[r0,#0x2c]         ;1207
0000c0  1bc9              SUBS     r1,r1,r7              ;1207
0000c2  62c1              STR      r1,[r0,#0x2c]         ;1207
                  |L10.196|
0000c4  60e5              STR      r5,[r4,#0xc]          ;1214
0000c6  4629              MOV      r1,r5                 ;1214
0000c8  6820              LDR      r0,[r4,#0]            ;1214
0000ca  f7fffffe          BL       clust2sect
0000ce  6120              STR      r0,[r4,#0x10]         ;1214
                  |L10.208|
0000d0  80e6              STRH     r6,[r4,#6]            ;1219
0000d2  f006010f          AND      r1,r6,#0xf            ;1220
0000d6  2230              MOVS     r2,#0x30              ;1220
0000d8  6820              LDR      r0,[r4,#0]            ;1220
0000da  eb021141          ADD      r1,r2,r1,LSL #5       ;1220
0000de  4408              ADD      r0,r0,r1              ;1220
0000e0  6160              STR      r0,[r4,#0x14]         ;1222
0000e2  2000              MOVS     r0,#0                 ;1222
0000e4  e7c3              B        |L10.110|
;;;1224   
                          ENDP


                          AREA ||i.dir_read||, CODE, READONLY, ALIGN=2

                  dir_read PROC
;;;1550   static
;;;1551   FRESULT dir_read (
000000  e92d5ff0          PUSH     {r4-r12,lr}
;;;1552   	DIR* dp,		/* Pointer to the directory object */
;;;1553   	int vol			/* Filtered by 0:file/directory or 1:volume label */
;;;1554   )
;;;1555   {
;;;1556   	FRESULT res;
;;;1557   	BYTE a, c, *dir;
;;;1558   #if _USE_LFN
;;;1559   	BYTE ord = 0xFF, sum = 0xFF;
000004  24ff              MOVS     r4,#0xff
000006  468b              MOV      r11,r1                ;1555
000008  4605              MOV      r5,r0                 ;1555
00000a  4627              MOV      r7,r4
;;;1560   #endif
;;;1561   
;;;1562   	res = FR_NO_FILE;
00000c  2604              MOVS     r6,#4
00000e  f64f78ff          MOV      r8,#0xffff
000012  f04f0900          MOV      r9,#0
000016  e064              B        |L11.226|
                  |L11.24|
;;;1563   	while (dp->sect) {
;;;1564   		res = move_window(dp->fs, dp->sect);
000018  6828              LDR      r0,[r5,#0]
00001a  f7fffffe          BL       move_window
00001e  0006              MOVS     r6,r0
;;;1565   		if (res != FR_OK) break;
000020  d163              BNE      |L11.234|
;;;1566   		dir = dp->dir;					/* Ptr to the directory entry of current index */
;;;1567   		c = dir[DIR_Name];
000022  6968              LDR      r0,[r5,#0x14]
000024  7801              LDRB     r1,[r0,#0]
;;;1568   		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
000026  b169              CBZ      r1,|L11.68|
;;;1569   		a = dir[DIR_Attr] & AM_MASK;
000028  7ac2              LDRB     r2,[r0,#0xb]
;;;1570   #if _USE_LFN	/* LFN configuration */
;;;1571   		if (c == DDE || (!_FS_RPATH && c == '.') || (int)(a == AM_VOL) != vol) {	/* An entry without valid data */
00002a  29e5              CMP      r1,#0xe5
00002c  f002023f          AND      r2,r2,#0x3f           ;1569
000030  d006              BEQ      |L11.64|
000032  292e              CMP      r1,#0x2e
000034  d004              BEQ      |L11.64|
000036  2a08              CMP      r2,#8
000038  d006              BEQ      |L11.72|
00003a  46b4              MOV      r12,r6
                  |L11.60|
00003c  45dc              CMP      r12,r11
00003e  d006              BEQ      |L11.78|
                  |L11.64|
;;;1572   			ord = 0xFF;
000040  24ff              MOVS     r4,#0xff
000042  e040              B        |L11.198|
                  |L11.68|
000044  2604              MOVS     r6,#4                 ;1568
000046  e050              B        |L11.234|
                  |L11.72|
000048  f04f0c01          MOV      r12,#1                ;1571
00004c  e7f6              B        |L11.60|
                  |L11.78|
;;;1573   		} else {
;;;1574   			if (a == AM_LFN) {			/* An LFN entry is found */
00004e  2a0f              CMP      r2,#0xf
000050  d001              BEQ      |L11.86|
;;;1575   				if (c & LLE) {			/* Is it start of LFN sequence? */
;;;1576   					sum = dir[LDIR_Chksum];
;;;1577   					c &= ~LLE; ord = c;
;;;1578   					dp->lfn_idx = dp->index;
;;;1579   				}
;;;1580   				/* Check LFN validity and capture it */
;;;1581   				ord = (c == ord && sum == dir[LDIR_Chksum] && pick_lfn(dp->lfn, dir)) ? ord - 1 : 0xFF;
;;;1582   			} else {					/* An SFN entry is found */
;;;1583   				if (ord || sum != sum_sfn(dir))	/* Is there a valid LFN? */
000052  bbac              CBNZ     r4,|L11.192|
000054  e03e              B        |L11.212|
                  |L11.86|
000056  064a              LSLS     r2,r1,#25             ;1575
000058  d505              BPL      |L11.102|
00005a  7b47              LDRB     r7,[r0,#0xd]          ;1576
00005c  f0210140          BIC      r1,r1,#0x40           ;1577
000060  88ea              LDRH     r2,[r5,#6]            ;1578
000062  460c              MOV      r4,r1                 ;1577
000064  84aa              STRH     r2,[r5,#0x24]         ;1578
                  |L11.102|
000066  42a1              CMP      r1,r4                 ;1581
000068  d12b              BNE      |L11.194|
00006a  7b41              LDRB     r1,[r0,#0xd]          ;1581
00006c  42b9              CMP      r1,r7                 ;1581
00006e  d128              BNE      |L11.194|
000070  7801              LDRB     r1,[r0,#0]            ;1581
000072  f8dfa080          LDR      r10,|L11.244|
000076  f001013f          AND      r1,r1,#0x3f           ;1581
00007a  1e49              SUBS     r1,r1,#1              ;1581
00007c  eb010281          ADD      r2,r1,r1,LSL #2       ;1581
000080  eb0201c1          ADD      r1,r2,r1,LSL #3       ;1581
000084  2200              MOVS     r2,#0                 ;1581
000086  f8d5c020          LDR      r12,[r5,#0x20]        ;1581
00008a  2601              MOVS     r6,#1                 ;1581
                  |L11.140|
00008c  f81a3002          LDRB     r3,[r10,r2]           ;1581
000090  4403              ADD      r3,r3,r0              ;1581
000092  881b              LDRH     r3,[r3,#0]            ;1581
000094  b136              CBZ      r6,|L11.164|
000096  29ff              CMP      r1,#0xff              ;1581
000098  d213              BCS      |L11.194|
00009a  f82c3011          STRH     r3,[r12,r1,LSL #1]    ;1581
00009e  461e              MOV      r6,r3                 ;1581
0000a0  1c49              ADDS     r1,r1,#1              ;1581
0000a2  e001              B        |L11.168|
                  |L11.164|
0000a4  4543              CMP      r3,r8                 ;1581
0000a6  d10c              BNE      |L11.194|
                  |L11.168|
0000a8  1c52              ADDS     r2,r2,#1              ;1581
0000aa  2a0d              CMP      r2,#0xd               ;1581
0000ac  d3ee              BCC      |L11.140|
0000ae  7800              LDRB     r0,[r0,#0]            ;1581
0000b0  0640              LSLS     r0,r0,#25             ;1581
0000b2  d503              BPL      |L11.188|
0000b4  29ff              CMP      r1,#0xff              ;1581
0000b6  d204              BCS      |L11.194|
0000b8  f82c9011          STRH     r9,[r12,r1,LSL #1]    ;1581
                  |L11.188|
0000bc  1e64              SUBS     r4,r4,#1              ;1581
0000be  e001              B        |L11.196|
                  |L11.192|
0000c0  e00c              B        |L11.220|
                  |L11.194|
0000c2  24ff              MOVS     r4,#0xff              ;1581
                  |L11.196|
0000c4  b2e4              UXTB     r4,r4                 ;1581
                  |L11.198|
;;;1584   					dp->lfn_idx = 0xFFFF;		/* It has no LFN. */
;;;1585   				break;
;;;1586   			}
;;;1587   		}
;;;1588   #else		/* Non LFN configuration */
;;;1589   		if (c != DDE && (_FS_RPATH || c != '.') && a != AM_LFN && (int)(a == AM_VOL) == vol)	/* Is it a valid entry? */
;;;1590   			break;
;;;1591   #endif
;;;1592   		res = dir_next(dp, 0);				/* Next entry */
0000c6  2100              MOVS     r1,#0
0000c8  4628              MOV      r0,r5
0000ca  f7fffffe          BL       dir_next
0000ce  0006              MOVS     r6,r0
;;;1593   		if (res != FR_OK) break;
0000d0  d007              BEQ      |L11.226|
0000d2  e00a              B        |L11.234|
                  |L11.212|
0000d4  f7fffffe          BL       sum_sfn
0000d8  42b8              CMP      r0,r7                 ;1583
0000da  d008              BEQ      |L11.238|
                  |L11.220|
0000dc  f8a58024          STRH     r8,[r5,#0x24]         ;1584
0000e0  e005              B        |L11.238|
                  |L11.226|
0000e2  6929              LDR      r1,[r5,#0x10]         ;1563
0000e4  2900              CMP      r1,#0                 ;1563
0000e6  d197              BNE      |L11.24|
;;;1594   	}
;;;1595   
;;;1596   	if (res != FR_OK) dp->sect = 0;
0000e8  b10e              CBZ      r6,|L11.238|
                  |L11.234|
0000ea  f8c59010          STR      r9,[r5,#0x10]
                  |L11.238|
;;;1597   
;;;1598   	return res;
0000ee  4630              MOV      r0,r6
;;;1599   }
0000f0  e8bd9ff0          POP      {r4-r12,pc}
;;;1600   #endif	/* _FS_MINIMIZE <= 1 || _USE_LABEL || _FS_RPATH >= 2 */
                          ENDP

                  |L11.244|
                          DCD      ||.constdata||

                          AREA ||i.dir_register||, CODE, READONLY, ALIGN=2

                  dir_register PROC
;;;1609   static
;;;1610   FRESULT dir_register (	/* FR_OK:Successful, FR_DENIED:No free entry or too many SFN collision, FR_DISK_ERR:Disk error */
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1611   	DIR* dp				/* Target directory with object name to be created */
;;;1612   )
;;;1613   {
;;;1614   	FRESULT res;
;;;1615   #if _USE_LFN	/* LFN configuration */
;;;1616   	UINT n, nent;
;;;1617   	BYTE sn[12], *fn, sum;
;;;1618   	WCHAR *lfn;
;;;1619   
;;;1620   
;;;1621   	fn = dp->fn; lfn = dp->lfn;
;;;1622   	mem_cpy(sn, fn, 12);
000004  6987              LDR      r7,[r0,#0x18]
000006  4604              MOV      r4,r0                 ;1613
000008  6a06              LDR      r6,[r0,#0x20]
00000a  220c              MOVS     r2,#0xc
00000c  4639              MOV      r1,r7
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       mem_cpy
;;;1623   
;;;1624   	if (_FS_RPATH && (sn[NS] & NS_DOT))		/* Cannot create dot entry */
;;;1625   		return FR_INVALID_NAME;
;;;1626   
;;;1627   	if (sn[NS] & NS_LOSS) {			/* When LFN is out of 8.3 format, generate a numbered name */
000014  f89d000b          LDRB     r0,[sp,#0xb]
000018  07c0              LSLS     r0,r0,#31
00001a  d018              BEQ      |L12.78|
;;;1628   		fn[NS] = 0; dp->lfn = 0;			/* Find only SFN */
00001c  2000              MOVS     r0,#0
00001e  72f8              STRB     r0,[r7,#0xb]
;;;1629   		for (n = 1; n < 100; n++) {
000020  2501              MOVS     r5,#1
000022  6220              STR      r0,[r4,#0x20]
                  |L12.36|
;;;1630   			gen_numname(fn, sn, lfn, n);	/* Generate a numbered name */
000024  462b              MOV      r3,r5
000026  4632              MOV      r2,r6
000028  4669              MOV      r1,sp
00002a  4638              MOV      r0,r7
00002c  f7fffffe          BL       gen_numname
;;;1631   			res = dir_find(dp);				/* Check if the name collides with existing SFN */
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       dir_find
;;;1632   			if (res != FR_OK) break;
000036  b910              CBNZ     r0,|L12.62|
000038  1c6d              ADDS     r5,r5,#1
00003a  2d64              CMP      r5,#0x64              ;1629
00003c  d3f2              BCC      |L12.36|
                  |L12.62|
;;;1633   		}
;;;1634   		if (n == 100) return FR_DENIED;		/* Abort if too many collisions */
00003e  2d64              CMP      r5,#0x64
000040  d00b              BEQ      |L12.90|
;;;1635   		if (res != FR_NO_FILE) return res;	/* Abort if the result is other than 'not collided' */
000042  2804              CMP      r0,#4
000044  d10a              BNE      |L12.92|
;;;1636   		fn[NS] = sn[NS]; dp->lfn = lfn;
000046  f89d000b          LDRB     r0,[sp,#0xb]
00004a  72f8              STRB     r0,[r7,#0xb]
00004c  6226              STR      r6,[r4,#0x20]
                  |L12.78|
;;;1637   	}
;;;1638   
;;;1639   	if (sn[NS] & NS_LFN) {			/* When LFN is to be created, allocate entries for an SFN + LFNs. */
00004e  f89d000b          LDRB     r0,[sp,#0xb]
000052  0780              LSLS     r0,r0,#30
000054  d50f              BPL      |L12.118|
;;;1640   		for (n = 0; lfn[n]; n++) ;
000056  2000              MOVS     r0,#0
000058  e004              B        |L12.100|
                  |L12.90|
00005a  2007              MOVS     r0,#7                 ;1634
                  |L12.92|
;;;1641   		nent = (n + 25) / 13;
;;;1642   	} else {						/* Otherwise allocate an entry for an SFN  */
;;;1643   		nent = 1;
;;;1644   	}
;;;1645   	res = dir_alloc(dp, nent);		/* Allocate entries */
;;;1646   
;;;1647   	if (res == FR_OK && --nent) {	/* Set LFN entry if needed */
;;;1648   		res = dir_sdi(dp, dp->index - nent);
;;;1649   		if (res == FR_OK) {
;;;1650   			sum = sum_sfn(dp->fn);	/* Sum value of the SFN tied to the LFN */
;;;1651   			do {					/* Store LFN entries in bottom first */
;;;1652   				res = move_window(dp->fs, dp->sect);
;;;1653   				if (res != FR_OK) break;
;;;1654   				fit_lfn(dp->lfn, dp->dir, (BYTE)nent, sum);
;;;1655   				dp->fs->wflag = 1;
;;;1656   				res = dir_next(dp, 0);	/* Next entry */
;;;1657   			} while (res == FR_OK && --nent);
;;;1658   		}
;;;1659   	}
;;;1660   #else	/* Non LFN configuration */
;;;1661   	res = dir_alloc(dp, 1);		/* Allocate an entry for SFN */
;;;1662   #endif
;;;1663   
;;;1664   	if (res == FR_OK) {				/* Set SFN entry */
;;;1665   		res = move_window(dp->fs, dp->sect);
;;;1666   		if (res == FR_OK) {
;;;1667   			mem_set(dp->dir, 0, SZ_DIR);	/* Clean the entry */
;;;1668   			mem_cpy(dp->dir, dp->fn, 11);	/* Put SFN */
;;;1669   #if _USE_LFN
;;;1670   			dp->dir[DIR_NTres] = dp->fn[NS] & (NS_BODY | NS_EXT);	/* Put NT flag */
;;;1671   #endif
;;;1672   			dp->fs->wflag = 1;
;;;1673   		}
;;;1674   	}
;;;1675   
;;;1676   	return res;
;;;1677   }
00005c  b004              ADD      sp,sp,#0x10
00005e  e8bd9ff0          POP      {r4-r12,pc}
                  |L12.98|
000062  1c40              ADDS     r0,r0,#1
                  |L12.100|
000064  f8361010          LDRH     r1,[r6,r0,LSL #1]     ;1640
000068  2900              CMP      r1,#0                 ;1640
00006a  d1fa              BNE      |L12.98|
00006c  210d              MOVS     r1,#0xd               ;1641
00006e  3019              ADDS     r0,r0,#0x19           ;1641
000070  fbb0f6f1          UDIV     r6,r0,r1              ;1641
000074  e000              B        |L12.120|
                  |L12.118|
000076  2601              MOVS     r6,#1                 ;1643
                  |L12.120|
000078  2100              MOVS     r1,#0                 ;1643
00007a  4620              MOV      r0,r4                 ;1643
00007c  f7fffffe          BL       dir_sdi
000080  b988              CBNZ     r0,|L12.166|
000082  2700              MOVS     r7,#0                 ;1643
                  |L12.132|
000084  6921              LDR      r1,[r4,#0x10]         ;1643
000086  6820              LDR      r0,[r4,#0]            ;1643
000088  f7fffffe          BL       move_window
00008c  b958              CBNZ     r0,|L12.166|
00008e  6960              LDR      r0,[r4,#0x14]         ;1643
000090  7800              LDRB     r0,[r0,#0]            ;1643
000092  28e5              CMP      r0,#0xe5              ;1643
000094  d00a              BEQ      |L12.172|
000096  b148              CBZ      r0,|L12.172|
000098  2700              MOVS     r7,#0                 ;1643
                  |L12.154|
00009a  2101              MOVS     r1,#1                 ;1643
00009c  4620              MOV      r0,r4                 ;1643
00009e  f7fffffe          BL       dir_next
0000a2  2800              CMP      r0,#0                 ;1643
0000a4  d0ee              BEQ      |L12.132|
                  |L12.166|
0000a6  2804              CMP      r0,#4                 ;1643
0000a8  d011              BEQ      |L12.206|
0000aa  e011              B        |L12.208|
                  |L12.172|
0000ac  1c7f              ADDS     r7,r7,#1              ;1643
0000ae  4630              MOV      r0,r6                 ;1643
0000b0  42b7              CMP      r7,r6                 ;1643
0000b2  d1f2              BNE      |L12.154|
0000b4  1e46              SUBS     r6,r0,#1              ;1647
0000b6  ea5f0a06          MOVS     r10,r6                ;1647
0000ba  d057              BEQ      |L12.364|
0000bc  88e1              LDRH     r1,[r4,#6]            ;1648
0000be  4620              MOV      r0,r4                 ;1648
0000c0  eba1010a          SUB      r1,r1,r10             ;1648
0000c4  f7fffffe          BL       dir_sdi
0000c8  0005              MOVS     r5,r0                 ;1648
0000ca  d003              BEQ      |L12.212|
0000cc  e067              B        |L12.414|
                  |L12.206|
0000ce  2007              MOVS     r0,#7                 ;1649
                  |L12.208|
0000d0  4605              MOV      r5,r0                 ;1645
0000d2  e064              B        |L12.414|
                  |L12.212|
0000d4  69a0              LDR      r0,[r4,#0x18]         ;1650
0000d6  f7fffffe          BL       sum_sfn
0000da  9003              STR      r0,[sp,#0xc]          ;1650
                  |L12.220|
0000dc  6921              LDR      r1,[r4,#0x10]         ;1652
0000de  6820              LDR      r0,[r4,#0]            ;1652
0000e0  f7fffffe          BL       move_window
0000e4  0005              MOVS     r5,r0                 ;1652
0000e6  d15a              BNE      |L12.414|
0000e8  6961              LDR      r1,[r4,#0x14]         ;1654
0000ea  f8d49020          LDR      r9,[r4,#0x20]         ;1654
0000ee  9803              LDR      r0,[sp,#0xc]          ;1654
0000f0  7348              STRB     r0,[r1,#0xd]          ;1654
0000f2  200f              MOVS     r0,#0xf               ;1654
0000f4  72c8              STRB     r0,[r1,#0xb]          ;1654
0000f6  2000              MOVS     r0,#0                 ;1654
0000f8  7308              STRB     r0,[r1,#0xc]          ;1654
0000fa  7688              STRB     r0,[r1,#0x1a]         ;1654
0000fc  f00a0bff          AND      r11,r10,#0xff         ;1654
000100  76c8              STRB     r0,[r1,#0x1b]         ;1654
000102  f1ab0001          SUB      r0,r11,#1             ;1654
000106  eb000280          ADD      r2,r0,r0,LSL #2       ;1654
00010a  eb0205c0          ADD      r5,r2,r0,LSL #3       ;1654
00010e  2300              MOVS     r3,#0                 ;1654
000110  f64f7eff          MOV      lr,#0xffff            ;1654
000114  4e23              LDR      r6,|L12.420|
000116  1c4a              ADDS     r2,r1,#1              ;1654
000118  e001              B        |L12.286|
                  |L12.282|
00011a  4560              CMP      r0,r12                ;1654
00011c  d003              BEQ      |L12.294|
                  |L12.286|
00011e  f8390015          LDRH     r0,[r9,r5,LSL #1]     ;1654
000122  46f4              MOV      r12,lr                ;1654
000124  1c6d              ADDS     r5,r5,#1              ;1654
                  |L12.294|
000126  5cf7              LDRB     r7,[r6,r3]            ;1654
000128  55c8              STRB     r0,[r1,r7]            ;1654
00012a  f8168003          LDRB     r8,[r6,r3]            ;1654
00012e  0a07              LSRS     r7,r0,#8              ;1654
000130  f8087002          STRB     r7,[r8,r2]            ;1654
000134  b900              CBNZ     r0,|L12.312|
000136  4660              MOV      r0,r12                ;1654
                  |L12.312|
000138  1c5b              ADDS     r3,r3,#1              ;1654
00013a  2b0d              CMP      r3,#0xd               ;1654
00013c  d3ed              BCC      |L12.282|
00013e  4570              CMP      r0,lr                 ;1654
000140  d002              BEQ      |L12.328|
000142  f8390015          LDRH     r0,[r9,r5,LSL #1]     ;1654
000146  b908              CBNZ     r0,|L12.332|
                  |L12.328|
000148  f04b0b40          ORR      r11,r11,#0x40         ;1654
                  |L12.332|
00014c  f881b000          STRB     r11,[r1,#0]           ;1654
000150  6821              LDR      r1,[r4,#0]            ;1655
000152  2001              MOVS     r0,#1                 ;1655
000154  7108              STRB     r0,[r1,#4]            ;1655
000156  2100              MOVS     r1,#0                 ;1656
000158  4620              MOV      r0,r4                 ;1656
00015a  f7fffffe          BL       dir_next
00015e  0005              MOVS     r5,r0                 ;1656
000160  d11d              BNE      |L12.414|
000162  f1aa0001          SUB      r0,r10,#1             ;1657
000166  ea5f0a00          MOVS     r10,r0                ;1657
00016a  d1b7              BNE      |L12.220|
                  |L12.364|
00016c  6921              LDR      r1,[r4,#0x10]         ;1665
00016e  6820              LDR      r0,[r4,#0]            ;1665
000170  f7fffffe          BL       move_window
000174  0005              MOVS     r5,r0                 ;1665
000176  d112              BNE      |L12.414|
000178  2220              MOVS     r2,#0x20              ;1667
00017a  2100              MOVS     r1,#0                 ;1667
00017c  6960              LDR      r0,[r4,#0x14]         ;1667
00017e  f7fffffe          BL       mem_set
000182  e9d40105          LDRD     r0,r1,[r4,#0x14]      ;1668
000186  220b              MOVS     r2,#0xb               ;1668
000188  f7fffffe          BL       mem_cpy
00018c  69a0              LDR      r0,[r4,#0x18]         ;1670
00018e  6961              LDR      r1,[r4,#0x14]         ;1670
000190  7ac0              LDRB     r0,[r0,#0xb]          ;1670
000192  f0000018          AND      r0,r0,#0x18           ;1670
000196  7308              STRB     r0,[r1,#0xc]          ;1670
000198  6821              LDR      r1,[r4,#0]            ;1672
00019a  2001              MOVS     r0,#1                 ;1672
00019c  7108              STRB     r0,[r1,#4]            ;1672
                  |L12.414|
00019e  4628              MOV      r0,r5                 ;1676
0001a0  e75c              B        |L12.92|
;;;1678   #endif /* !_FS_READONLY */
                          ENDP

0001a2  0000              DCW      0x0000
                  |L12.420|
                          DCD      ||.constdata||

                          AREA ||i.dir_remove||, CODE, READONLY, ALIGN=1

                  dir_remove PROC
;;;1687   static
;;;1688   FRESULT dir_remove (	/* FR_OK: Successful, FR_DISK_ERR: A disk error */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1689   	DIR* dp				/* Directory object pointing the entry to be removed */
;;;1690   )
;;;1691   {
;;;1692   	FRESULT res;
;;;1693   #if _USE_LFN	/* LFN configuration */
;;;1694   	UINT i;
;;;1695   
;;;1696   	i = dp->index;	/* SFN index */
;;;1697   	res = dir_sdi(dp, (dp->lfn_idx == 0xFFFF) ? i : dp->lfn_idx);	/* Goto the SFN or top of the LFN entries */
000004  8c81              LDRH     r1,[r0,#0x24]
000006  4604              MOV      r4,r0                 ;1691
000008  88c6              LDRH     r6,[r0,#6]            ;1696
00000a  f5a1407f          SUB      r0,r1,#0xff00
00000e  38ff              SUBS     r0,r0,#0xff
000010  d100              BNE      |L13.20|
000012  4631              MOV      r1,r6
                  |L13.20|
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       dir_sdi
00001a  0005              MOVS     r5,r0
;;;1698   	if (res == FR_OK) {
00001c  d11e              BNE      |L13.92|
;;;1699   		do {
;;;1700   			res = move_window(dp->fs, dp->sect);
;;;1701   			if (res != FR_OK) break;
;;;1702   			mem_set(dp->dir, 0, SZ_DIR);	/* Clear and mark the entry "deleted" */
;;;1703   			*dp->dir = DDE;
00001e  27e5              MOVS     r7,#0xe5
;;;1704   			dp->fs->wflag = 1;
000020  f04f0801          MOV      r8,#1
                  |L13.36|
000024  6921              LDR      r1,[r4,#0x10]         ;1700
000026  6820              LDR      r0,[r4,#0]            ;1700
000028  f7fffffe          BL       move_window
00002c  0005              MOVS     r5,r0                 ;1700
00002e  d112              BNE      |L13.86|
000030  2220              MOVS     r2,#0x20              ;1702
000032  2100              MOVS     r1,#0                 ;1702
000034  6960              LDR      r0,[r4,#0x14]         ;1702
000036  f7fffffe          BL       mem_set
00003a  6960              LDR      r0,[r4,#0x14]         ;1703
00003c  7007              STRB     r7,[r0,#0]            ;1703
00003e  6821              LDR      r1,[r4,#0]
000040  f8818004          STRB     r8,[r1,#4]
;;;1705   			if (dp->index >= i) break;	/* When reached SFN, all entries of the object has been deleted. */
000044  88e0              LDRH     r0,[r4,#6]
000046  42b0              CMP      r0,r6
000048  d208              BCS      |L13.92|
;;;1706   			res = dir_next(dp, 0);		/* Next entry */
00004a  2100              MOVS     r1,#0
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       dir_next
000052  0005              MOVS     r5,r0
;;;1707   		} while (res == FR_OK);
000054  d0e6              BEQ      |L13.36|
                  |L13.86|
;;;1708   		if (res == FR_NO_FILE) res = FR_INT_ERR;
000056  2d04              CMP      r5,#4
000058  d100              BNE      |L13.92|
00005a  2502              MOVS     r5,#2
                  |L13.92|
;;;1709   	}
;;;1710   
;;;1711   #else			/* Non LFN configuration */
;;;1712   	res = dir_sdi(dp, dp->index);
;;;1713   	if (res == FR_OK) {
;;;1714   		res = move_window(dp->fs, dp->sect);
;;;1715   		if (res == FR_OK) {
;;;1716   			mem_set(dp->dir, 0, SZ_DIR);	/* Clear and mark the entry "deleted" */
;;;1717   			*dp->dir = DDE;
;;;1718   			dp->fs->wflag = 1;
;;;1719   		}
;;;1720   	}
;;;1721   #endif
;;;1722   
;;;1723   	return res;
00005c  4628              MOV      r0,r5
;;;1724   }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;1725   #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.dir_sdi||, CODE, READONLY, ALIGN=2

                  dir_sdi PROC
;;;1116   static
;;;1117   FRESULT dir_sdi (
000000  b570              PUSH     {r4-r6,lr}
;;;1118   	DIR* dp,		/* Pointer to directory object */
;;;1119   	UINT idx		/* Index of directory table */
;;;1120   )
;;;1121   {
;;;1122   	DWORD clst, sect;
;;;1123   	UINT ic;
;;;1124   
;;;1125   
;;;1126   	dp->index = (WORD)idx;	/* Current index */
000002  80c1              STRH     r1,[r0,#6]
;;;1127   	clst = dp->sclust;		/* Table start cluster (0:root) */
;;;1128   	if (clst == 1 || clst >= dp->fs->n_fatent)	/* Check start cluster range */
000004  6883              LDR      r3,[r0,#8]
000006  460d              MOV      r5,r1                 ;1121
000008  4604              MOV      r4,r0                 ;1121
00000a  2b01              CMP      r3,#1
00000c  d035              BEQ      |L14.122|
00000e  6820              LDR      r0,[r4,#0]
000010  6941              LDR      r1,[r0,#0x14]
000012  4299              CMP      r1,r3
000014  d931              BLS      |L14.122|
;;;1129   		return FR_INT_ERR;
;;;1130   	if (!clst && dp->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
000016  b923              CBNZ     r3,|L14.34|
000018  7801              LDRB     r1,[r0,#0]
00001a  2903              CMP      r1,#3
00001c  d104              BNE      |L14.40|
;;;1131   		clst = dp->fs->dirbase;
00001e  6a43              LDR      r3,[r0,#0x24]
000020  b113              CBZ      r3,|L14.40|
                  |L14.34|
;;;1132   
;;;1133   	if (clst == 0) {	/* Static table (root-directory in FAT12/16) */
;;;1134   		if (idx >= dp->fs->n_rootdir)	/* Is index out of range? */
;;;1135   			return FR_INT_ERR;
;;;1136   		sect = dp->fs->dirbase;
;;;1137   	}
;;;1138   	else {				/* Dynamic table (root-directory in FAT32 or sub-directory) */
;;;1139   		ic = SS(dp->fs) / SZ_DIR * dp->fs->csize;	/* Entries per cluster */
000022  7880              LDRB     r0,[r0,#2]
000024  0106              LSLS     r6,r0,#4
;;;1140   		while (idx >= ic) {	/* Follow cluster chain */
000026  e011              B        |L14.76|
                  |L14.40|
000028  8901              LDRH     r1,[r0,#8]            ;1134
00002a  42a9              CMP      r1,r5                 ;1134
00002c  d925              BLS      |L14.122|
00002e  6a40              LDR      r0,[r0,#0x24]         ;1136
000030  e012              B        |L14.88|
;;;1141   			clst = get_fat(dp->fs, clst);				/* Get next cluster */
000032  bf00              NOP      
                  |L14.52|
000034  f7fffffe          BL       get_fat
000038  4603              MOV      r3,r0
;;;1142   			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
00003a  1c40              ADDS     r0,r0,#1
00003c  d01b              BEQ      |L14.118|
;;;1143   			if (clst < 2 || clst >= dp->fs->n_fatent)	/* Reached to end of table or internal error */
00003e  2b02              CMP      r3,#2
000040  d31b              BCC      |L14.122|
000042  6820              LDR      r0,[r4,#0]
000044  6940              LDR      r0,[r0,#0x14]
000046  4298              CMP      r0,r3
000048  d917              BLS      |L14.122|
;;;1144   				return FR_INT_ERR;
;;;1145   			idx -= ic;
00004a  1bad              SUBS     r5,r5,r6
                  |L14.76|
00004c  6820              LDR      r0,[r4,#0]            ;1140
00004e  42b5              CMP      r5,r6                 ;1140
;;;1146   		}
;;;1147   		sect = clust2sect(dp->fs, clst);
000050  4619              MOV      r1,r3
000052  d2ef              BCS      |L14.52|
000054  f7fffffe          BL       clust2sect
                  |L14.88|
;;;1148   	}
;;;1149   	dp->clust = clst;	/* Current cluster# */
;;;1150   	if (!sect) return FR_INT_ERR;
000058  60e3              STR      r3,[r4,#0xc]
00005a  b170              CBZ      r0,|L14.122|
;;;1151   	dp->sect = sect + idx / (SS(dp->fs) / SZ_DIR);					/* Sector# of the directory entry */
00005c  eb001015          ADD      r0,r0,r5,LSR #4
;;;1152   	dp->dir = dp->fs->win + (idx % (SS(dp->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
000060  6120              STR      r0,[r4,#0x10]
000062  f005010f          AND      r1,r5,#0xf
000066  2230              MOVS     r2,#0x30
000068  6820              LDR      r0,[r4,#0]
00006a  eb021141          ADD      r1,r2,r1,LSL #5
00006e  4408              ADD      r0,r0,r1
;;;1153   
;;;1154   	return FR_OK;
000070  6160              STR      r0,[r4,#0x14]
000072  2000              MOVS     r0,#0
;;;1155   }
000074  bd70              POP      {r4-r6,pc}
                  |L14.118|
000076  2001              MOVS     r0,#1                 ;1142
000078  bd70              POP      {r4-r6,pc}
                  |L14.122|
00007a  2002              MOVS     r0,#2                 ;1150
00007c  bd70              POP      {r4-r6,pc}
;;;1156   
                          ENDP


                          AREA ||i.f_chmod||, CODE, READONLY, ALIGN=1

                  f_chmod PROC
;;;3583   
;;;3584   FRESULT f_chmod (
000000  b537              PUSH     {r0-r2,r4,r5,lr}
;;;3585   	const TCHAR* path,	/* Pointer to the file path */
;;;3586   	BYTE value,			/* Attribute bits */
;;;3587   	BYTE mask			/* Attribute mask to change */
;;;3588   )
;;;3589   {
000002  f5ad7d0e          SUB      sp,sp,#0x238
000006  4615              MOV      r5,r2
000008  460c              MOV      r4,r1
;;;3590   	FRESULT res;
;;;3591   	DIR dj;
;;;3592   	BYTE *dir;
;;;3593   	DEF_NAMEBUF;
;;;3594   
;;;3595   
;;;3596   	/* Get logical drive number */
;;;3597   	res = find_volume(&dj.fs, &path, 1);
00000a  2201              MOVS     r2,#1
00000c  a98e              ADD      r1,sp,#0x238
00000e  a880              ADD      r0,sp,#0x200
000010  f7fffffe          BL       find_volume
;;;3598   	if (res == FR_OK) {
000014  2800              CMP      r0,#0
000016  d118              BNE      |L15.74|
;;;3599   		INIT_BUF(dj);
000018  a88a              ADD      r0,sp,#0x228
00001a  9086              STR      r0,[sp,#0x218]
00001c  f8cdd220          STR      sp,[sp,#0x220]
;;;3600   		res = follow_path(&dj, path);		/* Follow the file path */
000020  a880              ADD      r0,sp,#0x200
000022  998e              LDR      r1,[sp,#0x238]
000024  f7fffffe          BL       follow_path
;;;3601   		FREE_BUF();
;;;3602   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3603   			res = FR_INVALID_NAME;
;;;3604   		if (res == FR_OK) {
000028  2800              CMP      r0,#0
00002a  d10e              BNE      |L15.74|
;;;3605   			dir = dj.dir;
;;;3606   			if (!dir) {						/* Is it a root directory? */
00002c  9885              LDR      r0,[sp,#0x214]
00002e  b178              CBZ      r0,|L15.80|
;;;3607   				res = FR_INVALID_NAME;
;;;3608   			} else {						/* File or sub directory */
;;;3609   				mask &= AM_RDO|AM_HID|AM_SYS|AM_ARC;	/* Valid attribute mask */
000030  f0050127          AND      r1,r5,#0x27
;;;3610   				dir[DIR_Attr] = (value & mask) | (dir[DIR_Attr] & (BYTE)~mask);	/* Apply attribute change */
000034  7ac2              LDRB     r2,[r0,#0xb]
000036  400c              ANDS     r4,r4,r1
000038  438a              BICS     r2,r2,r1
00003a  4314              ORRS     r4,r4,r2
00003c  72c4              STRB     r4,[r0,#0xb]
;;;3611   				dj.fs->wflag = 1;
00003e  9980              LDR      r1,[sp,#0x200]
000040  2001              MOVS     r0,#1
000042  7108              STRB     r0,[r1,#4]
;;;3612   				res = sync_fs(dj.fs);
000044  9880              LDR      r0,[sp,#0x200]
000046  f7fffffe          BL       sync_fs
                  |L15.74|
;;;3613   			}
;;;3614   		}
;;;3615   	}
;;;3616   
;;;3617   	LEAVE_FF(dj.fs, res);
;;;3618   }
00004a  f50d7d11          ADD      sp,sp,#0x244
00004e  bd30              POP      {r4,r5,pc}
                  |L15.80|
000050  2006              MOVS     r0,#6                 ;3607
000052  e7fa              B        |L15.74|
;;;3619   
                          ENDP


                          AREA ||i.f_close||, CODE, READONLY, ALIGN=1

                  f_close PROC
;;;2821   
;;;2822   FRESULT f_close (
000000  b510              PUSH     {r4,lr}
;;;2823   	FIL *fp		/* Pointer to the file object to be closed */
;;;2824   )
;;;2825   {
000002  4604              MOV      r4,r0
;;;2826   	FRESULT res;
;;;2827   
;;;2828   
;;;2829   #if !_FS_READONLY
;;;2830   	res = f_sync(fp);					/* Flush cached data */
000004  f7fffffe          BL       f_sync
;;;2831   	if (res == FR_OK)
000008  2800              CMP      r0,#0
00000a  d10b              BNE      |L16.36|
;;;2832   #endif
;;;2833   	{
;;;2834   		res = validate(fp);				/* Lock volume */
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       validate
;;;2835   		if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d106              BNE      |L16.36|
;;;2836   #if _FS_REENTRANT
;;;2837   			FATFS *fs = fp->fs;
;;;2838   #endif
;;;2839   #if _FS_LOCK
;;;2840   			res = dec_lock(fp->lockid);	/* Decrement file open counter */
000016  6a60              LDR      r0,[r4,#0x24]
000018  f7fffffe          BL       dec_lock
;;;2841   			if (res == FR_OK)
00001c  2800              CMP      r0,#0
00001e  d101              BNE      |L16.36|
;;;2842   #endif
;;;2843   				fp->fs = 0;				/* Invalidate file object */
000020  2100              MOVS     r1,#0
000022  6021              STR      r1,[r4,#0]
                  |L16.36|
;;;2844   #if _FS_REENTRANT
;;;2845   			unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;2846   #endif
;;;2847   		}
;;;2848   	}
;;;2849   	return res;
;;;2850   }
000024  bd10              POP      {r4,pc}
;;;2851   
                          ENDP


                          AREA ||i.f_closedir||, CODE, READONLY, ALIGN=1

                  f_closedir PROC
;;;3207   
;;;3208   FRESULT f_closedir (
000000  b510              PUSH     {r4,lr}
;;;3209   	DIR *dp		/* Pointer to the directory object to be closed */
;;;3210   )
;;;3211   {
000002  4604              MOV      r4,r0
;;;3212   	FRESULT res;
;;;3213   
;;;3214   
;;;3215   	res = validate(dp);
000004  f7fffffe          BL       validate
;;;3216   	if (res == FR_OK) {
000008  2800              CMP      r0,#0
00000a  d108              BNE      |L17.30|
;;;3217   #if _FS_REENTRANT
;;;3218   		FATFS *fs = dp->fs;
;;;3219   #endif
;;;3220   #if _FS_LOCK
;;;3221   		if (dp->lockid)				/* Decrement sub-directory open counter */
00000c  69e1              LDR      r1,[r4,#0x1c]
00000e  b121              CBZ      r1,|L17.26|
000010  4608              MOV      r0,r1
;;;3222   			res = dec_lock(dp->lockid);
000012  f7fffffe          BL       dec_lock
000016  2800              CMP      r0,#0
000018  d101              BNE      |L17.30|
                  |L17.26|
;;;3223   		if (res == FR_OK)
;;;3224   #endif
;;;3225   			dp->fs = 0;				/* Invalidate directory object */
00001a  2100              MOVS     r1,#0
00001c  6021              STR      r1,[r4,#0]
                  |L17.30|
;;;3226   #if _FS_REENTRANT
;;;3227   		unlock_fs(fs, FR_OK);		/* Unlock volume */
;;;3228   #endif
;;;3229   	}
;;;3230   	return res;
;;;3231   }
00001e  bd10              POP      {r4,pc}
;;;3232   
                          ENDP


                          AREA ||i.f_getfree||, CODE, READONLY, ALIGN=1

                  f_getfree PROC
;;;3316   
;;;3317   FRESULT f_getfree (
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3318   	const TCHAR* path,	/* Path name of the logical drive number */
;;;3319   	DWORD* nclst,		/* Pointer to a variable to return number of free clusters */
;;;3320   	FATFS** fatfs		/* Pointer to return pointer to corresponding file system object */
;;;3321   )
;;;3322   {
000004  4614              MOV      r4,r2
000006  468a              MOV      r10,r1
;;;3323   	FRESULT res;
;;;3324   	FATFS *fs;
;;;3325   	DWORD n, clst, sect, stat;
;;;3326   	UINT i;
;;;3327   	BYTE fat, *p;
;;;3328   
;;;3329   
;;;3330   	/* Get logical drive number */
;;;3331   	res = find_volume(fatfs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  4669              MOV      r1,sp
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       find_volume
;;;3332   	fs = *fatfs;
000012  6824              LDR      r4,[r4,#0]
000014  ea5f0800          MOVS     r8,r0                 ;3331
;;;3333   	if (res == FR_OK) {
000018  d14f              BNE      |L18.186|
00001a  e9d40704          LDRD     r0,r7,[r4,#0x10]
;;;3334   		/* If free_clust is valid, return it without full cluster scan */
;;;3335   		if (fs->free_clust <= fs->n_fatent - 2) {
00001e  1eb9              SUBS     r1,r7,#2
000020  4288              CMP      r0,r1
000022  d802              BHI      |L18.42|
;;;3336   			*nclst = fs->free_clust;
000024  f8ca0000          STR      r0,[r10,#0]
000028  e047              B        |L18.186|
                  |L18.42|
;;;3337   		} else {
;;;3338   			/* Get number of free clusters */
;;;3339   			fat = fs->fs_type;
00002a  f8949000          LDRB     r9,[r4,#0]
;;;3340   			n = 0;
00002e  2500              MOVS     r5,#0
;;;3341   			if (fat == FS_FAT12) {
000030  f1b90f01          CMP      r9,#1
000034  d001              BEQ      |L18.58|
;;;3342   				clst = 2;
;;;3343   				do {
;;;3344   					stat = get_fat(fs, clst);
;;;3345   					if (stat == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }
;;;3346   					if (stat == 1) { res = FR_INT_ERR; break; }
;;;3347   					if (stat == 0) n++;
;;;3348   				} while (++clst < fs->n_fatent);
;;;3349   			} else {
;;;3350   				clst = fs->n_fatent;
;;;3351   				sect = fs->fatbase;
;;;3352   				i = 0; p = 0;
;;;3353   				do {
000036  6a26              LDR      r6,[r4,#0x20]
000038  e016              B        |L18.104|
                  |L18.58|
00003a  2602              MOVS     r6,#2                 ;3342
                  |L18.60|
00003c  4631              MOV      r1,r6                 ;3344
00003e  4620              MOV      r0,r4                 ;3344
000040  f7fffffe          BL       get_fat
000044  1c41              ADDS     r1,r0,#1              ;3345
000046  d003              BEQ      |L18.80|
000048  2801              CMP      r0,#1                 ;3346
00004a  d003              BEQ      |L18.84|
00004c  b128              CBZ      r0,|L18.90|
00004e  e005              B        |L18.92|
                  |L18.80|
000050  2001              MOVS     r0,#1                 ;3345
000052  e000              B        |L18.86|
                  |L18.84|
000054  2002              MOVS     r0,#2                 ;3346
                  |L18.86|
000056  4680              MOV      r8,r0                 ;3346
000058  e028              B        |L18.172|
                  |L18.90|
00005a  1c6d              ADDS     r5,r5,#1              ;3346
                  |L18.92|
00005c  6960              LDR      r0,[r4,#0x14]         ;3348
00005e  1c76              ADDS     r6,r6,#1              ;3348
000060  4286              CMP      r6,r0                 ;3348
000062  d3eb              BCC      |L18.60|
000064  e022              B        |L18.172|
                  |L18.102|
;;;3354   					if (!i) {
000066  b959              CBNZ     r1,|L18.128|
                  |L18.104|
;;;3355   						res = move_window(fs, sect++);
000068  4631              MOV      r1,r6
00006a  1c76              ADDS     r6,r6,#1
00006c  4620              MOV      r0,r4
00006e  f7fffffe          BL       move_window
000072  ea5f0800          MOVS     r8,r0
;;;3356   						if (res != FR_OK) break;
000076  d119              BNE      |L18.172|
;;;3357   						p = fs->win;
000078  f1040030          ADD      r0,r4,#0x30
;;;3358   						i = SS(fs);
00007c  f44f7100          MOV      r1,#0x200
                  |L18.128|
;;;3359   					}
;;;3360   					if (fat == FS_FAT16) {
000080  f1b90f02          CMP      r9,#2
000084  d007              BEQ      |L18.150|
;;;3361   						if (LD_WORD(p) == 0) n++;
;;;3362   						p += 2; i -= 2;
;;;3363   					} else {
;;;3364   						if ((LD_DWORD(p) & 0x0FFFFFFF) == 0) n++;
000086  7802              LDRB     r2,[r0,#0]
000088  f8d03001          LDR      r3,[r0,#1]
00008c  ea422203          ORR      r2,r2,r3,LSL #8
000090  0112              LSLS     r2,r2,#4
000092  d006              BEQ      |L18.162|
000094  e006              B        |L18.164|
                  |L18.150|
000096  8802              LDRH     r2,[r0,#0]            ;3361
000098  b902              CBNZ     r2,|L18.156|
00009a  1c6d              ADDS     r5,r5,#1              ;3361
                  |L18.156|
00009c  1c80              ADDS     r0,r0,#2              ;3361
00009e  1e89              SUBS     r1,r1,#2              ;3361
0000a0  e002              B        |L18.168|
                  |L18.162|
0000a2  1c6d              ADDS     r5,r5,#1              ;3362
                  |L18.164|
0000a4  1d00              ADDS     r0,r0,#4              ;3362
0000a6  1f09              SUBS     r1,r1,#4              ;3362
                  |L18.168|
0000a8  1e7f              SUBS     r7,r7,#1              ;3362
;;;3365   						p += 4; i -= 4;
;;;3366   					}
;;;3367   				} while (--clst);
0000aa  d1dc              BNE      |L18.102|
                  |L18.172|
;;;3368   			}
;;;3369   			fs->free_clust = n;
;;;3370   			fs->fsi_flag |= 1;
0000ac  6125              STR      r5,[r4,#0x10]
0000ae  7960              LDRB     r0,[r4,#5]
0000b0  f0400001          ORR      r0,r0,#1
0000b4  7160              STRB     r0,[r4,#5]
;;;3371   			*nclst = n;
0000b6  f8ca5000          STR      r5,[r10,#0]
                  |L18.186|
;;;3372   		}
;;;3373   	}
;;;3374   	LEAVE_FF(fs, res);
0000ba  4640              MOV      r0,r8
;;;3375   }
0000bc  e8bd8ffe          POP      {r1-r11,pc}
;;;3376   
                          ENDP


                          AREA ||i.f_lseek||, CODE, READONLY, ALIGN=1

                  f_lseek PROC
;;;2993   
;;;2994   FRESULT f_lseek (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;2995   	FIL* fp,		/* Pointer to the file object */
;;;2996   	DWORD ofs		/* File pointer from top of file */
;;;2997   )
;;;2998   {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;2999   	FRESULT res;
;;;3000   
;;;3001   
;;;3002   	res = validate(fp);					/* Check validity of the object */
000008  f7fffffe          BL       validate
00000c  ea5f0800          MOVS     r8,r0
;;;3003   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000010  d16f              BNE      |L19.242|
;;;3004   	if (fp->err)						/* Check error */
000012  79e0              LDRB     r0,[r4,#7]
000014  2800              CMP      r0,#0
000016  d16c              BNE      |L19.242|
;;;3005   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;3006   
;;;3007   #if _USE_FASTSEEK
;;;3008   	if (fp->cltbl) {	/* Fast seek */
;;;3009   		DWORD cl, pcl, ncl, tcl, dsc, tlen, ulen, *tbl;
;;;3010   
;;;3011   		if (ofs == CREATE_LINKMAP) {	/* Create CLMT */
;;;3012   			tbl = fp->cltbl;
;;;3013   			tlen = *tbl++; ulen = 2;	/* Given table size and required table size */
;;;3014   			cl = fp->sclust;			/* Top of the chain */
;;;3015   			if (cl) {
;;;3016   				do {
;;;3017   					/* Get a fragment */
;;;3018   					tcl = cl; ncl = 0; ulen += 2;	/* Top, length and used items */
;;;3019   					do {
;;;3020   						pcl = cl; ncl++;
;;;3021   						cl = get_fat(fp->fs, cl);
;;;3022   						if (cl <= 1) ABORT(fp->fs, FR_INT_ERR);
;;;3023   						if (cl == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;3024   					} while (cl == pcl + 1);
;;;3025   					if (ulen <= tlen) {		/* Store the length and top of the fragment */
;;;3026   						*tbl++ = ncl; *tbl++ = tcl;
;;;3027   					}
;;;3028   				} while (cl < fp->fs->n_fatent);	/* Repeat until end of chain */
;;;3029   			}
;;;3030   			*fp->cltbl = ulen;	/* Number of items used */
;;;3031   			if (ulen <= tlen)
;;;3032   				*tbl = 0;		/* Terminate table */
;;;3033   			else
;;;3034   				res = FR_NOT_ENOUGH_CORE;	/* Given table size is smaller than required */
;;;3035   
;;;3036   		} else {						/* Fast seek */
;;;3037   			if (ofs > fp->fsize)		/* Clip offset at the file size */
;;;3038   				ofs = fp->fsize;
;;;3039   			fp->fptr = ofs;				/* Set file pointer */
;;;3040   			if (ofs) {
;;;3041   				fp->clust = clmt_clust(fp, ofs - 1);
;;;3042   				dsc = clust2sect(fp->fs, fp->clust);
;;;3043   				if (!dsc) ABORT(fp->fs, FR_INT_ERR);
;;;3044   				dsc += (ofs - 1) / SS(fp->fs) & (fp->fs->csize - 1);
;;;3045   				if (fp->fptr % SS(fp->fs) && dsc != fp->dsect) {	/* Refill sector cache if needed */
;;;3046   #if !_FS_TINY
;;;3047   #if !_FS_READONLY
;;;3048   					if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;3049   						if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;;;3050   							ABORT(fp->fs, FR_DISK_ERR);
;;;3051   						fp->flag &= ~FA__DIRTY;
;;;3052   					}
;;;3053   #endif
;;;3054   					if (disk_read(fp->fs->drv, fp->buf, dsc, 1))	/* Load current sector */
;;;3055   						ABORT(fp->fs, FR_DISK_ERR);
;;;3056   #endif
;;;3057   					fp->dsect = dsc;
;;;3058   				}
;;;3059   			}
;;;3060   		}
;;;3061   	} else
;;;3062   #endif
;;;3063   
;;;3064   	/* Normal Seek */
;;;3065   	{
;;;3066   		DWORD clst, bcs, nsect, ifptr;
;;;3067   
;;;3068   		if (ofs > fp->fsize					/* In read-only mode, clip offset with the file size */
000018  68e0              LDR      r0,[r4,#0xc]
00001a  42a8              CMP      r0,r5
00001c  d203              BCS      |L19.38|
;;;3069   #if !_FS_READONLY
;;;3070   			 && !(fp->flag & FA_WRITE)
00001e  79a1              LDRB     r1,[r4,#6]
000020  0789              LSLS     r1,r1,#30
000022  d400              BMI      |L19.38|
;;;3071   #endif
;;;3072   			) ofs = fp->fsize;
000024  4605              MOV      r5,r0
                  |L19.38|
;;;3073   
;;;3074   		ifptr = fp->fptr;
;;;3075   		fp->fptr = nsect = 0;
000026  2700              MOVS     r7,#0
000028  68a0              LDR      r0,[r4,#8]
00002a  f04f0901          MOV      r9,#1                 ;3066
;;;3076   		if (ofs) {
00002e  60a7              STR      r7,[r4,#8]
000030  b30d              CBZ      r5,|L19.118|
;;;3077   			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
000032  6822              LDR      r2,[r4,#0]
;;;3078   			if (ifptr > 0 &&
;;;3079   				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
;;;3080   				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
;;;3081   				ofs -= fp->fptr;
;;;3082   				clst = fp->clust;
;;;3083   			} else {									/* When seek to back cluster, */
;;;3084   				clst = fp->sclust;						/* start from the first cluster */
;;;3085   #if !_FS_READONLY
;;;3086   				if (clst == 0) {						/* If no cluster chain, create a new chain */
;;;3087   					clst = create_chain(fp->fs, 0);
;;;3088   					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
000034  f04f0a02          MOV      r10,#2
000038  7891              LDRB     r1,[r2,#2]            ;3077
00003a  024e              LSLS     r6,r1,#9              ;3077
00003c  b168              CBZ      r0,|L19.90|
00003e  1e69              SUBS     r1,r5,#1              ;3079
000040  1e40              SUBS     r0,r0,#1              ;3079
000042  fbb1f1f6          UDIV     r1,r1,r6              ;3079
000046  fbb0f3f6          UDIV     r3,r0,r6              ;3079
00004a  4299              CMP      r1,r3                 ;3079
00004c  d305              BCC      |L19.90|
00004e  1e71              SUBS     r1,r6,#1              ;3080
000050  4388              BICS     r0,r0,r1              ;3080
000052  60a0              STR      r0,[r4,#8]            ;3082
000054  1a2d              SUBS     r5,r5,r0              ;3081
000056  6961              LDR      r1,[r4,#0x14]         ;3082
000058  e00c              B        |L19.116|
                  |L19.90|
00005a  6921              LDR      r1,[r4,#0x10]         ;3086
00005c  b949              CBNZ     r1,|L19.114|
00005e  2100              MOVS     r1,#0                 ;3087
000060  4610              MOV      r0,r2                 ;3087
000062  f7fffffe          BL       create_chain
000066  4601              MOV      r1,r0                 ;3087
000068  2801              CMP      r0,#1
00006a  d03f              BEQ      |L19.236|
;;;3089   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
00006c  1c48              ADDS     r0,r1,#1
00006e  d04e              BEQ      |L19.270|
;;;3090   					fp->sclust = clst;
000070  6121              STR      r1,[r4,#0x10]
                  |L19.114|
;;;3091   				}
;;;3092   #endif
;;;3093   				fp->clust = clst;
000072  6161              STR      r1,[r4,#0x14]
                  |L19.116|
;;;3094   			}
;;;3095   			if (clst != 0) {
000074  b9d1              CBNZ     r1,|L19.172|
                  |L19.118|
000076  e026              B        |L19.198|
                  |L19.120|
;;;3096   				while (ofs > bcs) {						/* Cluster following loop */
;;;3097   #if !_FS_READONLY
;;;3098   					if (fp->flag & FA_WRITE) {			/* Check if in write mode or not */
000078  79a0              LDRB     r0,[r4,#6]
00007a  0780              LSLS     r0,r0,#30
00007c  6820              LDR      r0,[r4,#0]
00007e  d505              BPL      |L19.140|
;;;3099   						clst = create_chain(fp->fs, clst);	/* Force stretch if in write mode */
000080  f7fffffe          BL       create_chain
000084  0001              MOVS     r1,r0
;;;3100   						if (clst == 0) {				/* When disk gets full, clip file size */
000086  d104              BNE      |L19.146|
;;;3101   							ofs = bcs; break;
000088  4635              MOV      r5,r6
00008a  e011              B        |L19.176|
                  |L19.140|
;;;3102   						}
;;;3103   					} else
;;;3104   #endif
;;;3105   						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
00008c  f7fffffe          BL       get_fat
000090  4601              MOV      r1,r0
                  |L19.146|
;;;3106   					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
000092  1c48              ADDS     r0,r1,#1
000094  d03b              BEQ      |L19.270|
;;;3107   					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
000096  2901              CMP      r1,#1
000098  d928              BLS      |L19.236|
00009a  6820              LDR      r0,[r4,#0]
00009c  6940              LDR      r0,[r0,#0x14]
00009e  4288              CMP      r0,r1
0000a0  d924              BLS      |L19.236|
;;;3108   					fp->clust = clst;
;;;3109   					fp->fptr += bcs;
0000a2  6161              STR      r1,[r4,#0x14]
0000a4  68a0              LDR      r0,[r4,#8]
;;;3110   					ofs -= bcs;
0000a6  1bad              SUBS     r5,r5,r6
0000a8  4430              ADD      r0,r0,r6              ;3109
0000aa  60a0              STR      r0,[r4,#8]
                  |L19.172|
0000ac  42b5              CMP      r5,r6                 ;3096
0000ae  d8e3              BHI      |L19.120|
                  |L19.176|
;;;3111   				}
;;;3112   				fp->fptr += ofs;
0000b0  68a0              LDR      r0,[r4,#8]
0000b2  4428              ADD      r0,r0,r5
;;;3113   				if (ofs % SS(fp->fs)) {
0000b4  60a0              STR      r0,[r4,#8]
0000b6  05e8              LSLS     r0,r5,#23
0000b8  d005              BEQ      |L19.198|
;;;3114   					nsect = clust2sect(fp->fs, clst);	/* Current sector */
0000ba  6820              LDR      r0,[r4,#0]
0000bc  f7fffffe          BL       clust2sect
;;;3115   					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
0000c0  b1a0              CBZ      r0,|L19.236|
;;;3116   					nsect += ofs / SS(fp->fs);
0000c2  eb002755          ADD      r7,r0,r5,LSR #9
                  |L19.198|
;;;3117   				}
;;;3118   			}
;;;3119   		}
;;;3120   		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
0000c6  8920              LDRH     r0,[r4,#8]
0000c8  05c0              LSLS     r0,r0,#23
0000ca  d025              BEQ      |L19.280|
0000cc  69a2              LDR      r2,[r4,#0x18]
0000ce  42ba              CMP      r2,r7
0000d0  d022              BEQ      |L19.280|
;;;3121   #if !_FS_TINY
;;;3122   #if !_FS_READONLY
;;;3123   			if (fp->flag & FA__DIRTY) {			/* Write-back dirty sector cache */
0000d2  79a0              LDRB     r0,[r4,#6]
;;;3124   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
0000d4  f1040528          ADD      r5,r4,#0x28
0000d8  0640              LSLS     r0,r0,#25             ;3123
0000da  d510              BPL      |L19.254|
0000dc  6820              LDR      r0,[r4,#0]
0000de  2301              MOVS     r3,#1
0000e0  4629              MOV      r1,r5
0000e2  7840              LDRB     r0,[r0,#1]
0000e4  f7fffffe          BL       disk_write
0000e8  b988              CBNZ     r0,|L19.270|
0000ea  e004              B        |L19.246|
                  |L19.236|
0000ec  f884a007          STRB     r10,[r4,#7]           ;3115
0000f0  2002              MOVS     r0,#2                 ;3115
                  |L19.242|
;;;3125   					ABORT(fp->fs, FR_DISK_ERR);
;;;3126   				fp->flag &= ~FA__DIRTY;
;;;3127   			}
;;;3128   #endif
;;;3129   			if (disk_read(fp->fs->drv, fp->buf, nsect, 1))	/* Fill sector cache */
;;;3130   				ABORT(fp->fs, FR_DISK_ERR);
;;;3131   #endif
;;;3132   			fp->dsect = nsect;
;;;3133   		}
;;;3134   #if !_FS_READONLY
;;;3135   		if (fp->fptr > fp->fsize) {			/* Set file change flag if the file size is extended */
;;;3136   			fp->fsize = fp->fptr;
;;;3137   			fp->flag |= FA__WRITTEN;
;;;3138   		}
;;;3139   #endif
;;;3140   	}
;;;3141   
;;;3142   	LEAVE_FF(fp->fs, res);
;;;3143   }
0000f2  e8bd87f0          POP      {r4-r10,pc}
                  |L19.246|
0000f6  79a0              LDRB     r0,[r4,#6]            ;3126
0000f8  f0200040          BIC      r0,r0,#0x40           ;3126
0000fc  71a0              STRB     r0,[r4,#6]            ;3126
                  |L19.254|
0000fe  6820              LDR      r0,[r4,#0]            ;3129
000100  2301              MOVS     r3,#1                 ;3129
000102  463a              MOV      r2,r7                 ;3129
000104  7840              LDRB     r0,[r0,#1]            ;3129
000106  4629              MOV      r1,r5                 ;3129
000108  f7fffffe          BL       disk_read
00010c  b118              CBZ      r0,|L19.278|
                  |L19.270|
00010e  f8849007          STRB     r9,[r4,#7]            ;3130
000112  2001              MOVS     r0,#1                 ;3130
000114  e7ed              B        |L19.242|
                  |L19.278|
000116  61a7              STR      r7,[r4,#0x18]         ;3132
                  |L19.280|
000118  e9d40102          LDRD     r0,r1,[r4,#8]         ;3132
00011c  4288              CMP      r0,r1                 ;3135
00011e  d904              BLS      |L19.298|
000120  60e0              STR      r0,[r4,#0xc]          ;3137
000122  79a0              LDRB     r0,[r4,#6]            ;3137
000124  f0400020          ORR      r0,r0,#0x20           ;3137
000128  71a0              STRB     r0,[r4,#6]            ;3137
                  |L19.298|
00012a  4640              MOV      r0,r8                 ;3142
00012c  e7e1              B        |L19.242|
;;;3144   
                          ENDP


                          AREA ||i.f_mkdir||, CODE, READONLY, ALIGN=1

                  f_mkdir PROC
;;;3509   
;;;3510   FRESULT f_mkdir (
000000  e92d4ff1          PUSH     {r0,r4-r11,lr}
;;;3511   	const TCHAR* path		/* Pointer to the directory path */
;;;3512   )
;;;3513   {
000004  f5ad7d0e          SUB      sp,sp,#0x238
;;;3514   	FRESULT res;
;;;3515   	DIR dj;
;;;3516   	BYTE *dir, n;
;;;3517   	DWORD dsc, dcl, pcl, tm = get_fattime();
000008  f7fffffe          BL       get_fattime
00000c  4607              MOV      r7,r0
;;;3518   	DEF_NAMEBUF;
;;;3519   
;;;3520   
;;;3521   	/* Get logical drive number */
;;;3522   	res = find_volume(&dj.fs, &path, 1);
00000e  2201              MOVS     r2,#1
000010  a98e              ADD      r1,sp,#0x238
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       find_volume
000018  0004              MOVS     r4,r0
;;;3523   	if (res == FR_OK) {
00001a  d10b              BNE      |L20.52|
;;;3524   		INIT_BUF(dj);
00001c  a88b              ADD      r0,sp,#0x22c
00001e  9006              STR      r0,[sp,#0x18]
000020  a80a              ADD      r0,sp,#0x28
;;;3525   		res = follow_path(&dj, path);			/* Follow the file path */
000022  9008              STR      r0,[sp,#0x20]
000024  4668              MOV      r0,sp
000026  998e              LDR      r1,[sp,#0x238]
000028  f7fffffe          BL       follow_path
00002c  0004              MOVS     r4,r0
;;;3526   		if (res == FR_OK) res = FR_EXIST;		/* Any object with same name is already existing */
00002e  d002              BEQ      |L20.54|
;;;3527   		if (_FS_RPATH && res == FR_NO_FILE && (dj.fn[NS] & NS_DOT))
;;;3528   			res = FR_INVALID_NAME;
;;;3529   		if (res == FR_NO_FILE) {				/* Can create a new directory */
000030  2c04              CMP      r4,#4
000032  d002              BEQ      |L20.58|
                  |L20.52|
000034  e08f              B        |L20.342|
                  |L20.54|
000036  2408              MOVS     r4,#8                 ;3526
000038  e08d              B        |L20.342|
                  |L20.58|
;;;3530   			dcl = create_chain(dj.fs, 0);		/* Allocate a cluster for the new directory table */
00003a  2100              MOVS     r1,#0
00003c  9800              LDR      r0,[sp,#0]
00003e  f7fffffe          BL       create_chain
000042  0006              MOVS     r6,r0
;;;3531   			res = FR_OK;
;;;3532   			if (dcl == 0) res = FR_DENIED;		/* No space to allocate a new cluster */
000044  d009              BEQ      |L20.90|
;;;3533   			if (dcl == 1) res = FR_INT_ERR;
000046  2e01              CMP      r6,#1
000048  d009              BEQ      |L20.94|
;;;3534   			if (dcl == 0xFFFFFFFF) res = FR_DISK_ERR;
00004a  1c70              ADDS     r0,r6,#1
00004c  d009              BEQ      |L20.98|
;;;3535   			if (res == FR_OK)					/* Flush FAT */
;;;3536   				res = sync_window(dj.fs);
00004e  9800              LDR      r0,[sp,#0]
000050  f7fffffe          BL       sync_window
000054  0004              MOVS     r4,r0
000056  d006              BEQ      |L20.102|
000058  e063              B        |L20.290|
                  |L20.90|
00005a  2407              MOVS     r4,#7                 ;3532
00005c  e061              B        |L20.290|
                  |L20.94|
00005e  2402              MOVS     r4,#2                 ;3533
000060  e05f              B        |L20.290|
                  |L20.98|
000062  2401              MOVS     r4,#1                 ;3534
000064  e05d              B        |L20.290|
                  |L20.102|
;;;3537   			if (res == FR_OK) {					/* Initialize the new directory table */
;;;3538   				dsc = clust2sect(dj.fs, dcl);
000066  4631              MOV      r1,r6
000068  9800              LDR      r0,[sp,#0]
00006a  f7fffffe          BL       clust2sect
;;;3539   				dir = dj.fs->win;
;;;3540   				mem_set(dir, 0, SS(dj.fs));
00006e  9d00              LDR      r5,[sp,#0]
000070  4680              MOV      r8,r0                 ;3538
000072  3530              ADDS     r5,r5,#0x30
000074  f44f7200          MOV      r2,#0x200
000078  2100              MOVS     r1,#0
00007a  4628              MOV      r0,r5
00007c  f7fffffe          BL       mem_set
;;;3541   				mem_set(dir+DIR_Name, ' ', 11);	/* Create "." entry */
000080  220b              MOVS     r2,#0xb
000082  2120              MOVS     r1,#0x20
000084  4628              MOV      r0,r5
000086  f7fffffe          BL       mem_set
;;;3542   				dir[DIR_Name] = '.';
00008a  242e              MOVS     r4,#0x2e
00008c  702c              STRB     r4,[r5,#0]
;;;3543   				dir[DIR_Attr] = AM_DIR;
00008e  2010              MOVS     r0,#0x10
000090  72e8              STRB     r0,[r5,#0xb]
;;;3544   				ST_DWORD(dir+DIR_WrtTime, tm);
000092  b2f8              UXTB     r0,r7
000094  908a              STR      r0,[sp,#0x228]
000096  75a8              STRB     r0,[r5,#0x16]
000098  f3c72b07          UBFX     r11,r7,#8,#8
00009c  f885b017          STRB     r11,[r5,#0x17]
0000a0  f3c74a07          UBFX     r10,r7,#16,#8
0000a4  f885a018          STRB     r10,[r5,#0x18]
0000a8  ea4f6917          LSR      r9,r7,#24
0000ac  f8859019          STRB     r9,[r5,#0x19]
;;;3545   				st_clust(dir, dcl);
0000b0  4631              MOV      r1,r6
0000b2  4628              MOV      r0,r5
0000b4  f7fffffe          BL       st_clust
;;;3546   				mem_cpy(dir+SZ_DIR, dir, SZ_DIR); 	/* Create ".." entry */
0000b8  f1050020          ADD      r0,r5,#0x20
0000bc  2220              MOVS     r2,#0x20
0000be  4629              MOV      r1,r5
0000c0  4607              MOV      r7,r0
0000c2  f7fffffe          BL       mem_cpy
;;;3547   				dir[SZ_DIR+1] = '.'; pcl = dj.sclust;
0000c6  f8854021          STRB     r4,[r5,#0x21]
;;;3548   				if (dj.fs->fs_type == FS_FAT32 && pcl == dj.fs->dirbase)
0000ca  9800              LDR      r0,[sp,#0]
0000cc  9902              LDR      r1,[sp,#8]
0000ce  7800              LDRB     r0,[r0,#0]
0000d0  2803              CMP      r0,#3
0000d2  d104              BNE      |L20.222|
0000d4  9800              LDR      r0,[sp,#0]
0000d6  6a40              LDR      r0,[r0,#0x24]
0000d8  4288              CMP      r0,r1
0000da  d100              BNE      |L20.222|
;;;3549   					pcl = 0;
0000dc  2100              MOVS     r1,#0
                  |L20.222|
0000de  4638              MOV      r0,r7
;;;3550   				st_clust(dir+SZ_DIR, pcl);
0000e0  f7fffffe          BL       st_clust
;;;3551   				for (n = dj.fs->csize; n; n--) {	/* Write dot entries and clear following sectors */
0000e4  9800              LDR      r0,[sp,#0]
0000e6  7887              LDRB     r7,[r0,#2]
0000e8  e014              B        |L20.276|
                  |L20.234|
;;;3552   					dj.fs->winsect = dsc++;
0000ea  9900              LDR      r1,[sp,#0]
;;;3553   					dj.fs->wflag = 1;
0000ec  2001              MOVS     r0,#1
0000ee  f8c1802c          STR      r8,[r1,#0x2c]         ;3552
0000f2  9900              LDR      r1,[sp,#0]
0000f4  f1080801          ADD      r8,r8,#1              ;3552
0000f8  7108              STRB     r0,[r1,#4]
;;;3554   					res = sync_window(dj.fs);
0000fa  9800              LDR      r0,[sp,#0]
0000fc  f7fffffe          BL       sync_window
000100  0004              MOVS     r4,r0
;;;3555   					if (res != FR_OK) break;
000102  d10e              BNE      |L20.290|
;;;3556   					mem_set(dir, 0, SS(dj.fs));
000104  f44f7200          MOV      r2,#0x200
000108  2100              MOVS     r1,#0
00010a  4628              MOV      r0,r5
00010c  f7fffffe          BL       mem_set
000110  1e7f              SUBS     r7,r7,#1
000112  b2ff              UXTB     r7,r7                 ;3551
                  |L20.276|
000114  2f00              CMP      r7,#0                 ;3551
000116  d1e8              BNE      |L20.234|
;;;3557   				}
;;;3558   			}
;;;3559   			if (res == FR_OK) res = dir_register(&dj);	/* Register the object to the directoy */
000118  4668              MOV      r0,sp
00011a  f7fffffe          BL       dir_register
00011e  0004              MOVS     r4,r0
000120  d004              BEQ      |L20.300|
                  |L20.290|
;;;3560   			if (res != FR_OK) {
;;;3561   				remove_chain(dj.fs, dcl);			/* Could not register, remove cluster chain */
000122  4631              MOV      r1,r6
000124  9800              LDR      r0,[sp,#0]
000126  f7fffffe          BL       remove_chain
00012a  e014              B        |L20.342|
                  |L20.300|
;;;3562   			} else {
;;;3563   				dir = dj.dir;
;;;3564   				dir[DIR_Attr] = AM_DIR;				/* Attribute */
00012c  9805              LDR      r0,[sp,#0x14]
00012e  2110              MOVS     r1,#0x10
000130  72c1              STRB     r1,[r0,#0xb]
;;;3565   				ST_DWORD(dir+DIR_WrtTime, tm);		/* Created time */
000132  998a              LDR      r1,[sp,#0x228]
000134  7581              STRB     r1,[r0,#0x16]
000136  f880b017          STRB     r11,[r0,#0x17]
00013a  f880a018          STRB     r10,[r0,#0x18]
00013e  f8809019          STRB     r9,[r0,#0x19]
;;;3566   				st_clust(dir, dcl);					/* Table start cluster */
000142  4631              MOV      r1,r6
000144  f7fffffe          BL       st_clust
;;;3567   				dj.fs->wflag = 1;
000148  9900              LDR      r1,[sp,#0]
00014a  2001              MOVS     r0,#1
00014c  7108              STRB     r0,[r1,#4]
;;;3568   				res = sync_fs(dj.fs);
00014e  9800              LDR      r0,[sp,#0]
000150  f7fffffe          BL       sync_fs
000154  4604              MOV      r4,r0
                  |L20.342|
;;;3569   			}
;;;3570   		}
;;;3571   		FREE_BUF();
;;;3572   	}
;;;3573   
;;;3574   	LEAVE_FF(dj.fs, res);
;;;3575   }
000156  f50d7d0f          ADD      sp,sp,#0x23c
00015a  4620              MOV      r0,r4                 ;3574
00015c  e8bd8ff0          POP      {r4-r11,pc}
;;;3576   
                          ENDP


                          AREA ||i.f_mount||, CODE, READONLY, ALIGN=2

                  f_mount PROC
;;;2367   
;;;2368   FRESULT f_mount (
000000  e92d41f7          PUSH     {r0-r2,r4-r8,lr}
;;;2369   	FATFS* fs,			/* Pointer to the file system object (NULL:unmount)*/
;;;2370   	const TCHAR* path,	/* Logical drive number to be mounted/unmounted */
;;;2371   	BYTE opt			/* 0:Do not mount (delayed mount), 1:Mount immediately */
;;;2372   )
;;;2373   {
000004  b081              SUB      sp,sp,#4
000006  4690              MOV      r8,r2
;;;2374   	FATFS *cfs;
;;;2375   	int vol;
;;;2376   	FRESULT res;
;;;2377   	const TCHAR *rp = path;
000008  9802              LDR      r0,[sp,#8]
;;;2378   
;;;2379   
;;;2380   	vol = get_ldnumber(&rp);
00000a  9000              STR      r0,[sp,#0]
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       get_ldnumber
000012  0004              MOVS     r4,r0
;;;2381   	if (vol < 0) return FR_INVALID_DRIVE;
000014  d503              BPL      |L21.30|
000016  200b              MOVS     r0,#0xb
                  |L21.24|
;;;2382   	cfs = FatFs[vol];					/* Pointer to fs object */
;;;2383   
;;;2384   	if (cfs) {
;;;2385   #if _FS_LOCK
;;;2386   		clear_lock(cfs);
;;;2387   #endif
;;;2388   #if _FS_REENTRANT						/* Discard sync object of the current volume */
;;;2389   		if (!ff_del_syncobj(cfs->sobj)) return FR_INT_ERR;
;;;2390   #endif
;;;2391   		cfs->fs_type = 0;				/* Clear old fs object */
;;;2392   	}
;;;2393   
;;;2394   	if (fs) {
;;;2395   		fs->fs_type = 0;				/* Clear new fs object */
;;;2396   #if _FS_REENTRANT						/* Create sync object for the new volume */
;;;2397   		if (!ff_cre_syncobj((BYTE)vol, &fs->sobj)) return FR_INT_ERR;
;;;2398   #endif
;;;2399   	}
;;;2400   	FatFs[vol] = fs;					/* Register new fs object */
;;;2401   
;;;2402   	if (!fs || opt != 1) return FR_OK;	/* Do not mount now, it will be mounted later */
;;;2403   
;;;2404   	res = find_volume(&fs, &path, 0);	/* Force mounted the volume */
;;;2405   	LEAVE_FF(fs, res);
;;;2406   }
000018  b004              ADD      sp,sp,#0x10
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L21.30|
00001e  4e0d              LDR      r6,|L21.84|
000020  2700              MOVS     r7,#0                 ;2382
000022  f8565024          LDR      r5,[r6,r4,LSL #2]     ;2382
000026  b11d              CBZ      r5,|L21.48|
000028  4628              MOV      r0,r5                 ;2386
00002a  f7fffffe          BL       clear_lock
00002e  702f              STRB     r7,[r5,#0]            ;2391
                  |L21.48|
000030  9801              LDR      r0,[sp,#4]            ;2394
000032  2800              CMP      r0,#0                 ;2394
000034  d000              BEQ      |L21.56|
000036  7007              STRB     r7,[r0,#0]            ;2395
                  |L21.56|
000038  f8460024          STR      r0,[r6,r4,LSL #2]     ;2400
00003c  d002              BEQ      |L21.68|
00003e  f1b80f01          CMP      r8,#1                 ;2402
000042  d001              BEQ      |L21.72|
                  |L21.68|
000044  2000              MOVS     r0,#0                 ;2402
000046  e7e7              B        |L21.24|
                  |L21.72|
000048  2200              MOVS     r2,#0                 ;2404
00004a  a902              ADD      r1,sp,#8              ;2404
00004c  a801              ADD      r0,sp,#4              ;2404
00004e  f7fffffe          BL       find_volume
000052  e7e1              B        |L21.24|
;;;2407   
                          ENDP

                  |L21.84|
                          DCD      ||.bss||

                          AREA ||i.f_open||, CODE, READONLY, ALIGN=2

                  f_open PROC
;;;2414   
;;;2415   FRESULT f_open (
000000  e92d47f7          PUSH     {r0-r2,r4-r10,lr}
;;;2416   	FIL* fp,			/* Pointer to the blank file object */
;;;2417   	const TCHAR* path,	/* Pointer to the file name */
;;;2418   	BYTE mode			/* Access mode and file open mode flags */
;;;2419   )
;;;2420   {
000004  f5ad7d11          SUB      sp,sp,#0x244
000008  0007              MOVS     r7,r0
00000a  d00e              BEQ      |L22.42|
;;;2421   	FRESULT res;
;;;2422   	DIR dj;
;;;2423   	BYTE *dir;
;;;2424   	DEF_NAMEBUF;
;;;2425   
;;;2426   
;;;2427   	if (!fp) return FR_INVALID_OBJECT;
;;;2428   	fp->fs = 0;			/* Clear file object */
00000c  f04f0800          MOV      r8,#0
;;;2429   
;;;2430   	/* Get logical drive number */
;;;2431   #if !_FS_READONLY
;;;2432   	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
000010  f002061f          AND      r6,r2,#0x1f
;;;2433   	res = find_volume(&dj.fs, &path, (BYTE)(mode & ~FA_READ));
000014  f0260201          BIC      r2,r6,#1
000018  a992              ADD      r1,sp,#0x248
00001a  a802              ADD      r0,sp,#8
00001c  f8c78000          STR      r8,[r7,#0]
000020  f7fffffe          BL       find_volume
000024  0004              MOVS     r4,r0
;;;2434   #else
;;;2435   	mode &= FA_READ;
;;;2436   	res = find_volume(&dj.fs, &path, 0);
;;;2437   #endif
;;;2438   	if (res == FR_OK) {
000026  d005              BEQ      |L22.52|
000028  e0ae              B        |L22.392|
                  |L22.42|
00002a  2009              MOVS     r0,#9                 ;2427
                  |L22.44|
;;;2439   		INIT_BUF(dj);
;;;2440   		res = follow_path(&dj, path);	/* Follow the file path */
;;;2441   		dir = dj.dir;
;;;2442   #if !_FS_READONLY	/* R/W configuration */
;;;2443   		if (res == FR_OK) {
;;;2444   			if (!dir)	/* Default directory itself */
;;;2445   				res = FR_INVALID_NAME;
;;;2446   #if _FS_LOCK
;;;2447   			else
;;;2448   				res = chk_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2449   #endif
;;;2450   		}
;;;2451   		/* Create or Open a file */
;;;2452   		if (mode & (FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW)) {
;;;2453   			DWORD dw, cl;
;;;2454   
;;;2455   			if (res != FR_OK) {					/* No file, create new */
;;;2456   				if (res == FR_NO_FILE)			/* There is no file to open, create a new entry */
;;;2457   #if _FS_LOCK
;;;2458   					res = enq_lock() ? dir_register(&dj) : FR_TOO_MANY_OPEN_FILES;
;;;2459   #else
;;;2460   					res = dir_register(&dj);
;;;2461   #endif
;;;2462   				mode |= FA_CREATE_ALWAYS;		/* File is created */
;;;2463   				dir = dj.dir;					/* New entry */
;;;2464   			}
;;;2465   			else {								/* Any object is already existing */
;;;2466   				if (dir[DIR_Attr] & (AM_RDO | AM_DIR)) {	/* Cannot overwrite it (R/O or DIR) */
;;;2467   					res = FR_DENIED;
;;;2468   				} else {
;;;2469   					if (mode & FA_CREATE_NEW)	/* Cannot create as new file */
;;;2470   						res = FR_EXIST;
;;;2471   				}
;;;2472   			}
;;;2473   			if (res == FR_OK && (mode & FA_CREATE_ALWAYS)) {	/* Truncate it if overwrite mode */
;;;2474   				dw = get_fattime();				/* Created time */
;;;2475   				ST_DWORD(dir+DIR_CrtTime, dw);
;;;2476   				dir[DIR_Attr] = 0;				/* Reset attribute */
;;;2477   				ST_DWORD(dir+DIR_FileSize, 0);	/* size = 0 */
;;;2478   				cl = ld_clust(dj.fs, dir);		/* Get start cluster */
;;;2479   				st_clust(dir, 0);				/* cluster = 0 */
;;;2480   				dj.fs->wflag = 1;
;;;2481   				if (cl) {						/* Remove the cluster chain if exist */
;;;2482   					dw = dj.fs->winsect;
;;;2483   					res = remove_chain(dj.fs, cl);
;;;2484   					if (res == FR_OK) {
;;;2485   						dj.fs->last_clust = cl - 1;	/* Reuse the cluster hole */
;;;2486   						res = move_window(dj.fs, dw);
;;;2487   					}
;;;2488   				}
;;;2489   			}
;;;2490   		}
;;;2491   		else {	/* Open an existing file */
;;;2492   			if (res == FR_OK) {					/* Follow succeeded */
;;;2493   				if (dir[DIR_Attr] & AM_DIR) {	/* It is a directory */
;;;2494   					res = FR_NO_FILE;
;;;2495   				} else {
;;;2496   					if ((mode & FA_WRITE) && (dir[DIR_Attr] & AM_RDO)) /* R/O violation */
;;;2497   						res = FR_DENIED;
;;;2498   				}
;;;2499   			}
;;;2500   		}
;;;2501   		if (res == FR_OK) {
;;;2502   			if (mode & FA_CREATE_ALWAYS)		/* Set file change flag if created or overwritten */
;;;2503   				mode |= FA__WRITTEN;
;;;2504   			fp->dir_sect = dj.fs->winsect;		/* Pointer to the directory entry */
;;;2505   			fp->dir_ptr = dir;
;;;2506   #if _FS_LOCK
;;;2507   			fp->lockid = inc_lock(&dj, (mode & ~FA_READ) ? 1 : 0);
;;;2508   			if (!fp->lockid) res = FR_INT_ERR;
;;;2509   #endif
;;;2510   		}
;;;2511   
;;;2512   #else				/* R/O configuration */
;;;2513   		if (res == FR_OK) {					/* Follow succeeded */
;;;2514   			dir = dj.dir;
;;;2515   			if (!dir) {						/* Current directory itself */
;;;2516   				res = FR_INVALID_NAME;
;;;2517   			} else {
;;;2518   				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
;;;2519   					res = FR_NO_FILE;
;;;2520   			}
;;;2521   		}
;;;2522   #endif
;;;2523   		FREE_BUF();
;;;2524   
;;;2525   		if (res == FR_OK) {
;;;2526   			fp->flag = mode;					/* File access mode */
;;;2527   			fp->err = 0;						/* Clear error flag */
;;;2528   			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
;;;2529   			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
;;;2530   			fp->fptr = 0;						/* File pointer */
;;;2531   			fp->dsect = 0;
;;;2532   #if _USE_FASTSEEK
;;;2533   			fp->cltbl = 0;						/* Normal seek mode */
;;;2534   #endif
;;;2535   			fp->fs = dj.fs;	 					/* Validate file object */
;;;2536   			fp->id = fp->fs->id;
;;;2537   		}
;;;2538   	}
;;;2539   
;;;2540   	LEAVE_FF(dj.fs, res);
;;;2541   }
00002c  f50d7d14          ADD      sp,sp,#0x250
000030  e8bd87f0          POP      {r4-r10,pc}
                  |L22.52|
000034  a88e              ADD      r0,sp,#0x238          ;2439
000036  9008              STR      r0,[sp,#0x20]         ;2439
000038  a80d              ADD      r0,sp,#0x34           ;2439
00003a  900a              STR      r0,[sp,#0x28]         ;2440
00003c  a802              ADD      r0,sp,#8              ;2440
00003e  9992              LDR      r1,[sp,#0x248]        ;2440
000040  f7fffffe          BL       follow_path
000044  9d07              LDR      r5,[sp,#0x1c]         ;2443
000046  0004              MOVS     r4,r0                 ;2440
000048  d10b              BNE      |L22.98|
00004a  b11d              CBZ      r5,|L22.84|
00004c  0870              LSRS     r0,r6,#1              ;2448
00004e  d003              BEQ      |L22.88|
000050  2101              MOVS     r1,#1                 ;2448
000052  e002              B        |L22.90|
                  |L22.84|
000054  2406              MOVS     r4,#6                 ;2445
000056  e004              B        |L22.98|
                  |L22.88|
000058  2100              MOVS     r1,#0                 ;2448
                  |L22.90|
00005a  a802              ADD      r0,sp,#8              ;2448
00005c  f7fffffe          BL       chk_lock
000060  4604              MOV      r4,r0                 ;2448
                  |L22.98|
000062  f0160f1c          TST      r6,#0x1c              ;2452
000066  d05e              BEQ      |L22.294|
000068  f04f0a01          MOV      r10,#1                ;2448
00006c  b1d4              CBZ      r4,|L22.164|
00006e  2c04              CMP      r4,#4                 ;2456
000070  d113              BNE      |L22.154|
000072  2000              MOVS     r0,#0                 ;2456
000074  4946              LDR      r1,|L22.400|
000076  e002              B        |L22.126|
                  |L22.120|
000078  1c40              ADDS     r0,r0,#1              ;2456
00007a  2803              CMP      r0,#3                 ;2456
00007c  d205              BCS      |L22.138|
                  |L22.126|
00007e  eb000240          ADD      r2,r0,r0,LSL #1       ;2456
000082  f8512022          LDR      r2,[r1,r2,LSL #2]     ;2456
000086  2a00              CMP      r2,#0                 ;2456
000088  d1f6              BNE      |L22.120|
                  |L22.138|
00008a  2803              CMP      r0,#3                 ;2456
00008c  d004              BEQ      |L22.152|
00008e  a802              ADD      r0,sp,#8              ;2458
000090  f7fffffe          BL       dir_register
000094  4604              MOV      r4,r0                 ;2458
000096  e000              B        |L22.154|
                  |L22.152|
000098  2412              MOVS     r4,#0x12              ;2458
                  |L22.154|
00009a  9d07              LDR      r5,[sp,#0x1c]         ;2463
00009c  f0460608          ORR      r6,r6,#8              ;2462
0000a0  b154              CBZ      r4,|L22.184|
0000a2  e071              B        |L22.392|
                  |L22.164|
0000a4  7ae8              LDRB     r0,[r5,#0xb]          ;2466
0000a6  f0100f11          TST      r0,#0x11              ;2466
0000aa  d001              BEQ      |L22.176|
                  |L22.172|
0000ac  2407              MOVS     r4,#7                 ;2467
0000ae  e06b              B        |L22.392|
                  |L22.176|
0000b0  0770              LSLS     r0,r6,#29             ;2469
0000b2  d501              BPL      |L22.184|
0000b4  2408              MOVS     r4,#8                 ;2470
0000b6  e067              B        |L22.392|
                  |L22.184|
0000b8  0730              LSLS     r0,r6,#28             ;2473
0000ba  d542              BPL      |L22.322|
0000bc  f7fffffe          BL       get_fattime
0000c0  73a8              STRB     r0,[r5,#0xe]          ;2475
0000c2  0a01              LSRS     r1,r0,#8              ;2475
0000c4  73e9              STRB     r1,[r5,#0xf]          ;2475
0000c6  0c01              LSRS     r1,r0,#16             ;2475
0000c8  7429              STRB     r1,[r5,#0x10]         ;2475
0000ca  0e00              LSRS     r0,r0,#24             ;2475
0000cc  7468              STRB     r0,[r5,#0x11]         ;2475
0000ce  f885800b          STRB     r8,[r5,#0xb]          ;2476
0000d2  f885801c          STRB     r8,[r5,#0x1c]         ;2477
0000d6  f885801d          STRB     r8,[r5,#0x1d]         ;2477
0000da  f885801e          STRB     r8,[r5,#0x1e]         ;2477
0000de  f885801f          STRB     r8,[r5,#0x1f]         ;2477
0000e2  4629              MOV      r1,r5                 ;2478
0000e4  9802              LDR      r0,[sp,#8]            ;2478
0000e6  f7fffffe          BL       ld_clust
0000ea  4681              MOV      r9,r0                 ;2478
0000ec  2100              MOVS     r1,#0                 ;2479
0000ee  4628              MOV      r0,r5                 ;2479
0000f0  f7fffffe          BL       st_clust
0000f4  9902              LDR      r1,[sp,#8]            ;2480
0000f6  f1b90f00          CMP      r9,#0                 ;2481
0000fa  f881a004          STRB     r10,[r1,#4]           ;2480
0000fe  d01e              BEQ      |L22.318|
000100  9802              LDR      r0,[sp,#8]            ;2482
000102  4649              MOV      r1,r9                 ;2483
000104  f8d0a02c          LDR      r10,[r0,#0x2c]        ;2483
000108  f7fffffe          BL       remove_chain
00010c  0004              MOVS     r4,r0                 ;2483
00010e  d13b              BNE      |L22.392|
000110  9902              LDR      r1,[sp,#8]            ;2485
000112  f1a90001          SUB      r0,r9,#1              ;2485
000116  60c8              STR      r0,[r1,#0xc]          ;2486
000118  4651              MOV      r1,r10                ;2486
00011a  9802              LDR      r0,[sp,#8]            ;2486
00011c  f7fffffe          BL       move_window
000120  0004              MOVS     r4,r0                 ;2486
000122  d00a              BEQ      |L22.314|
000124  e030              B        |L22.392|
                  |L22.294|
000126  bb7c              CBNZ     r4,|L22.392|
000128  7ae8              LDRB     r0,[r5,#0xb]          ;2493
00012a  06c1              LSLS     r1,r0,#27             ;2493
00012c  d501              BPL      |L22.306|
00012e  2404              MOVS     r4,#4                 ;2494
000130  e02a              B        |L22.392|
                  |L22.306|
000132  07b1              LSLS     r1,r6,#30             ;2496
000134  d501              BPL      |L22.314|
000136  07c0              LSLS     r0,r0,#31             ;2496
000138  d1b8              BNE      |L22.172|
                  |L22.314|
00013a  0730              LSLS     r0,r6,#28             ;2502
00013c  d501              BPL      |L22.322|
                  |L22.318|
00013e  f0460620          ORR      r6,r6,#0x20           ;2503
                  |L22.322|
000142  9802              LDR      r0,[sp,#8]            ;2504
000144  6ac0              LDR      r0,[r0,#0x2c]         ;2504
000146  e9c70507          STRD     r0,r5,[r7,#0x1c]      ;2504
00014a  0870              LSRS     r0,r6,#1              ;2507
00014c  d001              BEQ      |L22.338|
00014e  2101              MOVS     r1,#1                 ;2507
000150  e000              B        |L22.340|
                  |L22.338|
000152  2100              MOVS     r1,#0                 ;2507
                  |L22.340|
000154  a802              ADD      r0,sp,#8              ;2507
000156  f7fffffe          BL       inc_lock
00015a  6278              STR      r0,[r7,#0x24]         ;2508
00015c  b1b0              CBZ      r0,|L22.396|
00015e  71be              STRB     r6,[r7,#6]            ;2526
000160  f8878007          STRB     r8,[r7,#7]            ;2527
000164  4646              MOV      r6,r8                 ;2527
000166  4629              MOV      r1,r5                 ;2528
000168  9802              LDR      r0,[sp,#8]            ;2528
00016a  f7fffffe          BL       ld_clust
00016e  6138              STR      r0,[r7,#0x10]         ;2529
000170  7f28              LDRB     r0,[r5,#0x1c]         ;2529
000172  f8d5101d          LDR      r1,[r5,#0x1d]         ;2529
000176  ea402001          ORR      r0,r0,r1,LSL #8       ;2529
00017a  e9c76002          STRD     r6,r0,[r7,#8]         ;2529
00017e  61be              STR      r6,[r7,#0x18]         ;2535
000180  9802              LDR      r0,[sp,#8]            ;2535
000182  6038              STR      r0,[r7,#0]            ;2536
000184  88c0              LDRH     r0,[r0,#6]            ;2536
000186  80b8              STRH     r0,[r7,#4]            ;2536
                  |L22.392|
000188  4620              MOV      r0,r4                 ;2540
00018a  e74f              B        |L22.44|
                  |L22.396|
00018c  2402              MOVS     r4,#2                 ;2508
00018e  e7fb              B        |L22.392|
;;;2542   
                          ENDP

                  |L22.400|
                          DCD      ||.bss||+0xc

                          AREA ||i.f_opendir||, CODE, READONLY, ALIGN=1

                  f_opendir PROC
;;;3151   
;;;3152   FRESULT f_opendir (
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;3153   	DIR* dp,			/* Pointer to directory object to create */
;;;3154   	const TCHAR* path	/* Pointer to the directory path */
;;;3155   )
;;;3156   {
000002  f5ad7d04          SUB      sp,sp,#0x210
000006  0004              MOVS     r4,r0
000008  d009              BEQ      |L23.30|
;;;3157   	FRESULT res;
;;;3158   	FATFS* fs;
;;;3159   	DEF_NAMEBUF;
;;;3160   
;;;3161   
;;;3162   	if (!dp) return FR_INVALID_OBJECT;
;;;3163   
;;;3164   	/* Get logical drive number */
;;;3165   	res = find_volume(&fs, &path, 0);
00000a  2200              MOVS     r2,#0
00000c  a985              ADD      r1,sp,#0x214
00000e  a880              ADD      r0,sp,#0x200
000010  f7fffffe          BL       find_volume
000014  0005              MOVS     r5,r0
000016  f04f0600          MOV      r6,#0
;;;3166   	if (res == FR_OK) {
00001a  d004              BEQ      |L23.38|
00001c  e031              B        |L23.130|
                  |L23.30|
00001e  2009              MOVS     r0,#9                 ;3162
                  |L23.32|
;;;3167   		dp->fs = fs;
;;;3168   		INIT_BUF(*dp);
;;;3169   		res = follow_path(dp, path);			/* Follow the path to the directory */
;;;3170   		FREE_BUF();
;;;3171   		if (res == FR_OK) {						/* Follow completed */
;;;3172   			if (dp->dir) {						/* It is not the origin directory itself */
;;;3173   				if (dp->dir[DIR_Attr] & AM_DIR)	/* The object is a sub directory */
;;;3174   					dp->sclust = ld_clust(fs, dp->dir);
;;;3175   				else							/* The object is a file */
;;;3176   					res = FR_NO_PATH;
;;;3177   			}
;;;3178   			if (res == FR_OK) {
;;;3179   				dp->id = fs->id;
;;;3180   				res = dir_sdi(dp, 0);			/* Rewind directory */
;;;3181   #if _FS_LOCK
;;;3182   				if (res == FR_OK) {
;;;3183   					if (dp->sclust) {
;;;3184   						dp->lockid = inc_lock(dp, 0);	/* Lock the sub directory */
;;;3185   						if (!dp->lockid)
;;;3186   							res = FR_TOO_MANY_OPEN_FILES;
;;;3187   					} else {
;;;3188   						dp->lockid = 0;	/* Root directory need not to be locked */
;;;3189   					}
;;;3190   				}
;;;3191   #endif
;;;3192   			}
;;;3193   		}
;;;3194   		if (res == FR_NO_FILE) res = FR_NO_PATH;
;;;3195   	}
;;;3196   	if (res != FR_OK) dp->fs = 0;		/* Invalidate the directory object if function faild */
;;;3197   
;;;3198   	LEAVE_FF(fs, res);
;;;3199   }
000020  f50d7d06          ADD      sp,sp,#0x218
000024  bd70              POP      {r4-r6,pc}
                  |L23.38|
000026  9880              LDR      r0,[sp,#0x200]        ;3167
000028  6020              STR      r0,[r4,#0]            ;3168
00002a  a881              ADD      r0,sp,#0x204          ;3168
00002c  61a0              STR      r0,[r4,#0x18]         ;3168
00002e  f8c4d020          STR      sp,[r4,#0x20]         ;3168
000032  4620              MOV      r0,r4                 ;3169
000034  9985              LDR      r1,[sp,#0x214]        ;3169
000036  f7fffffe          BL       follow_path
00003a  0005              MOVS     r5,r0                 ;3169
00003c  d111              BNE      |L23.98|
00003e  6961              LDR      r1,[r4,#0x14]         ;3172
000040  b131              CBZ      r1,|L23.80|
000042  7ac8              LDRB     r0,[r1,#0xb]          ;3173
000044  06c0              LSLS     r0,r0,#27             ;3173
000046  d51b              BPL      |L23.128|
000048  9880              LDR      r0,[sp,#0x200]        ;3174
00004a  f7fffffe          BL       ld_clust
00004e  60a0              STR      r0,[r4,#8]            ;3174
                  |L23.80|
000050  9880              LDR      r0,[sp,#0x200]        ;3179
000052  2100              MOVS     r1,#0                 ;3180
000054  88c0              LDRH     r0,[r0,#6]            ;3179
000056  80a0              STRH     r0,[r4,#4]            ;3179
000058  4620              MOV      r0,r4                 ;3180
00005a  f7fffffe          BL       dir_sdi
00005e  0005              MOVS     r5,r0                 ;3180
000060  d002              BEQ      |L23.104|
                  |L23.98|
000062  2d04              CMP      r5,#4                 ;3194
000064  d00c              BEQ      |L23.128|
000066  e00c              B        |L23.130|
                  |L23.104|
000068  68a0              LDR      r0,[r4,#8]            ;3183
00006a  b138              CBZ      r0,|L23.124|
00006c  2100              MOVS     r1,#0                 ;3184
00006e  4620              MOV      r0,r4                 ;3184
000070  f7fffffe          BL       inc_lock
000074  61e0              STR      r0,[r4,#0x1c]         ;3185
000076  b928              CBNZ     r0,|L23.132|
000078  2512              MOVS     r5,#0x12              ;3186
00007a  e002              B        |L23.130|
                  |L23.124|
00007c  61e6              STR      r6,[r4,#0x1c]         ;3188
00007e  e001              B        |L23.132|
                  |L23.128|
000080  2505              MOVS     r5,#5                 ;3194
                  |L23.130|
000082  6026              STR      r6,[r4,#0]            ;3196
                  |L23.132|
000084  4628              MOV      r0,r5                 ;3198
000086  e7cb              B        |L23.32|
;;;3200   
                          ENDP


                          AREA ||i.f_read||, CODE, READONLY, ALIGN=1

                  f_read PROC
;;;2549   
;;;2550   FRESULT f_read (
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2551   	FIL* fp, 		/* Pointer to the file object */
;;;2552   	void* buff,		/* Pointer to data buffer */
;;;2553   	UINT btr,		/* Number of bytes to read */
;;;2554   	UINT* br		/* Pointer to number of bytes read */
;;;2555   )
;;;2556   {
000004  4604              MOV      r4,r0
;;;2557   	FRESULT res;
;;;2558   	DWORD clst, sect, remain;
;;;2559   	UINT rcnt, cc;
;;;2560   	BYTE csect, *rbuff = (BYTE*)buff;
;;;2561   
;;;2562   
;;;2563   	*br = 0;	/* Clear read byte counter */
000006  2000              MOVS     r0,#0
;;;2564   
;;;2565   	res = validate(fp);							/* Check validity */
000008  6018              STR      r0,[r3,#0]
00000a  4699              MOV      r9,r3                 ;2556
00000c  4615              MOV      r5,r2                 ;2556
00000e  4688              MOV      r8,r1                 ;2560
000010  4620              MOV      r0,r4
000012  f7fffffe          BL       validate
;;;2566   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000016  2800              CMP      r0,#0
000018  d112              BNE      |L24.64|
;;;2567   	if (fp->err)								/* Check error */
00001a  79e0              LDRB     r0,[r4,#7]
00001c  2800              CMP      r0,#0
00001e  d10f              BNE      |L24.64|
;;;2568   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2569   	if (!(fp->flag & FA_READ)) 					/* Check access mode */
000020  79a0              LDRB     r0,[r4,#6]
000022  07c0              LSLS     r0,r0,#31
000024  d00b              BEQ      |L24.62|
000026  e9d41002          LDRD     r1,r0,[r4,#8]
;;;2570   		LEAVE_FF(fp->fs, FR_DENIED);
;;;2571   	remain = fp->fsize - fp->fptr;
00002a  1a40              SUBS     r0,r0,r1
;;;2572   	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
;;;2573   
;;;2574   	for ( ;  btr;								/* Repeat until all data read */
;;;2575   		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
;;;2576   		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
;;;2577   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2578   			if (!csect) {						/* On the cluster boundary? */
;;;2579   				if (fp->fptr == 0) {			/* On the top of the file? */
;;;2580   					clst = fp->sclust;			/* Follow from the origin */
;;;2581   				} else {						/* Middle or end of the file */
;;;2582   #if _USE_FASTSEEK
;;;2583   					if (fp->cltbl)
;;;2584   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2585   					else
;;;2586   #endif
;;;2587   						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
;;;2588   				}
;;;2589   				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
;;;2590   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
00002c  2701              MOVS     r7,#1
00002e  f04f0a02          MOV      r10,#2                ;2589
;;;2591   				fp->clust = clst;				/* Update current cluster */
;;;2592   			}
;;;2593   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2594   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2595   			sect += csect;
;;;2596   			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
;;;2597   			if (cc) {							/* Read maximum contiguous sectors directly */
;;;2598   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2599   					cc = fp->fs->csize - csect;
;;;2600   				if (disk_read(fp->fs->drv, rbuff, sect, cc))
;;;2601   					ABORT(fp->fs, FR_DISK_ERR);
;;;2602   #if !_FS_READONLY && _FS_MINIMIZE <= 2			/* Replace one of the read sectors with cached data if it contains a dirty sector */
;;;2603   #if _FS_TINY
;;;2604   				if (fp->fs->wflag && fp->fs->winsect - sect < cc)
;;;2605   					mem_cpy(rbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), fp->fs->win, SS(fp->fs));
;;;2606   #else
;;;2607   				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
;;;2608   					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
000032  f1040b28          ADD      r11,r4,#0x28
000036  4285              CMP      r5,r0                 ;2572
000038  d900              BLS      |L24.60|
00003a  4605              MOV      r5,r0                 ;2572
                  |L24.60|
00003c  e080              B        |L24.320|
                  |L24.62|
00003e  2007              MOVS     r0,#7                 ;2570
                  |L24.64|
;;;2609   #endif
;;;2610   #endif
;;;2611   				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
;;;2612   				continue;
;;;2613   			}
;;;2614   #if !_FS_TINY
;;;2615   			if (fp->dsect != sect) {			/* Load data sector if not in cache */
;;;2616   #if !_FS_READONLY
;;;2617   				if (fp->flag & FA__DIRTY) {		/* Write-back dirty sector cache */
;;;2618   					if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;;;2619   						ABORT(fp->fs, FR_DISK_ERR);
;;;2620   					fp->flag &= ~FA__DIRTY;
;;;2621   				}
;;;2622   #endif
;;;2623   				if (disk_read(fp->fs->drv, fp->buf, sect, 1))	/* Fill sector cache */
;;;2624   					ABORT(fp->fs, FR_DISK_ERR);
;;;2625   			}
;;;2626   #endif
;;;2627   			fp->dsect = sect;
;;;2628   		}
;;;2629   		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
;;;2630   		if (rcnt > btr) rcnt = btr;
;;;2631   #if _FS_TINY
;;;2632   		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
;;;2633   			ABORT(fp->fs, FR_DISK_ERR);
;;;2634   		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2635   #else
;;;2636   		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
;;;2637   #endif
;;;2638   	}
;;;2639   
;;;2640   	LEAVE_FF(fp->fs, FR_OK);
;;;2641   }
000040  e8bd9ffc          POP      {r2-r12,pc}
                  |L24.68|
000044  68a0              LDR      r0,[r4,#8]            ;2576
000046  05c1              LSLS     r1,r0,#23             ;2576
000048  d162              BNE      |L24.272|
00004a  6822              LDR      r2,[r4,#0]            ;2577
00004c  7891              LDRB     r1,[r2,#2]            ;2577
00004e  1e49              SUBS     r1,r1,#1              ;2577
000050  ea012150          AND      r1,r1,r0,LSR #9       ;2577
000054  f01106ff          ANDS     r6,r1,#0xff           ;2577
000058  d109              BNE      |L24.110|
00005a  b308              CBZ      r0,|L24.160|
00005c  4610              MOV      r0,r2                 ;2587
00005e  6961              LDR      r1,[r4,#0x14]         ;2587
000060  f7fffffe          BL       get_fat
                  |L24.100|
000064  2802              CMP      r0,#2                 ;2589
000066  d31d              BCC      |L24.164|
000068  1c41              ADDS     r1,r0,#1              ;2590
00006a  d04c              BEQ      |L24.262|
00006c  6160              STR      r0,[r4,#0x14]         ;2591
                  |L24.110|
00006e  6961              LDR      r1,[r4,#0x14]         ;2593
000070  6820              LDR      r0,[r4,#0]            ;2593
000072  f7fffffe          BL       clust2sect
000076  b1a8              CBZ      r0,|L24.164|
000078  4430              ADD      r0,r0,r6              ;2595
00007a  9001              STR      r0,[sp,#4]            ;2596
00007c  0a68              LSRS     r0,r5,#9              ;2596
00007e  9000              STR      r0,[sp,#0]            ;2597
000080  d027              BEQ      |L24.210|
000082  1832              ADDS     r2,r6,r0              ;2598
000084  6820              LDR      r0,[r4,#0]            ;2598
000086  7881              LDRB     r1,[r0,#2]            ;2598
000088  428a              CMP      r2,r1                 ;2598
00008a  d901              BLS      |L24.144|
00008c  1b89              SUBS     r1,r1,r6              ;2599
00008e  9100              STR      r1,[sp,#0]            ;2599
                  |L24.144|
000090  e9dd3200          LDRD     r3,r2,[sp,#0]         ;2600
000094  7840              LDRB     r0,[r0,#1]            ;2600
000096  4641              MOV      r1,r8                 ;2600
000098  f7fffffe          BL       disk_read
00009c  bb98              CBNZ     r0,|L24.262|
00009e  e005              B        |L24.172|
                  |L24.160|
0000a0  6920              LDR      r0,[r4,#0x10]         ;2580
0000a2  e7df              B        |L24.100|
                  |L24.164|
0000a4  f884a007          STRB     r10,[r4,#7]           ;2594
0000a8  2002              MOVS     r0,#2                 ;2594
0000aa  e7c9              B        |L24.64|
                  |L24.172|
0000ac  79a0              LDRB     r0,[r4,#6]            ;2607
0000ae  0640              LSLS     r0,r0,#25             ;2607
0000b0  d50c              BPL      |L24.204|
0000b2  69a1              LDR      r1,[r4,#0x18]         ;2607
0000b4  9801              LDR      r0,[sp,#4]            ;2607
0000b6  1a08              SUBS     r0,r1,r0              ;2607
0000b8  9900              LDR      r1,[sp,#0]            ;2607
0000ba  4288              CMP      r0,r1                 ;2607
0000bc  d206              BCS      |L24.204|
0000be  eb082040          ADD      r0,r8,r0,LSL #9       ;2608
0000c2  f44f7200          MOV      r2,#0x200             ;2608
0000c6  4659              MOV      r1,r11                ;2608
0000c8  f7fffffe          BL       mem_cpy
                  |L24.204|
0000cc  9800              LDR      r0,[sp,#0]            ;2611
0000ce  0246              LSLS     r6,r0,#9              ;2611
0000d0  e02c              B        |L24.300|
                  |L24.210|
0000d2  69a2              LDR      r2,[r4,#0x18]         ;2615
0000d4  9801              LDR      r0,[sp,#4]            ;2615
0000d6  4282              CMP      r2,r0                 ;2615
0000d8  d018              BEQ      |L24.268|
0000da  79a0              LDRB     r0,[r4,#6]            ;2617
0000dc  0640              LSLS     r0,r0,#25             ;2617
0000de  d50a              BPL      |L24.246|
0000e0  6820              LDR      r0,[r4,#0]            ;2618
0000e2  2301              MOVS     r3,#1                 ;2618
0000e4  4659              MOV      r1,r11                ;2618
0000e6  7840              LDRB     r0,[r0,#1]            ;2618
0000e8  f7fffffe          BL       disk_write
0000ec  b958              CBNZ     r0,|L24.262|
0000ee  79a0              LDRB     r0,[r4,#6]            ;2620
0000f0  f0200040          BIC      r0,r0,#0x40           ;2620
0000f4  71a0              STRB     r0,[r4,#6]            ;2620
                  |L24.246|
0000f6  6820              LDR      r0,[r4,#0]            ;2623
0000f8  2301              MOVS     r3,#1                 ;2623
0000fa  4659              MOV      r1,r11                ;2623
0000fc  7840              LDRB     r0,[r0,#1]            ;2623
0000fe  9a01              LDR      r2,[sp,#4]            ;2623
000100  f7fffffe          BL       disk_read
000104  b110              CBZ      r0,|L24.268|
                  |L24.262|
000106  71e7              STRB     r7,[r4,#7]            ;2624
000108  2001              MOVS     r0,#1                 ;2624
00010a  e799              B        |L24.64|
                  |L24.268|
00010c  9801              LDR      r0,[sp,#4]            ;2627
00010e  61a0              STR      r0,[r4,#0x18]         ;2627
                  |L24.272|
000110  8920              LDRH     r0,[r4,#8]            ;2629
000112  f3c00008          UBFX     r0,r0,#0,#9           ;2629
000116  f5c07600          RSB      r6,r0,#0x200          ;2629
00011a  42ae              CMP      r6,r5                 ;2630
00011c  d900              BLS      |L24.288|
00011e  462e              MOV      r6,r5                 ;2630
                  |L24.288|
000120  1901              ADDS     r1,r0,r4              ;2636
000122  4632              MOV      r2,r6                 ;2636
000124  4640              MOV      r0,r8                 ;2636
000126  3128              ADDS     r1,r1,#0x28           ;2636
000128  f7fffffe          BL       mem_cpy
                  |L24.300|
00012c  68a0              LDR      r0,[r4,#8]            ;2575
00012e  44b0              ADD      r8,r8,r6              ;2575
000130  4430              ADD      r0,r0,r6              ;2575
000132  60a0              STR      r0,[r4,#8]            ;2575
000134  f8d90000          LDR      r0,[r9,#0]            ;2575
000138  1981              ADDS     r1,r0,r6              ;2575
00013a  1bad              SUBS     r5,r5,r6              ;2575
00013c  f8c91000          STR      r1,[r9,#0]            ;2575
                  |L24.320|
000140  2d00              CMP      r5,#0                 ;2574
000142  f47faf7f          BNE      |L24.68|
000146  2000              MOVS     r0,#0                 ;2640
000148  e77a              B        |L24.64|
;;;2642   
                          ENDP


                          AREA ||i.f_readdir||, CODE, READONLY, ALIGN=1

                  f_readdir PROC
;;;3239   
;;;3240   FRESULT f_readdir (
000000  b570              PUSH     {r4-r6,lr}
;;;3241   	DIR* dp,			/* Pointer to the open directory object */
;;;3242   	FILINFO* fno		/* Pointer to file information to return */
;;;3243   )
;;;3244   {
000002  f5ad7d04          SUB      sp,sp,#0x210
000006  460e              MOV      r6,r1
000008  4604              MOV      r4,r0
;;;3245   	FRESULT res;
;;;3246   	DEF_NAMEBUF;
;;;3247   
;;;3248   
;;;3249   	res = validate(dp);						/* Check validity of the object */
00000a  f7fffffe          BL       validate
;;;3250   	if (res == FR_OK) {
00000e  2800              CMP      r0,#0
000010  d119              BNE      |L25.70|
;;;3251   		if (!fno) {
000012  b1de              CBZ      r6,|L25.76|
;;;3252   			res = dir_sdi(dp, 0);			/* Rewind the directory object */
;;;3253   		} else {
;;;3254   			INIT_BUF(*dp);
000014  a880              ADD      r0,sp,#0x200
000016  61a0              STR      r0,[r4,#0x18]
000018  f8c4d020          STR      sp,[r4,#0x20]
;;;3255   			res = dir_read(dp, 0);			/* Read an item */
00001c  2100              MOVS     r1,#0
00001e  4620              MOV      r0,r4
000020  f7fffffe          BL       dir_read
000024  2500              MOVS     r5,#0
;;;3256   			if (res == FR_NO_FILE) {		/* Reached end of directory */
000026  2804              CMP      r0,#4
000028  d015              BEQ      |L25.86|
;;;3257   				dp->sect = 0;
;;;3258   				res = FR_OK;
;;;3259   			}
;;;3260   			if (res == FR_OK) {				/* A valid entry is found */
00002a  2800              CMP      r0,#0
00002c  d10b              BNE      |L25.70|
                  |L25.46|
;;;3261   				get_fileinfo(dp, fno);		/* Get the object information */
00002e  4631              MOV      r1,r6
000030  4620              MOV      r0,r4
000032  f7fffffe          BL       get_fileinfo
;;;3262   				res = dir_next(dp, 0);		/* Increment index for next */
000036  2100              MOVS     r1,#0
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       dir_next
;;;3263   				if (res == FR_NO_FILE) {
00003e  2804              CMP      r0,#4
000040  d101              BNE      |L25.70|
;;;3264   					dp->sect = 0;
;;;3265   					res = FR_OK;
000042  2000              MOVS     r0,#0
000044  6125              STR      r5,[r4,#0x10]
                  |L25.70|
;;;3266   				}
;;;3267   			}
;;;3268   			FREE_BUF();
;;;3269   		}
;;;3270   	}
;;;3271   
;;;3272   	LEAVE_FF(dp->fs, res);
;;;3273   }
000046  f50d7d04          ADD      sp,sp,#0x210
00004a  bd70              POP      {r4-r6,pc}
                  |L25.76|
00004c  2100              MOVS     r1,#0                 ;3252
00004e  4620              MOV      r0,r4                 ;3252
000050  f7fffffe          BL       dir_sdi
000054  e7f7              B        |L25.70|
                  |L25.86|
000056  6125              STR      r5,[r4,#0x10]         ;3258
000058  e7e9              B        |L25.46|
;;;3274   
                          ENDP


                          AREA ||i.f_rename||, CODE, READONLY, ALIGN=1

                  f_rename PROC
;;;3668   
;;;3669   FRESULT f_rename (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3670   	const TCHAR* path_old,	/* Pointer to the object to be renamed */
;;;3671   	const TCHAR* path_new	/* Pointer to the new name */
;;;3672   )
;;;3673   {
000002  f5ad7d1f          SUB      sp,sp,#0x27c
;;;3674   	FRESULT res;
;;;3675   	DIR djo, djn;
;;;3676   	BYTE buf[21], *dir;
;;;3677   	DWORD dw;
;;;3678   	DEF_NAMEBUF;
;;;3679   
;;;3680   
;;;3681   	/* Get logical drive number of the source object */
;;;3682   	res = find_volume(&djo.fs, &path_old, 1);
000006  2201              MOVS     r2,#1
000008  a99f              ADD      r1,sp,#0x27c
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       find_volume
;;;3683   	if (res == FR_OK) {
000010  2800              CMP      r0,#0
000012  d15f              BNE      |L26.212|
;;;3684   		djn.fs = djo.fs;
000014  9801              LDR      r0,[sp,#4]
;;;3685   		INIT_BUF(djo);
000016  900b              STR      r0,[sp,#0x2c]
000018  a89b              ADD      r0,sp,#0x26c
00001a  9007              STR      r0,[sp,#0x1c]
00001c  a815              ADD      r0,sp,#0x54
;;;3686   		res = follow_path(&djo, path_old);		/* Check old object */
00001e  9009              STR      r0,[sp,#0x24]
000020  a801              ADD      r0,sp,#4
000022  999f              LDR      r1,[sp,#0x27c]
000024  f7fffffe          BL       follow_path
;;;3687   		if (_FS_RPATH && res == FR_OK && (djo.fn[NS] & NS_DOT))
;;;3688   			res = FR_INVALID_NAME;
;;;3689   #if _FS_LOCK
;;;3690   		if (res == FR_OK) res = chk_lock(&djo, 2);
000028  2800              CMP      r0,#0
00002a  d153              BNE      |L26.212|
00002c  2102              MOVS     r1,#2
00002e  a801              ADD      r0,sp,#4
000030  f7fffffe          BL       chk_lock
000034  2800              CMP      r0,#0
000036  d14d              BNE      |L26.212|
;;;3691   #endif
;;;3692   		if (res == FR_OK) {						/* Old object is found */
;;;3693   			if (!djo.dir) {						/* Is root dir? */
000038  9806              LDR      r0,[sp,#0x18]
00003a  b3e8              CBZ      r0,|L26.184|
;;;3694   				res = FR_NO_FILE;
;;;3695   			} else {
;;;3696   				mem_cpy(buf, djo.dir+DIR_Attr, 21);		/* Save the object information except name */
00003c  f100010b          ADD      r1,r0,#0xb
000040  2215              MOVS     r2,#0x15
000042  a895              ADD      r0,sp,#0x254
000044  f7fffffe          BL       mem_cpy
;;;3697   				mem_cpy(&djn, &djo, sizeof (DIR));		/* Duplicate the directory object */
000048  2228              MOVS     r2,#0x28
00004a  a901              ADD      r1,sp,#4
00004c  a80b              ADD      r0,sp,#0x2c
00004e  f7fffffe          BL       mem_cpy
;;;3698   				if (get_ldnumber(&path_new) >= 0)		/* Snip drive number off and ignore it */
000052  a8a0              ADD      r0,sp,#0x280
000054  f7fffffe          BL       get_ldnumber
000058  2800              CMP      r0,#0
00005a  db3e              BLT      |L26.218|
;;;3699   					res = follow_path(&djn, path_new);	/* and check if new object is exist */
00005c  a80b              ADD      r0,sp,#0x2c
00005e  99a0              LDR      r1,[sp,#0x280]
000060  f7fffffe          BL       follow_path
000064  b348              CBZ      r0,|L26.186|
;;;3700   				else
;;;3701   					res = FR_INVALID_DRIVE;
;;;3702   				if (res == FR_OK) res = FR_EXIST;		/* The new object name is already existing */
;;;3703   				if (res == FR_NO_FILE) { 				/* Is it a valid path and no name collision? */
000066  2804              CMP      r0,#4
000068  d134              BNE      |L26.212|
;;;3704   /* Start critical section that any interruption can cause a cross-link */
;;;3705   					res = dir_register(&djn);			/* Register the new entry */
00006a  a80b              ADD      r0,sp,#0x2c
00006c  f7fffffe          BL       dir_register
;;;3706   					if (res == FR_OK) {
000070  2800              CMP      r0,#0
000072  d12f              BNE      |L26.212|
;;;3707   						dir = djn.dir;					/* Copy object information except name */
;;;3708   						mem_cpy(dir+13, buf+2, 19);
000074  9c10              LDR      r4,[sp,#0x40]
000076  2213              MOVS     r2,#0x13
000078  f20d2156          ADD      r1,sp,#0x256
00007c  f104000d          ADD      r0,r4,#0xd
000080  f7fffffe          BL       mem_cpy
;;;3709   						dir[DIR_Attr] = buf[0] | AM_ARC;
000084  f89d0254          LDRB     r0,[sp,#0x254]
;;;3710   						djo.fs->wflag = 1;
000088  2501              MOVS     r5,#1
00008a  f0400020          ORR      r0,r0,#0x20           ;3709
00008e  72e0              STRB     r0,[r4,#0xb]          ;3709
000090  9801              LDR      r0,[sp,#4]
000092  7105              STRB     r5,[r0,#4]
;;;3711   						if (djo.sclust != djn.sclust && (dir[DIR_Attr] & AM_DIR)) {		/* Update .. entry in the directory if needed */
000094  990d              LDR      r1,[sp,#0x34]
000096  9803              LDR      r0,[sp,#0xc]
000098  4288              CMP      r0,r1
00009a  d035              BEQ      |L26.264|
00009c  7ae0              LDRB     r0,[r4,#0xb]
00009e  06c0              LSLS     r0,r0,#27
0000a0  d532              BPL      |L26.264|
;;;3712   							dw = clust2sect(djo.fs, ld_clust(djo.fs, dir));
0000a2  4621              MOV      r1,r4
0000a4  9801              LDR      r0,[sp,#4]
0000a6  f7fffffe          BL       ld_clust
0000aa  4601              MOV      r1,r0
0000ac  9801              LDR      r0,[sp,#4]
0000ae  f7fffffe          BL       clust2sect
0000b2  0001              MOVS     r1,r0
;;;3713   							if (!dw) {
0000b4  d015              BEQ      |L26.226|
;;;3714   								res = FR_INT_ERR;
;;;3715   							} else {
;;;3716   								res = move_window(djo.fs, dw);
0000b6  e001              B        |L26.188|
                  |L26.184|
0000b8  e00b              B        |L26.210|
                  |L26.186|
0000ba  e010              B        |L26.222|
                  |L26.188|
0000bc  9801              LDR      r0,[sp,#4]
0000be  f7fffffe          BL       move_window
;;;3717   								dir = djo.fs->win+SZ_DIR;	/* .. entry */
0000c2  9a01              LDR      r2,[sp,#4]
0000c4  3250              ADDS     r2,r2,#0x50
;;;3718   								if (res == FR_OK && dir[1] == '.') {
0000c6  2800              CMP      r0,#0
0000c8  d104              BNE      |L26.212|
0000ca  7850              LDRB     r0,[r2,#1]
0000cc  282e              CMP      r0,#0x2e
0000ce  d00a              BEQ      |L26.230|
0000d0  e01a              B        |L26.264|
                  |L26.210|
0000d2  2004              MOVS     r0,#4                 ;3694
                  |L26.212|
;;;3719   									dw = (djo.fs->fs_type == FS_FAT32 && djn.sclust == djo.fs->dirbase) ? 0 : djn.sclust;
;;;3720   									st_clust(dir, dw);
;;;3721   									djo.fs->wflag = 1;
;;;3722   								}
;;;3723   							}
;;;3724   						}
;;;3725   						if (res == FR_OK) {
;;;3726   							res = dir_remove(&djo);		/* Remove old entry */
;;;3727   							if (res == FR_OK)
;;;3728   								res = sync_fs(djo.fs);
;;;3729   						}
;;;3730   					}
;;;3731   /* End critical section */
;;;3732   				}
;;;3733   			}
;;;3734   		}
;;;3735   		FREE_BUF();
;;;3736   	}
;;;3737   
;;;3738   	LEAVE_FF(djo.fs, res);
;;;3739   }
0000d4  f50d7d21          ADD      sp,sp,#0x284
0000d8  bd30              POP      {r4,r5,pc}
                  |L26.218|
0000da  200b              MOVS     r0,#0xb               ;3701
0000dc  e7fa              B        |L26.212|
                  |L26.222|
0000de  2008              MOVS     r0,#8                 ;3702
0000e0  e7f8              B        |L26.212|
                  |L26.226|
0000e2  2002              MOVS     r0,#2                 ;3714
0000e4  e7f6              B        |L26.212|
                  |L26.230|
0000e6  9801              LDR      r0,[sp,#4]            ;3719
0000e8  7800              LDRB     r0,[r0,#0]            ;3719
0000ea  2803              CMP      r0,#3                 ;3719
0000ec  d106              BNE      |L26.252|
0000ee  9901              LDR      r1,[sp,#4]            ;3719
0000f0  980d              LDR      r0,[sp,#0x34]         ;3719
0000f2  6a49              LDR      r1,[r1,#0x24]         ;3719
0000f4  4288              CMP      r0,r1                 ;3719
0000f6  d101              BNE      |L26.252|
0000f8  2100              MOVS     r1,#0                 ;3719
0000fa  e000              B        |L26.254|
                  |L26.252|
0000fc  990d              LDR      r1,[sp,#0x34]         ;3719
                  |L26.254|
0000fe  4610              MOV      r0,r2                 ;3720
000100  f7fffffe          BL       st_clust
000104  9801              LDR      r0,[sp,#4]            ;3721
000106  7105              STRB     r5,[r0,#4]            ;3721
                  |L26.264|
000108  a801              ADD      r0,sp,#4              ;3726
00010a  f7fffffe          BL       dir_remove
00010e  2800              CMP      r0,#0                 ;3727
000110  d1e0              BNE      |L26.212|
000112  9801              LDR      r0,[sp,#4]            ;3728
000114  f7fffffe          BL       sync_fs
000118  e7dc              B        |L26.212|
;;;3740   
                          ENDP


                          AREA ||i.f_stat||, CODE, READONLY, ALIGN=1

                  f_stat PROC
;;;3281   
;;;3282   FRESULT f_stat (
000000  b533              PUSH     {r0,r1,r4,r5,lr}
;;;3283   	const TCHAR* path,	/* Pointer to the file path */
;;;3284   	FILINFO* fno		/* Pointer to file information to return */
;;;3285   )
;;;3286   {
000002  f5ad7d0d          SUB      sp,sp,#0x234
000006  460d              MOV      r5,r1
;;;3287   	FRESULT res;
;;;3288   	DIR dj;
;;;3289   	DEF_NAMEBUF;
;;;3290   
;;;3291   
;;;3292   	/* Get logical drive number */
;;;3293   	res = find_volume(&dj.fs, &path, 0);
000008  2200              MOVS     r2,#0
00000a  a98d              ADD      r1,sp,#0x234
00000c  a880              ADD      r0,sp,#0x200
00000e  f7fffffe          BL       find_volume
000012  0004              MOVS     r4,r0
;;;3294   	if (res == FR_OK) {
000014  d112              BNE      |L27.60|
;;;3295   		INIT_BUF(dj);
000016  a88a              ADD      r0,sp,#0x228
000018  9086              STR      r0,[sp,#0x218]
00001a  f8cdd220          STR      sp,[sp,#0x220]
;;;3296   		res = follow_path(&dj, path);	/* Follow the file path */
00001e  a880              ADD      r0,sp,#0x200
000020  998d              LDR      r1,[sp,#0x234]
000022  f7fffffe          BL       follow_path
000026  0004              MOVS     r4,r0
;;;3297   		if (res == FR_OK) {				/* Follow completed */
000028  d108              BNE      |L27.60|
;;;3298   			if (dj.dir) {		/* Found an object */
00002a  9885              LDR      r0,[sp,#0x214]
00002c  b128              CBZ      r0,|L27.58|
;;;3299   				if (fno) get_fileinfo(&dj, fno);
00002e  b12d              CBZ      r5,|L27.60|
000030  4629              MOV      r1,r5
000032  a880              ADD      r0,sp,#0x200
000034  f7fffffe          BL       get_fileinfo
000038  e000              B        |L27.60|
                  |L27.58|
;;;3300   			} else {			/* It is root directory */
;;;3301   				res = FR_INVALID_NAME;
00003a  2406              MOVS     r4,#6
                  |L27.60|
;;;3302   			}
;;;3303   		}
;;;3304   		FREE_BUF();
;;;3305   	}
;;;3306   
;;;3307   	LEAVE_FF(dj.fs, res);
;;;3308   }
00003c  f50d7d0f          ADD      sp,sp,#0x23c
000040  4620              MOV      r0,r4                 ;3307
000042  bd30              POP      {r4,r5,pc}
;;;3309   
                          ENDP


                          AREA ||i.f_sync||, CODE, READONLY, ALIGN=1

                  f_sync PROC
;;;2772   
;;;2773   FRESULT f_sync (
000000  b570              PUSH     {r4-r6,lr}
;;;2774   	FIL* fp		/* Pointer to the file object */
;;;2775   )
;;;2776   {
000002  4604              MOV      r4,r0
;;;2777   	FRESULT res;
;;;2778   	DWORD tm;
;;;2779   	BYTE *dir;
;;;2780   
;;;2781   
;;;2782   	res = validate(fp);					/* Check validity of the object */
000004  f7fffffe          BL       validate
;;;2783   	if (res == FR_OK) {
000008  2800              CMP      r0,#0
00000a  d10e              BNE      |L28.42|
;;;2784   		if (fp->flag & FA__WRITTEN) {	/* Has the file been written? */
00000c  79a1              LDRB     r1,[r4,#6]
00000e  068a              LSLS     r2,r1,#26
000010  d50b              BPL      |L28.42|
;;;2785   			/* Write-back dirty buffer */
;;;2786   #if !_FS_TINY
;;;2787   			if (fp->flag & FA__DIRTY) {
000012  0648              LSLS     r0,r1,#25
000014  d50e              BPL      |L28.52|
;;;2788   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
000016  6820              LDR      r0,[r4,#0]
000018  2301              MOVS     r3,#1
00001a  f1040128          ADD      r1,r4,#0x28
00001e  7840              LDRB     r0,[r0,#1]
000020  69a2              LDR      r2,[r4,#0x18]
000022  f7fffffe          BL       disk_write
000026  b108              CBZ      r0,|L28.44|
;;;2789   					LEAVE_FF(fp->fs, FR_DISK_ERR);
000028  2001              MOVS     r0,#1
                  |L28.42|
;;;2790   				fp->flag &= ~FA__DIRTY;
;;;2791   			}
;;;2792   #endif
;;;2793   			/* Update the directory entry */
;;;2794   			res = move_window(fp->fs, fp->dir_sect);
;;;2795   			if (res == FR_OK) {
;;;2796   				dir = fp->dir_ptr;
;;;2797   				dir[DIR_Attr] |= AM_ARC;					/* Set archive bit */
;;;2798   				ST_DWORD(dir+DIR_FileSize, fp->fsize);		/* Update file size */
;;;2799   				st_clust(dir, fp->sclust);					/* Update start cluster */
;;;2800   				tm = get_fattime();							/* Update updated time */
;;;2801   				ST_DWORD(dir+DIR_WrtTime, tm);
;;;2802   				ST_WORD(dir+DIR_LstAccDate, 0);
;;;2803   				fp->flag &= ~FA__WRITTEN;
;;;2804   				fp->fs->wflag = 1;
;;;2805   				res = sync_fs(fp->fs);
;;;2806   			}
;;;2807   		}
;;;2808   	}
;;;2809   
;;;2810   	LEAVE_FF(fp->fs, res);
;;;2811   }
00002a  bd70              POP      {r4-r6,pc}
                  |L28.44|
00002c  79a0              LDRB     r0,[r4,#6]            ;2790
00002e  f0200040          BIC      r0,r0,#0x40           ;2790
000032  71a0              STRB     r0,[r4,#6]            ;2790
                  |L28.52|
000034  69e1              LDR      r1,[r4,#0x1c]         ;2794
000036  6820              LDR      r0,[r4,#0]            ;2794
000038  f7fffffe          BL       move_window
00003c  2800              CMP      r0,#0                 ;2795
00003e  d1f4              BNE      |L28.42|
000040  6a25              LDR      r5,[r4,#0x20]         ;2797
000042  7ae8              LDRB     r0,[r5,#0xb]          ;2797
000044  f0400020          ORR      r0,r0,#0x20           ;2797
000048  72e8              STRB     r0,[r5,#0xb]          ;2797
00004a  7b20              LDRB     r0,[r4,#0xc]          ;2798
00004c  7728              STRB     r0,[r5,#0x1c]         ;2798
00004e  89a0              LDRH     r0,[r4,#0xc]          ;2798
000050  0a00              LSRS     r0,r0,#8              ;2798
000052  7768              STRB     r0,[r5,#0x1d]         ;2798
000054  68e0              LDR      r0,[r4,#0xc]          ;2798
000056  0c00              LSRS     r0,r0,#16             ;2798
000058  77a8              STRB     r0,[r5,#0x1e]         ;2798
00005a  68e0              LDR      r0,[r4,#0xc]          ;2798
00005c  0e00              LSRS     r0,r0,#24             ;2798
00005e  77e8              STRB     r0,[r5,#0x1f]         ;2798
000060  4628              MOV      r0,r5                 ;2799
000062  6921              LDR      r1,[r4,#0x10]         ;2799
000064  f7fffffe          BL       st_clust
000068  f7fffffe          BL       get_fattime
00006c  75a8              STRB     r0,[r5,#0x16]         ;2801
00006e  0a01              LSRS     r1,r0,#8              ;2801
000070  75e9              STRB     r1,[r5,#0x17]         ;2801
000072  0c01              LSRS     r1,r0,#16             ;2801
000074  7629              STRB     r1,[r5,#0x18]         ;2801
000076  0e00              LSRS     r0,r0,#24             ;2801
000078  7668              STRB     r0,[r5,#0x19]         ;2801
00007a  2000              MOVS     r0,#0                 ;2802
00007c  74a8              STRB     r0,[r5,#0x12]         ;2802
00007e  74e8              STRB     r0,[r5,#0x13]         ;2802
000080  79a0              LDRB     r0,[r4,#6]            ;2803
000082  f0200020          BIC      r0,r0,#0x20           ;2803
000086  71a0              STRB     r0,[r4,#6]            ;2803
000088  6821              LDR      r1,[r4,#0]            ;2804
00008a  2001              MOVS     r0,#1                 ;2804
00008c  7108              STRB     r0,[r1,#4]            ;2804
00008e  6820              LDR      r0,[r4,#0]            ;2805
000090  e8bd4070          POP      {r4-r6,lr}            ;2805
000094  f7ffbffe          B.W      sync_fs
;;;2812   
                          ENDP


                          AREA ||i.f_truncate||, CODE, READONLY, ALIGN=1

                  f_truncate PROC
;;;3383   
;;;3384   FRESULT f_truncate (
000000  b570              PUSH     {r4-r6,lr}
;;;3385   	FIL* fp		/* Pointer to the file object */
;;;3386   )
;;;3387   {
000002  4604              MOV      r4,r0
;;;3388   	FRESULT res;
;;;3389   	DWORD ncl;
;;;3390   
;;;3391   
;;;3392   	res = validate(fp);						/* Check validity of the object */
000004  f7fffffe          BL       validate
000008  0005              MOVS     r5,r0
;;;3393   	if (res == FR_OK) {
00000a  d13d              BNE      |L29.136|
;;;3394   		if (fp->err) {						/* Check error */
00000c  79e0              LDRB     r0,[r4,#7]
00000e  b118              CBZ      r0,|L29.24|
;;;3395   			res = (FRESULT)fp->err;
000010  4605              MOV      r5,r0
;;;3396   		} else {
;;;3397   			if (!(fp->flag & FA_WRITE))		/* Check access mode */
;;;3398   				res = FR_DENIED;
;;;3399   		}
;;;3400   	}
;;;3401   	if (res == FR_OK) {
000012  0028              MOVS     r0,r5
000014  d005              BEQ      |L29.34|
000016  e037              B        |L29.136|
                  |L29.24|
000018  79a0              LDRB     r0,[r4,#6]            ;3397
00001a  0780              LSLS     r0,r0,#30             ;3397
00001c  d401              BMI      |L29.34|
00001e  2507              MOVS     r5,#7                 ;3398
000020  e032              B        |L29.136|
                  |L29.34|
000022  e9d40102          LDRD     r0,r1,[r4,#8]         ;3398
;;;3402   		if (fp->fsize > fp->fptr) {
000026  4281              CMP      r1,r0
000028  d92e              BLS      |L29.136|
;;;3403   			fp->fsize = fp->fptr;	/* Set file size to current R/W point */
;;;3404   			fp->flag |= FA__WRITTEN;
00002a  60e0              STR      r0,[r4,#0xc]
00002c  79a1              LDRB     r1,[r4,#6]
00002e  f0410120          ORR      r1,r1,#0x20
000032  71a1              STRB     r1,[r4,#6]
;;;3405   			if (fp->fptr == 0) {	/* When set file size to zero, remove entire cluster chain */
000034  b150              CBZ      r0,|L29.76|
;;;3406   				res = remove_chain(fp->fs, fp->sclust);
;;;3407   				fp->sclust = 0;
;;;3408   			} else {				/* When truncate a part of the file, remove remaining clusters */
;;;3409   				ncl = get_fat(fp->fs, fp->clust);
000036  6961              LDR      r1,[r4,#0x14]
000038  6820              LDR      r0,[r4,#0]
00003a  f7fffffe          BL       get_fat
00003e  4606              MOV      r6,r0
;;;3410   				res = FR_OK;
;;;3411   				if (ncl == 0xFFFFFFFF) res = FR_DISK_ERR;
000040  1c40              ADDS     r0,r0,#1
000042  d00b              BEQ      |L29.92|
;;;3412   				if (ncl == 1) res = FR_INT_ERR;
000044  2e01              CMP      r6,#1
000046  d00b              BEQ      |L29.96|
;;;3413   				if (res == FR_OK && ncl < fp->fs->n_fatent) {
000048  b165              CBZ      r5,|L29.100|
00004a  e01c              B        |L29.134|
                  |L29.76|
00004c  6921              LDR      r1,[r4,#0x10]         ;3406
00004e  6820              LDR      r0,[r4,#0]            ;3406
000050  f7fffffe          BL       remove_chain
000054  4605              MOV      r5,r0                 ;3406
000056  2000              MOVS     r0,#0                 ;3407
000058  6120              STR      r0,[r4,#0x10]         ;3407
00005a  e013              B        |L29.132|
                  |L29.92|
00005c  2501              MOVS     r5,#1                 ;3411
00005e  e012              B        |L29.134|
                  |L29.96|
000060  2502              MOVS     r5,#2                 ;3412
000062  e010              B        |L29.134|
                  |L29.100|
000064  6820              LDR      r0,[r4,#0]
000066  6941              LDR      r1,[r0,#0x14]
000068  42b1              CMP      r1,r6
00006a  d90f              BLS      |L29.140|
;;;3414   					res = put_fat(fp->fs, fp->clust, 0x0FFFFFFF);
00006c  f06f4270          MVN      r2,#0xf0000000
000070  6961              LDR      r1,[r4,#0x14]
000072  f7fffffe          BL       put_fat
000076  0005              MOVS     r5,r0
;;;3415   					if (res == FR_OK) res = remove_chain(fp->fs, ncl);
000078  d105              BNE      |L29.134|
00007a  4631              MOV      r1,r6
00007c  6820              LDR      r0,[r4,#0]
00007e  f7fffffe          BL       remove_chain
000082  4605              MOV      r5,r0
                  |L29.132|
;;;3416   				}
;;;3417   			}
;;;3418   #if !_FS_TINY
;;;3419   			if (res == FR_OK && (fp->flag & FA__DIRTY)) {
000084  b115              CBZ      r5,|L29.140|
                  |L29.134|
;;;3420   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;;;3421   					res = FR_DISK_ERR;
;;;3422   				else
;;;3423   					fp->flag &= ~FA__DIRTY;
;;;3424   			}
;;;3425   #endif
;;;3426   		}
;;;3427   		if (res != FR_OK) fp->err = (FRESULT)res;
000086  71e5              STRB     r5,[r4,#7]
                  |L29.136|
;;;3428   	}
;;;3429   
;;;3430   	LEAVE_FF(fp->fs, res);
000088  4628              MOV      r0,r5
;;;3431   }
00008a  bd70              POP      {r4-r6,pc}
                  |L29.140|
00008c  79a0              LDRB     r0,[r4,#6]            ;3419
00008e  0640              LSLS     r0,r0,#25             ;3419
000090  d5fa              BPL      |L29.136|
000092  6820              LDR      r0,[r4,#0]            ;3420
000094  2301              MOVS     r3,#1                 ;3420
000096  f1040128          ADD      r1,r4,#0x28           ;3420
00009a  7840              LDRB     r0,[r0,#1]            ;3420
00009c  69a2              LDR      r2,[r4,#0x18]         ;3420
00009e  f7fffffe          BL       disk_write
0000a2  2800              CMP      r0,#0                 ;3420
0000a4  d1da              BNE      |L29.92|
0000a6  79a0              LDRB     r0,[r4,#6]            ;3423
0000a8  f0200040          BIC      r0,r0,#0x40           ;3423
0000ac  71a0              STRB     r0,[r4,#6]            ;3423
0000ae  e7eb              B        |L29.136|
;;;3432   
                          ENDP


                          AREA ||i.f_unlink||, CODE, READONLY, ALIGN=1

                  f_unlink PROC
;;;3439   
;;;3440   FRESULT f_unlink (
000000  b571              PUSH     {r0,r4-r6,lr}
;;;3441   	const TCHAR* path		/* Pointer to the file or directory path */
;;;3442   )
;;;3443   {
000002  f5ad7d1b          SUB      sp,sp,#0x26c
;;;3444   	FRESULT res;
;;;3445   	DIR dj, sdj;
;;;3446   	BYTE *dir;
;;;3447   	DWORD dclst;
;;;3448   	DEF_NAMEBUF;
;;;3449   
;;;3450   
;;;3451   	/* Get logical drive number */
;;;3452   	res = find_volume(&dj.fs, &path, 1);
000006  2201              MOVS     r2,#1
000008  a99b              ADD      r1,sp,#0x26c
00000a  a801              ADD      r0,sp,#4
00000c  f7fffffe          BL       find_volume
000010  0004              MOVS     r4,r0
;;;3453   	if (res == FR_OK) {
000012  d14c              BNE      |L30.174|
;;;3454   		INIT_BUF(dj);
000014  a897              ADD      r0,sp,#0x25c
000016  9007              STR      r0,[sp,#0x1c]
000018  a80b              ADD      r0,sp,#0x2c
;;;3455   		res = follow_path(&dj, path);		/* Follow the file path */
00001a  9009              STR      r0,[sp,#0x24]
00001c  a801              ADD      r0,sp,#4
00001e  999b              LDR      r1,[sp,#0x26c]
000020  f7fffffe          BL       follow_path
000024  0004              MOVS     r4,r0
;;;3456   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3457   			res = FR_INVALID_NAME;			/* Cannot remove dot entry */
;;;3458   #if _FS_LOCK
;;;3459   		if (res == FR_OK) res = chk_lock(&dj, 2);	/* Cannot remove open file */
000026  d142              BNE      |L30.174|
000028  2102              MOVS     r1,#2
00002a  a801              ADD      r0,sp,#4
00002c  f7fffffe          BL       chk_lock
000030  0004              MOVS     r4,r0
000032  d13c              BNE      |L30.174|
;;;3460   #endif
;;;3461   		if (res == FR_OK) {					/* The object is accessible */
;;;3462   			dir = dj.dir;
;;;3463   			if (!dir) {
000034  9e06              LDR      r6,[sp,#0x18]
000036  b156              CBZ      r6,|L30.78|
;;;3464   				res = FR_INVALID_NAME;		/* Cannot remove the start directory */
;;;3465   			} else {
;;;3466   				if (dir[DIR_Attr] & AM_RDO)
000038  7af0              LDRB     r0,[r6,#0xb]
00003a  07c0              LSLS     r0,r0,#31
00003c  d000              BEQ      |L30.64|
;;;3467   					res = FR_DENIED;		/* Cannot remove R/O object */
00003e  2407              MOVS     r4,#7
                  |L30.64|
;;;3468   			}
;;;3469   			dclst = ld_clust(dj.fs, dir);
000040  4631              MOV      r1,r6
000042  9801              LDR      r0,[sp,#4]
000044  f7fffffe          BL       ld_clust
000048  4605              MOV      r5,r0
;;;3470   			if (res == FR_OK && (dir[DIR_Attr] & AM_DIR)) {	/* Is it a sub-dir? */
00004a  b114              CBZ      r4,|L30.82|
00004c  e02f              B        |L30.174|
                  |L30.78|
00004e  2406              MOVS     r4,#6                 ;3464
000050  e7f6              B        |L30.64|
                  |L30.82|
000052  7af0              LDRB     r0,[r6,#0xb]
000054  06c0              LSLS     r0,r0,#27
000056  d51a              BPL      |L30.142|
;;;3471   				if (dclst < 2) {
000058  2d02              CMP      r5,#2
00005a  d201              BCS      |L30.96|
;;;3472   					res = FR_INT_ERR;
00005c  2402              MOVS     r4,#2
00005e  e026              B        |L30.174|
                  |L30.96|
;;;3473   				} else {
;;;3474   					mem_cpy(&sdj, &dj, sizeof (DIR));	/* Check if the sub-directory is empty or not */
000060  2228              MOVS     r2,#0x28
000062  a901              ADD      r1,sp,#4
000064  a88d              ADD      r0,sp,#0x234
000066  f7fffffe          BL       mem_cpy
;;;3475   					sdj.sclust = dclst;
;;;3476   					res = dir_sdi(&sdj, 2);		/* Exclude dot entries */
00006a  2102              MOVS     r1,#2
00006c  a88d              ADD      r0,sp,#0x234
00006e  958f              STR      r5,[sp,#0x23c]
000070  f7fffffe          BL       dir_sdi
000074  0004              MOVS     r4,r0
;;;3477   					if (res == FR_OK) {
000076  d11a              BNE      |L30.174|
;;;3478   						res = dir_read(&sdj, 0);	/* Read an item */
000078  2100              MOVS     r1,#0
00007a  a88d              ADD      r0,sp,#0x234
00007c  f7fffffe          BL       dir_read
000080  0004              MOVS     r4,r0
;;;3479   						if (res == FR_OK		/* Not empty directory */
000082  d002              BEQ      |L30.138|
;;;3480   #if _FS_RPATH
;;;3481   						|| dclst == dj.fs->cdir	/* Current directory */
;;;3482   #endif
;;;3483   						) res = FR_DENIED;
;;;3484   						if (res == FR_NO_FILE) res = FR_OK;	/* Empty */
000084  2c04              CMP      r4,#4
000086  d002              BEQ      |L30.142|
000088  e011              B        |L30.174|
                  |L30.138|
00008a  2407              MOVS     r4,#7                 ;3483
00008c  e00f              B        |L30.174|
                  |L30.142|
;;;3485   					}
;;;3486   				}
;;;3487   			}
;;;3488   			if (res == FR_OK) {
;;;3489   				res = dir_remove(&dj);		/* Remove the directory entry */
00008e  a801              ADD      r0,sp,#4
000090  f7fffffe          BL       dir_remove
000094  0004              MOVS     r4,r0
;;;3490   				if (res == FR_OK) {
000096  d10a              BNE      |L30.174|
;;;3491   					if (dclst)				/* Remove the cluster chain if exist */
000098  b12d              CBZ      r5,|L30.166|
;;;3492   						res = remove_chain(dj.fs, dclst);
00009a  4629              MOV      r1,r5
00009c  9801              LDR      r0,[sp,#4]
00009e  f7fffffe          BL       remove_chain
0000a2  0004              MOVS     r4,r0
0000a4  d103              BNE      |L30.174|
                  |L30.166|
;;;3493   					if (res == FR_OK) res = sync_fs(dj.fs);
0000a6  9801              LDR      r0,[sp,#4]
0000a8  f7fffffe          BL       sync_fs
0000ac  4604              MOV      r4,r0
                  |L30.174|
;;;3494   				}
;;;3495   			}
;;;3496   		}
;;;3497   		FREE_BUF();
;;;3498   	}
;;;3499   
;;;3500   	LEAVE_FF(dj.fs, res);
;;;3501   }
0000ae  f50d7d1c          ADD      sp,sp,#0x270
0000b2  4620              MOV      r0,r4                 ;3500
0000b4  bd70              POP      {r4-r6,pc}
;;;3502   
                          ENDP


                          AREA ||i.f_utime||, CODE, READONLY, ALIGN=1

                  f_utime PROC
;;;3626   
;;;3627   FRESULT f_utime (
000000  b513              PUSH     {r0,r1,r4,lr}
;;;3628   	const TCHAR* path,	/* Pointer to the file/directory name */
;;;3629   	const FILINFO* fno	/* Pointer to the time stamp to be set */
;;;3630   )
;;;3631   {
000002  f5ad7d0e          SUB      sp,sp,#0x238
000006  460c              MOV      r4,r1
;;;3632   	FRESULT res;
;;;3633   	DIR dj;
;;;3634   	BYTE *dir;
;;;3635   	DEF_NAMEBUF;
;;;3636   
;;;3637   
;;;3638   	/* Get logical drive number */
;;;3639   	res = find_volume(&dj.fs, &path, 1);
000008  2201              MOVS     r2,#1
00000a  a98e              ADD      r1,sp,#0x238
00000c  a880              ADD      r0,sp,#0x200
00000e  f7fffffe          BL       find_volume
;;;3640   	if (res == FR_OK) {
000012  2800              CMP      r0,#0
000014  d11b              BNE      |L31.78|
;;;3641   		INIT_BUF(dj);
000016  a88a              ADD      r0,sp,#0x228
000018  9086              STR      r0,[sp,#0x218]
00001a  f8cdd220          STR      sp,[sp,#0x220]
;;;3642   		res = follow_path(&dj, path);	/* Follow the file path */
00001e  a880              ADD      r0,sp,#0x200
000020  998e              LDR      r1,[sp,#0x238]
000022  f7fffffe          BL       follow_path
;;;3643   		FREE_BUF();
;;;3644   		if (_FS_RPATH && res == FR_OK && (dj.fn[NS] & NS_DOT))
;;;3645   			res = FR_INVALID_NAME;
;;;3646   		if (res == FR_OK) {
000026  2800              CMP      r0,#0
000028  d111              BNE      |L31.78|
;;;3647   			dir = dj.dir;
;;;3648   			if (!dir) {					/* Root directory */
00002a  9885              LDR      r0,[sp,#0x214]
00002c  b190              CBZ      r0,|L31.84|
;;;3649   				res = FR_INVALID_NAME;
;;;3650   			} else {					/* File or sub-directory */
;;;3651   				ST_WORD(dir+DIR_WrtTime, fno->ftime);
00002e  79a1              LDRB     r1,[r4,#6]
000030  7581              STRB     r1,[r0,#0x16]
000032  88e1              LDRH     r1,[r4,#6]
000034  0a09              LSRS     r1,r1,#8
000036  75c1              STRB     r1,[r0,#0x17]
;;;3652   				ST_WORD(dir+DIR_WrtDate, fno->fdate);
000038  7921              LDRB     r1,[r4,#4]
00003a  7601              STRB     r1,[r0,#0x18]
00003c  88a1              LDRH     r1,[r4,#4]
00003e  0a09              LSRS     r1,r1,#8
000040  7641              STRB     r1,[r0,#0x19]
;;;3653   				dj.fs->wflag = 1;
000042  9980              LDR      r1,[sp,#0x200]
000044  2001              MOVS     r0,#1
000046  7108              STRB     r0,[r1,#4]
;;;3654   				res = sync_fs(dj.fs);
000048  9880              LDR      r0,[sp,#0x200]
00004a  f7fffffe          BL       sync_fs
                  |L31.78|
;;;3655   			}
;;;3656   		}
;;;3657   	}
;;;3658   
;;;3659   	LEAVE_FF(dj.fs, res);
;;;3660   }
00004e  f50d7d10          ADD      sp,sp,#0x240
000052  bd10              POP      {r4,pc}
                  |L31.84|
000054  2006              MOVS     r0,#6                 ;3649
000056  e7fa              B        |L31.78|
;;;3661   
                          ENDP


                          AREA ||i.f_write||, CODE, READONLY, ALIGN=1

                  f_write PROC
;;;2650   
;;;2651   FRESULT f_write (
000000  e92d5ffc          PUSH     {r2-r12,lr}
;;;2652   	FIL* fp,			/* Pointer to the file object */
;;;2653   	const void *buff,	/* Pointer to the data to be written */
;;;2654   	UINT btw,			/* Number of bytes to write */
;;;2655   	UINT* bw			/* Pointer to number of bytes written */
;;;2656   )
;;;2657   {
;;;2658   	FRESULT res;
;;;2659   	DWORD clst, sect;
;;;2660   	UINT wcnt, cc;
;;;2661   	const BYTE *wbuff = (const BYTE*)buff;
000004  4688              MOV      r8,r1
;;;2662   	BYTE csect;
;;;2663   
;;;2664   
;;;2665   	*bw = 0;	/* Clear write byte counter */
000006  2100              MOVS     r1,#0
000008  4699              MOV      r9,r3                 ;2657
00000a  4615              MOV      r5,r2                 ;2657
00000c  4604              MOV      r4,r0                 ;2657
;;;2666   
;;;2667   	res = validate(fp);						/* Check validity */
00000e  6019              STR      r1,[r3,#0]
000010  f7fffffe          BL       validate
;;;2668   	if (res != FR_OK) LEAVE_FF(fp->fs, res);
000014  2800              CMP      r0,#0
000016  d106              BNE      |L32.38|
;;;2669   	if (fp->err)							/* Check error */
000018  79e0              LDRB     r0,[r4,#7]
00001a  2800              CMP      r0,#0
00001c  d103              BNE      |L32.38|
;;;2670   		LEAVE_FF(fp->fs, (FRESULT)fp->err);
;;;2671   	if (!(fp->flag & FA_WRITE))				/* Check access mode */
00001e  79a0              LDRB     r0,[r4,#6]
000020  0780              LSLS     r0,r0,#30
000022  d402              BMI      |L32.42|
;;;2672   		LEAVE_FF(fp->fs, FR_DENIED);
000024  2007              MOVS     r0,#7
                  |L32.38|
;;;2673   	if (fp->fptr + btw < fp->fptr) btw = 0;	/* File size cannot reach 4GB */
;;;2674   
;;;2675   	for ( ;  btw;							/* Repeat until all data written */
;;;2676   		wbuff += wcnt, fp->fptr += wcnt, *bw += wcnt, btw -= wcnt) {
;;;2677   		if ((fp->fptr % SS(fp->fs)) == 0) {	/* On the sector boundary? */
;;;2678   			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
;;;2679   			if (!csect) {					/* On the cluster boundary? */
;;;2680   				if (fp->fptr == 0) {		/* On the top of the file? */
;;;2681   					clst = fp->sclust;		/* Follow from the origin */
;;;2682   					if (clst == 0)			/* When no cluster is allocated, */
;;;2683   						clst = create_chain(fp->fs, 0);	/* Create a new cluster chain */
;;;2684   				} else {					/* Middle or end of the file */
;;;2685   #if _USE_FASTSEEK
;;;2686   					if (fp->cltbl)
;;;2687   						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
;;;2688   					else
;;;2689   #endif
;;;2690   						clst = create_chain(fp->fs, fp->clust);	/* Follow or stretch cluster chain on the FAT */
;;;2691   				}
;;;2692   				if (clst == 0) break;		/* Could not allocate a new cluster (disk full) */
;;;2693   				if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
;;;2694   				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
;;;2695   				fp->clust = clst;			/* Update current cluster */
;;;2696   				if (fp->sclust == 0) fp->sclust = clst;	/* Set start cluster if the first write */
;;;2697   			}
;;;2698   #if _FS_TINY
;;;2699   			if (fp->fs->winsect == fp->dsect && sync_window(fp->fs))	/* Write-back sector cache */
;;;2700   				ABORT(fp->fs, FR_DISK_ERR);
;;;2701   #else
;;;2702   			if (fp->flag & FA__DIRTY) {		/* Write-back sector cache */
;;;2703   				if (disk_write(fp->fs->drv, fp->buf, fp->dsect, 1))
;;;2704   					ABORT(fp->fs, FR_DISK_ERR);
;;;2705   				fp->flag &= ~FA__DIRTY;
;;;2706   			}
;;;2707   #endif
;;;2708   			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
;;;2709   			if (!sect) ABORT(fp->fs, FR_INT_ERR);
;;;2710   			sect += csect;
;;;2711   			cc = btw / SS(fp->fs);			/* When remaining bytes >= sector size, */
;;;2712   			if (cc) {						/* Write maximum contiguous sectors directly */
;;;2713   				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
;;;2714   					cc = fp->fs->csize - csect;
;;;2715   				if (disk_write(fp->fs->drv, wbuff, sect, cc))
;;;2716   					ABORT(fp->fs, FR_DISK_ERR);
;;;2717   #if _FS_MINIMIZE <= 2
;;;2718   #if _FS_TINY
;;;2719   				if (fp->fs->winsect - sect < cc) {	/* Refill sector cache if it gets invalidated by the direct write */
;;;2720   					mem_cpy(fp->fs->win, wbuff + ((fp->fs->winsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2721   					fp->fs->wflag = 0;
;;;2722   				}
;;;2723   #else
;;;2724   				if (fp->dsect - sect < cc) { /* Refill sector cache if it gets invalidated by the direct write */
;;;2725   					mem_cpy(fp->buf, wbuff + ((fp->dsect - sect) * SS(fp->fs)), SS(fp->fs));
;;;2726   					fp->flag &= ~FA__DIRTY;
;;;2727   				}
;;;2728   #endif
;;;2729   #endif
;;;2730   				wcnt = SS(fp->fs) * cc;		/* Number of bytes transferred */
;;;2731   				continue;
;;;2732   			}
;;;2733   #if _FS_TINY
;;;2734   			if (fp->fptr >= fp->fsize) {	/* Avoid silly cache filling at growing edge */
;;;2735   				if (sync_window(fp->fs)) ABORT(fp->fs, FR_DISK_ERR);
;;;2736   				fp->fs->winsect = sect;
;;;2737   			}
;;;2738   #else
;;;2739   			if (fp->dsect != sect) {		/* Fill sector cache with file data */
;;;2740   				if (fp->fptr < fp->fsize &&
;;;2741   					disk_read(fp->fs->drv, fp->buf, sect, 1))
;;;2742   						ABORT(fp->fs, FR_DISK_ERR);
;;;2743   			}
;;;2744   #endif
;;;2745   			fp->dsect = sect;
;;;2746   		}
;;;2747   		wcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));/* Put partial sector into file I/O buffer */
;;;2748   		if (wcnt > btw) wcnt = btw;
;;;2749   #if _FS_TINY
;;;2750   		if (move_window(fp->fs, fp->dsect))	/* Move sector window */
;;;2751   			ABORT(fp->fs, FR_DISK_ERR);
;;;2752   		mem_cpy(&fp->fs->win[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2753   		fp->fs->wflag = 1;
;;;2754   #else
;;;2755   		mem_cpy(&fp->buf[fp->fptr % SS(fp->fs)], wbuff, wcnt);	/* Fit partial sector */
;;;2756   		fp->flag |= FA__DIRTY;
;;;2757   #endif
;;;2758   	}
;;;2759   
;;;2760   	if (fp->fptr > fp->fsize) fp->fsize = fp->fptr;	/* Update file size if needed */
;;;2761   	fp->flag |= FA__WRITTEN;						/* Set file change flag */
;;;2762   
;;;2763   	LEAVE_FF(fp->fs, FR_OK);
;;;2764   }
000026  e8bd9ffc          POP      {r2-r12,pc}
                  |L32.42|
00002a  68a0              LDR      r0,[r4,#8]            ;2673
00002c  2701              MOVS     r7,#1                 ;2659
00002e  1942              ADDS     r2,r0,r5              ;2673
000030  f04f0a02          MOV      r10,#2                ;2693
000034  f1040b28          ADD      r11,r4,#0x28          ;2703
000038  4282              CMP      r2,r0                 ;2673
00003a  d372              BCC      |L32.290|
00003c  e091              B        |L32.354|
                  |L32.62|
00003e  68a0              LDR      r0,[r4,#8]            ;2677
000040  05c1              LSLS     r1,r0,#23             ;2677
000042  d172              BNE      |L32.298|
000044  6822              LDR      r2,[r4,#0]            ;2678
000046  7891              LDRB     r1,[r2,#2]            ;2678
000048  1e49              SUBS     r1,r1,#1              ;2678
00004a  ea012150          AND      r1,r1,r0,LSR #9       ;2678
00004e  f01106ff          ANDS     r6,r1,#0xff           ;2678
000052  d112              BNE      |L32.122|
000054  b108              CBZ      r0,|L32.90|
000056  6961              LDR      r1,[r4,#0x14]         ;2690
000058  e002              B        |L32.96|
                  |L32.90|
00005a  6920              LDR      r0,[r4,#0x10]         ;2682
00005c  b928              CBNZ     r0,|L32.106|
00005e  2100              MOVS     r1,#0                 ;2683
                  |L32.96|
000060  4610              MOV      r0,r2                 ;2683
000062  f7fffffe          BL       create_chain
000066  2800              CMP      r0,#0                 ;2692
000068  d07e              BEQ      |L32.360|
                  |L32.106|
00006a  2801              CMP      r0,#1                 ;2693
00006c  d02d              BEQ      |L32.202|
00006e  1c41              ADDS     r1,r0,#1              ;2694
000070  d054              BEQ      |L32.284|
000072  6160              STR      r0,[r4,#0x14]         ;2696
000074  6921              LDR      r1,[r4,#0x10]         ;2696
000076  b901              CBNZ     r1,|L32.122|
000078  6120              STR      r0,[r4,#0x10]         ;2696
                  |L32.122|
00007a  79a0              LDRB     r0,[r4,#6]            ;2702
00007c  0640              LSLS     r0,r0,#25             ;2702
00007e  d50b              BPL      |L32.152|
000080  6820              LDR      r0,[r4,#0]            ;2703
000082  2301              MOVS     r3,#1                 ;2703
000084  4659              MOV      r1,r11                ;2703
000086  7840              LDRB     r0,[r0,#1]            ;2703
000088  69a2              LDR      r2,[r4,#0x18]         ;2703
00008a  f7fffffe          BL       disk_write
00008e  bba0              CBNZ     r0,|L32.250|
000090  79a0              LDRB     r0,[r4,#6]            ;2705
000092  f0200040          BIC      r0,r0,#0x40           ;2705
000096  71a0              STRB     r0,[r4,#6]            ;2705
                  |L32.152|
000098  6961              LDR      r1,[r4,#0x14]         ;2708
00009a  6820              LDR      r0,[r4,#0]            ;2708
00009c  f7fffffe          BL       clust2sect
0000a0  b198              CBZ      r0,|L32.202|
0000a2  4430              ADD      r0,r0,r6              ;2710
0000a4  9001              STR      r0,[sp,#4]            ;2711
0000a6  0a68              LSRS     r0,r5,#9              ;2711
0000a8  9000              STR      r0,[sp,#0]            ;2712
0000aa  d027              BEQ      |L32.252|
0000ac  1832              ADDS     r2,r6,r0              ;2713
0000ae  6820              LDR      r0,[r4,#0]            ;2713
0000b0  7881              LDRB     r1,[r0,#2]            ;2713
0000b2  428a              CMP      r2,r1                 ;2713
0000b4  d901              BLS      |L32.186|
0000b6  1b89              SUBS     r1,r1,r6              ;2714
0000b8  9100              STR      r1,[sp,#0]            ;2714
                  |L32.186|
0000ba  e9dd3200          LDRD     r3,r2,[sp,#0]         ;2715
0000be  7840              LDRB     r0,[r0,#1]            ;2715
0000c0  4641              MOV      r1,r8                 ;2715
0000c2  f7fffffe          BL       disk_write
0000c6  b9c0              CBNZ     r0,|L32.250|
0000c8  e003              B        |L32.210|
                  |L32.202|
0000ca  f884a007          STRB     r10,[r4,#7]           ;2709
0000ce  2002              MOVS     r0,#2                 ;2709
0000d0  e7a9              B        |L32.38|
                  |L32.210|
0000d2  69a1              LDR      r1,[r4,#0x18]         ;2724
0000d4  9801              LDR      r0,[sp,#4]            ;2724
0000d6  1a08              SUBS     r0,r1,r0              ;2724
0000d8  9900              LDR      r1,[sp,#0]            ;2724
0000da  4288              CMP      r0,r1                 ;2724
0000dc  d20a              BCS      |L32.244|
0000de  eb082140          ADD      r1,r8,r0,LSL #9       ;2725
0000e2  f44f7200          MOV      r2,#0x200             ;2725
0000e6  4658              MOV      r0,r11                ;2725
0000e8  f7fffffe          BL       mem_cpy
0000ec  79a0              LDRB     r0,[r4,#6]            ;2726
0000ee  f0200040          BIC      r0,r0,#0x40           ;2726
0000f2  71a0              STRB     r0,[r4,#6]            ;2726
                  |L32.244|
0000f4  9800              LDR      r0,[sp,#0]            ;2730
0000f6  0246              LSLS     r6,r0,#9              ;2730
0000f8  e029              B        |L32.334|
                  |L32.250|
0000fa  e00f              B        |L32.284|
                  |L32.252|
0000fc  69a1              LDR      r1,[r4,#0x18]         ;2739
0000fe  9801              LDR      r0,[sp,#4]            ;2739
000100  4281              CMP      r1,r0                 ;2739
000102  d010              BEQ      |L32.294|
000104  e9d40102          LDRD     r0,r1,[r4,#8]         ;2739
000108  4288              CMP      r0,r1                 ;2740
00010a  d20c              BCS      |L32.294|
00010c  6820              LDR      r0,[r4,#0]            ;2741
00010e  2301              MOVS     r3,#1                 ;2741
000110  4659              MOV      r1,r11                ;2741
000112  7840              LDRB     r0,[r0,#1]            ;2741
000114  9a01              LDR      r2,[sp,#4]            ;2741
000116  f7fffffe          BL       disk_read
00011a  b120              CBZ      r0,|L32.294|
                  |L32.284|
00011c  71e7              STRB     r7,[r4,#7]            ;2742
00011e  2001              MOVS     r0,#1                 ;2742
000120  e781              B        |L32.38|
                  |L32.290|
000122  e021              B        |L32.360|
000124  e001              B        |L32.298|
                  |L32.294|
000126  9801              LDR      r0,[sp,#4]            ;2745
000128  61a0              STR      r0,[r4,#0x18]         ;2745
                  |L32.298|
00012a  8920              LDRH     r0,[r4,#8]            ;2747
00012c  f3c00008          UBFX     r0,r0,#0,#9           ;2747
000130  f5c07600          RSB      r6,r0,#0x200          ;2747
000134  42ae              CMP      r6,r5                 ;2748
000136  d900              BLS      |L32.314|
000138  462e              MOV      r6,r5                 ;2748
                  |L32.314|
00013a  4420              ADD      r0,r0,r4              ;2755
00013c  4632              MOV      r2,r6                 ;2755
00013e  4641              MOV      r1,r8                 ;2755
000140  3028              ADDS     r0,r0,#0x28           ;2755
000142  f7fffffe          BL       mem_cpy
000146  79a0              LDRB     r0,[r4,#6]            ;2756
000148  f0400040          ORR      r0,r0,#0x40           ;2756
00014c  71a0              STRB     r0,[r4,#6]            ;2756
                  |L32.334|
00014e  68a0              LDR      r0,[r4,#8]            ;2676
000150  44b0              ADD      r8,r8,r6              ;2676
000152  4430              ADD      r0,r0,r6              ;2676
000154  60a0              STR      r0,[r4,#8]            ;2676
000156  f8d90000          LDR      r0,[r9,#0]            ;2676
00015a  1981              ADDS     r1,r0,r6              ;2676
00015c  1bad              SUBS     r5,r5,r6              ;2676
00015e  f8c91000          STR      r1,[r9,#0]            ;2676
                  |L32.354|
000162  2d00              CMP      r5,#0                 ;2675
000164  f47faf6b          BNE      |L32.62|
                  |L32.360|
000168  e9d40102          LDRD     r0,r1,[r4,#8]         ;2675
00016c  4288              CMP      r0,r1                 ;2760
00016e  d900              BLS      |L32.370|
000170  60e0              STR      r0,[r4,#0xc]          ;2760
                  |L32.370|
000172  79a0              LDRB     r0,[r4,#6]            ;2761
000174  f0400020          ORR      r0,r0,#0x20           ;2761
000178  71a0              STRB     r0,[r4,#6]            ;2761
00017a  2000              MOVS     r0,#0                 ;2763
00017c  e753              B        |L32.38|
;;;2765   
                          ENDP


                          AREA ||i.find_volume||, CODE, READONLY, ALIGN=2

                  find_volume PROC
;;;2163   static
;;;2164   FRESULT find_volume (	/* FR_OK(0): successful, !=0: any error occurred */
000000  e92d47ff          PUSH     {r0-r10,lr}
;;;2165   	FATFS** rfs,		/* Pointer to pointer to the found file system object */
;;;2166   	const TCHAR** path,	/* Pointer to pointer to the path name (drive number) */
;;;2167   	BYTE wmode			/* !=0: Check write protection for write access */
;;;2168   )
;;;2169   {
;;;2170   	BYTE fmt;
;;;2171   	int vol;
;;;2172   	DSTATUS stat;
;;;2173   	DWORD bsect, fasize, tsect, sysect, nclst, szbfat;
;;;2174   	WORD nrsv;
;;;2175   	FATFS *fs;
;;;2176   
;;;2177   
;;;2178   	/* Get logical drive number from the path name */
;;;2179   	*rfs = 0;
000004  f04f0900          MOV      r9,#0
000008  4607              MOV      r7,r0                 ;2169
;;;2180   	vol = get_ldnumber(path);
00000a  f8c09000          STR      r9,[r0,#0]
00000e  4616              MOV      r6,r2                 ;2169
000010  4608              MOV      r0,r1
000012  f7fffffe          BL       get_ldnumber
000016  0005              MOVS     r5,r0
;;;2181   	if (vol < 0) return FR_INVALID_DRIVE;
000018  d503              BPL      |L33.34|
00001a  200b              MOVS     r0,#0xb
                  |L33.28|
;;;2182   
;;;2183   	/* Check if the file system object is valid or not */
;;;2184   	fs = FatFs[vol];					/* Get pointer to the file system object */
;;;2185   	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
;;;2186   
;;;2187   	ENTER_FF(fs);						/* Lock the volume */
;;;2188   	*rfs = fs;							/* Return pointer to the file system object */
;;;2189   
;;;2190   	if (fs->fs_type) {					/* If the volume has been mounted */
;;;2191   		stat = disk_status(fs->drv);
;;;2192   		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized */
;;;2193   			if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check write protection if needed */
;;;2194   				return FR_WRITE_PROTECTED;
;;;2195   			return FR_OK;				/* The file system object is valid */
;;;2196   		}
;;;2197   	}
;;;2198   
;;;2199   	/* The file system object is not valid. */
;;;2200   	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */
;;;2201   
;;;2202   	fs->fs_type = 0;					/* Clear the file system object */
;;;2203   	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
;;;2204   	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
;;;2205   	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
;;;2206   		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
;;;2207   	if (!_FS_READONLY && wmode && (stat & STA_PROTECT))	/* Check disk write protection if needed */
;;;2208   		return FR_WRITE_PROTECTED;
;;;2209   #if _MAX_SS != _MIN_SS						/* Get sector size (multiple sector size cfg only) */
;;;2210   	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &SS(fs)) != RES_OK
;;;2211   		|| SS(fs) < _MIN_SS || SS(fs) > _MAX_SS) return FR_DISK_ERR;
;;;2212   #endif
;;;2213   	/* Find an FAT partition on the drive. Supports only generic partitioning, FDISK and SFD. */
;;;2214   	bsect = 0;
;;;2215   	fmt = check_fs(fs, bsect);					/* Load sector 0 and check if it is an FAT boot sector as SFD */
;;;2216   	if (fmt == 1 || (!fmt && (LD2PT(vol)))) {	/* Not an FAT boot sector or forced partition number */
;;;2217   		UINT i;
;;;2218   		DWORD br[4];
;;;2219   
;;;2220   		for (i = 0; i < 4; i++) {			/* Get partition offset */
;;;2221   			BYTE *pt = fs->win+MBR_Table + i * SZ_PTE;
;;;2222   			br[i] = pt[4] ? LD_DWORD(&pt[8]) : 0;
;;;2223   		}
;;;2224   		i = LD2PT(vol);						/* Partition number: 0:auto, 1-4:forced */
;;;2225   		if (i) i--;
;;;2226   		do {								/* Find an FAT volume */
;;;2227   			bsect = br[i];
;;;2228   			fmt = bsect ? check_fs(fs, bsect) : 2;	/* Check the partition */
;;;2229   		} while (!LD2PT(vol) && fmt && ++i < 4);
;;;2230   	}
;;;2231   	if (fmt == 3) return FR_DISK_ERR;		/* An error occured in the disk I/O layer */
;;;2232   	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
;;;2233   
;;;2234   	/* An FAT volume is found. Following code initializes the file system object */
;;;2235   
;;;2236   	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
;;;2237   		return FR_NO_FILESYSTEM;
;;;2238   
;;;2239   	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
;;;2240   	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
;;;2241   	fs->fsize = fasize;
;;;2242   
;;;2243   	fs->n_fats = fs->win[BPB_NumFATs];					/* Number of FAT copies */
;;;2244   	if (fs->n_fats != 1 && fs->n_fats != 2)				/* (Must be 1 or 2) */
;;;2245   		return FR_NO_FILESYSTEM;
;;;2246   	fasize *= fs->n_fats;								/* Number of sectors for FAT area */
;;;2247   
;;;2248   	fs->csize = fs->win[BPB_SecPerClus];				/* Number of sectors per cluster */
;;;2249   	if (!fs->csize || (fs->csize & (fs->csize - 1)))	/* (Must be power of 2) */
;;;2250   		return FR_NO_FILESYSTEM;
;;;2251   
;;;2252   	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
;;;2253   	if (fs->n_rootdir % (SS(fs) / SZ_DIR))				/* (Must be sector aligned) */
;;;2254   		return FR_NO_FILESYSTEM;
;;;2255   
;;;2256   	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
;;;2257   	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
;;;2258   
;;;2259   	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
;;;2260   	if (!nrsv) return FR_NO_FILESYSTEM;					/* (Must not be 0) */
;;;2261   
;;;2262   	/* Determine the FAT sub type */
;;;2263   	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
;;;2264   	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
;;;2265   	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
;;;2266   	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
;;;2267   	fmt = FS_FAT12;
;;;2268   	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
;;;2269   	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
;;;2270   
;;;2271   	/* Boundaries and Limits */
;;;2272   	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
;;;2273   	fs->volbase = bsect;								/* Volume start sector */
;;;2274   	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
;;;2275   	fs->database = bsect + sysect;						/* Data start sector */
;;;2276   	if (fmt == FS_FAT32) {
;;;2277   		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
;;;2278   		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
;;;2279   		szbfat = fs->n_fatent * 4;						/* (Needed FAT size) */
;;;2280   	} else {
;;;2281   		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
;;;2282   		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
;;;2283   		szbfat = (fmt == FS_FAT16) ?					/* (Needed FAT size) */
;;;2284   			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
;;;2285   	}
;;;2286   	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than needed) */
;;;2287   		return FR_NO_FILESYSTEM;
;;;2288   
;;;2289   #if !_FS_READONLY
;;;2290   	/* Initialize cluster allocation information */
;;;2291   	fs->last_clust = fs->free_clust = 0xFFFFFFFF;
;;;2292   
;;;2293   	/* Get fsinfo if available */
;;;2294   	fs->fsi_flag = 0x80;
;;;2295   #if (_FS_NOFSINFO & 3) != 3
;;;2296   	if (fmt == FS_FAT32				/* Enable FSINFO only if FAT32 and BPB_FSInfo is 1 */
;;;2297   		&& LD_WORD(fs->win+BPB_FSInfo) == 1
;;;2298   		&& move_window(fs, bsect + 1) == FR_OK)
;;;2299   	{
;;;2300   		fs->fsi_flag = 0;
;;;2301   		if (LD_WORD(fs->win+BS_55AA) == 0xAA55	/* Load FSINFO data if available */
;;;2302   			&& LD_DWORD(fs->win+FSI_LeadSig) == 0x41615252
;;;2303   			&& LD_DWORD(fs->win+FSI_StrucSig) == 0x61417272)
;;;2304   		{
;;;2305   #if (_FS_NOFSINFO & 1) == 0
;;;2306   			fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
;;;2307   #endif
;;;2308   #if (_FS_NOFSINFO & 2) == 0
;;;2309   			fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
;;;2310   #endif
;;;2311   		}
;;;2312   	}
;;;2313   #endif
;;;2314   #endif
;;;2315   	fs->fs_type = fmt;	/* FAT sub-type */
;;;2316   	fs->id = ++Fsid;	/* File system mount ID */
;;;2317   #if _FS_RPATH
;;;2318   	fs->cdir = 0;		/* Set current directory to root */
;;;2319   #endif
;;;2320   #if _FS_LOCK			/* Clear file lock semaphores */
;;;2321   	clear_lock(fs);
;;;2322   #endif
;;;2323   
;;;2324   	return FR_OK;
;;;2325   }
00001c  b004              ADD      sp,sp,#0x10
00001e  e8bd87f0          POP      {r4-r10,pc}
                  |L33.34|
000022  4883              LDR      r0,|L33.560|
000024  f8504025          LDR      r4,[r0,r5,LSL #2]     ;2184
000028  b18c              CBZ      r4,|L33.78|
00002a  603c              STR      r4,[r7,#0]            ;2190
00002c  7820              LDRB     r0,[r4,#0]            ;2190
00002e  b120              CBZ      r0,|L33.58|
000030  7860              LDRB     r0,[r4,#1]            ;2191
000032  f7fffffe          BL       disk_status
000036  07c1              LSLS     r1,r0,#31             ;2192
000038  d00b              BEQ      |L33.82|
                  |L33.58|
00003a  f8849000          STRB     r9,[r4,#0]            ;2202
00003e  b2e8              UXTB     r0,r5                 ;2203
000040  7060              STRB     r0,[r4,#1]            ;2203
000042  f7fffffe          BL       disk_initialize
000046  07c1              LSLS     r1,r0,#31             ;2205
000048  d008              BEQ      |L33.92|
00004a  2003              MOVS     r0,#3                 ;2206
00004c  e7e6              B        |L33.28|
                  |L33.78|
00004e  200c              MOVS     r0,#0xc               ;2185
000050  e7e4              B        |L33.28|
                  |L33.82|
000052  b10e              CBZ      r6,|L33.88|
000054  0740              LSLS     r0,r0,#29             ;2193
000056  d404              BMI      |L33.98|
                  |L33.88|
000058  2000              MOVS     r0,#0                 ;2195
00005a  e7df              B        |L33.28|
                  |L33.92|
00005c  b11e              CBZ      r6,|L33.102|
00005e  0740              LSLS     r0,r0,#29             ;2207
000060  d501              BPL      |L33.102|
                  |L33.98|
000062  200a              MOVS     r0,#0xa               ;2208
000064  e7da              B        |L33.28|
                  |L33.102|
000066  2500              MOVS     r5,#0                 ;2214
000068  4629              MOV      r1,r5                 ;2215
00006a  4620              MOV      r0,r4                 ;2215
00006c  f7fffffe          BL       check_fs
000070  2801              CMP      r0,#1                 ;2216
000072  d122              BNE      |L33.186|
000074  2000              MOVS     r0,#0                 ;2220
000076  466f              MOV      r7,sp                 ;2218
                  |L33.120|
000078  eb041100          ADD      r1,r4,r0,LSL #4       ;2221
00007c  f89121f2          LDRB     r2,[r1,#0x1f2]        ;2222
000080  f50171f7          ADD      r1,r1,#0x1ee          ;2222
000084  b12a              CBZ      r2,|L33.146|
000086  7a0a              LDRB     r2,[r1,#8]            ;2222
000088  f8d11009          LDR      r1,[r1,#9]            ;2222
00008c  ea422101          ORR      r1,r2,r1,LSL #8       ;2222
000090  e000              B        |L33.148|
                  |L33.146|
000092  2100              MOVS     r1,#0                 ;2222
                  |L33.148|
000094  f8471020          STR      r1,[r7,r0,LSL #2]     ;2222
000098  1c40              ADDS     r0,r0,#1              ;2222
00009a  2804              CMP      r0,#4                 ;2220
00009c  d3ec              BCC      |L33.120|
00009e  2600              MOVS     r6,#0                 ;2224
                  |L33.160|
0000a0  f8575026          LDR      r5,[r7,r6,LSL #2]     ;2227
0000a4  b12d              CBZ      r5,|L33.178|
0000a6  4629              MOV      r1,r5                 ;2228
0000a8  4620              MOV      r0,r4                 ;2228
0000aa  f7fffffe          BL       check_fs
0000ae  b908              CBNZ     r0,|L33.180|
0000b0  e009              B        |L33.198|
                  |L33.178|
0000b2  2002              MOVS     r0,#2                 ;2228
                  |L33.180|
0000b4  1c76              ADDS     r6,r6,#1              ;2228
0000b6  2e04              CMP      r6,#4                 ;2229
0000b8  d3f2              BCC      |L33.160|
                  |L33.186|
0000ba  2803              CMP      r0,#3                 ;2231
0000bc  d001              BEQ      |L33.194|
0000be  bbe8              CBNZ     r0,|L33.316|
0000c0  e001              B        |L33.198|
                  |L33.194|
0000c2  2001              MOVS     r0,#1                 ;2231
0000c4  e7aa              B        |L33.28|
                  |L33.198|
0000c6  f8b4003b          LDRH     r0,[r4,#0x3b]         ;2236
0000ca  f5b07f00          CMP      r0,#0x200             ;2236
0000ce  d15c              BNE      |L33.394|
0000d0  f8b42046          LDRH     r2,[r4,#0x46]         ;2239
0000d4  b92a              CBNZ     r2,|L33.226|
0000d6  f8940054          LDRB     r0,[r4,#0x54]         ;2240
0000da  f8d41055          LDR      r1,[r4,#0x55]         ;2240
0000de  ea402201          ORR      r2,r0,r1,LSL #8       ;2240
                  |L33.226|
0000e2  61a2              STR      r2,[r4,#0x18]         ;2243
0000e4  f8941040          LDRB     r1,[r4,#0x40]         ;2243
0000e8  70e1              STRB     r1,[r4,#3]            ;2243
0000ea  2901              CMP      r1,#1                 ;2244
0000ec  d001              BEQ      |L33.242|
0000ee  2902              CMP      r1,#2                 ;2244
0000f0  d14b              BNE      |L33.394|
                  |L33.242|
0000f2  f894003d          LDRB     r0,[r4,#0x3d]         ;2248
0000f6  4351              MULS     r1,r2,r1              ;2246
0000f8  70a0              STRB     r0,[r4,#2]            ;2248
0000fa  b1f8              CBZ      r0,|L33.316|
0000fc  1e43              SUBS     r3,r0,#1              ;2249
0000fe  4218              TST      r0,r3                 ;2249
000100  d143              BNE      |L33.394|
000102  f8b43041          LDRH     r3,[r4,#0x41]         ;2252
000106  8123              STRH     r3,[r4,#8]            ;2252
000108  071e              LSLS     r6,r3,#28             ;2253
00010a  d13e              BNE      |L33.394|
00010c  f8b46043          LDRH     r6,[r4,#0x43]         ;2256
000110  b92e              CBNZ     r6,|L33.286|
000112  f8946050          LDRB     r6,[r4,#0x50]         ;2257
000116  f8d47051          LDR      r7,[r4,#0x51]         ;2257
00011a  ea462607          ORR      r6,r6,r7,LSL #8       ;2257
                  |L33.286|
00011e  f8b4c03e          LDRH     r12,[r4,#0x3e]        ;2259
000122  f1bc0f00          CMP      r12,#0                ;2260
000126  d030              BEQ      |L33.394|
000128  eb0c0701          ADD      r7,r12,r1             ;2263
00012c  eb071713          ADD      r7,r7,r3,LSR #4       ;2263
000130  42be              CMP      r6,r7                 ;2264
000132  d32a              BCC      |L33.394|
000134  1bf6              SUBS     r6,r6,r7              ;2265
000136  fbb6f0f0          UDIV     r0,r6,r0              ;2265
00013a  e000              B        |L33.318|
                  |L33.316|
00013c  e025              B        |L33.394|
                  |L33.318|
00013e  b320              CBZ      r0,|L33.394|
000140  2601              MOVS     r6,#1                 ;2267
000142  f64078f6          MOV      r8,#0xff6             ;2268
000146  4540              CMP      r0,r8                 ;2268
000148  d300              BCC      |L33.332|
00014a  2602              MOVS     r6,#2                 ;2268
                  |L33.332|
00014c  f64f78f6          MOV      r8,#0xfff6            ;2269
000150  4540              CMP      r0,r8                 ;2269
000152  d300              BCC      |L33.342|
000154  2603              MOVS     r6,#3                 ;2269
                  |L33.342|
000156  1c80              ADDS     r0,r0,#2              ;2269
000158  442f              ADD      r7,r7,r5              ;2275
00015a  62a7              STR      r7,[r4,#0x28]         ;2276
00015c  44ac              ADD      r12,r12,r5            ;2274
00015e  6160              STR      r0,[r4,#0x14]         ;2276
000160  e9c45c07          STRD     r5,r12,[r4,#0x1c]     ;2276
000164  2e03              CMP      r6,#3                 ;2276
000166  d012              BEQ      |L33.398|
000168  b17b              CBZ      r3,|L33.394|
00016a  4461              ADD      r1,r1,r12             ;2282
00016c  6261              STR      r1,[r4,#0x24]         ;2283
00016e  2e02              CMP      r6,#2                 ;2283
000170  d018              BEQ      |L33.420|
000172  f0000101          AND      r1,r0,#1              ;2284
000176  eb000040          ADD      r0,r0,r0,LSL #1       ;2284
00017a  eb010050          ADD      r0,r1,r0,LSR #1       ;2284
00017e  bf00              NOP                            ;2284
                  |L33.384|
000180  f20010ff          ADD      r0,r0,#0x1ff          ;2284
000184  ebb22f50          CMP      r2,r0,LSR #9          ;2286
000188  d20e              BCS      |L33.424|
                  |L33.394|
00018a  200d              MOVS     r0,#0xd               ;2287
00018c  e746              B        |L33.28|
                  |L33.398|
00018e  2b00              CMP      r3,#0                 ;2277
000190  d1fb              BNE      |L33.394|
000192  f894105c          LDRB     r1,[r4,#0x5c]         ;2278
000196  f8d4305d          LDR      r3,[r4,#0x5d]         ;2278
00019a  0080              LSLS     r0,r0,#2              ;2279
00019c  ea412103          ORR      r1,r1,r3,LSL #8       ;2278
0001a0  6261              STR      r1,[r4,#0x24]         ;2279
0001a2  e7ed              B        |L33.384|
                  |L33.420|
0001a4  0040              LSLS     r0,r0,#1              ;2284
0001a6  e7eb              B        |L33.384|
                  |L33.424|
0001a8  f04f30ff          MOV      r0,#0xffffffff        ;2291
0001ac  6120              STR      r0,[r4,#0x10]         ;2291
0001ae  60e0              STR      r0,[r4,#0xc]          ;2294
0001b0  2080              MOVS     r0,#0x80              ;2294
0001b2  7160              STRB     r0,[r4,#5]            ;2294
0001b4  2e03              CMP      r6,#3                 ;2296
0001b6  d130              BNE      |L33.538|
0001b8  f8b40060          LDRH     r0,[r4,#0x60]         ;2297
0001bc  2801              CMP      r0,#1                 ;2297
0001be  d12c              BNE      |L33.538|
0001c0  4620              MOV      r0,r4                 ;2298
0001c2  1c69              ADDS     r1,r5,#1              ;2298
0001c4  f7fffffe          BL       move_window
0001c8  bb38              CBNZ     r0,|L33.538|
0001ca  f8849005          STRB     r9,[r4,#5]            ;2300
0001ce  f8b4022e          LDRH     r0,[r4,#0x22e]        ;2301
0001d2  f5a0412a          SUB      r1,r0,#0xaa00         ;2301
0001d6  3955              SUBS     r1,r1,#0x55           ;2301
0001d8  d11f              BNE      |L33.538|
0001da  f8940030          LDRB     r0,[r4,#0x30]         ;2302
0001de  f8d41031          LDR      r1,[r4,#0x31]         ;2302
0001e2  ea402001          ORR      r0,r0,r1,LSL #8       ;2302
0001e6  4913              LDR      r1,|L33.564|
0001e8  4288              CMP      r0,r1                 ;2302
0001ea  d116              BNE      |L33.538|
0001ec  f8940214          LDRB     r0,[r4,#0x214]        ;2303
0001f0  f8d41215          LDR      r1,[r4,#0x215]        ;2303
0001f4  ea402001          ORR      r0,r0,r1,LSL #8       ;2303
0001f8  490f              LDR      r1,|L33.568|
0001fa  4288              CMP      r0,r1                 ;2303
0001fc  d10d              BNE      |L33.538|
0001fe  f8940218          LDRB     r0,[r4,#0x218]        ;2306
000202  f8d41219          LDR      r1,[r4,#0x219]        ;2306
000206  ea402001          ORR      r0,r0,r1,LSL #8       ;2306
00020a  6120              STR      r0,[r4,#0x10]         ;2309
00020c  f894021c          LDRB     r0,[r4,#0x21c]        ;2309
000210  f8d4121d          LDR      r1,[r4,#0x21d]        ;2309
000214  ea402001          ORR      r0,r0,r1,LSL #8       ;2309
000218  60e0              STR      r0,[r4,#0xc]          ;2309
                  |L33.538|
00021a  4908              LDR      r1,|L33.572|
00021c  7026              STRB     r6,[r4,#0]            ;2315
00021e  8808              LDRH     r0,[r1,#0]            ;2316  ; Fsid
000220  1c40              ADDS     r0,r0,#1              ;2316
000222  8008              STRH     r0,[r1,#0]            ;2316
000224  80e0              STRH     r0,[r4,#6]            ;2316
000226  4620              MOV      r0,r4                 ;2321
000228  f7fffffe          BL       clear_lock
00022c  e714              B        |L33.88|
;;;2326   
                          ENDP

00022e  0000              DCW      0x0000
                  |L33.560|
                          DCD      ||.bss||
                  |L33.564|
                          DCD      0x41615252
                  |L33.568|
                          DCD      0x61417272
                  |L33.572|
                          DCD      ||.data||

                          AREA ||i.follow_path||, CODE, READONLY, ALIGN=1

                  follow_path PROC
;;;2014   static
;;;2015   FRESULT follow_path (	/* FR_OK(0): successful, !=0: error code */
000000  b573              PUSH     {r0,r1,r4-r6,lr}
;;;2016   	DIR* dp,			/* Directory object to return last directory and found object */
;;;2017   	const TCHAR* path	/* Full-path string to find a file or directory */
;;;2018   )
;;;2019   {
000002  4604              MOV      r4,r0
;;;2020   	FRESULT res;
;;;2021   	BYTE *dir, ns;
;;;2022   
;;;2023   
;;;2024   #if _FS_RPATH
;;;2025   	if (*path == '/' || *path == '\\') {	/* There is a heading separator */
;;;2026   		path++;	dp->sclust = 0;				/* Strip it and start from the root directory */
;;;2027   	} else {								/* No heading separator */
;;;2028   		dp->sclust = dp->fs->cdir;			/* Start from the current directory */
;;;2029   	}
;;;2030   #else
;;;2031   	if (*path == '/' || *path == '\\')		/* Strip heading separator if exist */
000004  9801              LDR      r0,[sp,#4]
000006  7801              LDRB     r1,[r0,#0]
000008  292f              CMP      r1,#0x2f
00000a  d001              BEQ      |L34.16|
00000c  295c              CMP      r1,#0x5c
00000e  d101              BNE      |L34.20|
                  |L34.16|
000010  1c40              ADDS     r0,r0,#1
;;;2032   		path++;
000012  9001              STR      r0,[sp,#4]
                  |L34.20|
;;;2033   	dp->sclust = 0;							/* Always start from the root directory */
000014  2500              MOVS     r5,#0
;;;2034   #endif
;;;2035   
;;;2036   	if ((UINT)*path < ' ') {				/* Null path name is the origin directory itself */
000016  60a5              STR      r5,[r4,#8]
000018  9801              LDR      r0,[sp,#4]
00001a  7800              LDRB     r0,[r0,#0]
00001c  2820              CMP      r0,#0x20
00001e  d205              BCS      |L34.44|
;;;2037   		res = dir_sdi(dp, 0);
000020  2100              MOVS     r1,#0
000022  4620              MOV      r0,r4
000024  f7fffffe          BL       dir_sdi
;;;2038   		dp->dir = 0;
000028  6165              STR      r5,[r4,#0x14]
                  |L34.42|
;;;2039   	} else {								/* Follow path */
;;;2040   		for (;;) {
;;;2041   			res = create_name(dp, &path);	/* Get a segment name of the path */
;;;2042   			if (res != FR_OK) break;
;;;2043   			res = dir_find(dp);				/* Find an object with the sagment name */
;;;2044   			ns = dp->fn[NS];
;;;2045   			if (res != FR_OK) {				/* Failed to find the object */
;;;2046   				if (res == FR_NO_FILE) {	/* Object is not found */
;;;2047   					if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exist, */
;;;2048   						dp->sclust = 0; dp->dir = 0;	/* it is the root directory and stay there */
;;;2049   						if (!(ns & NS_LAST)) continue;	/* Continue to follow if not last segment */
;;;2050   						res = FR_OK;					/* Ended at the root directroy. Function completed. */
;;;2051   					} else {							/* Could not find the object */
;;;2052   						if (!(ns & NS_LAST)) res = FR_NO_PATH;	/* Adjust error code if not last segment */
;;;2053   					}
;;;2054   				}
;;;2055   				break;
;;;2056   			}
;;;2057   			if (ns & NS_LAST) break;			/* Last segment matched. Function completed. */
;;;2058   			dir = dp->dir;						/* Follow the sub-directory */
;;;2059   			if (!(dir[DIR_Attr] & AM_DIR)) {	/* It is not a sub-directory and cannot follow */
;;;2060   				res = FR_NO_PATH; break;
;;;2061   			}
;;;2062   			dp->sclust = ld_clust(dp->fs, dir);
;;;2063   		}
;;;2064   	}
;;;2065   
;;;2066   	return res;
;;;2067   }
00002a  bd7c              POP      {r2-r6,pc}
                  |L34.44|
00002c  a901              ADD      r1,sp,#4              ;2041
00002e  4620              MOV      r0,r4                 ;2041
000030  f7fffffe          BL       create_name
000034  2800              CMP      r0,#0                 ;2042
000036  d1f8              BNE      |L34.42|
000038  4620              MOV      r0,r4                 ;2043
00003a  f7fffffe          BL       dir_find
00003e  69a1              LDR      r1,[r4,#0x18]         ;2044
000040  7ac9              LDRB     r1,[r1,#0xb]          ;2044
000042  b128              CBZ      r0,|L34.80|
000044  2804              CMP      r0,#4                 ;2046
000046  d1f0              BNE      |L34.42|
000048  0749              LSLS     r1,r1,#29             ;2052
00004a  d4ee              BMI      |L34.42|
                  |L34.76|
00004c  2005              MOVS     r0,#5                 ;2052
                  |L34.78|
00004e  bd7c              POP      {r2-r6,pc}
                  |L34.80|
000050  0749              LSLS     r1,r1,#29             ;2057
000052  d4fc              BMI      |L34.78|
000054  6961              LDR      r1,[r4,#0x14]         ;2059
000056  7ac8              LDRB     r0,[r1,#0xb]          ;2059
000058  06c0              LSLS     r0,r0,#27             ;2059
00005a  d5f7              BPL      |L34.76|
00005c  6820              LDR      r0,[r4,#0]            ;2062
00005e  f7fffffe          BL       ld_clust
000062  60a0              STR      r0,[r4,#8]            ;2049
000064  e7e2              B        |L34.44|
;;;2068   
                          ENDP


                          AREA ||i.gen_numname||, CODE, READONLY, ALIGN=2

                  gen_numname PROC
;;;1410   static
;;;1411   void gen_numname (
000000  b57c              PUSH     {r2-r6,lr}
;;;1412   	BYTE* dst,			/* Pointer to the buffer to store numbered SFN */
;;;1413   	const BYTE* src,	/* Pointer to SFN */
;;;1414   	const WCHAR* lfn,	/* Pointer to LFN */
;;;1415   	UINT seq			/* Sequence number */
;;;1416   )
;;;1417   {
000002  4616              MOV      r6,r2
000004  461c              MOV      r4,r3
000006  4605              MOV      r5,r0
;;;1418   	BYTE ns[8], c;
;;;1419   	UINT i, j;
;;;1420   
;;;1421   
;;;1422   	mem_cpy(dst, src, 11);
000008  220b              MOVS     r2,#0xb
00000a  f7fffffe          BL       mem_cpy
;;;1423   
;;;1424   	if (seq > 5) {	/* On many collisions, generate a hash number instead of sequential number */
00000e  2c05              CMP      r4,#5
000010  d911              BLS      |L35.54|
;;;1425   		WCHAR wc;
;;;1426   		DWORD sr = seq;
;;;1427   
;;;1428   		while (*lfn) {	/* Create a CRC */
;;;1429   			wc = *lfn++;
;;;1430   			for (i = 0; i < 16; i++) {
;;;1431   				sr = (sr << 1) + (wc & 1);
;;;1432   				wc >>= 1;
;;;1433   				if (sr & 0x10000) sr ^= 0x11021;
000012  4a1d              LDR      r2,|L35.136|
000014  e00c              B        |L35.48|
                  |L35.22|
000016  2100              MOVS     r1,#0                 ;1430
000018  1cb6              ADDS     r6,r6,#2              ;1430
                  |L35.26|
00001a  4623              MOV      r3,r4                 ;1431
00001c  4604              MOV      r4,r0                 ;1431
00001e  f363045f          BFI      r4,r3,#1,#31          ;1431
000022  0840              LSRS     r0,r0,#1              ;1432
000024  03e3              LSLS     r3,r4,#15
000026  d500              BPL      |L35.42|
000028  4054              EORS     r4,r4,r2
                  |L35.42|
00002a  1c49              ADDS     r1,r1,#1
00002c  2910              CMP      r1,#0x10              ;1430
00002e  d3f4              BCC      |L35.26|
                  |L35.48|
000030  8830              LDRH     r0,[r6,#0]            ;1428
000032  2800              CMP      r0,#0                 ;1428
000034  d1ef              BNE      |L35.22|
                  |L35.54|
;;;1434   			}
;;;1435   		}
;;;1436   		seq = (UINT)sr;
;;;1437   	}
;;;1438   
;;;1439   	/* itoa (hexdecimal) */
;;;1440   	i = 7;
000036  2107              MOVS     r1,#7
000038  ea4f030d          MOV.W    r3,sp                 ;1418
                  |L35.60|
;;;1441   	do {
;;;1442   		c = (seq % 16) + '0';
00003c  f004000f          AND      r0,r4,#0xf
000040  3030              ADDS     r0,r0,#0x30
;;;1443   		if (c > '9') c += 7;
000042  2839              CMP      r0,#0x39
000044  d900              BLS      |L35.72|
000046  1dc0              ADDS     r0,r0,#7
                  |L35.72|
;;;1444   		ns[i--] = c;
000048  5458              STRB     r0,[r3,r1]
00004a  1e49              SUBS     r1,r1,#1
;;;1445   		seq /= 16;
00004c  0924              LSRS     r4,r4,#4
;;;1446   	} while (seq);
00004e  d1f5              BNE      |L35.60|
;;;1447   	ns[i] = '~';
000050  207e              MOVS     r0,#0x7e
;;;1448   
;;;1449   	/* Append the number */
;;;1450   	for (j = 0; j < i && dst[j] != ' '; j++) {
000052  2200              MOVS     r2,#0
000054  5458              STRB     r0,[r3,r1]            ;1447
000056  1e4c              SUBS     r4,r1,#1              ;1444
000058  e006              B        |L35.104|
                  |L35.90|
00005a  3881              SUBS     r0,r0,#0x81
;;;1451   		if (IsDBCS1(dst[j])) {
00005c  287d              CMP      r0,#0x7d
00005e  d802              BHI      |L35.102|
;;;1452   			if (j == i - 1) break;
000060  42a2              CMP      r2,r4
000062  d006              BEQ      |L35.114|
000064  1c52              ADDS     r2,r2,#1
                  |L35.102|
000066  1c52              ADDS     r2,r2,#1
                  |L35.104|
000068  428a              CMP      r2,r1                 ;1450
00006a  d202              BCS      |L35.114|
00006c  5ca8              LDRB     r0,[r5,r2]            ;1450
00006e  2820              CMP      r0,#0x20              ;1450
000070  d1f3              BNE      |L35.90|
                  |L35.114|
;;;1453   			j++;
;;;1454   		}
;;;1455   	}
;;;1456   	do {
;;;1457   		dst[j++] = (i < 8) ? ns[i++] : ' ';
000072  2908              CMP      r1,#8
000074  d202              BCS      |L35.124|
000076  5c58              LDRB     r0,[r3,r1]
000078  1c49              ADDS     r1,r1,#1
00007a  e000              B        |L35.126|
                  |L35.124|
00007c  2020              MOVS     r0,#0x20
                  |L35.126|
00007e  54a8              STRB     r0,[r5,r2]
000080  1c52              ADDS     r2,r2,#1
;;;1458   	} while (j < 8);
000082  2a08              CMP      r2,#8
000084  d3f5              BCC      |L35.114|
;;;1459   }
000086  bd7c              POP      {r2-r6,pc}
;;;1460   #endif
                          ENDP

                  |L35.136|
                          DCD      0x00011021

                          AREA ||i.get_fat||, CODE, READONLY, ALIGN=1

                  get_fat PROC
;;;864    
;;;865    DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;866    	FATFS* fs,	/* File system object */
;;;867    	DWORD clst	/* Cluster# to get the link information */
;;;868    )
;;;869    {
000004  460d              MOV      r5,r1
000006  4604              MOV      r4,r0
;;;870    	UINT wc, bc;
;;;871    	BYTE *p;
;;;872    
;;;873    
;;;874    	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
000008  2902              CMP      r1,#2
00000a  d309              BCC      |L36.32|
00000c  6960              LDR      r0,[r4,#0x14]
00000e  42a8              CMP      r0,r5
000010  d906              BLS      |L36.32|
;;;875    		return 1;
;;;876    
;;;877    	switch (fs->fs_type) {
000012  7820              LDRB     r0,[r4,#0]
000014  2801              CMP      r0,#1
000016  d006              BEQ      |L36.38|
000018  2802              CMP      r0,#2
00001a  d028              BEQ      |L36.110|
00001c  2803              CMP      r0,#3
00001e  d032              BEQ      |L36.134|
                  |L36.32|
;;;878    	case FS_FAT12 :
;;;879    		bc = (UINT)clst; bc += bc / 2;
;;;880    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;881    		wc = fs->win[bc % SS(fs)]; bc++;
;;;882    		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
;;;883    		wc |= fs->win[bc % SS(fs)] << 8;
;;;884    		return clst & 1 ? wc >> 4 : (wc & 0xFFF);
;;;885    
;;;886    	case FS_FAT16 :
;;;887    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
;;;888    		p = &fs->win[clst * 2 % SS(fs)];
;;;889    		return LD_WORD(p);
;;;890    
;;;891    	case FS_FAT32 :
;;;892    		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
;;;893    		p = &fs->win[clst * 4 % SS(fs)];
;;;894    		return LD_DWORD(p) & 0x0FFFFFFF;
;;;895    
;;;896    	default:
;;;897    		return 1;
000020  2001              MOVS     r0,#1
                  |L36.34|
;;;898    	}
;;;899    
;;;900    	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
;;;901    }
000022  e8bd81f0          POP      {r4-r8,pc}
                  |L36.38|
000026  6a20              LDR      r0,[r4,#0x20]         ;880
000028  eb050655          ADD      r6,r5,r5,LSR #1       ;879
00002c  eb002156          ADD      r1,r0,r6,LSR #9       ;880
000030  4620              MOV      r0,r4                 ;880
000032  f7fffffe          BL       move_window
000036  bb68              CBNZ     r0,|L36.148|
000038  f3c60008          UBFX     r0,r6,#0,#9           ;881
00003c  4420              ADD      r0,r0,r4              ;881
00003e  1c76              ADDS     r6,r6,#1              ;882
000040  f8907030          LDRB     r7,[r0,#0x30]         ;881
000044  6a20              LDR      r0,[r4,#0x20]         ;882
000046  eb002156          ADD      r1,r0,r6,LSR #9       ;882
00004a  4620              MOV      r0,r4                 ;882
00004c  f7fffffe          BL       move_window
000050  bb00              CBNZ     r0,|L36.148|
000052  f3c60008          UBFX     r0,r6,#0,#9           ;883
000056  4420              ADD      r0,r0,r4              ;883
000058  07e9              LSLS     r1,r5,#31             ;884
00005a  f8900030          LDRB     r0,[r0,#0x30]         ;883
00005e  ea472000          ORR      r0,r7,r0,LSL #8       ;883
000062  d001              BEQ      |L36.104|
000064  0900              LSRS     r0,r0,#4              ;884
000066  e7dc              B        |L36.34|
                  |L36.104|
000068  f3c0000b          UBFX     r0,r0,#0,#12          ;884
00006c  e7d9              B        |L36.34|
                  |L36.110|
00006e  6a20              LDR      r0,[r4,#0x20]         ;887
000070  eb002115          ADD      r1,r0,r5,LSR #8       ;887
000074  4620              MOV      r0,r4                 ;887
000076  f7fffffe          BL       move_window
00007a  b958              CBNZ     r0,|L36.148|
00007c  b2e8              UXTB     r0,r5                 ;888
00007e  eb040040          ADD      r0,r4,r0,LSL #1       ;888
000082  8e00              LDRH     r0,[r0,#0x30]         ;889
000084  e7cd              B        |L36.34|
                  |L36.134|
000086  6a20              LDR      r0,[r4,#0x20]         ;892
000088  eb0011d5          ADD      r1,r0,r5,LSR #7       ;892
00008c  4620              MOV      r0,r4                 ;892
00008e  f7fffffe          BL       move_window
000092  b110              CBZ      r0,|L36.154|
                  |L36.148|
000094  f04f30ff          MOV      r0,#0xffffffff        ;900
000098  e7c3              B        |L36.34|
                  |L36.154|
00009a  f24010ff          MOV      r0,#0x1ff             ;893
00009e  ea000085          AND      r0,r0,r5,LSL #2       ;893
0000a2  4420              ADD      r0,r0,r4              ;893
0000a4  f8901030          LDRB     r1,[r0,#0x30]         ;894
0000a8  f8d00031          LDR      r0,[r0,#0x31]         ;894
0000ac  ea412000          ORR      r0,r1,r0,LSL #8       ;894
0000b0  f0204070          BIC      r0,r0,#0xf0000000     ;894
0000b4  e7b5              B        |L36.34|
;;;902    
                          ENDP


                          AREA ||i.get_fileinfo||, CODE, READONLY, ALIGN=1

                  get_fileinfo PROC
;;;1734   static
;;;1735   void get_fileinfo (		/* No return code */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1736   	DIR* dp,			/* Pointer to the directory object */
;;;1737   	FILINFO* fno	 	/* Pointer to the file information to be filled */
;;;1738   )
;;;1739   {
000004  460c              MOV      r4,r1
;;;1740   	UINT i;
;;;1741   	TCHAR *p, c;
;;;1742   
;;;1743   
;;;1744   	p = fno->fname;
000006  f1010209          ADD      r2,r1,#9
00000a  6901              LDR      r1,[r0,#0x10]         ;1739
00000c  b371              CBZ      r1,|L37.108|
;;;1745   	if (dp->sect) {		/* Get SFN */
;;;1746   		BYTE *dir = dp->dir;
;;;1747   
;;;1748   		i = 0;
00000e  2500              MOVS     r5,#0
;;;1749   		while (i < 11) {		/* Copy name body and extension */
;;;1750   			c = (TCHAR)dir[i++];
;;;1751   			if (c == ' ') continue;			/* Skip padding spaces */
;;;1752   			if (c == NDDE) c = (TCHAR)DDE;	/* Restore replaced DDE character */
;;;1753   			if (i == 9) *p++ = '.';			/* Insert a . if extension is exist */
000010  6943              LDR      r3,[r0,#0x14]
000012  262e              MOVS     r6,#0x2e
                  |L37.20|
000014  5d59              LDRB     r1,[r3,r5]            ;1750
000016  1c6d              ADDS     r5,r5,#1              ;1750
000018  2920              CMP      r1,#0x20              ;1751
00001a  d019              BEQ      |L37.80|
00001c  2905              CMP      r1,#5                 ;1752
00001e  d100              BNE      |L37.34|
000020  21e5              MOVS     r1,#0xe5              ;1752
                  |L37.34|
000022  2d09              CMP      r5,#9
000024  d101              BNE      |L37.42|
000026  f8026b01          STRB     r6,[r2],#1
                  |L37.42|
;;;1754   #if _USE_LFN
;;;1755   			if (IsUpper(c) && (dir[DIR_NTres] & (i >= 9 ? NS_EXT : NS_BODY)))
00002a  f1a10741          SUB      r7,r1,#0x41
00002e  2f19              CMP      r7,#0x19
000030  d80c              BHI      |L37.76|
000032  7b1f              LDRB     r7,[r3,#0xc]
000034  2d09              CMP      r5,#9
000036  d302              BCC      |L37.62|
000038  f04f0c10          MOV      r12,#0x10
00003c  e001              B        |L37.66|
                  |L37.62|
00003e  f04f0c08          MOV      r12,#8
                  |L37.66|
000042  ea170f0c          TST      r7,r12
000046  d001              BEQ      |L37.76|
000048  3120              ADDS     r1,r1,#0x20
;;;1756   				c += 0x20;			/* To lower */
00004a  b2c9              UXTB     r1,r1
                  |L37.76|
;;;1757   #if _LFN_UNICODE
;;;1758   			if (IsDBCS1(c) && i != 8 && i != 11 && IsDBCS2(dir[i]))
;;;1759   				c = c << 8 | dir[i++];
;;;1760   			c = ff_convert(c, 1);	/* OEM -> Unicode */
;;;1761   			if (!c) c = '?';
;;;1762   #endif
;;;1763   #endif
;;;1764   			*p++ = c;
00004c  f8021b01          STRB     r1,[r2],#1
                  |L37.80|
000050  2d0b              CMP      r5,#0xb               ;1749
000052  d3df              BCC      |L37.20|
;;;1765   		}
;;;1766   		fno->fattrib = dir[DIR_Attr];				/* Attribute */
000054  7ad9              LDRB     r1,[r3,#0xb]
000056  7221              STRB     r1,[r4,#8]
;;;1767   		fno->fsize = LD_DWORD(dir+DIR_FileSize);	/* Size */
000058  7f19              LDRB     r1,[r3,#0x1c]
00005a  f8d3501d          LDR      r5,[r3,#0x1d]
00005e  ea412105          ORR      r1,r1,r5,LSL #8
;;;1768   		fno->fdate = LD_WORD(dir+DIR_WrtDate);		/* Date */
000062  6021              STR      r1,[r4,#0]
000064  8b19              LDRH     r1,[r3,#0x18]
000066  80a1              STRH     r1,[r4,#4]
;;;1769   		fno->ftime = LD_WORD(dir+DIR_WrtTime);		/* Time */
000068  8ad9              LDRH     r1,[r3,#0x16]
00006a  80e1              STRH     r1,[r4,#6]
                  |L37.108|
;;;1770   	}
;;;1771   	*p = 0;		/* Terminate SFN string by a \0 */
00006c  f04f0800          MOV      r8,#0
000070  f8828000          STRB     r8,[r2,#0]
;;;1772   
;;;1773   #if _USE_LFN
;;;1774   	if (fno->lfname) {
000074  69a6              LDR      r6,[r4,#0x18]
000076  2e00              CMP      r6,#0
000078  d022              BEQ      |L37.192|
;;;1775   		WCHAR w, *lfn;
;;;1776   
;;;1777   		i = 0; p = fno->lfname;
;;;1778   		if (dp->sect && fno->lfsize && dp->lfn_idx != 0xFFFF) {	/* Get LFN if available */
00007a  6901              LDR      r1,[r0,#0x10]
00007c  2500              MOVS     r5,#0                 ;1777
00007e  b1e9              CBZ      r1,|L37.188|
000080  69e1              LDR      r1,[r4,#0x1c]
000082  b1d9              CBZ      r1,|L37.188|
000084  8c81              LDRH     r1,[r0,#0x24]
000086  f5a1427f          SUB      r2,r1,#0xff00
00008a  3aff              SUBS     r2,r2,#0xff
00008c  d016              BEQ      |L37.188|
;;;1779   			lfn = dp->lfn;
;;;1780   			while ((w = *lfn++) != 0) {		/* Get an LFN character */
00008e  6a07              LDR      r7,[r0,#0x20]
000090  e010              B        |L37.180|
                  |L37.146|
;;;1781   #if !_LFN_UNICODE
;;;1782   				w = ff_convert(w, 0);		/* Unicode -> OEM */
000092  2100              MOVS     r1,#0
000094  f7fffffe          BL       ff_convert
;;;1783   				if (!w) { i = 0; break; }	/* No LFN if it could not be converted */
000098  b140              CBZ      r0,|L37.172|
;;;1784   				if (_DF1S && w >= 0x100)	/* Put 1st byte if it is a DBC (always false on SBCS cfg) */
00009a  28ff              CMP      r0,#0xff
00009c  d902              BLS      |L37.164|
;;;1785   					p[i++] = (TCHAR)(w >> 8);
00009e  0a01              LSRS     r1,r0,#8
0000a0  5571              STRB     r1,[r6,r5]
0000a2  1c6d              ADDS     r5,r5,#1
                  |L37.164|
;;;1786   #endif
;;;1787   				if (i >= fno->lfsize - 1) { i = 0; break; }	/* No LFN if buffer overflow */
0000a4  69e1              LDR      r1,[r4,#0x1c]
0000a6  1e49              SUBS     r1,r1,#1
0000a8  42a9              CMP      r1,r5
0000aa  d801              BHI      |L37.176|
                  |L37.172|
0000ac  2500              MOVS     r5,#0
0000ae  e005              B        |L37.188|
                  |L37.176|
;;;1788   				p[i++] = (TCHAR)w;
0000b0  5570              STRB     r0,[r6,r5]
0000b2  1c6d              ADDS     r5,r5,#1
                  |L37.180|
0000b4  f8370b02          LDRH     r0,[r7],#2            ;1780
0000b8  2800              CMP      r0,#0                 ;1780
0000ba  d1ea              BNE      |L37.146|
                  |L37.188|
;;;1789   			}
;;;1790   		}
;;;1791   		p[i] = 0;	/* Terminate LFN string by a \0 */
0000bc  f8068005          STRB     r8,[r6,r5]
                  |L37.192|
;;;1792   	}
;;;1793   #endif
;;;1794   }
0000c0  e8bd81f0          POP      {r4-r8,pc}
;;;1795   #endif /* _FS_MINIMIZE <= 1 || _FS_RPATH >= 2*/
                          ENDP


                          AREA ||i.get_ldnumber||, CODE, READONLY, ALIGN=1

                  get_ldnumber PROC
;;;2076   static
;;;2077   int get_ldnumber (		/* Returns logical drive number (-1:invalid drive) */
000000  b510              PUSH     {r4,lr}
;;;2078   	const TCHAR** path	/* Pointer to pointer to the path name */
;;;2079   )
;;;2080   {
000002  4604              MOV      r4,r0
;;;2081   	const TCHAR *tp, *tt;
;;;2082   	UINT i;
;;;2083   	int vol = -1;
000004  f04f30ff          MOV      r0,#0xffffffff
000008  6822              LDR      r2,[r4,#0]            ;2080
00000a  2a00              CMP      r2,#0                 ;2080
00000c  d013              BEQ      |L38.54|
00000e  4611              MOV      r1,r2                 ;2080
;;;2084   
;;;2085   
;;;2086   	if (*path) {	/* If the pointer is not a null */
;;;2087   		for (tt = *path; (UINT)*tt >= (_USE_LFN ? ' ' : '!') && *tt != ':'; tt++) ;	/* Find ':' in the path */
000010  e000              B        |L38.20|
                  |L38.18|
000012  1c49              ADDS     r1,r1,#1
                  |L38.20|
000014  780b              LDRB     r3,[r1,#0]
000016  2b20              CMP      r3,#0x20
000018  d30e              BCC      |L38.56|
00001a  2b3a              CMP      r3,#0x3a
00001c  d1f9              BNE      |L38.18|
;;;2088   		if (*tt == ':') {	/* If a ':' is exist in the path name */
;;;2089   			tp = *path;
;;;2090   			i = *tp++ - '0'; 
00001e  f8123b01          LDRB     r3,[r2],#1
000022  3b30              SUBS     r3,r3,#0x30
;;;2091   			if (i < 10 && tp == tt) {	/* Is there a numeric drive id? */
000024  2b0a              CMP      r3,#0xa
000026  d206              BCS      |L38.54|
000028  428a              CMP      r2,r1
00002a  d104              BNE      |L38.54|
;;;2092   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
00002c  2b03              CMP      r3,#3
00002e  d202              BCS      |L38.54|
;;;2093   					vol = (int)i;
000030  1c49              ADDS     r1,r1,#1
000032  4618              MOV      r0,r3
;;;2094   					*path = ++tt;
000034  6021              STR      r1,[r4,#0]
                  |L38.54|
;;;2095   				}
;;;2096   			} else {	/* No numeric drive number */
;;;2097   #if _STR_VOLUME_ID		/* Find string drive id */
;;;2098   				static const char* const str[] = {_VOLUME_STRS};
;;;2099   				const char *sp;
;;;2100   				char c;
;;;2101   				TCHAR tc;
;;;2102   
;;;2103   				i = 0; tt++;
;;;2104   				do {
;;;2105   					sp = str[i]; tp = *path;
;;;2106   					do {	/* Compare a string drive id with path name */
;;;2107   						c = *sp++; tc = *tp++;
;;;2108   						if (IsLower(tc)) tc -= 0x20;
;;;2109   					} while (c && (TCHAR)c == tc);
;;;2110   				} while ((c || tp != tt) && ++i < _VOLUMES);	/* Repeat for each id until pattern match */
;;;2111   				if (i < _VOLUMES) {	/* If a drive id is found, get the value and strip it */
;;;2112   					vol = (int)i;
;;;2113   					*path = tt;
;;;2114   				}
;;;2115   #endif
;;;2116   			}
;;;2117   			return vol;
;;;2118   		}
;;;2119   #if _FS_RPATH && _VOLUMES >= 2
;;;2120   		vol = CurrVol;	/* Current drive */
;;;2121   #else
;;;2122   		vol = 0;		/* Drive 0 */
;;;2123   #endif
;;;2124   	}
;;;2125   	return vol;
;;;2126   }
000036  bd10              POP      {r4,pc}
                  |L38.56|
000038  2000              MOVS     r0,#0                 ;2122
00003a  bd10              POP      {r4,pc}
;;;2127   
                          ENDP


                          AREA ||i.inc_lock||, CODE, READONLY, ALIGN=2

                  inc_lock PROC
;;;679    static
;;;680    UINT inc_lock (	/* Increment object open counter and returns its index (0:Internal error) */
000000  b5f0              PUSH     {r4-r7,lr}
;;;681    	DIR* dp,	/* Directory object pointing the file to register or increment */
;;;682    	int acc		/* Desired access (0:Read, 1:Write, 2:Delete/Rename) */
;;;683    )
;;;684    {
000002  4603              MOV      r3,r0
;;;685    	UINT i;
;;;686    
;;;687    
;;;688    	for (i = 0; i < _FS_LOCK; i++) {	/* Find the object */
;;;689    		if (Files[i].fs == dp->fs &&
000004  4a23              LDR      r2,|L39.148|
000006  f8d34000          LDR.W    r4,[r3,#0]
00000a  2000              MOVS     r0,#0                 ;688
                  |L39.12|
00000c  eb000540          ADD      r5,r0,r0,LSL #1
000010  f8526025          LDR      r6,[r2,r5,LSL #2]
000014  42a6              CMP      r6,r4
000016  d109              BNE      |L39.44|
;;;690    			Files[i].clu == dp->sclust &&
000018  eb020585          ADD      r5,r2,r5,LSL #2
00001c  689e              LDR      r6,[r3,#8]
00001e  686f              LDR      r7,[r5,#4]
000020  42b7              CMP      r7,r6
000022  d103              BNE      |L39.44|
;;;691    			Files[i].idx == dp->index) break;
000024  892d              LDRH     r5,[r5,#8]
000026  88de              LDRH     r6,[r3,#6]
000028  42b5              CMP      r5,r6
00002a  d002              BEQ      |L39.50|
                  |L39.44|
00002c  1c40              ADDS     r0,r0,#1
00002e  2803              CMP      r0,#3                 ;688
000030  d3ec              BCC      |L39.12|
                  |L39.50|
;;;692    	}
;;;693    
;;;694    	if (i == _FS_LOCK) {				/* Not opened. Register it as new. */
000032  2803              CMP      r0,#3
000034  d118              BNE      |L39.104|
;;;695    		for (i = 0; i < _FS_LOCK && Files[i].fs; i++) ;
000036  2000              MOVS     r0,#0
000038  e002              B        |L39.64|
                  |L39.58|
00003a  1c40              ADDS     r0,r0,#1
00003c  2803              CMP      r0,#3
00003e  d205              BCS      |L39.76|
                  |L39.64|
000040  eb000540          ADD      r5,r0,r0,LSL #1
000044  f8525025          LDR      r5,[r2,r5,LSL #2]
000048  2d00              CMP      r5,#0
00004a  d1f6              BNE      |L39.58|
                  |L39.76|
;;;696    		if (i == _FS_LOCK) return 0;	/* No free entry to register (int err) */
00004c  2803              CMP      r0,#3
00004e  d013              BEQ      |L39.120|
;;;697    		Files[i].fs = dp->fs;
000050  eb000540          ADD      r5,r0,r0,LSL #1
000054  f8424025          STR      r4,[r2,r5,LSL #2]
;;;698    		Files[i].clu = dp->sclust;
000058  eb020485          ADD      r4,r2,r5,LSL #2
00005c  689e              LDR      r6,[r3,#8]
;;;699    		Files[i].idx = dp->index;
00005e  6066              STR      r6,[r4,#4]
000060  88db              LDRH     r3,[r3,#6]
000062  8123              STRH     r3,[r4,#8]
;;;700    		Files[i].ctr = 0;
000064  2300              MOVS     r3,#0
000066  8163              STRH     r3,[r4,#0xa]
                  |L39.104|
;;;701    	}
;;;702    
;;;703    	if (acc && Files[i].ctr) return 0;	/* Access violation (int err) */
000068  2900              CMP      r1,#0
;;;704    
;;;705    	Files[i].ctr = acc ? 0x100 : Files[i].ctr + 1;	/* Set semaphore value */
00006a  eb000140          ADD      r1,r0,r0,LSL #1
00006e  eb020181          ADD      r1,r2,r1,LSL #2
000072  8949              LDRH     r1,[r1,#0xa]
000074  d002              BEQ      |L39.124|
000076  b119              CBZ      r1,|L39.128|
                  |L39.120|
000078  2000              MOVS     r0,#0                 ;703
;;;706    
;;;707    	return i + 1;
;;;708    }
00007a  bdf0              POP      {r4-r7,pc}
                  |L39.124|
00007c  1c49              ADDS     r1,r1,#1
00007e  e001              B        |L39.132|
                  |L39.128|
000080  f44f7180          MOV      r1,#0x100             ;705
                  |L39.132|
000084  eb000340          ADD      r3,r0,r0,LSL #1       ;705
000088  eb020283          ADD      r2,r2,r3,LSL #2       ;705
00008c  1c40              ADDS     r0,r0,#1              ;705
00008e  8151              STRH     r1,[r2,#0xa]          ;705
000090  bdf0              POP      {r4-r7,pc}
;;;709    
                          ENDP

000092  0000              DCW      0x0000
                  |L39.148|
                          DCD      ||.bss||+0xc

                          AREA ||i.ld_clust||, CODE, READONLY, ALIGN=1

                  ld_clust PROC
;;;1269   static
;;;1270   DWORD ld_clust (
000000  4602              MOV      r2,r0
;;;1271   	FATFS* fs,	/* Pointer to the fs object */
;;;1272   	BYTE* dir	/* Pointer to the directory entry */
;;;1273   )
;;;1274   {
;;;1275   	DWORD cl;
;;;1276   
;;;1277   	cl = LD_WORD(dir+DIR_FstClusLO);
000002  8b48              LDRH     r0,[r1,#0x1a]
;;;1278   	if (fs->fs_type == FS_FAT32)
000004  7812              LDRB     r2,[r2,#0]
000006  2a03              CMP      r2,#3
000008  d102              BNE      |L40.16|
;;;1279   		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
00000a  8a89              LDRH     r1,[r1,#0x14]
00000c  ea404001          ORR      r0,r0,r1,LSL #16
                  |L40.16|
;;;1280   
;;;1281   	return cl;
;;;1282   }
000010  4770              BX       lr
;;;1283   
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=2

                  mem_cpy PROC
;;;561    static
;;;562    void mem_cpy (void* dst, const void* src, UINT cnt) {
000000  e004              B        |L41.12|
;;;563    	BYTE *d = (BYTE*)dst;
;;;564    	const BYTE *s = (const BYTE*)src;
;;;565    
;;;566    #if _WORD_ACCESS == 1
;;;567    	while (cnt >= sizeof (int)) {
;;;568    		*(int*)d = *(int*)s;
;;;569    		d += sizeof (int); s += sizeof (int);
;;;570    		cnt -= sizeof (int);
;;;571    	}
;;;572    #endif
;;;573    	while (cnt--)
;;;574    		*d++ = *s++;
000002  bf00              NOP      
                  |L41.4|
000004  f8113b01          LDRB     r3,[r1],#1
000008  f8003b01          STRB     r3,[r0],#1
                  |L41.12|
00000c  1e52              SUBS     r2,r2,#1
00000e  d2f9              BCS      |L41.4|
;;;575    }
000010  4770              BX       lr
;;;576    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=1

                  mem_set PROC
;;;578    static
;;;579    void mem_set (void* dst, int val, UINT cnt) {
000000  b2c9              UXTB     r1,r1
000002  e001              B        |L42.8|
                  |L42.4|
;;;580    	BYTE *d = (BYTE*)dst;
;;;581    
;;;582    	while (cnt--)
;;;583    		*d++ = (BYTE)val;
000004  f8001b01          STRB     r1,[r0],#1
                  |L42.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L42.4|
;;;584    }
00000c  4770              BX       lr
;;;585    
                          ENDP


                          AREA ||i.move_window||, CODE, READONLY, ALIGN=1

                  move_window PROC
;;;780    static
;;;781    FRESULT move_window (
000000  b570              PUSH     {r4-r6,lr}
;;;782    	FATFS* fs,		/* File system object */
;;;783    	DWORD sector	/* Sector number to make appearance in the fs->win[] */
;;;784    )
;;;785    {
000002  4604              MOV      r4,r0
;;;786    	if (sector != fs->winsect) {	/* Changed current window */
000004  6ac0              LDR      r0,[r0,#0x2c]
000006  460d              MOV      r5,r1                 ;785
000008  42a8              CMP      r0,r5
00000a  d00e              BEQ      |L43.42|
;;;787    #if !_FS_READONLY
;;;788    		if (sync_window(fs) != FR_OK)
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       sync_window
000012  b938              CBNZ     r0,|L43.36|
;;;789    			return FR_DISK_ERR;
;;;790    #endif
;;;791    		if (disk_read(fs->drv, fs->win, sector, 1))
000014  7860              LDRB     r0,[r4,#1]
000016  2301              MOVS     r3,#1
000018  462a              MOV      r2,r5
00001a  f1040130          ADD      r1,r4,#0x30
00001e  f7fffffe          BL       disk_read
000022  b108              CBZ      r0,|L43.40|
                  |L43.36|
;;;792    			return FR_DISK_ERR;
000024  2001              MOVS     r0,#1
;;;793    		fs->winsect = sector;
;;;794    	}
;;;795    
;;;796    	return FR_OK;
;;;797    }
000026  bd70              POP      {r4-r6,pc}
                  |L43.40|
000028  62e5              STR      r5,[r4,#0x2c]         ;793
                  |L43.42|
00002a  2000              MOVS     r0,#0                 ;796
00002c  bd70              POP      {r4-r6,pc}
;;;798    
                          ENDP


                          AREA ||i.put_fat||, CODE, READONLY, ALIGN=2

                  put_fat PROC
;;;910    
;;;911    FRESULT put_fat (
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;912    	FATFS* fs,	/* File system object */
;;;913    	DWORD clst,	/* Cluster# to be changed in range of 2 to fs->n_fatent - 1 */
;;;914    	DWORD val	/* New value to mark the cluster */
;;;915    )
;;;916    {
000004  4617              MOV      r7,r2
000006  460d              MOV      r5,r1
000008  4604              MOV      r4,r0
;;;917    	UINT bc;
;;;918    	BYTE *p;
;;;919    	FRESULT res;
;;;920    
;;;921    
;;;922    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
00000a  2902              CMP      r1,#2
00000c  d302              BCC      |L44.20|
00000e  6960              LDR      r0,[r4,#0x14]
000010  42a8              CMP      r0,r5
000012  d802              BHI      |L44.26|
                  |L44.20|
;;;923    		res = FR_INT_ERR;
000014  2002              MOVS     r0,#2
                  |L44.22|
;;;924    
;;;925    	} else {
;;;926    		switch (fs->fs_type) {
;;;927    		case FS_FAT12 :
;;;928    			bc = (UINT)clst; bc += bc / 2;
;;;929    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;930    			if (res != FR_OK) break;
;;;931    			p = &fs->win[bc % SS(fs)];
;;;932    			*p = (clst & 1) ? ((*p & 0x0F) | ((BYTE)val << 4)) : (BYTE)val;
;;;933    			bc++;
;;;934    			fs->wflag = 1;
;;;935    			res = move_window(fs, fs->fatbase + (bc / SS(fs)));
;;;936    			if (res != FR_OK) break;
;;;937    			p = &fs->win[bc % SS(fs)];
;;;938    			*p = (clst & 1) ? (BYTE)(val >> 4) : ((*p & 0xF0) | ((BYTE)(val >> 8) & 0x0F));
;;;939    			break;
;;;940    
;;;941    		case FS_FAT16 :
;;;942    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)));
;;;943    			if (res != FR_OK) break;
;;;944    			p = &fs->win[clst * 2 % SS(fs)];
;;;945    			ST_WORD(p, (WORD)val);
;;;946    			break;
;;;947    
;;;948    		case FS_FAT32 :
;;;949    			res = move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)));
;;;950    			if (res != FR_OK) break;
;;;951    			p = &fs->win[clst * 4 % SS(fs)];
;;;952    			val |= LD_DWORD(p) & 0xF0000000;
;;;953    			ST_DWORD(p, val);
;;;954    			break;
;;;955    
;;;956    		default :
;;;957    			res = FR_INT_ERR;
;;;958    		}
;;;959    		fs->wflag = 1;
;;;960    	}
;;;961    
;;;962    	return res;
;;;963    }
000016  e8bd87f0          POP      {r4-r10,pc}
                  |L44.26|
00001a  7821              LDRB     r1,[r4,#0]            ;926
00001c  f00708ff          AND      r8,r7,#0xff           ;932
000020  f04f0901          MOV      r9,#1                 ;926
000024  2901              CMP      r1,#1                 ;926
000026  d008              BEQ      |L44.58|
000028  2902              CMP      r1,#2                 ;926
00002a  d038              BEQ      |L44.158|
00002c  2903              CMP      r1,#3                 ;926
00002e  d047              BEQ      |L44.192|
000030  f05f0002          MOVS.W   r0,#2                 ;957
                  |L44.52|
000034  f8849004          STRB     r9,[r4,#4]            ;959
000038  e7ed              B        |L44.22|
                  |L44.58|
00003a  6a20              LDR      r0,[r4,#0x20]         ;929
00003c  eb050655          ADD      r6,r5,r5,LSR #1       ;928
000040  eb002156          ADD      r1,r0,r6,LSR #9       ;929
000044  4620              MOV      r0,r4                 ;929
000046  f7fffffe          BL       move_window
00004a  2800              CMP      r0,#0                 ;930
00004c  d1f2              BNE      |L44.52|
00004e  f3c60008          UBFX     r0,r6,#0,#9           ;931
000052  4420              ADD      r0,r0,r4              ;931
000054  3030              ADDS     r0,r0,#0x30           ;931
000056  07e9              LSLS     r1,r5,#31             ;932
000058  d003              BEQ      |L44.98|
00005a  7801              LDRB     r1,[r0,#0]            ;932
00005c  f368111f          BFI      r1,r8,#4,#28          ;932
000060  e000              B        |L44.100|
                  |L44.98|
000062  4639              MOV      r1,r7                 ;932
                  |L44.100|
000064  7001              STRB     r1,[r0,#0]            ;932
000066  f8849004          STRB     r9,[r4,#4]            ;934
00006a  6a20              LDR      r0,[r4,#0x20]         ;935
00006c  1c76              ADDS     r6,r6,#1              ;935
00006e  eb002156          ADD      r1,r0,r6,LSR #9       ;935
000072  4620              MOV      r0,r4                 ;935
000074  f7fffffe          BL       move_window
000078  2800              CMP      r0,#0                 ;936
00007a  d1db              BNE      |L44.52|
00007c  f3c60108          UBFX     r1,r6,#0,#9           ;937
000080  4421              ADD      r1,r1,r4              ;937
000082  3130              ADDS     r1,r1,#0x30           ;937
000084  07ea              LSLS     r2,r5,#31             ;938
000086  d002              BEQ      |L44.142|
000088  f3c71207          UBFX     r2,r7,#4,#8           ;938
00008c  e005              B        |L44.154|
                  |L44.142|
00008e  780a              LDRB     r2,[r1,#0]            ;938
000090  f3c72303          UBFX     r3,r7,#8,#4           ;938
000094  f00202f0          AND      r2,r2,#0xf0           ;938
000098  431a              ORRS     r2,r2,r3              ;938
                  |L44.154|
00009a  700a              STRB     r2,[r1,#0]            ;938
00009c  e7ca              B        |L44.52|
                  |L44.158|
00009e  6a20              LDR      r0,[r4,#0x20]         ;942
0000a0  eb002115          ADD      r1,r0,r5,LSR #8       ;942
0000a4  4620              MOV      r0,r4                 ;942
0000a6  f7fffffe          BL       move_window
0000aa  2800              CMP      r0,#0                 ;943
0000ac  d1c2              BNE      |L44.52|
0000ae  b2e9              UXTB     r1,r5                 ;944
0000b0  eb040141          ADD      r1,r4,r1,LSL #1       ;944
0000b4  0a3a              LSRS     r2,r7,#8              ;945
0000b6  f8818030          STRB     r8,[r1,#0x30]         ;945
0000ba  f8812031          STRB     r2,[r1,#0x31]         ;945
0000be  e7b9              B        |L44.52|
                  |L44.192|
0000c0  6a20              LDR      r0,[r4,#0x20]         ;949
0000c2  eb0011d5          ADD      r1,r0,r5,LSR #7       ;949
0000c6  4620              MOV      r0,r4                 ;949
0000c8  f7fffffe          BL       move_window
0000cc  2800              CMP      r0,#0                 ;950
0000ce  d1b1              BNE      |L44.52|
0000d0  f24011ff          MOV      r1,#0x1ff             ;951
0000d4  ea010185          AND      r1,r1,r5,LSL #2       ;951
0000d8  190a              ADDS     r2,r1,r4              ;951
0000da  f04f4370          MOV      r3,#0xf0000000        ;952
0000de  f8d21031          LDR      r1,[r2,#0x31]         ;952
0000e2  ea032101          AND      r1,r3,r1,LSL #8       ;952
0000e6  4339              ORRS     r1,r1,r7              ;952
0000e8  f8021f30          STRB     r1,[r2,#0x30]!        ;953
0000ec  0a0b              LSRS     r3,r1,#8              ;953
0000ee  7053              STRB     r3,[r2,#1]            ;953
0000f0  0c0b              LSRS     r3,r1,#16             ;953
0000f2  7093              STRB     r3,[r2,#2]            ;953
0000f4  0e09              LSRS     r1,r1,#24             ;953
0000f6  70d1              STRB     r1,[r2,#3]            ;953
0000f8  e79c              B        |L44.52|
;;;964    #endif /* !_FS_READONLY */
                          ENDP


                          AREA ||i.remove_chain||, CODE, READONLY, ALIGN=1

                  remove_chain PROC
;;;973    static
;;;974    FRESULT remove_chain (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;975    	FATFS* fs,			/* File system object */
;;;976    	DWORD clst			/* Cluster# to remove a chain from */
;;;977    )
;;;978    {
000004  460f              MOV      r7,r1
000006  4606              MOV      r6,r0
;;;979    	FRESULT res;
;;;980    	DWORD nxt;
;;;981    #if _USE_ERASE
;;;982    	DWORD scl = clst, ecl = clst, rt[2];
;;;983    #endif
;;;984    
;;;985    	if (clst < 2 || clst >= fs->n_fatent) {	/* Check range */
000008  2902              CMP      r1,#2
00000a  d316              BCC      |L45.58|
00000c  6970              LDR      r0,[r6,#0x14]
00000e  42b8              CMP      r0,r7
000010  d913              BLS      |L45.58|
;;;986    		res = FR_INT_ERR;
;;;987    
;;;988    	} else {
;;;989    		res = FR_OK;
000012  2500              MOVS     r5,#0
;;;990    		while (clst < fs->n_fatent) {			/* Not a last link? */
000014  e01f              B        |L45.86|
                  |L45.22|
;;;991    			nxt = get_fat(fs, clst);			/* Get cluster status */
000016  4639              MOV      r1,r7
000018  4630              MOV      r0,r6
00001a  f7fffffe          BL       get_fat
00001e  0004              MOVS     r4,r0
;;;992    			if (nxt == 0) break;				/* Empty cluster? */
000020  d01c              BEQ      |L45.92|
;;;993    			if (nxt == 1) { res = FR_INT_ERR; break; }	/* Internal error? */
000022  2c01              CMP      r4,#1
000024  d009              BEQ      |L45.58|
;;;994    			if (nxt == 0xFFFFFFFF) { res = FR_DISK_ERR; break; }	/* Disk error? */
000026  1c60              ADDS     r0,r4,#1
000028  d009              BEQ      |L45.62|
;;;995    			res = put_fat(fs, clst, 0);			/* Mark the cluster "empty" */
00002a  2200              MOVS     r2,#0
00002c  4639              MOV      r1,r7
00002e  4630              MOV      r0,r6
000030  f7fffffe          BL       put_fat
000034  0005              MOVS     r5,r0
;;;996    			if (res != FR_OK) break;
000036  d111              BNE      |L45.92|
000038  e003              B        |L45.66|
                  |L45.58|
00003a  2502              MOVS     r5,#2                 ;993
00003c  e00e              B        |L45.92|
                  |L45.62|
00003e  2501              MOVS     r5,#1                 ;994
000040  e00c              B        |L45.92|
                  |L45.66|
;;;997    			if (fs->free_clust != 0xFFFFFFFF) {	/* Update FSINFO */
000042  6930              LDR      r0,[r6,#0x10]
000044  1c41              ADDS     r1,r0,#1
000046  d005              BEQ      |L45.84|
000048  1c40              ADDS     r0,r0,#1
;;;998    				fs->free_clust++;
;;;999    				fs->fsi_flag |= 1;
00004a  6130              STR      r0,[r6,#0x10]
00004c  7970              LDRB     r0,[r6,#5]
00004e  f0400001          ORR      r0,r0,#1
000052  7170              STRB     r0,[r6,#5]
                  |L45.84|
;;;1000   			}
;;;1001   #if _USE_ERASE
;;;1002   			if (ecl + 1 == nxt) {	/* Is next cluster contiguous? */
;;;1003   				ecl = nxt;
;;;1004   			} else {				/* End of contiguous clusters */ 
;;;1005   				rt[0] = clust2sect(fs, scl);					/* Start sector */
;;;1006   				rt[1] = clust2sect(fs, ecl) + fs->csize - 1;	/* End sector */
;;;1007   				disk_ioctl(fs->drv, CTRL_ERASE_SECTOR, rt);		/* Erase the block */
;;;1008   				scl = ecl = nxt;
;;;1009   			}
;;;1010   #endif
;;;1011   			clst = nxt;	/* Next cluster */
000054  4627              MOV      r7,r4
                  |L45.86|
000056  6970              LDR      r0,[r6,#0x14]         ;990
000058  42b8              CMP      r0,r7                 ;990
00005a  d8dc              BHI      |L45.22|
                  |L45.92|
;;;1012   		}
;;;1013   	}
;;;1014   
;;;1015   	return res;
00005c  4628              MOV      r0,r5
;;;1016   }
00005e  e8bd81f0          POP      {r4-r8,pc}
;;;1017   #endif
                          ENDP


                          AREA ||i.st_clust||, CODE, READONLY, ALIGN=1

                  st_clust PROC
;;;1286   static
;;;1287   void st_clust (
000000  7681              STRB     r1,[r0,#0x1a]
;;;1288   	BYTE* dir,	/* Pointer to the directory entry */
;;;1289   	DWORD cl	/* Value to be set */
;;;1290   )
;;;1291   {
;;;1292   	ST_WORD(dir+DIR_FstClusLO, cl);
000002  0a0a              LSRS     r2,r1,#8
000004  76c2              STRB     r2,[r0,#0x1b]
;;;1293   	ST_WORD(dir+DIR_FstClusHI, cl >> 16);
000006  0c0a              LSRS     r2,r1,#16
000008  7502              STRB     r2,[r0,#0x14]
00000a  0e09              LSRS     r1,r1,#24
00000c  7541              STRB     r1,[r0,#0x15]
;;;1294   }
00000e  4770              BX       lr
;;;1295   #endif
                          ENDP


                          AREA ||i.sum_sfn||, CODE, READONLY, ALIGN=1

                  sum_sfn PROC
;;;1469   static
;;;1470   BYTE sum_sfn (
000000  4601              MOV      r1,r0
;;;1471   	const BYTE* dir		/* Pointer to the SFN entry */
;;;1472   )
;;;1473   {
;;;1474   	BYTE sum = 0;
000002  2000              MOVS     r0,#0
;;;1475   	UINT n = 11;
000004  220b              MOVS     r2,#0xb
                  |L47.6|
;;;1476   
;;;1477   	do sum = (sum >> 1) + (sum << 7) + *dir++; while (--n);
000006  0843              LSRS     r3,r0,#1
000008  eb0310c0          ADD      r0,r3,r0,LSL #7
00000c  f8113b01          LDRB     r3,[r1],#1
000010  1e52              SUBS     r2,r2,#1
000012  4418              ADD      r0,r0,r3
000014  b2c0              UXTB     r0,r0
000016  d1f6              BNE      |L47.6|
;;;1478   	return sum;
;;;1479   }
000018  4770              BX       lr
;;;1480   #endif
                          ENDP


                          AREA ||i.sync_fs||, CODE, READONLY, ALIGN=1

                  sync_fs PROC
;;;806    static
;;;807    FRESULT sync_fs (	/* FR_OK: successful, FR_DISK_ERR: failed */
000000  b570              PUSH     {r4-r6,lr}
;;;808    	FATFS* fs		/* File system object */
;;;809    )
;;;810    {
000002  4604              MOV      r4,r0
;;;811    	FRESULT res;
;;;812    
;;;813    
;;;814    	res = sync_window(fs);
000004  f7fffffe          BL       sync_window
000008  0005              MOVS     r5,r0
;;;815    	if (res == FR_OK) {
00000a  d14f              BNE      |L48.172|
;;;816    		/* Update FSINFO sector if needed */
;;;817    		if (fs->fs_type == FS_FAT32 && fs->fsi_flag == 1) {
00000c  7820              LDRB     r0,[r4,#0]
00000e  2803              CMP      r0,#3
000010  d145              BNE      |L48.158|
000012  7960              LDRB     r0,[r4,#5]
000014  2801              CMP      r0,#1
000016  d142              BNE      |L48.158|
;;;818    			/* Create FSINFO structure */
;;;819    			mem_set(fs->win, 0, SS(fs));
000018  0242              LSLS     r2,r0,#9
00001a  f1040030          ADD      r0,r4,#0x30
00001e  2100              MOVS     r1,#0
000020  4606              MOV      r6,r0
000022  f7fffffe          BL       mem_set
;;;820    			ST_WORD(fs->win+BS_55AA, 0xAA55);
000026  2055              MOVS     r0,#0x55
000028  f884022e          STRB     r0,[r4,#0x22e]
00002c  20aa              MOVS     r0,#0xaa
00002e  f884022f          STRB     r0,[r4,#0x22f]
;;;821    			ST_DWORD(fs->win+FSI_LeadSig, 0x41615252);
000032  2052              MOVS     r0,#0x52
000034  f8840030          STRB     r0,[r4,#0x30]
000038  f8840031          STRB     r0,[r4,#0x31]
00003c  2061              MOVS     r0,#0x61
00003e  f8840032          STRB     r0,[r4,#0x32]
000042  2141              MOVS     r1,#0x41
000044  f8841033          STRB     r1,[r4,#0x33]
;;;822    			ST_DWORD(fs->win+FSI_StrucSig, 0x61417272);
000048  2272              MOVS     r2,#0x72
00004a  f8842214          STRB     r2,[r4,#0x214]
00004e  f8842215          STRB     r2,[r4,#0x215]
000052  f8841216          STRB     r1,[r4,#0x216]
000056  f8840217          STRB     r0,[r4,#0x217]
;;;823    			ST_DWORD(fs->win+FSI_Free_Count, fs->free_clust);
00005a  6920              LDR      r0,[r4,#0x10]
00005c  f8840218          STRB     r0,[r4,#0x218]
000060  0a01              LSRS     r1,r0,#8
000062  f8841219          STRB     r1,[r4,#0x219]
000066  0c01              LSRS     r1,r0,#16
000068  f884121a          STRB     r1,[r4,#0x21a]
00006c  0e00              LSRS     r0,r0,#24
00006e  f884021b          STRB     r0,[r4,#0x21b]
;;;824    			ST_DWORD(fs->win+FSI_Nxt_Free, fs->last_clust);
000072  68e0              LDR      r0,[r4,#0xc]
000074  f884021c          STRB     r0,[r4,#0x21c]
000078  0a01              LSRS     r1,r0,#8
00007a  f884121d          STRB     r1,[r4,#0x21d]
00007e  0c01              LSRS     r1,r0,#16
000080  f884121e          STRB     r1,[r4,#0x21e]
000084  0e00              LSRS     r0,r0,#24
000086  f884021f          STRB     r0,[r4,#0x21f]
;;;825    			/* Write it into the FSINFO sector */
;;;826    			fs->winsect = fs->volbase + 1;
00008a  69e2              LDR      r2,[r4,#0x1c]
;;;827    			disk_write(fs->drv, fs->win, fs->winsect, 1);
00008c  2301              MOVS     r3,#1
00008e  1c52              ADDS     r2,r2,#1              ;826
000090  62e2              STR      r2,[r4,#0x2c]
000092  7860              LDRB     r0,[r4,#1]
000094  4631              MOV      r1,r6
000096  f7fffffe          BL       disk_write
;;;828    			fs->fsi_flag = 0;
00009a  2000              MOVS     r0,#0
00009c  7160              STRB     r0,[r4,#5]
                  |L48.158|
;;;829    		}
;;;830    		/* Make sure that no pending write process in the physical drive */
;;;831    		if (disk_ioctl(fs->drv, CTRL_SYNC, 0) != RES_OK)
00009e  2200              MOVS     r2,#0
0000a0  7860              LDRB     r0,[r4,#1]
0000a2  4611              MOV      r1,r2
0000a4  f7fffffe          BL       disk_ioctl
0000a8  b100              CBZ      r0,|L48.172|
;;;832    			res = FR_DISK_ERR;
0000aa  2501              MOVS     r5,#1
                  |L48.172|
;;;833    	}
;;;834    
;;;835    	return res;
0000ac  4628              MOV      r0,r5
;;;836    }
0000ae  bd70              POP      {r4-r6,pc}
;;;837    #endif
                          ENDP


                          AREA ||i.sync_window||, CODE, READONLY, ALIGN=1

                  sync_window PROC
;;;754    static
;;;755    FRESULT sync_window (
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;756    	FATFS* fs		/* File system object */
;;;757    )
;;;758    {
000004  4604              MOV      r4,r0
;;;759    	DWORD wsect;
;;;760    	UINT nf;
;;;761    
;;;762    
;;;763    	if (fs->wflag) {	/* Write back the sector if it is dirty */
000006  7900              LDRB     r0,[r0,#4]
000008  b300              CBZ      r0,|L49.76|
;;;764    		wsect = fs->winsect;	/* Current sector number */
;;;765    		if (disk_write(fs->drv, fs->win, wsect, 1))
00000a  6ae5              LDR      r5,[r4,#0x2c]
00000c  f1040130          ADD      r1,r4,#0x30
000010  7860              LDRB     r0,[r4,#1]
000012  2301              MOVS     r3,#1
000014  462a              MOV      r2,r5
000016  460f              MOV      r7,r1
000018  f7fffffe          BL       disk_write
00001c  b110              CBZ      r0,|L49.36|
;;;766    			return FR_DISK_ERR;
00001e  2001              MOVS     r0,#1
                  |L49.32|
;;;767    		fs->wflag = 0;
;;;768    		if (wsect - fs->fatbase < fs->fsize) {		/* Is it in the FAT area? */
;;;769    			for (nf = fs->n_fats; nf >= 2; nf--) {	/* Reflect the change to all FAT copies */
;;;770    				wsect += fs->fsize;
;;;771    				disk_write(fs->drv, fs->win, wsect, 1);
;;;772    			}
;;;773    		}
;;;774    	}
;;;775    	return FR_OK;
;;;776    }
000020  e8bd81f0          POP      {r4-r8,pc}
                  |L49.36|
000024  2000              MOVS     r0,#0                 ;767
000026  7120              STRB     r0,[r4,#4]            ;767
000028  6a20              LDR      r0,[r4,#0x20]         ;768
00002a  69a1              LDR      r1,[r4,#0x18]         ;768
00002c  1a28              SUBS     r0,r5,r0              ;768
00002e  4288              CMP      r0,r1                 ;768
000030  d20c              BCS      |L49.76|
000032  78e6              LDRB     r6,[r4,#3]            ;769
000034  e008              B        |L49.72|
                  |L49.54|
000036  69a0              LDR      r0,[r4,#0x18]         ;770
000038  2301              MOVS     r3,#1                 ;771
00003a  4405              ADD      r5,r5,r0              ;770
00003c  7860              LDRB     r0,[r4,#1]            ;771
00003e  462a              MOV      r2,r5                 ;771
000040  4639              MOV      r1,r7                 ;771
000042  f7fffffe          BL       disk_write
000046  1e76              SUBS     r6,r6,#1              ;771
                  |L49.72|
000048  2e02              CMP      r6,#2                 ;769
00004a  d2f4              BCS      |L49.54|
                  |L49.76|
00004c  2000              MOVS     r0,#0                 ;775
00004e  e7e7              B        |L49.32|
;;;777    #endif
                          ENDP


                          AREA ||i.validate||, CODE, READONLY, ALIGN=1

                  validate PROC
;;;2334   static
;;;2335   FRESULT validate (	/* FR_OK(0): The object is valid, !=0: Invalid */
000000  b510              PUSH     {r4,lr}
;;;2336   	void* obj		/* Pointer to the object FIL/DIR to check validity */
;;;2337   )
;;;2338   {
000002  b138              CBZ      r0,|L50.20|
;;;2339   	FIL *fil = (FIL*)obj;	/* Assuming offset of .fs and .id in the FIL/DIR structure is identical */
;;;2340   
;;;2341   
;;;2342   	if (!fil || !fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
000004  6801              LDR      r1,[r0,#0]
000006  b129              CBZ      r1,|L50.20|
000008  780a              LDRB     r2,[r1,#0]
00000a  b11a              CBZ      r2,|L50.20|
00000c  88ca              LDRH     r2,[r1,#6]
00000e  8880              LDRH     r0,[r0,#4]
000010  4282              CMP      r2,r0
000012  d001              BEQ      |L50.24|
                  |L50.20|
;;;2343   		return FR_INVALID_OBJECT;
000014  2009              MOVS     r0,#9
                  |L50.22|
;;;2344   
;;;2345   	ENTER_FF(fil->fs);		/* Lock file system */
;;;2346   
;;;2347   	if (disk_status(fil->fs->drv) & STA_NOINIT)
;;;2348   		return FR_NOT_READY;
;;;2349   
;;;2350   	return FR_OK;
;;;2351   }
000016  bd10              POP      {r4,pc}
                  |L50.24|
000018  7848              LDRB     r0,[r1,#1]            ;2347
00001a  f7fffffe          BL       disk_status
00001e  07c0              LSLS     r0,r0,#31             ;2347
000020  d0f9              BEQ      |L50.22|
000022  2003              MOVS     r0,#3                 ;2348
000024  bd10              POP      {r4,pc}
;;;2352   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  FatFs
                          %        12
                  Files
                          %        36

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  LfnOfs
000000  01030507          DCB      0x01,0x03,0x05,0x07
000004  090e1012          DCB      0x09,0x0e,0x10,0x12
000008  1416181c          DCB      0x14,0x16,0x18,0x1c
00000c  1e                DCB      0x1e

                          AREA ||.data||, DATA, ALIGN=1

                  Fsid
000000  0000              DCB      0x00,0x00
