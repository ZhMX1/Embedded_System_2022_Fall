; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\file_sys.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\file_sys.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\file_sys.crf ..\..\User\CH376\src\FILE_SYS.C]
                          THUMB

                          AREA ||i.CH376ByteLocate||, CODE, READONLY, ALIGN=1

                  CH376ByteLocate PROC
;;;369    
;;;370    UINT8	CH376ByteLocate( UINT32 offset )  /* 以字节为单位移动当前文件指针 */
000000  b510              PUSH     {r4,lr}
;;;371    {
000002  4604              MOV      r4,r0
;;;372    	xWriteCH376Cmd( CMD4H_BYTE_LOCATE );
000004  2039              MOVS     r0,#0x39
000006  f7fffffe          BL       xWriteCH376Cmd
;;;373    	xWriteCH376Data( (UINT8)offset );
00000a  b2e0              UXTB     r0,r4
00000c  f7fffffe          BL       xWriteCH376Data
;;;374    	xWriteCH376Data( (UINT8)((UINT16)offset>>8) );
000010  f3c42007          UBFX     r0,r4,#8,#8
000014  f7fffffe          BL       xWriteCH376Data
;;;375    	xWriteCH376Data( (UINT8)(offset>>16) );
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       xWriteCH376Data
;;;376    	xWriteCH376Data( (UINT8)(offset>>24) );
000020  0e20              LSRS     r0,r4,#24
000022  f7fffffe          BL       xWriteCH376Data
;;;377    	xEndCH376Cmd( );
000026  f7fffffe          BL       xEndCH376Cmd
;;;378    	return( Wait376Interrupt( ) );
00002a  e8bd4010          POP      {r4,lr}
00002e  f7ffbffe          B.W      Wait376Interrupt
;;;379    }
;;;380    
                          ENDP


                          AREA ||i.CH376ByteRead||, CODE, READONLY, ALIGN=1

                  CH376ByteRead PROC
;;;380    
;;;381    UINT8	CH376ByteRead( PUINT8 buf, UINT16 ReqCount, PUINT16 RealCount )  /* 以字节为单位从当前位置读取数据块 */
000000  b570              PUSH     {r4-r6,lr}
;;;382    {
000002  4606              MOV      r6,r0
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
;;;383    	UINT8	s;
;;;384    	xWriteCH376Cmd( CMD2H_BYTE_READ );
000008  203a              MOVS     r0,#0x3a
00000a  f7fffffe          BL       xWriteCH376Cmd
;;;385    	xWriteCH376Data( (UINT8)ReqCount );
00000e  b2e8              UXTB     r0,r5
000010  f7fffffe          BL       xWriteCH376Data
;;;386    	xWriteCH376Data( (UINT8)(ReqCount>>8) );
000014  0a28              LSRS     r0,r5,#8
000016  f7fffffe          BL       xWriteCH376Data
;;;387    	xEndCH376Cmd( );
00001a  f7fffffe          BL       xEndCH376Cmd
;;;388    	if ( RealCount ) *RealCount = 0;
00001e  b10c              CBZ      r4,|L2.36|
000020  2000              MOVS     r0,#0
000022  e011              B        |L2.72|
                  |L2.36|
;;;389    	while ( 1 ) {
;;;390    		s = Wait376Interrupt( );
000024  f7fffffe          BL       Wait376Interrupt
;;;391    		if ( s == USB_INT_DISK_READ ) {
000028  281d              CMP      r0,#0x1d
00002a  d10f              BNE      |L2.76|
;;;392    			s = CH376ReadBlock( buf );  /* 从当前主机端点的接收缓冲区读取数据块,返回长度 */
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       CH376ReadBlock
000032  4605              MOV      r5,r0
;;;393    			xWriteCH376Cmd( CMD0H_BYTE_RD_GO );
000034  203b              MOVS     r0,#0x3b
000036  f7fffffe          BL       xWriteCH376Cmd
;;;394    			xEndCH376Cmd( );
00003a  f7fffffe          BL       xEndCH376Cmd
;;;395    			buf += s;
00003e  442e              ADD      r6,r6,r5
;;;396    			if ( RealCount ) *RealCount += s;
000040  2c00              CMP      r4,#0
000042  d0ef              BEQ      |L2.36|
000044  8820              LDRH     r0,[r4,#0]
000046  4428              ADD      r0,r0,r5
                  |L2.72|
000048  8020              STRH     r0,[r4,#0]            ;388
00004a  e7eb              B        |L2.36|
                  |L2.76|
;;;397    		}
;;;398    /*		else if ( s == USB_INT_SUCCESS ) return( s );*/  /* 结束 */
;;;399    		else return( s );  /* 错误 */
;;;400    	}
;;;401    }
00004c  bd70              POP      {r4-r6,pc}
;;;402    
                          ENDP


                          AREA ||i.CH376ByteWrite||, CODE, READONLY, ALIGN=1

                  CH376ByteWrite PROC
;;;402    
;;;403    UINT8	CH376ByteWrite( PUINT8 buf, UINT16 ReqCount, PUINT16 RealCount )  /* 以字节为单位向当前位置写入数据块 */
000000  b570              PUSH     {r4-r6,lr}
;;;404    {
000002  4606              MOV      r6,r0
000004  4614              MOV      r4,r2
000006  460d              MOV      r5,r1
;;;405    	UINT8	s;
;;;406    	xWriteCH376Cmd( CMD2H_BYTE_WRITE );
000008  203c              MOVS     r0,#0x3c
00000a  f7fffffe          BL       xWriteCH376Cmd
;;;407    	xWriteCH376Data( (UINT8)ReqCount );
00000e  b2e8              UXTB     r0,r5
000010  f7fffffe          BL       xWriteCH376Data
;;;408    	xWriteCH376Data( (UINT8)(ReqCount>>8) );
000014  0a28              LSRS     r0,r5,#8
000016  f7fffffe          BL       xWriteCH376Data
;;;409    	xEndCH376Cmd( );
00001a  f7fffffe          BL       xEndCH376Cmd
;;;410    	if ( RealCount ) *RealCount = 0;
00001e  b10c              CBZ      r4,|L3.36|
000020  2000              MOVS     r0,#0
000022  e011              B        |L3.72|
                  |L3.36|
;;;411    	while ( 1 ) {
;;;412    		s = Wait376Interrupt( );
000024  f7fffffe          BL       Wait376Interrupt
;;;413    		if ( s == USB_INT_DISK_WRITE ) {
000028  281e              CMP      r0,#0x1e
00002a  d10f              BNE      |L3.76|
;;;414    			s = CH376WriteReqBlock( buf );  /* 向内部指定缓冲区写入请求的数据块,返回长度 */
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       CH376WriteReqBlock
000032  4605              MOV      r5,r0
;;;415    			xWriteCH376Cmd( CMD0H_BYTE_WR_GO );
000034  203d              MOVS     r0,#0x3d
000036  f7fffffe          BL       xWriteCH376Cmd
;;;416    			xEndCH376Cmd( );
00003a  f7fffffe          BL       xEndCH376Cmd
;;;417    			buf += s;
00003e  442e              ADD      r6,r6,r5
;;;418    			if ( RealCount ) *RealCount += s;
000040  2c00              CMP      r4,#0
000042  d0ef              BEQ      |L3.36|
000044  8820              LDRH     r0,[r4,#0]
000046  4428              ADD      r0,r0,r5
                  |L3.72|
000048  8020              STRH     r0,[r4,#0]            ;410
00004a  e7eb              B        |L3.36|
                  |L3.76|
;;;419    		}
;;;420    /*		else if ( s == USB_INT_SUCCESS ) return( s );*/  /* 结束 */
;;;421    		else return( s );  /* 错误 */
;;;422    	}
;;;423    }
00004c  bd70              POP      {r4-r6,pc}
;;;424    
                          ENDP


                          AREA ||i.CH376DirCreate||, CODE, READONLY, ALIGN=1

                  CH376DirCreate PROC
;;;242    
;;;243    UINT8	CH376DirCreate( PUINT8 name )  /* 在根目录下新建目录(文件夹)并打开,如果目录已经存在那么直接打开 */
000000  b510              PUSH     {r4,lr}
;;;244    {
000002  4604              MOV      r4,r0
;;;245    	CH376SetFileName( name );  /* 设置将要操作的文件的文件名 */
000004  f7fffffe          BL       CH376SetFileName
;;;246    	if ( name[0] == DEF_SEPAR_CHAR1 || name[0] == DEF_SEPAR_CHAR2 ) CH376WriteVar32( VAR_CURRENT_CLUST, 0 );
000008  7820              LDRB     r0,[r4,#0]
00000a  285c              CMP      r0,#0x5c
00000c  d001              BEQ      |L4.18|
00000e  282f              CMP      r0,#0x2f
000010  d103              BNE      |L4.26|
                  |L4.18|
000012  2100              MOVS     r1,#0
000014  2064              MOVS     r0,#0x64
000016  f7fffffe          BL       CH376WriteVar32
                  |L4.26|
;;;247    	return( CH376SendCmdWaitInt( CMD0H_DIR_CREATE ) );
00001a  e8bd4010          POP      {r4,lr}
00001e  2040              MOVS     r0,#0x40
000020  f7ffbffe          B.W      CH376SendCmdWaitInt
;;;248    }
;;;249    
                          ENDP


                          AREA ||i.CH376DirInfoRead||, CODE, READONLY, ALIGN=1

                  CH376DirInfoRead PROC
;;;359    
;;;360    UINT8	CH376DirInfoRead( void )  /* 读取当前文件的目录信息 */
000000  21ff              MOVS     r1,#0xff
;;;361    {
;;;362    	return( CH376SendCmdDatWaitInt( CMD1H_DIR_INFO_READ, 0xFF ) );
000002  2037              MOVS     r0,#0x37
000004  f7ffbffe          B.W      CH376SendCmdDatWaitInt
;;;363    }
;;;364    
                          ENDP


                          AREA ||i.CH376DirInfoSave||, CODE, READONLY, ALIGN=1

                  CH376DirInfoSave PROC
;;;364    
;;;365    UINT8	CH376DirInfoSave( void )  /* 保存文件的目录信息 */
000000  2038              MOVS     r0,#0x38
;;;366    {
;;;367    	return( CH376SendCmdWaitInt( CMD0H_DIR_INFO_SAVE ) );
000002  f7ffbffe          B.W      CH376SendCmdWaitInt
;;;368    }
;;;369    
                          ENDP


                          AREA ||i.CH376DiskConnect||, CODE, READONLY, ALIGN=1

                  CH376DiskConnect PROC
;;;218    
;;;219    UINT8	CH376DiskConnect( void )  /* 检查U盘是否连接,不支持SD卡 */
000000  b510              PUSH     {r4,lr}
;;;220    {
;;;221    	if ( Query376Interrupt( ) ) CH376GetIntStatus( );  /* 检测到中断 */
000002  f7fffffe          BL       Query376Interrupt
000006  b108              CBZ      r0,|L7.12|
000008  f7fffffe          BL       CH376GetIntStatus
                  |L7.12|
;;;222    	return( CH376SendCmdWaitInt( CMD0H_DISK_CONNECT ) );
00000c  e8bd4010          POP      {r4,lr}
000010  2030              MOVS     r0,#0x30
000012  f7ffbffe          B.W      CH376SendCmdWaitInt
;;;223    }
;;;224    
                          ENDP


                          AREA ||i.CH376DiskMount||, CODE, READONLY, ALIGN=1

                  CH376DiskMount PROC
;;;224    
;;;225    UINT8	CH376DiskMount( void )  /* 初始化磁盘并测试磁盘是否就绪 */
000000  2031              MOVS     r0,#0x31
;;;226    {
;;;227    	return( CH376SendCmdWaitInt( CMD0H_DISK_MOUNT ) );
000002  f7ffbffe          B.W      CH376SendCmdWaitInt
;;;228    }
;;;229    
                          ENDP


                          AREA ||i.CH376DiskReqSense||, CODE, READONLY, ALIGN=1

                  CH376DiskReqSense PROC
;;;209    
;;;210    UINT8	CH376DiskReqSense( void )  /* 检查USB存储器错误 */
000000  b510              PUSH     {r4,lr}
;;;211    {
;;;212    	UINT8	s;
;;;213    	mDelaymS( 5 );
000002  2005              MOVS     r0,#5
000004  f7fffffe          BL       mDelaymS
;;;214    	s = CH376SendCmdWaitInt( CMD0H_DISK_R_SENSE );
000008  205a              MOVS     r0,#0x5a
00000a  f7fffffe          BL       CH376SendCmdWaitInt
00000e  4604              MOV      r4,r0
;;;215    	mDelaymS( 5 );
000010  2005              MOVS     r0,#5
000012  f7fffffe          BL       mDelaymS
;;;216    	return( s );
000016  4620              MOV      r0,r4
;;;217    }
000018  bd10              POP      {r4,pc}
;;;218    
                          ENDP


                          AREA ||i.CH376EndDirInfo||, CODE, READONLY, ALIGN=1

                  CH376EndDirInfo PROC
;;;144    
;;;145    void	CH376EndDirInfo( void )  /* 在调用CH376DirInfoRead获取FAT_DIR_INFO结构之后应该通知CH376结束 */
000000  2100              MOVS     r1,#0
;;;146    {
;;;147    	CH376WriteVar8( 0x0D, 0x00 );
000002  200d              MOVS     r0,#0xd
000004  f7ffbffe          B.W      CH376WriteVar8
;;;148    }
;;;149    
                          ENDP


                          AREA ||i.CH376FileClose||, CODE, READONLY, ALIGN=1

                  CH376FileClose PROC
;;;354    
;;;355    UINT8	CH376FileClose( UINT8 UpdateSz )  /* 关闭当前已经打开的文件或者目录(文件夹) */
000000  4601              MOV      r1,r0
;;;356    {
;;;357    	return( CH376SendCmdDatWaitInt( CMD1H_FILE_CLOSE, UpdateSz ) );
000002  2036              MOVS     r0,#0x36
000004  f7ffbffe          B.W      CH376SendCmdDatWaitInt
;;;358    }
;;;359    
                          ENDP


                          AREA ||i.CH376FileCreate||, CODE, READONLY, ALIGN=1

                  CH376FileCreate PROC
;;;236    
;;;237    UINT8	CH376FileCreate( PUINT8 name )  /* 在根目录或者当前目录下新建文件,如果文件已经存在那么先删除 */
000000  b510              PUSH     {r4,lr}
;;;238    {
000002  b108              CBZ      r0,|L12.8|
;;;239    	if ( name ) CH376SetFileName( name );  /* 设置将要操作的文件的文件名 */
000004  f7fffffe          BL       CH376SetFileName
                  |L12.8|
;;;240    	return( CH376SendCmdWaitInt( CMD0H_FILE_CREATE ) );
000008  e8bd4010          POP      {r4,lr}
00000c  2034              MOVS     r0,#0x34
00000e  f7ffbffe          B.W      CH376SendCmdWaitInt
;;;241    }
;;;242    
                          ENDP


                          AREA ||i.CH376FileCreatePath||, CODE, READONLY, ALIGN=1

                  CH376FileCreatePath PROC
;;;286    
;;;287    UINT8	CH376FileCreatePath( PUINT8 PathName )  /* 新建多级目录下的文件,支持多级目录路径,支持路径分隔符,路径长度不超过255个字符 */
000000  b570              PUSH     {r4-r6,lr}
;;;288    {
000002  4605              MOV      r5,r0
;;;289    	UINT8	s;
;;;290    	UINT8	Name;
;;;291    	Name = CH376SeparatePath( PathName );  /* 从路径中分离出最后一级文件名,返回最后一级文件名的偏移 */
000004  f7fffffe          BL       CH376SeparatePath
000008  0004              MOVS     r4,r0
;;;292    	if ( Name ) {  /* 是多级目录 */
00000a  d00d              BEQ      |L13.40|
;;;293    		s = CH376FileOpenDir( PathName, Name );  /* 打开多级目录下的最后一级目录,即打开新建文件的上级目录 */
00000c  4601              MOV      r1,r0
00000e  4628              MOV      r0,r5
000010  f7fffffe          BL       CH376FileOpenDir
;;;294    		if ( s != ERR_OPEN_DIR ) {  /* 因为是打开上级目录,所以,如果不是成功打开了目录,那么说明有问题 */
000014  2841              CMP      r0,#0x41
000016  d007              BEQ      |L13.40|
;;;295    			if ( s == USB_INT_SUCCESS ) return( ERR_FOUND_NAME );  /* 中间路径必须是目录名,如果是文件名则出错 */
000018  2814              CMP      r0,#0x14
00001a  d003              BEQ      |L13.36|
;;;296    			else if ( s == ERR_MISS_FILE ) return( ERR_MISS_DIR );  /* 中间路径的某个子目录没有找到,可能是目录名称错误 */
00001c  2842              CMP      r0,#0x42
00001e  d100              BNE      |L13.34|
000020  20b3              MOVS     r0,#0xb3
                  |L13.34|
;;;297    			else return( s );  /* 操作出错 */
;;;298    		}
;;;299    	}
;;;300    	return( CH376FileCreate( &PathName[Name] ) );  /* 在根目录或者当前目录下新建文件 */
;;;301    }
000022  bd70              POP      {r4-r6,pc}
                  |L13.36|
000024  2043              MOVS     r0,#0x43              ;295
000026  bd70              POP      {r4-r6,pc}
                  |L13.40|
000028  1928              ADDS     r0,r5,r4              ;300
00002a  e8bd4070          POP      {r4-r6,lr}            ;300
00002e  f7ffbffe          B.W      CH376FileCreate
;;;302    
                          ENDP


                          AREA ||i.CH376FileErase||, CODE, READONLY, ALIGN=1

                  CH376FileErase PROC
;;;340    
;;;341    UINT8	CH376FileErase( PUINT8 PathName )  /* 删除文件,如果已经打开则直接删除,否则对于文件会先打开再删除,支持多级目录路径 */
000000  b510              PUSH     {r4,lr}
;;;342    {
000002  b160              CBZ      r0,|L14.30|
;;;343    	UINT8	s;
;;;344    	if ( PathName ) {  /* 文件尚未打开 */
;;;345    		for ( s = 1; PathName[s] != DEF_SEPAR_CHAR1 && PathName[s] != DEF_SEPAR_CHAR2 && PathName[s] != 0; ++ s );  /* 搜索下一个路径分隔符或者路径结束符 */
000004  2101              MOVS     r1,#1
000006  e001              B        |L14.12|
                  |L14.8|
000008  1c49              ADDS     r1,r1,#1
00000a  b2c9              UXTB     r1,r1
                  |L14.12|
00000c  5c42              LDRB     r2,[r0,r1]
00000e  2a5c              CMP      r2,#0x5c
000010  d00a              BEQ      |L14.40|
000012  2a2f              CMP      r2,#0x2f
000014  d008              BEQ      |L14.40|
000016  2a00              CMP      r2,#0
000018  d1f6              BNE      |L14.8|
;;;346    		if ( PathName[s] ) {  /* 有路径分隔符,是多级目录下的文件或者目录 */
;;;347    			s = CH376FileOpenPath( PathName );  /* 打开多级目录下的文件或者目录 */
;;;348    			if ( s != USB_INT_SUCCESS && s != ERR_OPEN_DIR ) return( s );  /* 操作出错 */
;;;349    		}
;;;350    		else CH376SetFileName( PathName );  /* 没有路径分隔符,是根目录或者当前目录下的文件或者目录,设置将要操作的文件的文件名 */
00001a  f7fffffe          BL       CH376SetFileName
                  |L14.30|
;;;351    	}
;;;352    	return( CH376SendCmdWaitInt( CMD0H_FILE_ERASE ) );
00001e  e8bd4010          POP      {r4,lr}
000022  2035              MOVS     r0,#0x35
000024  f7ffbffe          B.W      CH376SendCmdWaitInt
                  |L14.40|
000028  f7fffffe          BL       CH376FileOpenPath
00002c  2814              CMP      r0,#0x14              ;348
00002e  d0f6              BEQ      |L14.30|
000030  2841              CMP      r0,#0x41              ;348
000032  d0f4              BEQ      |L14.30|
;;;353    }
000034  bd10              POP      {r4,pc}
;;;354    
                          ENDP


                          AREA ||i.CH376FileOpen||, CODE, READONLY, ALIGN=1

                  CH376FileOpen PROC
;;;229    
;;;230    UINT8	CH376FileOpen( PUINT8 name )  /* 在根目录或者当前目录下打开文件或者目录(文件夹) */
000000  b510              PUSH     {r4,lr}
;;;231    {
000002  4604              MOV      r4,r0
;;;232    	CH376SetFileName( name );  /* 设置将要操作的文件的文件名 */
000004  f7fffffe          BL       CH376SetFileName
;;;233    	if ( name[0] == DEF_SEPAR_CHAR1 || name[0] == DEF_SEPAR_CHAR2 ) CH376WriteVar32( VAR_CURRENT_CLUST, 0 );
000008  7820              LDRB     r0,[r4,#0]
00000a  285c              CMP      r0,#0x5c
00000c  d001              BEQ      |L15.18|
00000e  282f              CMP      r0,#0x2f
000010  d103              BNE      |L15.26|
                  |L15.18|
000012  2100              MOVS     r1,#0
000014  2064              MOVS     r0,#0x64
000016  f7fffffe          BL       CH376WriteVar32
                  |L15.26|
;;;234    	return( CH376SendCmdWaitInt( CMD0H_FILE_OPEN ) );
00001a  e8bd4010          POP      {r4,lr}
00001e  2032              MOVS     r0,#0x32
000020  f7ffbffe          B.W      CH376SendCmdWaitInt
;;;235    }
;;;236    
                          ENDP


                          AREA ||i.CH376FileOpenDir||, CODE, READONLY, ALIGN=1

                  CH376FileOpenDir PROC
;;;258    
;;;259    UINT8	CH376FileOpenDir( PUINT8 PathName, UINT8 StopName )  /* 打开多级目录下的文件或者目录的上级目录,支持多级目录路径,支持路径分隔符,路径长度不超过255个字符 */
000000  b570              PUSH     {r4-r6,lr}
;;;260    /* StopName 指向最后一级文件名或者目录名 */
;;;261    {
000002  4605              MOV      r5,r0
;;;262    	UINT8	i, s;
;;;263    	s = 0;
000004  2000              MOVS     r0,#0
000006  460e              MOV      r6,r1                 ;261
;;;264    	i = 1;  /* 跳过有可能的根目录符 */
000008  2401              MOVS     r4,#1
00000a  e001              B        |L16.16|
                  |L16.12|
00000c  1c64              ADDS     r4,r4,#1              ;261
;;;265    	while ( 1 ) {
;;;266    		while ( PathName[i] != DEF_SEPAR_CHAR1 && PathName[i] != DEF_SEPAR_CHAR2 && PathName[i] != 0 ) ++ i;  /* 搜索下一个路径分隔符或者路径结束符 */
00000e  b2e4              UXTB     r4,r4
                  |L16.16|
000010  5d29              LDRB     r1,[r5,r4]
000012  295c              CMP      r1,#0x5c
000014  d013              BEQ      |L16.62|
000016  292f              CMP      r1,#0x2f
000018  d011              BEQ      |L16.62|
00001a  2900              CMP      r1,#0
00001c  d1f6              BNE      |L16.12|
;;;267    		if ( PathName[i] ) i ++;  /* 找到了路径分隔符,修改指向目标文件的最后一级文件名 */
;;;268    		else i = 0;  /* 路径结束 */
00001e  2400              MOVS     r4,#0
                  |L16.32|
;;;269    		s = CH376FileOpen( &PathName[s] );  /* 打开文件或者目录 */
000020  4428              ADD      r0,r0,r5
000022  f7fffffe          BL       CH376FileOpen
;;;270    		if ( i && i != StopName ) {  /* 路径尚未结束 */
000026  2c00              CMP      r4,#0
000028  d008              BEQ      |L16.60|
00002a  42b4              CMP      r4,r6
00002c  d006              BEQ      |L16.60|
;;;271    			if ( s != ERR_OPEN_DIR ) {  /* 因为是逐级打开,尚未到路径结束,所以,如果不是成功打开了目录,那么说明有问题 */
00002e  2841              CMP      r0,#0x41
000030  d00a              BEQ      |L16.72|
;;;272    				if ( s == USB_INT_SUCCESS ) return( ERR_FOUND_NAME );  /* 中间路径必须是目录名,如果是文件名则出错 */
000032  2814              CMP      r0,#0x14
000034  d006              BEQ      |L16.68|
;;;273    				else if ( s == ERR_MISS_FILE ) return( ERR_MISS_DIR );  /* 中间路径的某个子目录没有找到,可能是目录名称错误 */
000036  2842              CMP      r0,#0x42
000038  d100              BNE      |L16.60|
00003a  20b3              MOVS     r0,#0xb3
                  |L16.60|
;;;274    				else return( s );  /* 操作出错 */
;;;275    			}
;;;276    			s = i;  /* 从下一级目录开始继续 */
;;;277    		}
;;;278    		else return( s );  /* 路径结束,USB_INT_SUCCESS为成功打开文件,ERR_OPEN_DIR为成功打开目录(文件夹),其它为操作出错 */
;;;279    	}
;;;280    }
00003c  bd70              POP      {r4-r6,pc}
                  |L16.62|
00003e  1c64              ADDS     r4,r4,#1
000040  b2e4              UXTB     r4,r4                 ;267
000042  e7ed              B        |L16.32|
                  |L16.68|
000044  2043              MOVS     r0,#0x43              ;272
000046  bd70              POP      {r4-r6,pc}
                  |L16.72|
000048  4620              MOV      r0,r4                 ;276
00004a  e7e1              B        |L16.16|
;;;281    
                          ENDP


                          AREA ||i.CH376FileOpenPath||, CODE, READONLY, ALIGN=1

                  CH376FileOpenPath PROC
;;;281    
;;;282    UINT8	CH376FileOpenPath( PUINT8 PathName )  /* 打开多级目录下的文件或者目录(文件夹),支持多级目录路径,支持路径分隔符,路径长度不超过255个字符 */
000000  21ff              MOVS     r1,#0xff
;;;283    {
;;;284    	return( CH376FileOpenDir( PathName, 0xFF ) );
000002  f7ffbffe          B.W      CH376FileOpenDir
;;;285    }
;;;286    
                          ENDP


                          AREA ||i.CH376GetDiskStatus||, CODE, READONLY, ALIGN=1

                  CH376GetDiskStatus PROC
;;;154    
;;;155    UINT8	CH376GetDiskStatus( void )  /* 获取磁盘和文件系统的工作状态 */
000000  202b              MOVS     r0,#0x2b
;;;156    {
;;;157    	return( CH376ReadVar8( VAR_DISK_STATUS ) );
000002  f7ffbffe          B.W      CH376ReadVar8
;;;158    }
;;;159    
                          ENDP


                          AREA ||i.CH376GetFileSize||, CODE, READONLY, ALIGN=1

                  CH376GetFileSize PROC
;;;149    
;;;150    UINT32	CH376GetFileSize( void )  /* 读取当前文件长度 */
000000  2068              MOVS     r0,#0x68
;;;151    {
;;;152    	return( CH376ReadVar32( VAR_FILE_SIZE ) );
000002  f7ffbffe          B.W      CH376ReadVar32
;;;153    }
;;;154    
                          ENDP


                          AREA ||i.CH376GetIntStatus||, CODE, READONLY, ALIGN=1

                  CH376GetIntStatus PROC
;;;159    
;;;160    UINT8	CH376GetIntStatus( void )  /* 获取中断状态并取消中断请求 */
000000  b510              PUSH     {r4,lr}
;;;161    {
;;;162    	UINT8	s;
;;;163    	xWriteCH376Cmd( CMD01_GET_STATUS );
000002  2022              MOVS     r0,#0x22
000004  f7fffffe          BL       xWriteCH376Cmd
;;;164    	s = xReadCH376Data( );
000008  f7fffffe          BL       xReadCH376Data
00000c  4604              MOV      r4,r0
;;;165    	xEndCH376Cmd( );
00000e  f7fffffe          BL       xEndCH376Cmd
;;;166    	return( s );
000012  4620              MOV      r0,r4
;;;167    }
000014  bd10              POP      {r4,pc}
;;;168    
                          ENDP


                          AREA ||i.CH376Read32bitDat||, CODE, READONLY, ALIGN=1

                  CH376Read32bitDat PROC
;;;97     
;;;98     UINT32	CH376Read32bitDat( void )  /* 从CH376芯片读取32位的数据并结束命令 */
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;99     {
;;;100    	UINT8	c0, c1, c2, c3;
;;;101    	c0 = xReadCH376Data( );
000004  f7fffffe          BL       xReadCH376Data
000008  4606              MOV      r6,r0
;;;102    	c1 = xReadCH376Data( );
00000a  f7fffffe          BL       xReadCH376Data
00000e  4605              MOV      r5,r0
;;;103    	c2 = xReadCH376Data( );
000010  f7fffffe          BL       xReadCH376Data
000014  4604              MOV      r4,r0
;;;104    	c3 = xReadCH376Data( );
000016  f7fffffe          BL       xReadCH376Data
00001a  4607              MOV      r7,r0
;;;105    	xEndCH376Cmd( );
00001c  f7fffffe          BL       xEndCH376Cmd
;;;106    	return( c0 | (UINT16)c1 << 8 | (UINT32)c2 << 16 | (UINT32)c3 << 24 );
000020  ea462005          ORR      r0,r6,r5,LSL #8
000024  ea404004          ORR      r0,r0,r4,LSL #16
000028  ea406007          ORR      r0,r0,r7,LSL #24
;;;107    }
00002c  e8bd81f0          POP      {r4-r8,pc}
;;;108    
                          ENDP


                          AREA ||i.CH376ReadBlock||, CODE, READONLY, ALIGN=1

                  CH376ReadBlock PROC
;;;18     
;;;19     UINT8	CH376ReadBlock( PUINT8 buf )  /* 从当前主机端点的接收缓冲区读取数据块,返回长度 */
000000  b570              PUSH     {r4-r6,lr}
;;;20     {
000002  4605              MOV      r5,r0
;;;21     	UINT8	s, l;
;;;22     	xWriteCH376Cmd( CMD01_RD_USB_DATA0 );
000004  2027              MOVS     r0,#0x27
000006  f7fffffe          BL       xWriteCH376Cmd
;;;23     	s = l = xReadCH376Data( );  /* 长度 */
00000a  f7fffffe          BL       xReadCH376Data
00000e  0004              MOVS     r4,r0
000010  4626              MOV      r6,r4
;;;24     	if ( l ) {
000012  d007              BEQ      |L22.36|
                  |L22.20|
;;;25     		do {
;;;26     			*buf = xReadCH376Data( );
000014  f7fffffe          BL       xReadCH376Data
000018  1e64              SUBS     r4,r4,#1
00001a  f8050b01          STRB     r0,[r5],#1
;;;27     			buf ++;
;;;28     		} while ( -- l );
00001e  f01404ff          ANDS     r4,r4,#0xff
000022  d1f7              BNE      |L22.20|
                  |L22.36|
;;;29     	}
;;;30     	xEndCH376Cmd( );
000024  f7fffffe          BL       xEndCH376Cmd
;;;31     	return( s );
000028  4630              MOV      r0,r6
;;;32     }
00002a  bd70              POP      {r4-r6,pc}
;;;33     
                          ENDP


                          AREA ||i.CH376ReadVar32||, CODE, READONLY, ALIGN=1

                  CH376ReadVar32 PROC
;;;126    
;;;127    UINT32	CH376ReadVar32( UINT8 var )  /* 读CH376芯片内部的32位变量 */
000000  b510              PUSH     {r4,lr}
;;;128    {
000002  4604              MOV      r4,r0
;;;129    	xWriteCH376Cmd( CMD14_READ_VAR32 );
000004  200c              MOVS     r0,#0xc
000006  f7fffffe          BL       xWriteCH376Cmd
;;;130    	xWriteCH376Data( var );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       xWriteCH376Data
;;;131    	return( CH376Read32bitDat( ) );  /* 从CH376芯片读取32位的数据并结束命令 */
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      CH376Read32bitDat
;;;132    }
;;;133    
                          ENDP


                          AREA ||i.CH376ReadVar8||, CODE, READONLY, ALIGN=1

                  CH376ReadVar8 PROC
;;;108    
;;;109    UINT8	CH376ReadVar8( UINT8 var )  /* 读CH376芯片内部的8位变量 */
000000  b510              PUSH     {r4,lr}
;;;110    {
000002  4604              MOV      r4,r0
;;;111    	UINT8	c0;
;;;112    	xWriteCH376Cmd( CMD11_READ_VAR8 );
000004  200a              MOVS     r0,#0xa
000006  f7fffffe          BL       xWriteCH376Cmd
;;;113    	xWriteCH376Data( var );
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       xWriteCH376Data
;;;114    	c0 = xReadCH376Data( );
000010  f7fffffe          BL       xReadCH376Data
000014  4604              MOV      r4,r0
;;;115    	xEndCH376Cmd( );
000016  f7fffffe          BL       xEndCH376Cmd
;;;116    	return( c0 );
00001a  4620              MOV      r0,r4
;;;117    }
00001c  bd10              POP      {r4,pc}
;;;118    
                          ENDP


                          AREA ||i.CH376SecLocate||, CODE, READONLY, ALIGN=1

                  CH376SecLocate PROC
;;;465    
;;;466    UINT8	CH376SecLocate( UINT32 offset )  /* 以扇区为单位移动当前文件指针 */
000000  b510              PUSH     {r4,lr}
;;;467    {
000002  4604              MOV      r4,r0
;;;468    	xWriteCH376Cmd( CMD4H_SEC_LOCATE );
000004  204a              MOVS     r0,#0x4a
000006  f7fffffe          BL       xWriteCH376Cmd
;;;469    	xWriteCH376Data( (UINT8)offset );
00000a  b2e0              UXTB     r0,r4
00000c  f7fffffe          BL       xWriteCH376Data
;;;470    	xWriteCH376Data( (UINT8)((UINT16)offset>>8) );
000010  f3c42007          UBFX     r0,r4,#8,#8
000014  f7fffffe          BL       xWriteCH376Data
;;;471    	xWriteCH376Data( (UINT8)(offset>>16) );
000018  f3c44007          UBFX     r0,r4,#16,#8
00001c  f7fffffe          BL       xWriteCH376Data
;;;472    	xWriteCH376Data( 0 );  /* 超出最大文件尺寸 */
000020  2000              MOVS     r0,#0
000022  f7fffffe          BL       xWriteCH376Data
;;;473    	xEndCH376Cmd( );
000026  f7fffffe          BL       xEndCH376Cmd
;;;474    	return( Wait376Interrupt( ) );
00002a  e8bd4010          POP      {r4,lr}
00002e  f7ffbffe          B.W      Wait376Interrupt
;;;475    }
;;;476    
                          ENDP


                          AREA ||i.CH376SendCmdDatWaitInt||, CODE, READONLY, ALIGN=1

                  CH376SendCmdDatWaitInt PROC
;;;201    
;;;202    UINT8	CH376SendCmdDatWaitInt( UINT8 mCmd, UINT8 mDat )  /* 发出命令码和一字节数据后,等待中断 */
000000  b510              PUSH     {r4,lr}
;;;203    {
000002  460c              MOV      r4,r1
;;;204    	xWriteCH376Cmd( mCmd );
000004  f7fffffe          BL       xWriteCH376Cmd
;;;205    	xWriteCH376Data( mDat );
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       xWriteCH376Data
;;;206    	xEndCH376Cmd( );
00000e  f7fffffe          BL       xEndCH376Cmd
;;;207    	return( Wait376Interrupt( ) );
000012  e8bd4010          POP      {r4,lr}
000016  f7ffbffe          B.W      Wait376Interrupt
;;;208    }
;;;209    
                          ENDP


                          AREA ||i.CH376SendCmdWaitInt||, CODE, READONLY, ALIGN=1

                  CH376SendCmdWaitInt PROC
;;;194    
;;;195    UINT8	CH376SendCmdWaitInt( UINT8 mCmd )  /* 发出命令码后,等待中断 */
000000  b510              PUSH     {r4,lr}
;;;196    {
;;;197    	xWriteCH376Cmd( mCmd );
000002  f7fffffe          BL       xWriteCH376Cmd
;;;198    	xEndCH376Cmd( );
000006  f7fffffe          BL       xEndCH376Cmd
;;;199    	return( Wait376Interrupt( ) );
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      Wait376Interrupt
;;;200    }
;;;201    
                          ENDP


                          AREA ||i.CH376SeparatePath||, CODE, READONLY, ALIGN=2

                  CH376SeparatePath PROC
;;;249    
;;;250    UINT8	CH376SeparatePath( PUINT8 path )  /* 从路径中分离出最后一级文件名或者目录(文件夹)名,返回最后一级文件名或者目录名的字节偏移 */
000000  4601              MOV      r1,r0
;;;251    {
000002  e000              B        |L28.6|
                  |L28.4|
000004  1c49              ADDS     r1,r1,#1
                  |L28.6|
;;;252    	PUINT8	pName;
;;;253    	for ( pName = path; *pName != 0; ++ pName );  /* 到文件名字符串结束位置 */
000006  780a              LDRB     r2,[r1,#0]
000008  2a00              CMP      r2,#0
00000a  d1fb              BNE      |L28.4|
00000c  e006              B        |L28.28|
;;;254    	while ( *pName != DEF_SEPAR_CHAR1 && *pName != DEF_SEPAR_CHAR2 && pName != path ) pName --;  /*  搜索倒数第一个路径分隔符 */
00000e  bf00              NOP      
                  |L28.16|
000010  f8112d01          LDRB     r2,[r1,#-1]!
000014  2a5c              CMP      r2,#0x5c
000016  d003              BEQ      |L28.32|
000018  2a2f              CMP      r2,#0x2f
00001a  d001              BEQ      |L28.32|
                  |L28.28|
00001c  4281              CMP      r1,r0
00001e  d1f7              BNE      |L28.16|
                  |L28.32|
;;;255    	if ( pName != path ) pName ++;  /* 找到了路径分隔符,则修改指向目标文件的最后一级文件名,跳过前面的多级目录名及路径分隔符 */
000020  4281              CMP      r1,r0
000022  d000              BEQ      |L28.38|
000024  1c49              ADDS     r1,r1,#1
                  |L28.38|
;;;256    	return( pName - path );
000026  1a08              SUBS     r0,r1,r0
000028  b2c0              UXTB     r0,r0
;;;257    }
00002a  4770              BX       lr
;;;258    
                          ENDP


                          AREA ||i.CH376SetFileName||, CODE, READONLY, ALIGN=2

                  CH376SetFileName PROC
;;;75     
;;;76     void	CH376SetFileName( PUINT8 name )  /* 设置将要操作的文件的文件名 */
000000  b570              PUSH     {r4-r6,lr}
;;;77     {
000002  4605              MOV      r5,r0
;;;78     /*	UINT8	i;*/
;;;79     	UINT8	c;
;;;80     	xWriteCH376Cmd( CMD10_SET_FILE_NAME );
000004  202f              MOVS     r0,#0x2f
000006  f7fffffe          BL       xWriteCH376Cmd
;;;81     /*	for ( i = MAX_FILE_NAME_LEN; i != 0; -- i ) {
;;;82     		c = *name;
;;;83     		xWriteCH376Data( c );
;;;84     		if ( c == 0 ) break;
;;;85     		name ++;
;;;86     	}*/
;;;87     	c = *name;
00000a  782c              LDRB     r4,[r5,#0]
;;;88     	xWriteCH376Data( c );
;;;89     	while ( c ) {
00000c  e006              B        |L29.28|
;;;90     		name ++;
;;;91     		c = *name;
00000e  bf00              NOP      
                  |L29.16|
000010  f8154f01          LDRB     r4,[r5,#1]!
;;;92     		if ( c == DEF_SEPAR_CHAR1 || c == DEF_SEPAR_CHAR2 ) c = 0;  /* 强行将文件名截止 */
000014  2c5c              CMP      r4,#0x5c
000016  d00a              BEQ      |L29.46|
000018  2c2f              CMP      r4,#0x2f
00001a  d008              BEQ      |L29.46|
                  |L29.28|
;;;93     		xWriteCH376Data( c );
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       xWriteCH376Data
000022  2c00              CMP      r4,#0                 ;89
000024  d1f4              BNE      |L29.16|
                  |L29.38|
;;;94     	}
;;;95     	xEndCH376Cmd( );
000026  e8bd4070          POP      {r4-r6,lr}
00002a  f7ffbffe          B.W      xEndCH376Cmd
                  |L29.46|
00002e  2000              MOVS     r0,#0                 ;92
000030  f7fffffe          BL       xWriteCH376Data
000034  e7f7              B        |L29.38|
;;;96     }
;;;97     
                          ENDP


                          AREA ||i.CH376WriteHostBlock||, CODE, READONLY, ALIGN=1

                  CH376WriteHostBlock PROC
;;;48     
;;;49     void	CH376WriteHostBlock( PUINT8 buf, UINT8 len )  /* 向USB主机端点的发送缓冲区写入数据块 */
000000  b570              PUSH     {r4-r6,lr}
;;;50     {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;51     	xWriteCH376Cmd( CMD10_WR_HOST_DATA );
000006  202c              MOVS     r0,#0x2c
000008  f7fffffe          BL       xWriteCH376Cmd
;;;52     	xWriteCH376Data( len );  /* 长度 */
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       xWriteCH376Data
;;;53     	if ( len ) {
000012  b13c              CBZ      r4,|L30.36|
                  |L30.20|
;;;54     		do {
;;;55     			xWriteCH376Data( *buf );
000014  7828              LDRB     r0,[r5,#0]
000016  f7fffffe          BL       xWriteCH376Data
00001a  1e64              SUBS     r4,r4,#1
00001c  1c6d              ADDS     r5,r5,#1
;;;56     			buf ++;
;;;57     		} while ( -- len );
00001e  f01404ff          ANDS     r4,r4,#0xff
000022  d1f7              BNE      |L30.20|
                  |L30.36|
;;;58     	}
;;;59     	xEndCH376Cmd( );
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      xEndCH376Cmd
;;;60     }
;;;61     
                          ENDP


                          AREA ||i.CH376WriteOfsBlock||, CODE, READONLY, ALIGN=1

                  CH376WriteOfsBlock PROC
;;;61     
;;;62     void	CH376WriteOfsBlock( PUINT8 buf, UINT8 ofs, UINT8 len )  /* 向内部缓冲区指定偏移地址写入数据块 */
000000  b570              PUSH     {r4-r6,lr}
;;;63     {
000002  4605              MOV      r5,r0
000004  4614              MOV      r4,r2
000006  460e              MOV      r6,r1
;;;64     	xWriteCH376Cmd( CMD20_WR_OFS_DATA );
000008  202e              MOVS     r0,#0x2e
00000a  f7fffffe          BL       xWriteCH376Cmd
;;;65     	xWriteCH376Data( ofs );  /* 偏移地址 */
00000e  4630              MOV      r0,r6
000010  f7fffffe          BL       xWriteCH376Data
;;;66     	xWriteCH376Data( len );  /* 长度 */
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       xWriteCH376Data
;;;67     	if ( len ) {
00001a  b13c              CBZ      r4,|L31.44|
                  |L31.28|
;;;68     		do {
;;;69     			xWriteCH376Data( *buf );
00001c  7828              LDRB     r0,[r5,#0]
00001e  f7fffffe          BL       xWriteCH376Data
000022  1e64              SUBS     r4,r4,#1
000024  1c6d              ADDS     r5,r5,#1
;;;70     			buf ++;
;;;71     		} while ( -- len );
000026  f01404ff          ANDS     r4,r4,#0xff
00002a  d1f7              BNE      |L31.28|
                  |L31.44|
;;;72     	}
;;;73     	xEndCH376Cmd( );
00002c  e8bd4070          POP      {r4-r6,lr}
000030  f7ffbffe          B.W      xEndCH376Cmd
;;;74     }
;;;75     
                          ENDP


                          AREA ||i.CH376WriteReqBlock||, CODE, READONLY, ALIGN=1

                  CH376WriteReqBlock PROC
;;;33     
;;;34     UINT8	CH376WriteReqBlock( PUINT8 buf )  /* 向内部指定缓冲区写入请求的数据块,返回长度 */
000000  b570              PUSH     {r4-r6,lr}
;;;35     {
000002  4605              MOV      r5,r0
;;;36     	UINT8	s, l;
;;;37     	xWriteCH376Cmd( CMD01_WR_REQ_DATA );
000004  202d              MOVS     r0,#0x2d
000006  f7fffffe          BL       xWriteCH376Cmd
;;;38     	s = l = xReadCH376Data( );  /* 长度 */
00000a  f7fffffe          BL       xReadCH376Data
00000e  0004              MOVS     r4,r0
000010  4626              MOV      r6,r4
;;;39     	if ( l ) {
000012  d007              BEQ      |L32.36|
                  |L32.20|
;;;40     		do {
;;;41     			xWriteCH376Data( *buf );
000014  7828              LDRB     r0,[r5,#0]
000016  f7fffffe          BL       xWriteCH376Data
00001a  1e64              SUBS     r4,r4,#1
00001c  1c6d              ADDS     r5,r5,#1
;;;42     			buf ++;
;;;43     		} while ( -- l );
00001e  f01404ff          ANDS     r4,r4,#0xff
000022  d1f7              BNE      |L32.20|
                  |L32.36|
;;;44     	}
;;;45     	xEndCH376Cmd( );
000024  f7fffffe          BL       xEndCH376Cmd
;;;46     	return( s );
000028  4630              MOV      r0,r6
;;;47     }
00002a  bd70              POP      {r4-r6,pc}
;;;48     
                          ENDP


                          AREA ||i.CH376WriteVar32||, CODE, READONLY, ALIGN=1

                  CH376WriteVar32 PROC
;;;133    
;;;134    void	CH376WriteVar32( UINT8 var, UINT32 dat )  /* 写CH376芯片内部的32位变量 */
000000  b570              PUSH     {r4-r6,lr}
;;;135    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;136    	xWriteCH376Cmd( CMD50_WRITE_VAR32 );
000006  200d              MOVS     r0,#0xd
000008  f7fffffe          BL       xWriteCH376Cmd
;;;137    	xWriteCH376Data( var );
00000c  4628              MOV      r0,r5
00000e  f7fffffe          BL       xWriteCH376Data
;;;138    	xWriteCH376Data( (UINT8)dat );
000012  b2e0              UXTB     r0,r4
000014  f7fffffe          BL       xWriteCH376Data
;;;139    	xWriteCH376Data( (UINT8)( (UINT16)dat >> 8 ) );
000018  f3c42007          UBFX     r0,r4,#8,#8
00001c  f7fffffe          BL       xWriteCH376Data
;;;140    	xWriteCH376Data( (UINT8)( dat >> 16 ) );
000020  f3c44007          UBFX     r0,r4,#16,#8
000024  f7fffffe          BL       xWriteCH376Data
;;;141    	xWriteCH376Data( (UINT8)( dat >> 24 ) );
000028  0e20              LSRS     r0,r4,#24
00002a  f7fffffe          BL       xWriteCH376Data
;;;142    	xEndCH376Cmd( );
00002e  e8bd4070          POP      {r4-r6,lr}
000032  f7ffbffe          B.W      xEndCH376Cmd
;;;143    }
;;;144    
                          ENDP


                          AREA ||i.CH376WriteVar8||, CODE, READONLY, ALIGN=1

                  CH376WriteVar8 PROC
;;;118    
;;;119    void	CH376WriteVar8( UINT8 var, UINT8 dat )  /* 写CH376芯片内部的8位变量 */
000000  b570              PUSH     {r4-r6,lr}
;;;120    {
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;121    	xWriteCH376Cmd( CMD20_WRITE_VAR8 );
000006  200b              MOVS     r0,#0xb
000008  f7fffffe          BL       xWriteCH376Cmd
;;;122    	xWriteCH376Data( var );
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       xWriteCH376Data
;;;123    	xWriteCH376Data( dat );
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       xWriteCH376Data
;;;124    	xEndCH376Cmd( );
000018  e8bd4070          POP      {r4-r6,lr}
00001c  f7ffbffe          B.W      xEndCH376Cmd
;;;125    }
;;;126    
                          ENDP


                          AREA ||i.Wait376Interrupt||, CODE, READONLY, ALIGN=2

                  Wait376Interrupt PROC
;;;169    #ifndef	NO_DEFAULT_CH376_INT
;;;170    UINT8	Wait376Interrupt( void )  /* 等待CH376中断(INT#低电平)，返回中断状态码, 超时则返回ERR_USB_UNKNOWN */
000000  b570              PUSH     {r4-r6,lr}
;;;171    {
;;;172    #ifdef	DEF_INT_TIMEOUT
;;;173    #if		DEF_INT_TIMEOUT < 1
;;;174    	while ( Query376Interrupt( ) == FALSE );  /* 一直等中断 */
;;;175    	return( CH376GetIntStatus( ) );  /* 检测到中断 */
;;;176    #else
;;;177    	UINT32	i;
;;;178    	for ( i = 0; i < DEF_INT_TIMEOUT; i ++ ) {  /* 计数防止超时 */
;;;179    		if ( Query376Interrupt( ) ) return( CH376GetIntStatus( ) );  /* 检测到中断 */
;;;180    /* 在等待CH376中断的过程中,可以做些需要及时处理的其它事情 */
;;;181    	}
;;;182    	return( ERR_USB_UNKNOWN );  /* 不应该发生的情况 */
;;;183    #endif
;;;184    #else
;;;185    	UINT32	i;
;;;186    	for ( i = 0; i < 5000000; i ++ ) {  /* 计数防止超时,默认的超时时间,与单片机主频有关 */
000002  4d07              LDR      r5,|L35.32|
000004  2400              MOVS     r4,#0
;;;187    		if ( Query376Interrupt( ) ) return( CH376GetIntStatus( ) );  /* 检测到中断 */
000006  bf00              NOP      
                  |L35.8|
000008  f7fffffe          BL       Query376Interrupt
00000c  b118              CBZ      r0,|L35.22|
00000e  e8bd4070          POP      {r4-r6,lr}
000012  f7ffbffe          B.W      CH376GetIntStatus
                  |L35.22|
000016  1c64              ADDS     r4,r4,#1
000018  42ac              CMP      r4,r5                 ;186
00001a  d3f5              BCC      |L35.8|
;;;188    /* 在等待CH376中断的过程中,可以做些需要及时处理的其它事情 */
;;;189    	}
;;;190    	return( ERR_USB_UNKNOWN );  /* 不应该发生的情况 */
00001c  20fa              MOVS     r0,#0xfa
;;;191    #endif
;;;192    }
00001e  bd70              POP      {r4-r6,pc}
;;;193    #endif
                          ENDP

                  |L35.32|
                          DCD      0x004c4b40
