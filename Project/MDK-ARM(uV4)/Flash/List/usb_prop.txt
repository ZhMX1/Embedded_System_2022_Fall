; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\usb_prop.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\usb_prop.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\usb_prop.crf ..\..\User\usb_mass\usb_prop.c]
                          THUMB

                          AREA ||i.Get_Max_Lun||, CODE, READONLY, ALIGN=2

                  Get_Max_Lun PROC
;;;409    *******************************************************************************/
;;;410    uint8_t *Get_Max_Lun(uint16_t Length)
000000  b108              CBZ      r0,|L1.6|
;;;411    {
;;;412      if (Length == 0)
;;;413      {
;;;414        pInformation->Ctrl_Info.Usb_wLength = LUN_DATA_LENGTH;
;;;415        return 0;
;;;416      }
;;;417      else
;;;418      {
;;;419        return (uint8_t *)&Max_Lun;
000002  4804              LDR      r0,|L1.20|
;;;420      }
;;;421    }
000004  4770              BX       lr
                  |L1.6|
000006  4904              LDR      r1,|L1.24|
000008  2001              MOVS     r0,#1                 ;414
00000a  6809              LDR      r1,[r1,#0]            ;414  ; pInformation
00000c  8208              STRH     r0,[r1,#0x10]         ;414
00000e  2000              MOVS     r0,#0                 ;415
000010  4770              BX       lr
;;;422    
                          ENDP

000012  0000              DCW      0x0000
                  |L1.20|
                          DCD      Max_Lun
                  |L1.24|
                          DCD      pInformation

                          AREA ||i.MASS_Data_Setup||, CODE, READONLY, ALIGN=2

                  MASS_Data_Setup PROC
;;;271    *******************************************************************************/
;;;272    RESULT MASS_Data_Setup(uint8_t RequestNo)
000000  490d              LDR      r1,|L2.56|
;;;273    {
000002  b500              PUSH     {lr}
;;;274      uint8_t    *(*CopyRoutine)(uint16_t);
;;;275    
;;;276      CopyRoutine = NULL;
;;;277      if ((Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT))
000004  6809              LDR      r1,[r1,#0]  ; pInformation
000006  780a              LDRB     r2,[r1,#0]
000008  f002027f          AND      r2,r2,#0x7f
00000c  2a21              CMP      r2,#0x21
00000e  d108              BNE      |L2.34|
;;;278          && (RequestNo == GET_MAX_LUN) && (pInformation->USBwValue == 0)
000010  28fe              CMP      r0,#0xfe
000012  d106              BNE      |L2.34|
000014  8848              LDRH     r0,[r1,#2]
000016  b920              CBNZ     r0,|L2.34|
;;;279          && (pInformation->USBwIndex == 0) && (pInformation->USBwLength == 0x01))
000018  8888              LDRH     r0,[r1,#4]
00001a  b910              CBNZ     r0,|L2.34|
00001c  88c8              LDRH     r0,[r1,#6]
00001e  2801              CMP      r0,#1
000020  d001              BEQ      |L2.38|
                  |L2.34|
;;;280      {
;;;281        CopyRoutine = Get_Max_Lun;
;;;282      }
;;;283      else
;;;284      {
;;;285        return USB_UNSUPPORT;
000022  2002              MOVS     r0,#2
;;;286      }
;;;287    
;;;288      if (CopyRoutine == NULL)
;;;289      {
;;;290        return USB_UNSUPPORT;
;;;291      }
;;;292    
;;;293      pInformation->Ctrl_Info.CopyData = CopyRoutine;
;;;294      pInformation->Ctrl_Info.Usb_wOffset = 0;
;;;295      (*CopyRoutine)(0);
;;;296    
;;;297      return USB_SUCCESS;
;;;298    
;;;299    }
000024  bd00              POP      {pc}
                  |L2.38|
000026  4805              LDR      r0,|L2.60|
000028  6188              STR      r0,[r1,#0x18]         ;294
00002a  2000              MOVS     r0,#0                 ;294
00002c  8248              STRH     r0,[r1,#0x12]         ;294
00002e  f7fffffe          BL       Get_Max_Lun
000032  2000              MOVS     r0,#0                 ;297
000034  bd00              POP      {pc}
;;;300    
                          ENDP

000036  0000              DCW      0x0000
                  |L2.56|
                          DCD      pInformation
                  |L2.60|
                          DCD      Get_Max_Lun

                          AREA ||i.MASS_GetConfigDescriptor||, CODE, READONLY, ALIGN=2

                  MASS_GetConfigDescriptor PROC
;;;376    *******************************************************************************/
;;;377    uint8_t *MASS_GetConfigDescriptor(uint16_t Length)
000000  4901              LDR      r1,|L3.8|
;;;378    {
;;;379      return Standard_GetDescriptorData(Length, &Config_Descriptor );
000002  f7ffbffe          B.W      Standard_GetDescriptorData
;;;380    }
;;;381    
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||area_number.18||+0x8

                          AREA ||i.MASS_GetDeviceDescriptor||, CODE, READONLY, ALIGN=2

                  MASS_GetDeviceDescriptor PROC
;;;364    *******************************************************************************/
;;;365    uint8_t *MASS_GetDeviceDescriptor(uint16_t Length)
000000  4901              LDR      r1,|L4.8|
;;;366    {
;;;367      return Standard_GetDescriptorData(Length, &Device_Descriptor );
000002  f7ffbffe          B.W      Standard_GetDescriptorData
;;;368    }
;;;369    
                          ENDP

000006  0000              DCW      0x0000
                  |L4.8|
                          DCD      ||area_number.18||

                          AREA ||i.MASS_GetStringDescriptor||, CODE, READONLY, ALIGN=2

                  MASS_GetStringDescriptor PROC
;;;388    *******************************************************************************/
;;;389    uint8_t *MASS_GetStringDescriptor(uint16_t Length)
000000  4905              LDR      r1,|L5.24|
;;;390    {
;;;391      uint8_t wValue0 = pInformation->USBwValue0;
000002  6809              LDR      r1,[r1,#0]  ; pInformation
000004  78c9              LDRB     r1,[r1,#3]
;;;392    
;;;393      if (wValue0 > 5)
000006  2905              CMP      r1,#5
000008  d901              BLS      |L5.14|
;;;394      {
;;;395        return NULL;
00000a  2000              MOVS     r0,#0
;;;396      }
;;;397      else
;;;398      {
;;;399        return Standard_GetDescriptorData(Length, &String_Descriptor[wValue0]);
;;;400      }
;;;401    }
00000c  4770              BX       lr
                  |L5.14|
00000e  4a03              LDR      r2,|L5.28|
000010  eb0201c1          ADD      r1,r2,r1,LSL #3       ;399
000014  f7ffbffe          B.W      Standard_GetDescriptorData
;;;402    
                          ENDP

                  |L5.24|
                          DCD      pInformation
                  |L5.28|
                          DCD      ||area_number.18||+0x40

                          AREA ||i.MASS_Get_Interface_Setting||, CODE, READONLY, ALIGN=1

                  MASS_Get_Interface_Setting PROC
;;;344    *******************************************************************************/
;;;345    RESULT MASS_Get_Interface_Setting(uint8_t Interface, uint8_t AlternateSetting)
000000  b909              CBNZ     r1,|L6.6|
;;;346    {
;;;347      if (AlternateSetting > 0)
;;;348      {
;;;349        return USB_UNSUPPORT;/* in this application we don't have AlternateSetting*/
;;;350      }
;;;351      else if (Interface > 0)
000002  2800              CMP      r0,#0
000004  d000              BEQ      |L6.8|
                  |L6.6|
;;;352      {
;;;353        return USB_UNSUPPORT;/*in this application we have only 1 interfaces*/
000006  2002              MOVS     r0,#2
                  |L6.8|
;;;354      }
;;;355      return USB_SUCCESS;
;;;356    }
000008  4770              BX       lr
;;;357    
                          ENDP


                          AREA ||i.MASS_NoData_Setup||, CODE, READONLY, ALIGN=2

                  MASS_NoData_Setup PROC
;;;307    *******************************************************************************/
;;;308    RESULT MASS_NoData_Setup(uint8_t RequestNo)
000000  490f              LDR      r1,|L7.64|
;;;309    {
000002  b510              PUSH     {r4,lr}
;;;310      if ((Type_Recipient == (CLASS_REQUEST | INTERFACE_RECIPIENT))
000004  6809              LDR      r1,[r1,#0]  ; pInformation
000006  780a              LDRB     r2,[r1,#0]
000008  f002027f          AND      r2,r2,#0x7f
00000c  2a21              CMP      r2,#0x21
00000e  d107              BNE      |L7.32|
;;;311          && (RequestNo == MASS_STORAGE_RESET) && (pInformation->USBwValue == 0)
000010  28ff              CMP      r0,#0xff
000012  d105              BNE      |L7.32|
000014  8848              LDRH     r0,[r1,#2]
000016  b918              CBNZ     r0,|L7.32|
;;;312          && (pInformation->USBwIndex == 0) && (pInformation->USBwLength == 0x00))
000018  8888              LDRH     r0,[r1,#4]
00001a  b908              CBNZ     r0,|L7.32|
00001c  88c8              LDRH     r0,[r1,#6]
00001e  b108              CBZ      r0,|L7.36|
                  |L7.32|
;;;313      {
;;;314       #ifdef STM32F10X_CL 
;;;315        /* Init EP1 IN as Bulk endpoint */
;;;316        OTG_DEV_EP_Init(EP1_IN, OTG_DEV_EP_TYPE_BULK, BULK_MAX_PACKET_SIZE);
;;;317      
;;;318        /* Init EP2 OUT as Bulk endpoint */
;;;319        OTG_DEV_EP_Init(EP2_OUT, OTG_DEV_EP_TYPE_BULK, BULK_MAX_PACKET_SIZE);     
;;;320       #else
;;;321        /* Initialize Endpoint 1 */
;;;322        ClearDTOG_TX(ENDP1);
;;;323    
;;;324        /* Initialize Endpoint 2 */
;;;325        ClearDTOG_RX(ENDP2);
;;;326       #endif /* STM32F10X_CL */
;;;327    
;;;328        /*initialize the CBW signature to enable the clear feature*/
;;;329        CBW.dSignature = BOT_CBW_SIGNATURE;
;;;330        Bot_State = BOT_IDLE;
;;;331    
;;;332        return USB_SUCCESS;
;;;333      }
;;;334      return USB_UNSUPPORT;
000020  2002              MOVS     r0,#2
;;;335    }
000022  bd10              POP      {r4,pc}
                  |L7.36|
000024  2001              MOVS     r0,#1                 ;322
000026  f7fffffe          BL       ClearDTOG_TX
00002a  2002              MOVS     r0,#2                 ;325
00002c  f7fffffe          BL       ClearDTOG_RX
000030  4905              LDR      r1,|L7.72|
000032  4804              LDR      r0,|L7.68|
000034  6008              STR      r0,[r1,#0]            ;330  ; CBW
000036  4905              LDR      r1,|L7.76|
000038  2000              MOVS     r0,#0                 ;330
00003a  7008              STRB     r0,[r1,#0]            ;330
00003c  bd10              POP      {r4,pc}
;;;336    
                          ENDP

00003e  0000              DCW      0x0000
                  |L7.64|
                          DCD      pInformation
                  |L7.68|
                          DCD      0x43425355
                  |L7.72|
                          DCD      ||CBW||
                  |L7.76|
                          DCD      Bot_State

                          AREA ||i.MASS_Reset||, CODE, READONLY, ALIGN=2

                  MASS_Reset PROC
;;;125    *******************************************************************************/
;;;126    void MASS_Reset()
000000  b570              PUSH     {r4-r6,lr}
;;;127    {
;;;128      /* Set the device as not configured */
;;;129      Device_Info.Current_Configuration = 0;
000002  4831              LDR      r0,|L8.200|
000004  2500              MOVS     r5,#0
;;;130    
;;;131      /* Current Feature initialization */
;;;132      pInformation->Current_Feature = MASS_ConfigDescriptor[7];
000006  4932              LDR      r1,|L8.208|
000008  7285              STRB     r5,[r0,#0xa]          ;129
00000a  4830              LDR      r0,|L8.204|
00000c  6809              LDR      r1,[r1,#0]  ; pInformation
00000e  79c0              LDRB     r0,[r0,#7]  ; MASS_ConfigDescriptor
000010  7248              STRB     r0,[r1,#9]
;;;133    
;;;134    #ifdef STM32F10X_CL   
;;;135      
;;;136      /* EP0 is already configured by USB_SIL_Init() function */
;;;137    
;;;138      /* Init EP1 IN as Bulk endpoint */
;;;139      OTG_DEV_EP_Init(EP1_IN, OTG_DEV_EP_TYPE_BULK, BULK_MAX_PACKET_SIZE);
;;;140      
;;;141      /* Init EP2 OUT as Bulk endpoint */
;;;142      OTG_DEV_EP_Init(EP2_OUT, OTG_DEV_EP_TYPE_BULK, BULK_MAX_PACKET_SIZE); 
;;;143      
;;;144    #else 
;;;145    
;;;146      SetBTABLE(BTABLE_ADDRESS);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SetBTABLE
;;;147    
;;;148      /* Initialize Endpoint 0 */
;;;149      SetEPType(ENDP0, EP_CONTROL);
000018  f44f7100          MOV      r1,#0x200
00001c  2000              MOVS     r0,#0
00001e  f7fffffe          BL       SetEPType
;;;150      SetEPTxStatus(ENDP0, EP_TX_NAK);
000022  2120              MOVS     r1,#0x20
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       SetEPTxStatus
;;;151      SetEPRxAddr(ENDP0, ENDP0_RXADDR);
00002a  2118              MOVS     r1,#0x18
00002c  2000              MOVS     r0,#0
00002e  f7fffffe          BL       SetEPRxAddr
;;;152      SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
000032  4c28              LDR      r4,|L8.212|
000034  2000              MOVS     r0,#0
000036  f8141f2c          LDRB     r1,[r4,#0x2c]!  ; Device_Property
00003a  f7fffffe          BL       SetEPRxCount
;;;153      SetEPTxAddr(ENDP0, ENDP0_TXADDR);
00003e  2158              MOVS     r1,#0x58
000040  2000              MOVS     r0,#0
000042  f7fffffe          BL       SetEPTxAddr
;;;154      Clear_Status_Out(ENDP0);
000046  2000              MOVS     r0,#0
000048  f7fffffe          BL       Clear_Status_Out
;;;155      SetEPRxValid(ENDP0);
00004c  2000              MOVS     r0,#0
00004e  f7fffffe          BL       SetEPRxValid
;;;156    
;;;157      /* Initialize Endpoint 1 */
;;;158      SetEPType(ENDP1, EP_BULK);
000052  2100              MOVS     r1,#0
000054  2001              MOVS     r0,#1
000056  f7fffffe          BL       SetEPType
;;;159      SetEPTxAddr(ENDP1, ENDP1_TXADDR);
00005a  2198              MOVS     r1,#0x98
00005c  2001              MOVS     r0,#1
00005e  f7fffffe          BL       SetEPTxAddr
;;;160      SetEPTxStatus(ENDP1, EP_TX_NAK);
000062  2120              MOVS     r1,#0x20
000064  2001              MOVS     r0,#1
000066  f7fffffe          BL       SetEPTxStatus
;;;161      SetEPRxStatus(ENDP1, EP_RX_DIS);
00006a  2100              MOVS     r1,#0
00006c  2001              MOVS     r0,#1
00006e  f7fffffe          BL       SetEPRxStatus
;;;162    
;;;163      /* Initialize Endpoint 2 */
;;;164      SetEPType(ENDP2, EP_BULK);
000072  2100              MOVS     r1,#0
000074  2002              MOVS     r0,#2
000076  f7fffffe          BL       SetEPType
;;;165      SetEPRxAddr(ENDP2, ENDP2_RXADDR);
00007a  21d8              MOVS     r1,#0xd8
00007c  2002              MOVS     r0,#2
00007e  f7fffffe          BL       SetEPRxAddr
;;;166      SetEPRxCount(ENDP2, Device_Property.MaxPacketSize);
000082  7821              LDRB     r1,[r4,#0]  ; Device_Property
000084  2002              MOVS     r0,#2
000086  f7fffffe          BL       SetEPRxCount
;;;167      SetEPRxStatus(ENDP2, EP_RX_VALID);
00008a  f44f5140          MOV      r1,#0x3000
00008e  2002              MOVS     r0,#2
000090  f7fffffe          BL       SetEPRxStatus
;;;168      SetEPTxStatus(ENDP2, EP_TX_DIS);
000094  2100              MOVS     r1,#0
000096  2002              MOVS     r0,#2
000098  f7fffffe          BL       SetEPTxStatus
;;;169    
;;;170    
;;;171      SetEPRxCount(ENDP0, Device_Property.MaxPacketSize);
00009c  7821              LDRB     r1,[r4,#0]  ; Device_Property
00009e  2000              MOVS     r0,#0
0000a0  f7fffffe          BL       SetEPRxCount
;;;172      SetEPRxValid(ENDP0);
0000a4  2000              MOVS     r0,#0
0000a6  f7fffffe          BL       SetEPRxValid
;;;173    
;;;174      /* Set the device to response on default address */
;;;175      SetDeviceAddress(0);
0000aa  2000              MOVS     r0,#0
0000ac  f7fffffe          BL       SetDeviceAddress
;;;176    #endif /* STM32F10X_CL */
;;;177    
;;;178      bDeviceState = ATTACHED;
0000b0  4909              LDR      r1,|L8.216|
0000b2  2001              MOVS     r0,#1
0000b4  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;179    
;;;180      CBW.dSignature = BOT_CBW_SIGNATURE;
0000b6  490a              LDR      r1,|L8.224|
0000b8  4808              LDR      r0,|L8.220|
;;;181      Bot_State = BOT_IDLE;
0000ba  6008              STR      r0,[r1,#0]  ; CBW
0000bc  4809              LDR      r0,|L8.228|
0000be  7005              STRB     r5,[r0,#0]
;;;182    
;;;183      USB_NotConfigured_LED();
0000c0  e8bd4070          POP      {r4-r6,lr}
0000c4  f7ffbffe          B.W      USB_NotConfigured_LED
;;;184    }
;;;185    
                          ENDP

                  |L8.200|
                          DCD      Device_Info
                  |L8.204|
                          DCD      MASS_ConfigDescriptor
                  |L8.208|
                          DCD      pInformation
                  |L8.212|
                          DCD      ||area_number.18||+0x10
                  |L8.216|
                          DCD      bDeviceState
                  |L8.220|
                          DCD      0x43425355
                  |L8.224|
                          DCD      ||CBW||
                  |L8.228|
                          DCD      Bot_State

                          AREA ||i.MASS_Status_In||, CODE, READONLY, ALIGN=1

                  MASS_Status_In PROC
;;;247    *******************************************************************************/
;;;248    void MASS_Status_In(void)
000000  4770              BX       lr
;;;249    {
;;;250      return;
;;;251    }
;;;252    
                          ENDP


                          AREA ||i.MASS_Status_Out||, CODE, READONLY, ALIGN=1

                  MASS_Status_Out PROC
;;;259    *******************************************************************************/
;;;260    void MASS_Status_Out(void)
000000  4770              BX       lr
;;;261    {
;;;262      return;
;;;263    }
;;;264    
                          ENDP


                          AREA ||i.MASS_init||, CODE, READONLY, ALIGN=2

                  MASS_init PROC
;;;101    *******************************************************************************/
;;;102    void MASS_init()
000000  b510              PUSH     {r4,lr}
;;;103    {
;;;104      /* Update the serial number string descriptor with the data from the unique
;;;105      ID*/
;;;106      Get_SerialNum();
000002  f7fffffe          BL       Get_SerialNum
;;;107    
;;;108      pInformation->Current_Configuration = 0;
000006  4805              LDR      r0,|L11.28|
000008  2400              MOVS     r4,#0
00000a  6800              LDR      r0,[r0,#0]  ; pInformation
00000c  7284              STRB     r4,[r0,#0xa]
;;;109    
;;;110      /* Connect the device */
;;;111      PowerOn();
00000e  f7fffffe          BL       PowerOn
;;;112    
;;;113      /* Perform basic device initialization operations */
;;;114      USB_SIL_Init();
000012  f7fffffe          BL       USB_SIL_Init
;;;115    
;;;116      bDeviceState = UNCONNECTED;
000016  4802              LDR      r0,|L11.32|
000018  6004              STR      r4,[r0,#0]  ; bDeviceState
;;;117    }
00001a  bd10              POP      {r4,pc}
;;;118    
                          ENDP

                  |L11.28|
                          DCD      pInformation
                  |L11.32|
                          DCD      bDeviceState

                          AREA ||i.Mass_Storage_ClearFeature||, CODE, READONLY, ALIGN=2

                  Mass_Storage_ClearFeature PROC
;;;221    *******************************************************************************/
;;;222    void Mass_Storage_ClearFeature(void)
000000  4804              LDR      r0,|L12.20|
;;;223    {
;;;224      /* when the host send a CBW with invalid signature or invalid length the two
;;;225         Endpoints (IN & OUT) shall stall until receiving a Mass Storage Reset     */
;;;226      if (CBW.dSignature != BOT_CBW_SIGNATURE)
000002  4905              LDR      r1,|L12.24|
000004  6800              LDR      r0,[r0,#0]  ; CBW
000006  4288              CMP      r0,r1
000008  d002              BEQ      |L12.16|
;;;227        Bot_Abort(BOTH_DIR);
00000a  2002              MOVS     r0,#2
00000c  f7ffbffe          B.W      Bot_Abort
                  |L12.16|
;;;228    }
000010  4770              BX       lr
;;;229    
                          ENDP

000012  0000              DCW      0x0000
                  |L12.20|
                          DCD      ||CBW||
                  |L12.24|
                          DCD      0x43425355

                          AREA ||i.Mass_Storage_SetConfiguration||, CODE, READONLY, ALIGN=2

                  Mass_Storage_SetConfiguration PROC
;;;192    *******************************************************************************/
;;;193    void Mass_Storage_SetConfiguration(void)
000000  4809              LDR      r0,|L13.40|
;;;194    {
000002  b510              PUSH     {r4,lr}
;;;195      if (pInformation->Current_Configuration != 0)
000004  6800              LDR      r0,[r0,#0]  ; pInformation
000006  7a80              LDRB     r0,[r0,#0xa]
000008  2800              CMP      r0,#0                 ;194
00000a  d00b              BEQ      |L13.36|
;;;196      {
;;;197        /* Device configured */
;;;198        bDeviceState = CONFIGURED;
00000c  4907              LDR      r1,|L13.44|
00000e  2005              MOVS     r0,#5
000010  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;199    
;;;200    #ifdef STM32F10X_CL 
;;;201        /* Init EP1 IN as Bulk endpoint */
;;;202        OTG_DEV_EP_Init(EP1_IN, OTG_DEV_EP_TYPE_BULK, BULK_MAX_PACKET_SIZE);
;;;203      
;;;204        /* Init EP2 OUT as Bulk endpoint */
;;;205        OTG_DEV_EP_Init(EP2_OUT, OTG_DEV_EP_TYPE_BULK, BULK_MAX_PACKET_SIZE);     
;;;206    #else    
;;;207        ClearDTOG_TX(ENDP1);
000012  2001              MOVS     r0,#1
000014  f7fffffe          BL       ClearDTOG_TX
;;;208        ClearDTOG_RX(ENDP2);
000018  2002              MOVS     r0,#2
00001a  f7fffffe          BL       ClearDTOG_RX
;;;209    #endif /* STM32F10X_CL */
;;;210    
;;;211        Bot_State = BOT_IDLE; /* set the Bot state machine to the IDLE state */
00001e  4904              LDR      r1,|L13.48|
000020  2000              MOVS     r0,#0
000022  7008              STRB     r0,[r1,#0]
                  |L13.36|
;;;212      }
;;;213    }
000024  bd10              POP      {r4,pc}
;;;214    
                          ENDP

000026  0000              DCW      0x0000
                  |L13.40|
                          DCD      pInformation
                  |L13.44|
                          DCD      bDeviceState
                  |L13.48|
                          DCD      Bot_State

                          AREA ||i.Mass_Storage_SetDeviceAddress||, CODE, READONLY, ALIGN=2

                  Mass_Storage_SetDeviceAddress PROC
;;;236    *******************************************************************************/
;;;237    void Mass_Storage_SetDeviceAddress (void)
000000  4901              LDR      r1,|L14.8|
;;;238    {
;;;239      bDeviceState = ADDRESSED;
000002  2004              MOVS     r0,#4
000004  6008              STR      r0,[r1,#0]  ; bDeviceState
;;;240    }
000006  4770              BX       lr
;;;241    /*******************************************************************************
                          ENDP

                  |L14.8|
                          DCD      bDeviceState

                          AREA ||.data||, DATA, ALIGN=0

                  Device_Table
000000  0301              DCB      0x03,0x01

                          AREA ||area_number.18||, DATA, ALIGN=2

                          EXPORTAS ||area_number.18||, ||.data||
                  Device_Descriptor
                          DCD      MASS_DeviceDescriptor
000004  0012              DCW      0x0012
000006  0000              DCB      0x00,0x00
                  Config_Descriptor
                          DCD      MASS_ConfigDescriptor
00000c  0020              DCW      0x0020
00000e  0000              DCB      0x00,0x00
                  Device_Property
                          DCD      MASS_init
                          DCD      MASS_Reset
                          DCD      MASS_Status_In
                          DCD      MASS_Status_Out
                          DCD      MASS_Data_Setup
                          DCD      MASS_NoData_Setup
                          DCD      MASS_Get_Interface_Setting
                          DCD      MASS_GetDeviceDescriptor
                          DCD      MASS_GetConfigDescriptor
                          DCD      MASS_GetStringDescriptor
                          DCD      0x00000000
00003c  40000000          DCB      0x40,0x00,0x00,0x00
                  String_Descriptor
                          DCD      MASS_StringLangID
000044  0004              DCW      0x0004
000046  0000              DCB      0x00,0x00
                          DCD      MASS_StringVendor
00004c  0026              DCW      0x0026
00004e  0000              DCB      0x00,0x00
                          DCD      MASS_StringProduct
000054  0026              DCW      0x0026
000056  0000              DCB      0x00,0x00
                          DCD      MASS_StringSerial
00005c  001a              DCW      0x001a
00005e  0000              DCB      0x00,0x00
                          DCD      MASS_StringInterface
000064  0010              DCW      0x0010
000066  0000              DCB      0x00,0x00

                          AREA ||area_number.19||, DATA, ALIGN=2

                          EXPORTAS ||area_number.19||, ||.data||
                  User_Standard_Requests
                          DCD      NOP_Process
                          DCD      Mass_Storage_SetConfiguration
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      Mass_Storage_ClearFeature
                          DCD      NOP_Process
                          DCD      NOP_Process
                          DCD      Mass_Storage_SetDeviceAddress

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\usb_mass\\usb_prop.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_prop_c_e95c9bdd____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_usb_prop_c_e95c9bdd____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_usb_prop_c_e95c9bdd____REVSH|
#line 128
|__asm___10_usb_prop_c_e95c9bdd____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
