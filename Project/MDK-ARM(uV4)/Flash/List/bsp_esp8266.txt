; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_esp8266.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_esp8266.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_esp8266.crf ..\..\User\bsp\src\bsp_esp8266.c]
                          THUMB

                          AREA ||i.ESP8266_CloseTcpUdp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ESP8266_CloseTcpUdp PROC
;;;501    */
;;;502    void ESP8266_CloseTcpUdp(uint8_t _id)
000000  b510              PUSH     {r4,lr}
;;;503    {
000002  4604              MOV      r4,r0
000004  b088              SUB      sp,sp,#0x20
;;;504    	char buf[32];
;;;505    
;;;506    	ESP8266_SendAT("ATE0");		/* 打开回显功能 */
000006  a008              ADR      r0,|L1.40|
000008  f7fffffe          BL       ESP8266_SendAT
;;;507    	ESP8266_WaitResponse("SEND OK", 50);
00000c  2132              MOVS     r1,#0x32
00000e  a008              ADR      r0,|L1.48|
000010  f7fffffe          BL       ESP8266_WaitResponse
;;;508    	
;;;509    	sprintf(buf, "AT+CIPCLOSE=%d", _id);
000014  4622              MOV      r2,r4
000016  a108              ADR      r1,|L1.56|
000018  4668              MOV      r0,sp
00001a  f7fffffe          BL       __2sprintf
;;;510    	ESP8266_SendAT(buf);
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       ESP8266_SendAT
;;;511    }
000024  b008              ADD      sp,sp,#0x20
000026  bd10              POP      {r4,pc}
;;;512    
                          ENDP

                  |L1.40|
000028  41544530          DCB      "ATE0",0
00002c  00      
00002d  00                DCB      0
00002e  00                DCB      0
00002f  00                DCB      0
                  |L1.48|
000030  53454e44          DCB      "SEND OK",0
000034  204f4b00
                  |L1.56|
000038  41542b43          DCB      "AT+CIPCLOSE=%d",0
00003c  4950434c
000040  4f53453d
000044  256400  
000047  00                DCB      0

                          AREA ||i.ESP8266_CreateTCPServer||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ESP8266_CreateTCPServer PROC
;;;437    */
;;;438    uint8_t ESP8266_CreateTCPServer(uint16_t _TcpPort)
000000  b530              PUSH     {r4,r5,lr}
;;;439    {
000002  4605              MOV      r5,r0
000004  b089              SUB      sp,sp,#0x24
;;;440    	char cmd_buf[30];
;;;441    	
;;;442    	ESP8266_SendAT("AT+CIPMUX=1");	/* 启动多连接 */
000006  a013              ADR      r0,|L2.84|
000008  f7fffffe          BL       ESP8266_SendAT
;;;443    	if (ESP8266_WaitResponse("OK", 2000) == 0)
00000c  f44f64fa          MOV      r4,#0x7d0
000010  4621              MOV      r1,r4
000012  a013              ADR      r0,|L2.96|
000014  f7fffffe          BL       ESP8266_WaitResponse
000018  2800              CMP      r0,#0
00001a  d018              BEQ      |L2.78|
;;;444    	{
;;;445    		return 0;
;;;446    	}
;;;447    	
;;;448    	/* 开启TCP server, 端口为 _TcpPort */
;;;449    	sprintf(cmd_buf, "AT+CIPSERVER=1,%d", _TcpPort);
00001c  462a              MOV      r2,r5
00001e  a111              ADR      r1,|L2.100|
000020  4668              MOV      r0,sp
000022  f7fffffe          BL       __2sprintf
;;;450    	ESP8266_SendAT(cmd_buf);	
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       ESP8266_SendAT
;;;451    	if (ESP8266_WaitResponse("OK", 2000) == 0)
00002c  4621              MOV      r1,r4
00002e  a00c              ADR      r0,|L2.96|
000030  f7fffffe          BL       ESP8266_WaitResponse
000034  2800              CMP      r0,#0
000036  d00a              BEQ      |L2.78|
;;;452    	{
;;;453    		return 0;
;;;454    	}
;;;455    
;;;456    	ESP8266_SendAT("ATE0");		/* 关闭回显功能，主机发送的字符，模块无需返回 */
000038  a00f              ADR      r0,|L2.120|
00003a  f7fffffe          BL       ESP8266_SendAT
;;;457    	if (ESP8266_WaitResponse("OK", 10000) == 0)
00003e  f2427110          MOV      r1,#0x2710
000042  a007              ADR      r0,|L2.96|
000044  f7fffffe          BL       ESP8266_WaitResponse
000048  2800              CMP      r0,#0
00004a  d000              BEQ      |L2.78|
;;;458    	{
;;;459    		return 0;
;;;460    	}
;;;461    	
;;;462    	return 1;
00004c  2001              MOVS     r0,#1
                  |L2.78|
;;;463    }
00004e  b009              ADD      sp,sp,#0x24
000050  bd30              POP      {r4,r5,pc}
;;;464    
                          ENDP

000052  0000              DCW      0x0000
                  |L2.84|
000054  41542b43          DCB      "AT+CIPMUX=1",0
000058  49504d55
00005c  583d3100
                  |L2.96|
000060  4f4b00            DCB      "OK",0
000063  00                DCB      0
                  |L2.100|
000064  41542b43          DCB      "AT+CIPSERVER=1,%d",0
000068  49505345
00006c  52564552
000070  3d312c25
000074  6400    
000076  00                DCB      0
000077  00                DCB      0
                  |L2.120|
000078  41544530          DCB      "ATE0",0
00007c  00      
00007d  00                DCB      0
00007e  00                DCB      0
00007f  00                DCB      0

                          AREA ||i.ESP8266_EnterISP||, CODE, READONLY, ALIGN=2

                  ESP8266_EnterISP PROC
;;;281    */
;;;282    void ESP8266_EnterISP(void)
000000  b510              PUSH     {r4,lr}
;;;283    {
;;;284    	ESP_CH_PD_0();
000002  4c07              LDR      r4,|L3.32|
000004  2110              MOVS     r1,#0x10
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;285    	ESP_GPIO0_0()  /* 0 表示进入固件升级模式 */
00000c  2180              MOVS     r1,#0x80
00000e  4805              LDR      r0,|L3.36|
000010  f7fffffe          BL       GPIO_ResetBits
;;;286    	ESP_CH_PD_1();
000014  4620              MOV      r0,r4
000016  e8bd4010          POP      {r4,lr}
00001a  2110              MOVS     r1,#0x10
00001c  f7ffbffe          B.W      GPIO_SetBits
;;;287    }
;;;288    
                          ENDP

                  |L3.32|
                          DCD      0x40010c00
                  |L3.36|
                          DCD      0x40011c00

                          AREA ||i.ESP8266_ExitISP||, CODE, READONLY, ALIGN=2

                  ESP8266_ExitISP PROC
;;;296    */
;;;297    void ESP8266_ExitISP(void)
000000  b510              PUSH     {r4,lr}
;;;298    {
;;;299    	ESP_CH_PD_0();
000002  4c07              LDR      r4,|L4.32|
000004  2110              MOVS     r1,#0x10
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;300    	ESP_GPIO0_1()  /* 1 表示进入用户程序（AT指令）模式 */
00000c  2180              MOVS     r1,#0x80
00000e  4805              LDR      r0,|L4.36|
000010  f7fffffe          BL       GPIO_SetBits
;;;301    	ESP_CH_PD_1();
000014  4620              MOV      r0,r4
000016  e8bd4010          POP      {r4,lr}
00001a  2110              MOVS     r1,#0x10
00001c  f7ffbffe          B.W      GPIO_SetBits
;;;302    }
;;;303    
                          ENDP

                  |L4.32|
                          DCD      0x40010c00
                  |L4.36|
                          DCD      0x40011c00

                          AREA ||i.ESP8266_GetLocalIP||, CODE, READONLY, ALIGN=2

                  ESP8266_GetLocalIP PROC
;;;521    */
;;;522    uint8_t ESP8266_GetLocalIP(char *_ip, char *_mac)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;523    {
000004  4606              MOV      r6,r0
000006  b090              SUB      sp,sp,#0x40
000008  460f              MOV      r7,r1
;;;524    	char buf[64];
;;;525    	uint8_t i, m;
;;;526    	uint8_t ret = 0;
00000a  f04f0900          MOV      r9,#0
;;;527    	uint8_t temp;
;;;528    	
;;;529    	ESP8266_SendAT("AT+CIFSR");
00000e  a023              ADR      r0,|L5.156|
000010  f7fffffe          BL       ESP8266_SendAT
;;;530    	
;;;531    	/*　模块将应答:
;;;532    		
;;;533    	+CIFSR:STAIP,"192.168.1.18"
;;;534    	+CIFSR:STAMAC,"18:fe:34:a6:44:75"
;;;535    	
;;;536    	OK	
;;;537    	*/
;;;538    	
;;;539    	_ip[0] = 0;
000014  2500              MOVS     r5,#0
000016  7035              STRB     r5,[r6,#0]
;;;540    	_mac[0] = 0;
000018  703d              STRB     r5,[r7,#0]
;;;541    	for (i = 0; i < 4; i++)
00001a  462c              MOV      r4,r5
;;;542    	{
;;;543    		ESP8266_ReadLine(buf, sizeof(buf), 500);
00001c  f44f7afa          MOV      r10,#0x1f4
000020  46e8              MOV      r8,sp                 ;524
                  |L5.34|
000022  4652              MOV      r2,r10
000024  2140              MOVS     r1,#0x40
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       ESP8266_ReadLine
;;;544    		if (memcmp(buf, "+CIFSR:STAIP", 12) == 0)
00002c  220c              MOVS     r2,#0xc
00002e  a11e              ADR      r1,|L5.168|
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       memcmp
000036  b198              CBZ      r0,|L5.96|
;;;545    		{
;;;546    			
;;;547    			for (m = 0; m < 20; m++)
;;;548    			{
;;;549    				temp = buf[14 + m];
;;;550    				_ip[m] = temp;
;;;551    				if (temp == '"')
;;;552    				{
;;;553    					_ip[m] = 0;
;;;554    					ret = 1;
;;;555    					break;
;;;556    				}
;;;557    			}
;;;558    		}
;;;559    		else if (memcmp(buf, "+CIFSR:STAMAC,", 14) == 0)
000038  220e              MOVS     r2,#0xe
00003a  a11f              ADR      r1,|L5.184|
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       memcmp
000042  b1e8              CBZ      r0,|L5.128|
;;;560    		{
;;;561    			for (m = 0; m < 20; m++)
;;;562    			{
;;;563    				temp = buf[15 + m];
;;;564    				_mac[m] = temp;
;;;565    				if (temp == '"')
;;;566    				{
;;;567    					_mac[m] = 0;
;;;568    					break;
;;;569    				}
;;;570    			}
;;;571    		}
;;;572    		else if (memcmp(buf, "OK", 2) == 0)
000044  2202              MOVS     r2,#2
000046  a120              ADR      r1,|L5.200|
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       memcmp
00004e  b118              CBZ      r0,|L5.88|
                  |L5.80|
000050  1c64              ADDS     r4,r4,#1
000052  b2e4              UXTB     r4,r4                 ;541
000054  2c04              CMP      r4,#4                 ;541
000056  d3e4              BCC      |L5.34|
                  |L5.88|
;;;573    		{
;;;574    			break;
;;;575    		}
;;;576    	}
;;;577    	return ret;
;;;578    }
000058  b010              ADD      sp,sp,#0x40
00005a  4648              MOV      r0,r9                 ;577
00005c  e8bd87f0          POP      {r4-r10,pc}
                  |L5.96|
000060  2000              MOVS     r0,#0                 ;547
000062  4642              MOV      r2,r8                 ;524
                  |L5.100|
000064  1811              ADDS     r1,r2,r0              ;549
000066  7b89              LDRB     r1,[r1,#0xe]          ;549
000068  5431              STRB     r1,[r6,r0]            ;550
00006a  2922              CMP      r1,#0x22              ;551
00006c  d004              BEQ      |L5.120|
00006e  1c40              ADDS     r0,r0,#1              ;551
000070  b2c0              UXTB     r0,r0                 ;547
000072  2814              CMP      r0,#0x14              ;547
000074  d3f6              BCC      |L5.100|
000076  e7eb              B        |L5.80|
                  |L5.120|
000078  5435              STRB     r5,[r6,r0]            ;553
00007a  f04f0901          MOV      r9,#1                 ;554
00007e  e7e7              B        |L5.80|
                  |L5.128|
000080  2000              MOVS     r0,#0                 ;561
000082  4642              MOV      r2,r8                 ;524
                  |L5.132|
000084  1811              ADDS     r1,r2,r0              ;563
000086  7bc9              LDRB     r1,[r1,#0xf]          ;563
000088  5439              STRB     r1,[r7,r0]            ;564
00008a  2922              CMP      r1,#0x22              ;565
00008c  d004              BEQ      |L5.152|
00008e  1c40              ADDS     r0,r0,#1              ;565
000090  b2c0              UXTB     r0,r0                 ;561
000092  2814              CMP      r0,#0x14              ;561
000094  d3f6              BCC      |L5.132|
000096  e7db              B        |L5.80|
                  |L5.152|
000098  543d              STRB     r5,[r7,r0]            ;567
00009a  e7d9              B        |L5.80|
;;;579    
                          ENDP

                  |L5.156|
00009c  41542b43          DCB      "AT+CIFSR",0
0000a0  49465352
0000a4  00      
0000a5  00                DCB      0
0000a6  00                DCB      0
0000a7  00                DCB      0
                  |L5.168|
0000a8  2b434946          DCB      "+CIFSR:STAIP",0
0000ac  53523a53
0000b0  54414950
0000b4  00      
0000b5  00                DCB      0
0000b6  00                DCB      0
0000b7  00                DCB      0
                  |L5.184|
0000b8  2b434946          DCB      "+CIFSR:STAMAC,",0
0000bc  53523a53
0000c0  54414d41
0000c4  432c00  
0000c7  00                DCB      0
                  |L5.200|
0000c8  4f4b00            DCB      "OK",0
0000cb  00                DCB      0

                          AREA ||i.ESP8266_JoinAP||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                  ESP8266_JoinAP PROC
;;;588    */
;;;589    uint8_t ESP8266_JoinAP(char *_ssid, char *_pwd, uint16_t _timeout)
000000  b510              PUSH     {r4,lr}
;;;590    {
000002  4614              MOV      r4,r2
000004  b090              SUB      sp,sp,#0x40
;;;591    	char buf[64];
;;;592    
;;;593    	sprintf(buf, "AT+CWJAP=\"%s\",\"%s\"", _ssid, _pwd);
000006  460b              MOV      r3,r1
000008  4602              MOV      r2,r0
00000a  a114              ADR      r1,|L6.92|
00000c  4668              MOV      r0,sp
00000e  f7fffffe          BL       __2sprintf
;;;594    	ESP8266_SendAT(buf);
000012  4668              MOV      r0,sp
000014  f7fffffe          BL       ESP8266_SendAT
;;;595    	
;;;596    	if (ESP8266_ReadLine(buf, 64, _timeout))
000018  4622              MOV      r2,r4
00001a  2140              MOVS     r1,#0x40
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       ESP8266_ReadLine
000022  b1a8              CBZ      r0,|L6.80|
;;;597    	{
;;;598    		if (memcmp(buf, "AT+CWJAP", 8) == 0)		/* 第1次读到的是 命令本身 */
000024  2208              MOVS     r2,#8
000026  a112              ADR      r1,|L6.112|
000028  4668              MOV      r0,sp
00002a  f7fffffe          BL       memcmp
00002e  b948              CBNZ     r0,|L6.68|
;;;599    		{
;;;600    			ESP8266_ReadLine(buf, 64, _timeout);	/* 这个是回车 */
000030  4622              MOV      r2,r4
000032  2140              MOVS     r1,#0x40
000034  4668              MOV      r0,sp
000036  f7fffffe          BL       ESP8266_ReadLine
;;;601    			ESP8266_ReadLine(buf, 64, _timeout);	/* 这次是读应答的OK */
00003a  4622              MOV      r2,r4
00003c  2140              MOVS     r1,#0x40
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       ESP8266_ReadLine
                  |L6.68|
;;;602    		}		
;;;603    		if (memcmp(buf, "OK", 2) == 0)
000044  2202              MOVS     r2,#2
000046  a10d              ADR      r1,|L6.124|
000048  4668              MOV      r0,sp
00004a  f7fffffe          BL       memcmp
00004e  b110              CBZ      r0,|L6.86|
                  |L6.80|
;;;604    		{
;;;605    			return 1;
;;;606    		}
;;;607    	}	
;;;608    	return 0;
000050  2000              MOVS     r0,#0
                  |L6.82|
;;;609    }
000052  b010              ADD      sp,sp,#0x40
000054  bd10              POP      {r4,pc}
                  |L6.86|
000056  2001              MOVS     r0,#1                 ;605
000058  e7fb              B        |L6.82|
;;;610    
                          ENDP

00005a  0000              DCW      0x0000
                  |L6.92|
00005c  41542b43          DCB      "AT+CWJAP=""%s"",""%s""",0
000060  574a4150
000064  3d222573
000068  222c2225
00006c  732200  
00006f  00                DCB      0
                  |L6.112|
000070  41542b43          DCB      "AT+CWJAP",0
000074  574a4150
000078  00      
000079  00                DCB      0
00007a  00                DCB      0
00007b  00                DCB      0
                  |L6.124|
00007c  4f4b00            DCB      "OK",0
00007f  00                DCB      0

                          AREA ||i.ESP8266_PowerOff||, CODE, READONLY, ALIGN=2

                  ESP8266_PowerOff PROC
;;;251    */
;;;252    void ESP8266_PowerOff(void)
000000  2110              MOVS     r1,#0x10
;;;253    {
;;;254    	ESP_CH_PD_0();
000002  4801              LDR      r0,|L7.8|
000004  f7ffbffe          B.W      GPIO_ResetBits
;;;255    }
;;;256    
                          ENDP

                  |L7.8|
                          DCD      0x40010c00

                          AREA ||i.ESP8266_PowerOn||, CODE, READONLY, ALIGN=2

                  ESP8266_PowerOn PROC
;;;204    */
;;;205    void ESP8266_PowerOn(void)
000000  b510              PUSH     {r4,lr}
;;;206    {
;;;207    	/* WIFI模块上电时，会以74880波特率打印如下信息:
;;;208    		 ets Jan  8 2013,rst cause:1, boot mode:(3,6)
;;;209    
;;;210    		load 0x40100000, len 25052, room 16
;;;211    		tail 12
;;;212    		chksum 0x0b
;;;213    		ho 0 tail 12 room 4
;;;214    		load 0x3ffe8000, len 3312, room 12
;;;215    		tail 4
;;;216    		chksum 0x53
;;;217    		load 0x3ffe8cf0, len 6576, room 4
;;;218    		tail 12
;;;219    		chksum 0x0d
;;;220    		csum 0x0d	    <-----  程序识别 csum 后，再自动切换到正常波特率
;;;221    	*/
;;;222    
;;;223    	ESP_CH_PD_0();
000002  4c12              LDR      r4,|L8.76|
000004  2110              MOVS     r1,#0x10
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;224    
;;;225    	comSetBaud(COM_ESP8266, 74880);	/* 1表示硬件流控CRS RTS有效;  0表示无需硬件流控 */
00000c  4910              LDR      r1,|L8.80|
00000e  2001              MOVS     r0,#1
000010  f7fffffe          BL       comSetBaud
;;;226    
;;;227    	ESP_CH_PD_1();
000014  2110              MOVS     r1,#0x10
000016  4620              MOV      r0,r4
000018  f7fffffe          BL       GPIO_SetBits
;;;228    
;;;229    	ESP8266_Reset();
00001c  f7fffffe          BL       ESP8266_Reset
;;;230    
;;;231    	/* 等待模块完成上电，超时500ms 自动退出 */
;;;232    	ESP8266_WaitResponse("csum", 1000);	/* 先等待 csum */
000020  f44f747a          MOV      r4,#0x3e8
000024  4621              MOV      r1,r4
000026  a00b              ADR      r0,|L8.84|
000028  f7fffffe          BL       ESP8266_WaitResponse
;;;233    	ESP8266_WaitResponse("\n", 1000);	/* 再等待回车换行字符结束 */
00002c  4621              MOV      r1,r4
00002e  a00b              ADR      r0,|L8.92|
000030  f7fffffe          BL       ESP8266_WaitResponse
;;;234    
;;;235    	comSetBaud(COM_ESP8266,115200);	/* 1表示硬件流控CRS RTS有效;  0表示无需硬件流控 */
000034  f44f31e1          MOV      r1,#0x1c200
000038  2001              MOVS     r0,#1
00003a  f7fffffe          BL       comSetBaud
;;;236    
;;;237    	/* 等待模块完成上电，判断是否接收到 ready */
;;;238    	ESP8266_WaitResponse("ready", 5000);
00003e  e8bd4010          POP      {r4,lr}
000042  f2413188          MOV      r1,#0x1388
000046  a006              ADR      r0,|L8.96|
000048  f7ffbffe          B.W      ESP8266_WaitResponse
;;;239    
;;;240    	// ESP8266_SendAT("AT+RST");
;;;241    	// ESP8266_WaitResponse("ready", 5000);
;;;242    }
;;;243    
                          ENDP

                  |L8.76|
                          DCD      0x40010c00
                  |L8.80|
                          DCD      0x00012480
                  |L8.84|
000054  6373756d          DCB      "csum",0
000058  00      
000059  00                DCB      0
00005a  00                DCB      0
00005b  00                DCB      0
                  |L8.92|
00005c  0a00              DCB      "\n",0
00005e  00                DCB      0
00005f  00                DCB      0
                  |L8.96|
000060  72656164          DCB      "ready",0
000064  7900    
000066  00                DCB      0
000067  00                DCB      0

                          AREA ||i.ESP8266_PrintRxData||, CODE, READONLY, ALIGN=1

                  ESP8266_PrintRxData PROC
;;;189    */
;;;190    void ESP8266_PrintRxData(uint8_t _ch)
000000  4601              MOV      r1,r0
;;;191    {
;;;192    	#ifdef ESP8266_TO_COM1_EN
;;;193    		comSendChar(COM1, _ch);		/* 将接收到数据打印到调试串口1 */
000002  2000              MOVS     r0,#0
000004  f7ffbffe          B.W      comSendChar
;;;194    	#endif
;;;195    }
;;;196    
                          ENDP


                          AREA ||i.ESP8266_QuitAP||, CODE, READONLY, ALIGN=2

                  ESP8266_QuitAP PROC
;;;618    */
;;;619    void ESP8266_QuitAP(void)
000000  a001              ADR      r0,|L10.8|
;;;620    {
;;;621    	ESP8266_SendAT("AT+ CWQAP");
000002  f7ffbffe          B.W      ESP8266_SendAT
;;;622    }
;;;623    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
000008  41542b20          DCB      "AT+ CWQAP",0
00000c  43575141
000010  5000    
000012  00                DCB      0
000013  00                DCB      0

                          AREA ||i.ESP8266_ReadLine||, CODE, READONLY, ALIGN=1

                  ESP8266_ReadLine PROC
;;;376    */
;;;377    uint16_t ESP8266_ReadLine(char *_pBuf, uint16_t _usBufSize, uint16_t _usTimeOut)
000000  b5f8              PUSH     {r3-r7,lr}
;;;378    {
000002  0011              MOVS     r1,r2
000004  4605              MOV      r5,r0
;;;379    	uint8_t ucData;
;;;380    	uint16_t pos = 0;
000006  f04f0400          MOV      r4,#0
00000a  d002              BEQ      |L11.18|
;;;381    	uint8_t ret;
;;;382    
;;;383    	/* _usTimeOut == 0 表示无限等待 */
;;;384    	if (_usTimeOut > 0)
;;;385    	{
;;;386    		bsp_StartTimer(ESP8266_TMR_ID, _usTimeOut);		/* 使用软件定时器作为超时控制 */
00000c  2003              MOVS     r0,#3
00000e  f7fffffe          BL       bsp_StartTimer
                  |L11.18|
000012  2600              MOVS     r6,#0
;;;387    	}
;;;388    	while (1)
;;;389    	{
;;;390    		bsp_Idle();				/* CPU空闲执行的操作， 见 bsp.c 和 bsp.h 文件 */
;;;391    
;;;392    		if (bsp_CheckTimer(ESP8266_TMR_ID))
;;;393    		{
;;;394    			_pBuf[pos] = 0;	/* 结尾加0， 便于函数调用者识别字符串结束 */
;;;395    			ret = pos;		/* 成功。 返回数据长度 */
;;;396    			break;
;;;397    		}
;;;398    
;;;399    		if (comGetChar(COM_ESP8266, &ucData))
;;;400    		{
;;;401    			ESP8266_PrintRxData(ucData);		/* 将接收到数据打印到调试串口1 */
;;;402    
;;;403    			bsp_StartTimer(ESP8266_TMR_ID, 500);
000014  f44f77fa          MOV      r7,#0x1f4
                  |L11.24|
000018  f7fffffe          BL       bsp_Idle
00001c  2003              MOVS     r0,#3                 ;392
00001e  f7fffffe          BL       bsp_CheckTimer
000022  b9b0              CBNZ     r0,|L11.82|
000024  4669              MOV      r1,sp                 ;399
000026  2001              MOVS     r0,#1                 ;399
000028  f7fffffe          BL       comGetChar
00002c  2800              CMP      r0,#0                 ;399
00002e  d0f3              BEQ      |L11.24|
000030  f89d0000          LDRB     r0,[sp,#0]            ;401
000034  f7fffffe          BL       ESP8266_PrintRxData
000038  4639              MOV      r1,r7
00003a  2003              MOVS     r0,#3
00003c  f7fffffe          BL       bsp_StartTimer
;;;404    			_pBuf[pos++] = ucData;		/* 保存接收到的数据 */
000040  f89d0000          LDRB     r0,[sp,#0]
000044  5528              STRB     r0,[r5,r4]
000046  1c64              ADDS     r4,r4,#1
;;;405    			if (ucData == 0x0A)
000048  f89d0000          LDRB     r0,[sp,#0]
00004c  b2a4              UXTH     r4,r4                 ;404
00004e  280a              CMP      r0,#0xa
000050  d1e2              BNE      |L11.24|
                  |L11.82|
;;;406    			{
;;;407    				_pBuf[pos] = 0;
000052  552e              STRB     r6,[r5,r4]
;;;408    				ret = pos;		/* 成功。 返回数据长度 */
000054  b2e0              UXTB     r0,r4
;;;409    				break;
;;;410    			}
;;;411    		}
;;;412    	}
;;;413    	return ret;
;;;414    }
000056  bdf8              POP      {r3-r7,pc}
;;;415    
                          ENDP


                          AREA ||i.ESP8266_Reset||, CODE, READONLY, ALIGN=2

                  ESP8266_Reset PROC
;;;264    */
;;;265    void ESP8266_Reset(void)
000000  b510              PUSH     {r4,lr}
;;;266    {
;;;267    	ESP_RESET_0();
000002  4c08              LDR      r4,|L12.36|
000004  2104              MOVS     r1,#4
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       GPIO_ResetBits
;;;268    	bsp_DelayMS(20);
00000c  2014              MOVS     r0,#0x14
00000e  f7fffffe          BL       bsp_DelayMS
;;;269    	ESP_RESET_1();
000012  2104              MOVS     r1,#4
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       GPIO_SetBits
;;;270    
;;;271    	bsp_DelayMS(10);
00001a  e8bd4010          POP      {r4,lr}
00001e  200a              MOVS     r0,#0xa
000020  f7ffbffe          B.W      bsp_DelayMS
;;;272    }
;;;273    
                          ENDP

                  |L12.36|
                          DCD      0x40011000

                          AREA ||i.ESP8266_RxNew||, CODE, READONLY, ALIGN=2

                  ESP8266_RxNew PROC
;;;712    */
;;;713    uint16_t ESP8266_RxNew(uint8_t *_pRxBuf)
000000  b5f8              PUSH     {r3-r7,lr}
;;;714    {
000002  4606              MOV      r6,r0
;;;715    	uint8_t ucData;
;;;716    	static uint8_t s_buf[512];	/* 约定最长256 */
;;;717    	static uint16_t s_len = 0;
;;;718    	static uint8_t s_flag = 0;
;;;719    	static uint16_t s_data_len = 0;
;;;720    	char *p1;
;;;721    	
;;;722    	/* +IPD,0,7:ledon 1 */
;;;723    
;;;724    	if (comGetChar(COM_ESP8266, &ucData))
000004  4669              MOV      r1,sp
000006  2001              MOVS     r0,#1
000008  f7fffffe          BL       comGetChar
00000c  b380              CBZ      r0,|L13.112|
;;;725    	{
;;;726    		ESP8266_PrintRxData(ucData);		/* 将接收到数据打印到调试串口1 */
00000e  f89d0000          LDRB     r0,[sp,#0]
000012  f7fffffe          BL       ESP8266_PrintRxData
;;;727    
;;;728    		if (s_flag == 0)
000016  4c1e              LDR      r4,|L13.144|
000018  2500              MOVS     r5,#0
;;;729    		{
;;;730    			if (s_len < sizeof(s_buf))
;;;731    			{
;;;732    				s_buf[s_len++] = ucData;		/* 保存接收到的数据 */
00001a  481e              LDR      r0,|L13.148|
00001c  7821              LDRB     r1,[r4,#0]            ;728  ; s_flag
00001e  f44f7200          MOV      r2,#0x200             ;730
000022  2900              CMP      r1,#0                 ;728
;;;733    			}			
;;;734    			if (ucData == '+')
;;;735    			{
;;;736    				s_len = 1;
;;;737    				s_data_len = 0;
;;;738    				s_buf[0] = 0;
;;;739    			}
;;;740    			if (s_len > 7 && ucData == ':')
;;;741    			{
;;;742    				p1 = (char *)&s_buf[7];
;;;743    				s_data_len = str_to_int(p1);	
;;;744    				s_flag = 1;	
;;;745    				s_len = 0;
;;;746    			}
;;;747    		}
;;;748    		else
;;;749    		{
;;;750    			if (s_len < sizeof(s_buf))
000024  8861              LDRH     r1,[r4,#2]  ; s_len
000026  d012              BEQ      |L13.78|
000028  4291              CMP      r1,r2
00002a  d22d              BCS      |L13.136|
;;;751    			{
;;;752    				s_buf[s_len++] = ucData;		/* 保存接收到的数据 */
00002c  f89d2000          LDRB     r2,[sp,#0]
000030  5442              STRB     r2,[r0,r1]
000032  1c49              ADDS     r1,r1,#1
000034  b288              UXTH     r0,r1
000036  8060              STRH     r0,[r4,#2]
;;;753    				
;;;754    				if (s_len == s_data_len)
000038  88a2              LDRH     r2,[r4,#4]  ; s_data_len
00003a  4290              CMP      r0,r2
00003c  d125              BNE      |L13.138|
;;;755    				{
;;;756    					s_flag = 0;
00003e  7025              STRB     r5,[r4,#0]
;;;757    					s_len = 0;
000040  8065              STRH     r5,[r4,#2]
;;;758    					
;;;759    					memcpy(_pRxBuf, s_buf, s_data_len);
000042  4914              LDR      r1,|L13.148|
000044  4630              MOV      r0,r6
000046  f7fffffe          BL       __aeabi_memcpy
;;;760    					
;;;761    					return s_data_len;
00004a  88a0              LDRH     r0,[r4,#4]  ; s_data_len
;;;762    				}
;;;763    			}	
;;;764    			else
;;;765    			{
;;;766    				s_flag = 0;
;;;767    			}
;;;768    		}
;;;769    
;;;770    	}
;;;771    	return 0;
;;;772    }
00004c  bdf8              POP      {r3-r7,pc}
                  |L13.78|
00004e  4291              CMP      r1,r2                 ;730
000050  d204              BCS      |L13.92|
000052  f89d2000          LDRB     r2,[sp,#0]            ;732
000056  5442              STRB     r2,[r0,r1]            ;732
000058  1c49              ADDS     r1,r1,#1              ;732
00005a  8061              STRH     r1,[r4,#2]            ;732
                  |L13.92|
00005c  f89d1000          LDRB     r1,[sp,#0]            ;734
000060  2601              MOVS     r6,#1                 ;724
000062  292b              CMP      r1,#0x2b              ;734
000064  d005              BEQ      |L13.114|
000066  8862              LDRH     r2,[r4,#2]            ;740  ; s_len
000068  2a07              CMP      r2,#7                 ;740
00006a  d90e              BLS      |L13.138|
00006c  293a              CMP      r1,#0x3a              ;740
00006e  d004              BEQ      |L13.122|
                  |L13.112|
000070  e00b              B        |L13.138|
                  |L13.114|
000072  8066              STRH     r6,[r4,#2]            ;736
000074  80a5              STRH     r5,[r4,#4]            ;737
000076  7005              STRB     r5,[r0,#0]            ;738
000078  e007              B        |L13.138|
                  |L13.122|
00007a  1dc0              ADDS     r0,r0,#7              ;738
00007c  f7fffffe          BL       str_to_int
000080  80a0              STRH     r0,[r4,#4]            ;743
000082  7026              STRB     r6,[r4,#0]            ;744
000084  8065              STRH     r5,[r4,#2]            ;745
000086  e000              B        |L13.138|
                  |L13.136|
000088  7025              STRB     r5,[r4,#0]            ;766
                  |L13.138|
00008a  2000              MOVS     r0,#0                 ;771
00008c  bdf8              POP      {r3-r7,pc}
;;;773    
                          ENDP

00008e  0000              DCW      0x0000
                  |L13.144|
                          DCD      ||.data||
                  |L13.148|
                          DCD      ||.bss||

                          AREA ||i.ESP8266_ScanAP||, CODE, READONLY, ALIGN=2

                  ESP8266_ScanAP PROC
;;;632    */
;;;633    int16_t ESP8266_ScanAP(WIFI_AP_T *_pList, uint16_t _MaxNum)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;634    {
000004  b0a1              SUB      sp,sp,#0x84
000006  4604              MOV      r4,r0
;;;635    	uint16_t i;
;;;636    	uint16_t count;
;;;637    	char buf[128];
;;;638    	WIFI_AP_T *p;
;;;639    	char *p1, *p2;
;;;640    	uint16_t timeout;
;;;641    
;;;642    	buf[127] = 0;
000008  f04f0800          MOV      r8,#0
00000c  460f              MOV      r7,r1                 ;634
00000e  f88d807f          STRB     r8,[sp,#0x7f]
;;;643    	ESP8266_SendAT("AT+CWLAP");
000012  a03a              ADR      r0,|L14.252|
000014  f7fffffe          BL       ESP8266_SendAT
;;;644    
;;;645    	p = (WIFI_AP_T *)_pList;
;;;646    	count = 0;
000018  2600              MOVS     r6,#0
;;;647    	timeout = 8000;
00001a  f44f59fa          MOV      r9,#0x1f40
;;;648    	for (i = 0; i < _MaxNum; i++)
00001e  4635              MOV      r5,r6
000020  e065              B        |L14.238|
                  |L14.34|
;;;649    	{
;;;650    		ESP8266_ReadLine(buf, 128, timeout);
000022  464a              MOV      r2,r9
000024  2180              MOVS     r1,#0x80
000026  4668              MOV      r0,sp
000028  f7fffffe          BL       ESP8266_ReadLine
;;;651    		if (memcmp(buf, "OK", 2) == 0)
00002c  2202              MOVS     r2,#2
00002e  a136              ADR      r1,|L14.264|
000030  4668              MOV      r0,sp
000032  f7fffffe          BL       memcmp
000036  2800              CMP      r0,#0
000038  d05b              BEQ      |L14.242|
;;;652    		{
;;;653    			break;
;;;654    		}
;;;655    		else if (memcmp(buf, "ERROR", 5) == 0)
00003a  2205              MOVS     r2,#5
00003c  a133              ADR      r1,|L14.268|
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       memcmp
000044  2800              CMP      r0,#0
000046  d054              BEQ      |L14.242|
;;;656    		{
;;;657    			break;
;;;658    		}
;;;659    		else if (memcmp(buf, "+CWLAP:", 7) == 0)
000048  2207              MOVS     r2,#7
00004a  a132              ADR      r1,|L14.276|
00004c  4668              MOV      r0,sp
00004e  f7fffffe          BL       memcmp
000052  2800              CMP      r0,#0
000054  d149              BNE      |L14.234|
;;;660    		{
;;;661    			p1 = buf;
000056  4668              MOV      r0,sp
;;;662    
;;;663    			/* +CWLAP:(4,"BaiTu",-87,"9c:21:6a:3c:89:52",1) */
;;;664    			/* 解析加密方式 */
;;;665    			p1 = strchr(p1, '(');	/* 搜索到(*/
000058  2128              MOVS     r1,#0x28
00005a  f7fffffe          BL       strchr
00005e  1c40              ADDS     r0,r0,#1
;;;666    			p1++;
000060  4681              MOV      r9,r0
;;;667    			p->ecn = str_to_int(p1);
000062  f7fffffe          BL       str_to_int
000066  f8840021          STRB     r0,[r4,#0x21]
;;;668    
;;;669    			/* 解析ssid */
;;;670    			p1 = strchr(p1, '"');	/* 搜索到第1个分号 */
00006a  2122              MOVS     r1,#0x22
00006c  4648              MOV      r0,r9
00006e  f7fffffe          BL       strchr
000072  1c40              ADDS     r0,r0,#1
;;;671    			p1++;
000074  4681              MOV      r9,r0
;;;672    			p2 = strchr(p1, '"');	/* 搜索到第2个分号 */
000076  2122              MOVS     r1,#0x22
000078  f7fffffe          BL       strchr
00007c  4683              MOV      r11,r0
;;;673    			memcpy(p->ssid, p1, p2 - p1);
00007e  ebab0209          SUB      r2,r11,r9
000082  4692              MOV      r10,r2
000084  4649              MOV      r1,r9
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       __aeabi_memcpy
;;;674    			p->ssid[p2 - p1] = 0;
00008c  f804800a          STRB     r8,[r4,r10]
;;;675    
;;;676    			/* 解析 rssi */
;;;677    			p1 = strchr(p2, ',');	/* 搜索到逗号*/
000090  212c              MOVS     r1,#0x2c
000092  4658              MOV      r0,r11
000094  f7fffffe          BL       strchr
000098  1c40              ADDS     r0,r0,#1
;;;678    			p1++;
00009a  4681              MOV      r9,r0
;;;679    			p->rssi = str_to_int(p1);
00009c  f7fffffe          BL       str_to_int
;;;680    
;;;681    			/* 解析mac */
;;;682    			p1 = strchr(p1, '"');	/* 搜索到分号*/
0000a0  6260              STR      r0,[r4,#0x24]
0000a2  2122              MOVS     r1,#0x22
0000a4  4648              MOV      r0,r9
0000a6  f7fffffe          BL       strchr
0000aa  1c40              ADDS     r0,r0,#1
;;;683    			p1++;
0000ac  4681              MOV      r9,r0
;;;684    			p2 = strchr(p1, '"');	/* 搜索到分号*/
0000ae  2122              MOVS     r1,#0x22
0000b0  f7fffffe          BL       strchr
0000b4  4683              MOV      r11,r0
;;;685    			memcpy(p->mac, p1, p2 - p1);
0000b6  ebab0209          SUB      r2,r11,r9
0000ba  4692              MOV      r10,r2
0000bc  4649              MOV      r1,r9
0000be  f1040028          ADD      r0,r4,#0x28
0000c2  f7fffffe          BL       __aeabi_memcpy
;;;686    			p->mac[p2 - p1] = 0;
0000c6  eb0a0104          ADD      r1,r10,r4
;;;687    
;;;688    			/* 解析ch */
;;;689    			p1 = strchr(p2, ',');	/* 搜索到逗号*/
0000ca  4658              MOV      r0,r11
0000cc  f8818028          STRB     r8,[r1,#0x28]         ;686
0000d0  212c              MOVS     r1,#0x2c
0000d2  f7fffffe          BL       strchr
0000d6  1c40              ADDS     r0,r0,#1
;;;690    			p1++;
;;;691    			p->ch = str_to_int(p1);
0000d8  f7fffffe          BL       str_to_int
0000dc  1c76              ADDS     r6,r6,#1
0000de  f884003c          STRB     r0,[r4,#0x3c]
;;;692    
;;;693    			/* 有效的AP名字 */
;;;694    			count++;
0000e2  b2b6              UXTH     r6,r6
;;;695    
;;;696    			p++;
;;;697    			
;;;698    			timeout = 2000;
0000e4  f44f69fa          MOV      r9,#0x7d0
0000e8  3440              ADDS     r4,r4,#0x40
                  |L14.234|
0000ea  1c6d              ADDS     r5,r5,#1
0000ec  b2ad              UXTH     r5,r5                 ;648
                  |L14.238|
0000ee  42bd              CMP      r5,r7                 ;648
0000f0  d397              BCC      |L14.34|
                  |L14.242|
;;;699    		}
;;;700    	}
;;;701    
;;;702    	return count;
;;;703    }
0000f2  b021              ADD      sp,sp,#0x84
0000f4  b230              SXTH     r0,r6                 ;702
0000f6  e8bd8ff0          POP      {r4-r11,pc}
;;;704    
                          ENDP

0000fa  0000              DCW      0x0000
                  |L14.252|
0000fc  41542b43          DCB      "AT+CWLAP",0
000100  574c4150
000104  00      
000105  00                DCB      0
000106  00                DCB      0
000107  00                DCB      0
                  |L14.264|
000108  4f4b00            DCB      "OK",0
00010b  00                DCB      0
                  |L14.268|
00010c  4552524f          DCB      "ERROR",0
000110  5200    
000112  00                DCB      0
000113  00                DCB      0
                  |L14.276|
000114  2b43574c          DCB      "+CWLAP:",0
000118  41503a00

                          AREA ||i.ESP8266_SendAT||, CODE, READONLY, ALIGN=2

                  ESP8266_SendAT PROC
;;;423    */
;;;424    void ESP8266_SendAT(char *_Cmd)
000000  b510              PUSH     {r4,lr}
;;;425    {
000002  4604              MOV      r4,r0
;;;426    	comSendBuf(COM_ESP8266, (uint8_t *)_Cmd, strlen(_Cmd));
000004  f7fffffe          BL       strlen
000008  b282              UXTH     r2,r0
00000a  4621              MOV      r1,r4
00000c  2001              MOVS     r0,#1
00000e  f7fffffe          BL       comSendBuf
;;;427    	comSendBuf(COM_ESP8266, "\r\n", 2);
000012  2202              MOVS     r2,#2
000014  e8bd4010          POP      {r4,lr}
000018  a101              ADR      r1,|L15.32|
00001a  2001              MOVS     r0,#1
00001c  f7ffbffe          B.W      comSendBuf
;;;428    }
;;;429    
                          ENDP

                  |L15.32|
000020  0d0a00            DCB      "\r\n",0
000023  00                DCB      0

                          AREA ||i.ESP8266_SendTcpUdp||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  ESP8266_SendTcpUdp PROC
;;;474    */
;;;475    void ESP8266_SendTcpUdp(uint8_t *_databuf, uint16_t _len)
000000  b530              PUSH     {r4,r5,lr}
;;;476    {
000002  4605              MOV      r5,r0
;;;477    	char buf[32];
;;;478    
;;;479    	if (_len > 2048)
000004  f44f6000          MOV      r0,#0x800
000008  b089              SUB      sp,sp,#0x24           ;476
00000a  460c              MOV      r4,r1                 ;476
00000c  4281              CMP      r1,r0
00000e  d900              BLS      |L16.18|
;;;480    	{
;;;481    		_len = 2048;
000010  4604              MOV      r4,r0
                  |L16.18|
;;;482    	}
;;;483    
;;;484    	sprintf(buf, "AT+CIPSEND=0,%d\r\n", _len);
000012  4622              MOV      r2,r4
000014  a10e              ADR      r1,|L16.80|
000016  4668              MOV      r0,sp
000018  f7fffffe          BL       __2sprintf
;;;485    	comSendBuf(COM_ESP8266, (uint8_t *)buf, strlen(buf));
00001c  4668              MOV      r0,sp
00001e  f7fffffe          BL       strlen
000022  b282              UXTH     r2,r0
000024  4669              MOV      r1,sp
000026  2001              MOVS     r0,#1
000028  f7fffffe          BL       comSendBuf
;;;486    
;;;487    	ESP8266_WaitResponse(">", 1000);
00002c  f44f717a          MOV      r1,#0x3e8
000030  a00c              ADR      r0,|L16.100|
000032  f7fffffe          BL       ESP8266_WaitResponse
;;;488    
;;;489    	comSendBuf(COM_ESP8266, _databuf, _len);
000036  4622              MOV      r2,r4
000038  4629              MOV      r1,r5
00003a  2001              MOVS     r0,#1
00003c  f7fffffe          BL       comSendBuf
;;;490    	ESP8266_WaitResponse("SEND OK", 8000);
000040  f44f51fa          MOV      r1,#0x1f40
000044  a008              ADR      r0,|L16.104|
000046  f7fffffe          BL       ESP8266_WaitResponse
;;;491    }
00004a  b009              ADD      sp,sp,#0x24
00004c  bd30              POP      {r4,r5,pc}
;;;492    
                          ENDP

00004e  0000              DCW      0x0000
                  |L16.80|
000050  41542b43          DCB      "AT+CIPSEND=0,%d\r\n",0
000054  49505345
000058  4e443d30
00005c  2c25640d
000060  0a00    
000062  00                DCB      0
000063  00                DCB      0
                  |L16.100|
000064  3e00              DCB      ">",0
000066  00                DCB      0
000067  00                DCB      0
                  |L16.104|
000068  53454e44          DCB      "SEND OK",0
00006c  204f4b00

                          AREA ||i.ESP8266_WaitResponse||, CODE, READONLY, ALIGN=1

                  ESP8266_WaitResponse PROC
;;;312    */
;;;313    uint8_t ESP8266_WaitResponse(char *_pAckStr, uint16_t _usTimeOut)
000000  b5f8              PUSH     {r3-r7,lr}
;;;314    {
000002  460e              MOV      r6,r1
000004  4607              MOV      r7,r0
;;;315    	uint8_t ucData;
;;;316    	uint16_t pos = 0;
000006  2400              MOVS     r4,#0
;;;317    	uint32_t len;
;;;318    	uint8_t ret;
;;;319    
;;;320    	len = strlen(_pAckStr);
000008  f7fffffe          BL       strlen
00000c  4605              MOV      r5,r0
;;;321    	if (len > 255)
00000e  28ff              CMP      r0,#0xff
000010  d80b              BHI      |L17.42|
;;;322    	{
;;;323    		return 0;
;;;324    	}
;;;325    
;;;326    	/* _usTimeOut == 0 表示无限等待 */
;;;327    	if (_usTimeOut > 0)
000012  b166              CBZ      r6,|L17.46|
;;;328    	{
;;;329    		bsp_StartTimer(ESP8266_TMR_ID, _usTimeOut);		/* 使用软件定时器3，作为超时控制 */
000014  4631              MOV      r1,r6
000016  2003              MOVS     r0,#3
000018  f7fffffe          BL       bsp_StartTimer
                  |L17.28|
;;;330    	}
;;;331    	while (1)
;;;332    	{
;;;333    		bsp_Idle();				/* CPU空闲执行的操作， 见 bsp.c 和 bsp.h 文件 */
00001c  f7fffffe          BL       bsp_Idle
;;;334    
;;;335    		if (_usTimeOut > 0)
000020  b13e              CBZ      r6,|L17.50|
;;;336    		{
;;;337    			if (bsp_CheckTimer(ESP8266_TMR_ID))
000022  2003              MOVS     r0,#3
000024  f7fffffe          BL       bsp_CheckTimer
000028  b118              CBZ      r0,|L17.50|
                  |L17.42|
;;;338    			{
;;;339    				ret = 0;	/* 超时 */
00002a  2000              MOVS     r0,#0
;;;340    				break;
;;;341    			}
;;;342    		}
;;;343    
;;;344    		if (comGetChar(COM_ESP8266, &ucData))
;;;345    		{
;;;346    			ESP8266_PrintRxData(ucData);		/* 将接收到数据打印到调试串口1 */
;;;347    
;;;348    			if (ucData == _pAckStr[pos])
;;;349    			{
;;;350    				pos++;
;;;351    
;;;352    				if (pos == len)
;;;353    				{
;;;354    					ret = 1;	/* 收到指定的应答数据，返回成功 */
;;;355    					break;
;;;356    				}
;;;357    			}
;;;358    			else
;;;359    			{
;;;360    				pos = 0;
;;;361    			}
;;;362    		}
;;;363    	}
;;;364    	return ret;
;;;365    }
00002c  bdf8              POP      {r3-r7,pc}
                  |L17.46|
00002e  f7fffffe          BL       bsp_Idle
                  |L17.50|
000032  4669              MOV      r1,sp                 ;344
000034  2001              MOVS     r0,#1                 ;344
000036  f7fffffe          BL       comGetChar
00003a  2800              CMP      r0,#0                 ;344
00003c  d0ee              BEQ      |L17.28|
00003e  f89d0000          LDRB     r0,[sp,#0]            ;346
000042  f7fffffe          BL       ESP8266_PrintRxData
000046  5d38              LDRB     r0,[r7,r4]            ;348
000048  f89d1000          LDRB     r1,[sp,#0]            ;348
00004c  4288              CMP      r0,r1                 ;348
00004e  d105              BNE      |L17.92|
000050  1c64              ADDS     r4,r4,#1              ;348
000052  b2a4              UXTH     r4,r4                 ;350
000054  42ac              CMP      r4,r5                 ;352
000056  d1e1              BNE      |L17.28|
000058  2001              MOVS     r0,#1                 ;354
00005a  bdf8              POP      {r3-r7,pc}
                  |L17.92|
00005c  2400              MOVS     r4,#0                 ;360
00005e  e7dd              B        |L17.28|
;;;366    
                          ENDP


                          AREA ||i.bsp_InitESP8266||, CODE, READONLY, ALIGN=2

                  bsp_InitESP8266 PROC
;;;139    */
;;;140    void bsp_InitESP8266(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;141    {
;;;142    	GPIO_InitTypeDef GPIO_InitStructure;
;;;143    
;;;144    	/* 打开GPIO时钟 */
;;;145    	RCC_APB2PeriphClockCmd(RCC_CH_PD | RCC_RESET | RCC_GPIO2 | RCC_GPIO0, ENABLE);
000002  2101              MOVS     r1,#1
000004  209c              MOVS     r0,#0x9c
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;146    
;;;147    	
;;;148    	/* Disable the Serial Wire Jtag Debug Port SWJ-DP 
;;;149    		JTAG-DP Disabled and SW-DP Enabled 
;;;150    	 PB4/TRST/GPRS_TERM_ON 缺省用于JTAG信号，需要重新映射为	
;;;151    	*/
;;;152        GPIO_PinRemapConfig(GPIO_Remap_SWJ_JTAGDisable, ENABLE);
00000a  2101              MOVS     r1,#1
00000c  481c              LDR      r0,|L18.128|
00000e  f7fffffe          BL       GPIO_PinRemapConfig
;;;153    
;;;154    	/* 配置几个推完输出IO */
;;;155    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2003              MOVS     r0,#3
000014  f88d0002          STRB     r0,[sp,#2]
;;;156    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;	/* 推挽输出模式 */
000018  2010              MOVS     r0,#0x10
00001a  f88d0003          STRB     r0,[sp,#3]
;;;157    
;;;158    	GPIO_InitStructure.GPIO_Pin = PIN_CH_PD;
;;;159    	GPIO_Init(PORT_CH_PD, &GPIO_InitStructure);
00001e  4d19              LDR      r5,|L18.132|
000020  f8ad0000          STRH     r0,[sp,#0]            ;158
000024  4669              MOV      r1,sp
000026  4628              MOV      r0,r5
000028  f7fffffe          BL       GPIO_Init
;;;160    
;;;161    	GPIO_InitStructure.GPIO_Pin = PIN_RESET;
00002c  2004              MOVS     r0,#4
00002e  f8ad0000          STRH     r0,[sp,#0]
;;;162    	GPIO_Init(PORT_RESET, &GPIO_InitStructure);
000032  4669              MOV      r1,sp
000034  4814              LDR      r0,|L18.136|
000036  f7fffffe          BL       GPIO_Init
;;;163    
;;;164    	GPIO_InitStructure.GPIO_Pin = PIN_GPIO2;
;;;165    	GPIO_Init(PORT_GPIO2, &GPIO_InitStructure);
00003a  4e14              LDR      r6,|L18.140|
00003c  f44f4400          MOV      r4,#0x8000            ;164
000040  f8ad4000          STRH     r4,[sp,#0]            ;164
000044  4669              MOV      r1,sp
000046  4630              MOV      r0,r6
000048  f7fffffe          BL       GPIO_Init
;;;166    
;;;167    	GPIO_InitStructure.GPIO_Pin = PIN_GPIO0;
00004c  2080              MOVS     r0,#0x80
;;;168    	GPIO_Init(PORT_GPIO0, &GPIO_InitStructure);
00004e  4f10              LDR      r7,|L18.144|
000050  f8ad0000          STRH     r0,[sp,#0]            ;167
000054  4669              MOV      r1,sp
000056  4638              MOV      r0,r7
000058  f7fffffe          BL       GPIO_Init
;;;169    
;;;170    	ESP_GPIO2_1();
00005c  4621              MOV      r1,r4
00005e  4630              MOV      r0,r6
000060  f7fffffe          BL       GPIO_SetBits
;;;171    
;;;172    	/* CPU的串口配置已经由 bsp_uart_fifo.c 中的 bsp_InitUart() 做了 */
;;;173    	ESP_CH_PD_0();
000064  2110              MOVS     r1,#0x10
000066  4628              MOV      r0,r5
000068  f7fffffe          BL       GPIO_ResetBits
;;;174    
;;;175    	ESP_EXIT_ISP();
00006c  2180              MOVS     r1,#0x80
00006e  4638              MOV      r0,r7
000070  f7fffffe          BL       GPIO_SetBits
;;;176    
;;;177    	//ESP8266_Reset();
;;;178    
;;;179    	comSetBaud(COM_ESP8266,115200);
000074  f44f31e1          MOV      r1,#0x1c200
000078  2001              MOVS     r0,#1
00007a  f7fffffe          BL       comSetBaud
;;;180    }
00007e  bdf8              POP      {r3-r7,pc}
;;;181    
                          ENDP

                  |L18.128|
                          DCD      0x00300200
                  |L18.132|
                          DCD      0x40010c00
                  |L18.136|
                          DCD      0x40011000
                  |L18.140|
                          DCD      0x40010800
                  |L18.144|
                          DCD      0x40011c00

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  s_buf
                          %        512

                          AREA ||area_number.21||, DATA, NOINIT, ALIGN=0

                          EXPORTAS ||area_number.21||, ||.bss||
                  g_EspBuf
                          %        2048

                          AREA ||.data||, DATA, ALIGN=1

                  s_flag
000000  0000              DCB      0x00,0x00
                  s_len
000002  0000              DCW      0x0000
                  s_data_len
000004  0000              DCW      0x0000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_esp8266.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_esp8266_c_156369de____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_esp8266_c_156369de____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_esp8266_c_156369de____REVSH|
#line 128
|__asm___13_bsp_esp8266_c_156369de____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
