; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_rtc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_rtc.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\stm32f10x_rtc.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_rtc.c]
                          THUMB

                          AREA ||i.RTC_ClearFlag||, CODE, READONLY, ALIGN=2

                  RTC_ClearFlag PROC
;;;291      */
;;;292    void RTC_ClearFlag(uint16_t RTC_FLAG)
000000  4902              LDR      r1,|L1.12|
;;;293    {
;;;294      /* Check the parameters */
;;;295      assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
;;;296        
;;;297      /* Clear the corresponding RTC flag */
;;;298      RTC->CRL &= (uint16_t)~RTC_FLAG;
000002  880a              LDRH     r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  800a              STRH     r2,[r1,#0]
;;;299    }
000008  4770              BX       lr
;;;300    
                          ENDP

00000a  0000              DCW      0x0000
                  |L1.12|
                          DCD      0x40002804

                          AREA ||i.RTC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  RTC_ClearITPendingBit PROC
;;;336      */
;;;337    void RTC_ClearITPendingBit(uint16_t RTC_IT)
000000  4902              LDR      r1,|L2.12|
;;;338    {
;;;339      /* Check the parameters */
;;;340      assert_param(IS_RTC_IT(RTC_IT));  
;;;341      
;;;342      /* Clear the corresponding RTC pending bit */
;;;343      RTC->CRL &= (uint16_t)~RTC_IT;
000002  880a              LDRH     r2,[r1,#0]
000004  4382              BICS     r2,r2,r0
000006  800a              STRH     r2,[r1,#0]
;;;344    }
000008  4770              BX       lr
;;;345    
                          ENDP

00000a  0000              DCW      0x0000
                  |L2.12|
                          DCD      0x40002804

                          AREA ||i.RTC_EnterConfigMode||, CODE, READONLY, ALIGN=2

                  RTC_EnterConfigMode PROC
;;;116      */
;;;117    void RTC_EnterConfigMode(void)
000000  4802              LDR      r0,|L3.12|
;;;118    {
;;;119      /* Set the CNF flag to enter in the Configuration Mode */
;;;120      RTC->CRL |= RTC_CRL_CNF;
000002  8801              LDRH     r1,[r0,#0]
000004  f0410110          ORR      r1,r1,#0x10
000008  8001              STRH     r1,[r0,#0]
;;;121    }
00000a  4770              BX       lr
;;;122    
                          ENDP

                  |L3.12|
                          DCD      0x40002804

                          AREA ||i.RTC_ExitConfigMode||, CODE, READONLY, ALIGN=2

                  RTC_ExitConfigMode PROC
;;;127      */
;;;128    void RTC_ExitConfigMode(void)
000000  4802              LDR      r0,|L4.12|
;;;129    {
;;;130      /* Reset the CNF flag to exit from the Configuration Mode */
;;;131      RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
000002  8801              LDRH     r1,[r0,#0]
000004  f0210110          BIC      r1,r1,#0x10
000008  8001              STRH     r1,[r0,#0]
;;;132    }
00000a  4770              BX       lr
;;;133    
                          ENDP

                  |L4.12|
                          DCD      0x40002804

                          AREA ||i.RTC_GetCounter||, CODE, READONLY, ALIGN=2

                  RTC_GetCounter PROC
;;;138      */
;;;139    uint32_t RTC_GetCounter(void)
000000  4806              LDR      r0,|L5.28|
;;;140    {
;;;141      uint16_t high1 = 0, high2 = 0, low = 0;
;;;142    
;;;143      high1 = RTC->CNTH;
000002  8801              LDRH     r1,[r0,#0]
;;;144      low   = RTC->CNTL;
000004  1d03              ADDS     r3,r0,#4
000006  881a              LDRH     r2,[r3,#0]
;;;145      high2 = RTC->CNTH;
000008  8800              LDRH     r0,[r0,#0]
;;;146    
;;;147      if (high1 != high2)
00000a  4281              CMP      r1,r0
00000c  d003              BEQ      |L5.22|
;;;148      { /* In this case the counter roll over during reading of CNTL and CNTH registers, 
;;;149           read again CNTL register then return the counter value */
;;;150        return (((uint32_t) high2 << 16 ) | RTC->CNTL);
00000e  8819              LDRH     r1,[r3,#0]
000010  ea414000          ORR      r0,r1,r0,LSL #16
;;;151      }
;;;152      else
;;;153      { /* No counter roll over during reading of CNTL and CNTH registers, counter 
;;;154           value is equal to first value of CNTL and CNTH */
;;;155        return (((uint32_t) high1 << 16 ) | low);
;;;156      }
;;;157    }
000014  4770              BX       lr
                  |L5.22|
000016  ea424001          ORR      r0,r2,r1,LSL #16      ;155
00001a  4770              BX       lr
;;;158    
                          ENDP

                  |L5.28|
                          DCD      0x40002818

                          AREA ||i.RTC_GetDivider||, CODE, READONLY, ALIGN=2

                  RTC_GetDivider PROC
;;;211      */
;;;212    uint32_t RTC_GetDivider(void)
000000  4804              LDR      r0,|L6.20|
;;;213    {
;;;214      uint32_t tmp = 0x00;
;;;215      tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
000002  8800              LDRH     r0,[r0,#0]
000004  0700              LSLS     r0,r0,#28
000006  0b01              LSRS     r1,r0,#12
;;;216      tmp |= RTC->DIVL;
000008  4802              LDR      r0,|L6.20|
00000a  1d00              ADDS     r0,r0,#4
00000c  8800              LDRH     r0,[r0,#0]
00000e  4308              ORRS     r0,r0,r1
;;;217      return tmp;
;;;218    }
000010  4770              BX       lr
;;;219    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      0x40002810

                          AREA ||i.RTC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetFlagStatus PROC
;;;262      */
;;;263    FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
000000  4a03              LDR      r2,|L7.16|
;;;264    {
000002  4601              MOV      r1,r0
;;;265      FlagStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;266      
;;;267      /* Check the parameters */
;;;268      assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
;;;269      
;;;270      if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
000006  8812              LDRH     r2,[r2,#0]
000008  420a              TST      r2,r1
00000a  d000              BEQ      |L7.14|
;;;271      {
;;;272        bitstatus = SET;
00000c  2001              MOVS     r0,#1
                  |L7.14|
;;;273      }
;;;274      else
;;;275      {
;;;276        bitstatus = RESET;
;;;277      }
;;;278      return bitstatus;
;;;279    }
00000e  4770              BX       lr
;;;280    
                          ENDP

                  |L7.16|
                          DCD      0x40002804

                          AREA ||i.RTC_GetITStatus||, CODE, READONLY, ALIGN=2

                  RTC_GetITStatus PROC
;;;309      */
;;;310    ITStatus RTC_GetITStatus(uint16_t RTC_IT)
000000  4906              LDR      r1,|L8.28|
;;;311    {
;;;312      ITStatus bitstatus = RESET;
;;;313      /* Check the parameters */
;;;314      assert_param(IS_RTC_GET_IT(RTC_IT)); 
;;;315      
;;;316      bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
000002  8809              LDRH     r1,[r1,#0]
000004  b2c2              UXTB     r2,r0
000006  4011              ANDS     r1,r1,r2
;;;317      if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
000008  4a04              LDR      r2,|L8.28|
00000a  1f12              SUBS     r2,r2,#4
00000c  8812              LDRH     r2,[r2,#0]
00000e  4202              TST      r2,r0
000010  d002              BEQ      |L8.24|
000012  b109              CBZ      r1,|L8.24|
;;;318      {
;;;319        bitstatus = SET;
000014  2001              MOVS     r0,#1
;;;320      }
;;;321      else
;;;322      {
;;;323        bitstatus = RESET;
;;;324      }
;;;325      return bitstatus;
;;;326    }
000016  4770              BX       lr
                  |L8.24|
000018  2000              MOVS     r0,#0                 ;323
00001a  4770              BX       lr
;;;327    
                          ENDP

                  |L8.28|
                          DCD      0x40002804

                          AREA ||i.RTC_ITConfig||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;95       */
;;;96     void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
000000  4a04              LDR      r2,|L9.20|
;;;97     {
;;;98       /* Check the parameters */
;;;99       assert_param(IS_RTC_IT(RTC_IT));  
;;;100      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;101      
;;;102      if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;103      {
;;;104        RTC->CRH |= RTC_IT;
;;;105      }
;;;106      else
;;;107      {
;;;108        RTC->CRH &= (uint16_t)~RTC_IT;
000004  8811              LDRH     r1,[r2,#0]
000006  d001              BEQ      |L9.12|
000008  4301              ORRS     r1,r1,r0              ;104
00000a  e000              B        |L9.14|
                  |L9.12|
00000c  4381              BICS     r1,r1,r0
                  |L9.14|
00000e  8011              STRH     r1,[r2,#0]            ;104
;;;109      }
;;;110    }
000010  4770              BX       lr
;;;111    
                          ENDP

000012  0000              DCW      0x0000
                  |L9.20|
                          DCD      0x40002800

                          AREA ||i.RTC_SetAlarm||, CODE, READONLY, ALIGN=2

                  RTC_SetAlarm PROC
;;;196      */
;;;197    void RTC_SetAlarm(uint32_t AlarmValue)
000000  b500              PUSH     {lr}
;;;198    {  
000002  4602              MOV      r2,r0
;;;199      RTC_EnterConfigMode();
000004  f7fffffe          BL       RTC_EnterConfigMode
;;;200      /* Set the ALARM MSB word */
;;;201      RTC->ALRH = AlarmValue >> 16;
000008  4904              LDR      r1,|L10.28|
00000a  0c10              LSRS     r0,r2,#16
00000c  8008              STRH     r0,[r1,#0]
;;;202      /* Set the ALARM LSB word */
;;;203      RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
00000e  1d08              ADDS     r0,r1,#4
000010  8002              STRH     r2,[r0,#0]
;;;204      RTC_ExitConfigMode();
000012  f85deb04          POP      {lr}
000016  f7ffbffe          B.W      RTC_ExitConfigMode
;;;205    }
;;;206    
                          ENDP

00001a  0000              DCW      0x0000
                  |L10.28|
                          DCD      0x40002820

                          AREA ||i.RTC_SetCounter||, CODE, READONLY, ALIGN=2

                  RTC_SetCounter PROC
;;;163      */
;;;164    void RTC_SetCounter(uint32_t CounterValue)
000000  b500              PUSH     {lr}
;;;165    { 
000002  4602              MOV      r2,r0
;;;166      RTC_EnterConfigMode();
000004  f7fffffe          BL       RTC_EnterConfigMode
;;;167      /* Set RTC COUNTER MSB word */
;;;168      RTC->CNTH = CounterValue >> 16;
000008  4904              LDR      r1,|L11.28|
00000a  0c10              LSRS     r0,r2,#16
00000c  8008              STRH     r0,[r1,#0]
;;;169      /* Set RTC COUNTER LSB word */
;;;170      RTC->CNTL = (CounterValue & RTC_LSB_MASK);
00000e  1d08              ADDS     r0,r1,#4
000010  8002              STRH     r2,[r0,#0]
;;;171      RTC_ExitConfigMode();
000012  f85deb04          POP      {lr}
000016  f7ffbffe          B.W      RTC_ExitConfigMode
;;;172    }
;;;173    
                          ENDP

00001a  0000              DCW      0x0000
                  |L11.28|
                          DCD      0x40002818

                          AREA ||i.RTC_SetPrescaler||, CODE, READONLY, ALIGN=2

                  RTC_SetPrescaler PROC
;;;178      */
;;;179    void RTC_SetPrescaler(uint32_t PrescalerValue)
000000  b500              PUSH     {lr}
;;;180    {
000002  4602              MOV      r2,r0
;;;181      /* Check the parameters */
;;;182      assert_param(IS_RTC_PRESCALER(PrescalerValue));
;;;183      
;;;184      RTC_EnterConfigMode();
000004  f7fffffe          BL       RTC_EnterConfigMode
;;;185      /* Set RTC PRESCALER MSB word */
;;;186      RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
000008  4904              LDR      r1,|L12.28|
00000a  f3c24003          UBFX     r0,r2,#16,#4
00000e  8008              STRH     r0,[r1,#0]
;;;187      /* Set RTC PRESCALER LSB word */
;;;188      RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
000010  1d08              ADDS     r0,r1,#4
000012  8002              STRH     r2,[r0,#0]
;;;189      RTC_ExitConfigMode();
000014  f85deb04          POP      {lr}
000018  f7ffbffe          B.W      RTC_ExitConfigMode
;;;190    }
;;;191    
                          ENDP

                  |L12.28|
                          DCD      0x40002808

                          AREA ||i.RTC_WaitForLastTask||, CODE, READONLY, ALIGN=2

                  RTC_WaitForLastTask PROC
;;;225      */
;;;226    void RTC_WaitForLastTask(void)
000000  4802              LDR      r0,|L13.12|
                  |L13.2|
;;;227    {
;;;228      /* Loop until RTOFF flag is set */
;;;229      while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
000002  8801              LDRH     r1,[r0,#0]
000004  0689              LSLS     r1,r1,#26
000006  d5fc              BPL      |L13.2|
;;;230      {
;;;231      }
;;;232    }
000008  4770              BX       lr
;;;233    
                          ENDP

00000a  0000              DCW      0x0000
                  |L13.12|
                          DCD      0x40002804

                          AREA ||i.RTC_WaitForSynchro||, CODE, READONLY, ALIGN=2

                  RTC_WaitForSynchro PROC
;;;241      */
;;;242    void RTC_WaitForSynchro(void)
000000  4804              LDR      r0,|L14.20|
;;;243    {
;;;244      /* Clear RSF flag */
;;;245      RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
000002  8801              LDRH     r1,[r0,#0]
000004  f0210108          BIC      r1,r1,#8
000008  8001              STRH     r1,[r0,#0]
                  |L14.10|
;;;246      /* Loop until RSF flag is set */
;;;247      while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
00000a  8801              LDRH     r1,[r0,#0]
00000c  0709              LSLS     r1,r1,#28
00000e  d5fc              BPL      |L14.10|
;;;248      {
;;;249      }
;;;250    }
000010  4770              BX       lr
;;;251    
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      0x40002804

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_rtc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rtc_c_383801d5____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_rtc_c_383801d5____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_rtc_c_383801d5____REVSH|
#line 128
|__asm___15_stm32f10x_rtc_c_383801d5____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
