; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\diskio.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\diskio.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\diskio.crf ..\..\User\FatFS\src\diskio.c]
                          THUMB

                          AREA ||i.disk_initialize||, CODE, READONLY, ALIGN=1

                  disk_initialize PROC
;;;53     
;;;54     DSTATUS disk_initialize (
000000  b510              PUSH     {r4,lr}
;;;55     	BYTE pdrv				/* Physical drive nmuber to identify the drive */
;;;56     )
;;;57     {
;;;58     	DSTATUS stat = STA_NOINIT;
000002  2401              MOVS     r4,#1
000004  b110              CBZ      r0,|L1.12|
;;;59     
;;;60     	switch (pdrv)
000006  2801              CMP      r0,#1
000008  d109              BNE      |L1.30|
00000a  e004              B        |L1.22|
                  |L1.12|
;;;61     	{
;;;62     		case FS_SD :		/* SD卡 */
;;;63     			if (SD_Init() == SD_OK)
00000c  f7fffffe          BL       SD_Init
000010  b120              CBZ      r0,|L1.28|
;;;64     			{
;;;65     				stat = RES_OK;
;;;66     			}
;;;67     			else
;;;68     			{
;;;69     				stat = STA_NODISK;
000012  2402              MOVS     r4,#2
000014  e003              B        |L1.30|
                  |L1.22|
;;;70     			}
;;;71     			break;
;;;72     
;;;73     		case FS_NAND :		/* NAND Flash */
;;;74     			if (NAND_Init() == NAND_OK)
000016  f7fffffe          BL       NAND_Init
00001a  b900              CBNZ     r0,|L1.30|
                  |L1.28|
;;;75     			{
;;;76     				stat = RES_OK;
00001c  2400              MOVS     r4,#0
                  |L1.30|
;;;77     			}
;;;78     			else
;;;79     			{
;;;80     				/* 如果初始化失败，请执行低级格式化 */
;;;81     				ff_printf("NAND_Init() Error!  \r\n");
;;;82     				stat = RES_ERROR;
;;;83     			}
;;;84     			break;
;;;85     
;;;86     		default :
;;;87     			break;
;;;88     	}
;;;89     	return stat;
00001e  4620              MOV      r0,r4
;;;90     }
000020  bd10              POP      {r4,pc}
;;;91     
                          ENDP


                          AREA ||i.disk_ioctl||, CODE, READONLY, ALIGN=2

                  disk_ioctl PROC
;;;253    #if _USE_IOCTL
;;;254    DRESULT disk_ioctl (
000000  b510              PUSH     {r4,lr}
;;;255    	BYTE pdrv,		/* Physical drive nmuber (0..) */
;;;256    	BYTE cmd,		/* Control code */
;;;257    	void *buff		/* Buffer to send/receive control data */
;;;258    )
;;;259    {
000002  4614              MOV      r4,r2
000004  0003              MOVS     r3,r0
;;;260    	DRESULT res = RES_PARERR;
000006  f04f0004          MOV      r0,#4
;;;261    
;;;262    	switch (pdrv) {
;;;263    	case FS_SD :
;;;264    		res = RES_ERROR;
;;;265    		switch (cmd)
;;;266    		{
;;;267    			/* SD卡磁盘容量： SDCardInfo.CardCapacity */
;;;268    			case CTRL_SYNC :		/* Wait for end of internal write process of the drive */
;;;269    				res = RES_OK;
;;;270    				break;
;;;271    
;;;272    			case GET_SECTOR_COUNT :	/* Get drive capacity in unit of sector (DWORD) */
;;;273    				*(DWORD*)buff = SDCardInfo.CardCapacity / 512;
;;;274    				res = RES_OK;
;;;275    				break;
;;;276    
;;;277    			case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */
;;;278    				*(WORD*)buff = 512;
00000a  f44f7200          MOV      r2,#0x200
00000e  d009              BEQ      |L2.36|
000010  2b01              CMP      r3,#1                 ;262
000012  d10d              BNE      |L2.48|
;;;279    				res = RES_OK;
;;;280    				break;
;;;281    
;;;282    			case CTRL_ERASE_SECTOR: /* Erase a block of sectors (used when _USE_ERASE == 1) */
;;;283    			default:
;;;284    				res = RES_PARERR;
;;;285    				break;
;;;286    		}
;;;287    		break;
;;;288    
;;;289    	case FS_NAND :
;;;290    		res = RES_ERROR;
;;;291    		switch (cmd)
000014  b169              CBZ      r1,|L2.50|
000016  2901              CMP      r1,#1
000018  d015              BEQ      |L2.70|
00001a  2902              CMP      r1,#2
00001c  d018              BEQ      |L2.80|
00001e  2903              CMP      r1,#3
000020  d105              BNE      |L2.46|
000022  e017              B        |L2.84|
                  |L2.36|
000024  b129              CBZ      r1,|L2.50|
000026  2901              CMP      r1,#1                 ;265
000028  d005              BEQ      |L2.54|
00002a  2903              CMP      r1,#3                 ;265
00002c  d010              BEQ      |L2.80|
                  |L2.46|
00002e  2004              MOVS     r0,#4                 ;284
                  |L2.48|
;;;292    		{
;;;293    			case CTRL_SYNC :		/* Make sure that no pending write process */
;;;294    				res = RES_OK;
;;;295    				break;
;;;296    
;;;297    			case GET_SECTOR_COUNT :	/* Get number of sectors on the disk (DWORD) */
;;;298    				//*(DWORD*)buff = 262144;
;;;299    				//*block_num =  (NAND_PAGE_SIZE / 512) * NAND_BLOCK_SIZE * NAND_ZONE_SIZE * NAND_MAX_ZONE;
;;;300    				*(DWORD*)buff = NAND_FormatCapacity() / 512;	/* 必须为可用的扇区个数，不是芯片的理论容量 */
;;;301    				res = RES_OK;
;;;302    				break;
;;;303    
;;;304    			case GET_SECTOR_SIZE :	/* Get R/W sector size (WORD) */
;;;305    				*(WORD*)buff = 512;
;;;306    				res = RES_OK;
;;;307    				break;
;;;308    
;;;309    			case GET_BLOCK_SIZE :	/* Get erase block size in unit of sector (DWORD) */\
;;;310    				*(DWORD*)buff = 512;
;;;311    				res = RES_OK;
;;;312    				break;
;;;313    
;;;314    			default:
;;;315    				res = RES_PARERR;
;;;316    				break;
;;;317    		}
;;;318    		break;
;;;319    
;;;320    	default:
;;;321    		res = RES_PARERR;
;;;322    		break;
;;;323    	}
;;;324    	return res;
;;;325    }
000030  bd10              POP      {r4,pc}
                  |L2.50|
000032  2000              MOVS     r0,#0                 ;269
000034  bd10              POP      {r4,pc}
                  |L2.54|
000036  4908              LDR      r1,|L2.88|
000038  6c88              LDR      r0,[r1,#0x48]         ;273  ; SDCardInfo
00003a  f8b1104c          LDRH     r1,[r1,#0x4c]         ;273  ; SDCardInfo
00003e  0a40              LSRS     r0,r0,#9              ;273
000040  ea4050c1          ORR      r0,r0,r1,LSL #23      ;273
000044  e002              B        |L2.76|
                  |L2.70|
000046  f7fffffe          BL       NAND_FormatCapacity
00004a  0a40              LSRS     r0,r0,#9              ;300
                  |L2.76|
00004c  6020              STR      r0,[r4,#0]            ;300
00004e  e7f0              B        |L2.50|
                  |L2.80|
000050  8022              STRH     r2,[r4,#0]            ;305
000052  e7ee              B        |L2.50|
                  |L2.84|
000054  6022              STR      r2,[r4,#0]            ;312
000056  e7ec              B        |L2.50|
;;;326    #endif
                          ENDP

                  |L2.88|
                          DCD      SDCardInfo

                          AREA ||i.disk_read||, CODE, READONLY, ALIGN=2

                  disk_read PROC
;;;97     
;;;98     DRESULT disk_read (
000000  b57c              PUSH     {r2-r6,lr}
;;;99     	BYTE pdrv,		/* Physical drive nmuber to identify the drive */
;;;100    	BYTE *buff,		/* Data buffer to store read data */
;;;101    	DWORD sector,	/* Sector address in LBA */
;;;102    	UINT count		/* Number of sectors to read */
;;;103    )
;;;104    {
000002  4615              MOV      r5,r2
000004  460e              MOV      r6,r1
;;;105    	DRESULT res = RES_OK;
000006  2400              MOVS     r4,#0
;;;106    	SD_Error Status;
;;;107    
;;;108    	switch (pdrv)
;;;109    	{
;;;110    		case FS_SD :
;;;111    			if (count == 1)
;;;112    			{
;;;113    				Status = SD_ReadBlock(buff, sector << 9 , SECTOR_SIZE);
000008  f44f7200          MOV      r2,#0x200
00000c  b120              CBZ      r0,|L3.24|
00000e  2801              CMP      r0,#1                 ;108
000010  d027              BEQ      |L3.98|
;;;114    			}
;;;115    			else
;;;116    			{
;;;117    				Status = SD_ReadMultiBlocks(buff, sector << 9 , SECTOR_SIZE, count);
;;;118    			}
;;;119    			
;;;120    			/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;121    			Status = SD_WaitReadOperation();
;;;122    			if (Status != SD_OK)
;;;123    			{
;;;124    				return RES_ERROR;
;;;125    			}
;;;126    			
;;;127    			//while(SD_GetStatus() != SD_TRANSFER_OK); 如果不插卡，则此处会死机
;;;128    			{
;;;129    				uint32_t i;
;;;130    				SDTransferState status;
;;;131    				
;;;132    				for (i = 0; i < 100000; i++)
;;;133    				{									
;;;134    					status = SD_GetStatus();
;;;135    					if (status == SD_TRANSFER_ERROR)
;;;136    					{
;;;137    						res = RES_ERROR;
;;;138    						break;
;;;139    					}
;;;140    					else if (status == SD_TRANSFER_OK)
;;;141    					{
;;;142    						res = RES_OK;
;;;143    						break;
;;;144    					}
;;;145    					//  SD_TRANSFER_BUSY 则继续等待 
;;;146    				}
;;;147    			}
;;;148    			break;
;;;149    
;;;150    		case FS_NAND :
;;;151    			if (NAND_OK == NAND_ReadMultiSectors(buff, sector, 512, count))
;;;152    			{
;;;153    				res = RES_OK;
;;;154    			}
;;;155    			else
;;;156    			{
;;;157    				ff_printf("NAND_ReadMultiSectors() Error! sector = %d, count = %d \r\n", sector, count);
;;;158    				res = RES_ERROR;
;;;159    			}
;;;160    			break;
;;;161    
;;;162    		default:
;;;163    			res = RES_PARERR;
000012  2404              MOVS     r4,#4
                  |L3.20|
;;;164    			break;
;;;165    	}
;;;166    	return res;
000014  4620              MOV      r0,r4
;;;167    }
000016  bd7c              POP      {r2-r6,pc}
                  |L3.24|
000018  0268              LSLS     r0,r5,#9              ;113
00001a  2b01              CMP      r3,#1                 ;111
00001c  d00b              BEQ      |L3.54|
00001e  e9cd2300          STRD     r2,r3,[sp,#0]         ;111
000022  4602              MOV      r2,r0                 ;111
000024  2300              MOVS     r3,#0                 ;117
000026  4608              MOV      r0,r1                 ;117
000028  f7fffffe          BL       SD_ReadMultiBlocks
                  |L3.44|
00002c  f7fffffe          BL       SD_WaitReadOperation
000030  b140              CBZ      r0,|L3.68|
000032  2001              MOVS     r0,#1                 ;124
000034  bd7c              POP      {r2-r6,pc}
                  |L3.54|
000036  9200              STR      r2,[sp,#0]            ;113
000038  4602              MOV      r2,r0                 ;113
00003a  2300              MOVS     r3,#0                 ;113
00003c  4608              MOV      r0,r1                 ;113
00003e  f7fffffe          BL       SD_ReadBlock
000042  e7f3              B        |L3.44|
                  |L3.68|
000044  2500              MOVS     r5,#0                 ;132
000046  4e0a              LDR      r6,|L3.112|
                  |L3.72|
000048  f7fffffe          BL       SD_GetStatus
00004c  2802              CMP      r0,#2                 ;135
00004e  d004              BEQ      |L3.90|
000050  b128              CBZ      r0,|L3.94|
000052  1c6d              ADDS     r5,r5,#1              ;140
000054  42b5              CMP      r5,r6                 ;132
000056  d3f7              BCC      |L3.72|
000058  e7dc              B        |L3.20|
                  |L3.90|
00005a  2401              MOVS     r4,#1                 ;137
00005c  e7da              B        |L3.20|
                  |L3.94|
00005e  2400              MOVS     r4,#0                 ;142
000060  e7d8              B        |L3.20|
                  |L3.98|
000062  4629              MOV      r1,r5                 ;151
000064  4630              MOV      r0,r6                 ;151
000066  f7fffffe          BL       NAND_ReadMultiSectors
00006a  2800              CMP      r0,#0                 ;151
00006c  d0d2              BEQ      |L3.20|
00006e  e7f4              B        |L3.90|
;;;168    
                          ENDP

                  |L3.112|
                          DCD      0x000186a0

                          AREA ||i.disk_status||, CODE, READONLY, ALIGN=1

                  disk_status PROC
;;;21     
;;;22     DSTATUS disk_status (
000000  0001              MOVS     r1,r0
;;;23     	BYTE pdrv		/* Physical drive nmuber to identify the drive */
;;;24     )
;;;25     {
;;;26     	DSTATUS stat = STA_NOINIT;
000002  f04f0001          MOV      r0,#1
000006  d003              BEQ      |L4.16|
;;;27     
;;;28     	switch (pdrv)
000008  2901              CMP      r1,#1
00000a  d001              BEQ      |L4.16|
00000c  2902              CMP      r1,#2
00000e  d100              BNE      |L4.18|
                  |L4.16|
;;;29     	{
;;;30     		case FS_SD :
;;;31     			stat = 0;
;;;32     			break;
;;;33     
;;;34     		case FS_NAND :
;;;35     			stat = 0;
;;;36     			break;
;;;37     
;;;38     		case FS_USB :
;;;39     			stat = 0;
000010  2000              MOVS     r0,#0
                  |L4.18|
;;;40     			break;
;;;41     
;;;42     		default:
;;;43     			break;
;;;44     	}
;;;45     	return stat;
;;;46     }
000012  4770              BX       lr
;;;47     
                          ENDP


                          AREA ||i.disk_write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  disk_write PROC
;;;175    #if _USE_WRITE
;;;176    DRESULT disk_write (
000000  e92d41fc          PUSH     {r2-r8,lr}
;;;177    	BYTE pdrv,			/* Physical drive nmuber to identify the drive */
;;;178    	const BYTE *buff,	/* Data to be written */
;;;179    	DWORD sector,		/* Sector address in LBA */
;;;180    	UINT count			/* Number of sectors to write */
;;;181    )
;;;182    {
000004  4616              MOV      r6,r2
000006  461d              MOV      r5,r3
000008  460f              MOV      r7,r1
;;;183    	DRESULT res = RES_OK;
00000a  2400              MOVS     r4,#0
;;;184    	SD_Error Status;
;;;185    
;;;186    	switch (pdrv)
;;;187    	{
;;;188    		case FS_SD :
;;;189    			if (count == 1)
;;;190    			{
;;;191    				Status = SD_WriteBlock((uint8_t *)buff, sector << 9 , SECTOR_SIZE);
00000c  f44f7200          MOV      r2,#0x200
000010  b128              CBZ      r0,|L5.30|
000012  2801              CMP      r0,#1                 ;186
000014  d029              BEQ      |L5.106|
;;;192    			}
;;;193    			else
;;;194    			{
;;;195    				Status = SD_WriteMultiBlocks((uint8_t *)buff, sector << 9 ,SECTOR_SIZE, count);
;;;196    			}
;;;197    
;;;198    			/* SDIO工作在DMA模式，需要检查操作DMA传输是否完成 */
;;;199    			Status = SD_WaitReadOperation();
;;;200    			if (Status != SD_OK)
;;;201    			{
;;;202    				return RES_ERROR;
;;;203    			}
;;;204    			
;;;205    			//while(SD_GetStatus() != SD_TRANSFER_OK); 如果不插卡，则此处会死机
;;;206    			{
;;;207    				uint32_t i;
;;;208    				SDTransferState status;
;;;209    				
;;;210    				for (i = 0; i < 100000; i++)
;;;211    				{									
;;;212    					status = SD_GetStatus();
;;;213    					if (status == SD_TRANSFER_ERROR)
;;;214    					{
;;;215    						res = RES_ERROR;
;;;216    						break;
;;;217    					}
;;;218    					else if (status == SD_TRANSFER_OK)
;;;219    					{
;;;220    						res = RES_OK;
;;;221    						break;
;;;222    					}
;;;223    					//  SD_TRANSFER_BUSY 则继续等待 
;;;224    				}
;;;225    			}
;;;226    			break;
;;;227    
;;;228    		case FS_NAND :
;;;229    			if (NAND_OK == NAND_WriteMultiSectors((uint8_t *)buff, sector, 512, count))
;;;230    			{
;;;231    				res = RES_OK;
;;;232    			}
;;;233    			else
;;;234    			{
;;;235    				printf("NAND_WriteMultiSectors() Error! sector = %d, count = %d \r\n", sector, count);
;;;236    				res = RES_ERROR;
;;;237    			}
;;;238    			break;
;;;239    
;;;240    		default:
;;;241    			res = RES_PARERR;
000016  2404              MOVS     r4,#4
                  |L5.24|
;;;242    			break;
;;;243    	}
;;;244    	return res;
000018  4620              MOV      r0,r4
                  |L5.26|
;;;245    }
00001a  e8bd81fc          POP      {r2-r8,pc}
                  |L5.30|
00001e  0270              LSLS     r0,r6,#9              ;191
000020  2d01              CMP      r5,#1                 ;189
000022  d00c              BEQ      |L5.62|
000024  e9cd2300          STRD     r2,r3,[sp,#0]         ;189
000028  4602              MOV      r2,r0                 ;189
00002a  2300              MOVS     r3,#0                 ;195
00002c  4608              MOV      r0,r1                 ;195
00002e  f7fffffe          BL       SD_WriteMultiBlocks
000032  bf00              NOP                            ;199
                  |L5.52|
000034  f7fffffe          BL       SD_WaitReadOperation
000038  b140              CBZ      r0,|L5.76|
00003a  2001              MOVS     r0,#1                 ;202
00003c  e7ed              B        |L5.26|
                  |L5.62|
00003e  9200              STR      r2,[sp,#0]            ;191
000040  4602              MOV      r2,r0                 ;191
000042  2300              MOVS     r3,#0                 ;191
000044  4608              MOV      r0,r1                 ;191
000046  f7fffffe          BL       SD_WriteBlock
00004a  e7f3              B        |L5.52|
                  |L5.76|
00004c  2500              MOVS     r5,#0                 ;210
00004e  4e0d              LDR      r6,|L5.132|
                  |L5.80|
000050  f7fffffe          BL       SD_GetStatus
000054  2802              CMP      r0,#2                 ;213
000056  d004              BEQ      |L5.98|
000058  b128              CBZ      r0,|L5.102|
00005a  1c6d              ADDS     r5,r5,#1              ;218
00005c  42b5              CMP      r5,r6                 ;210
00005e  d3f7              BCC      |L5.80|
000060  e7da              B        |L5.24|
                  |L5.98|
000062  2401              MOVS     r4,#1                 ;215
000064  e7d8              B        |L5.24|
                  |L5.102|
000066  2400              MOVS     r4,#0                 ;220
000068  e7d6              B        |L5.24|
                  |L5.106|
00006a  4631              MOV      r1,r6                 ;229
00006c  4638              MOV      r0,r7                 ;229
00006e  f7fffffe          BL       NAND_WriteMultiSectors
000072  2800              CMP      r0,#0                 ;229
000074  d0d0              BEQ      |L5.24|
000076  462a              MOV      r2,r5                 ;235
000078  4631              MOV      r1,r6                 ;235
00007a  a003              ADR      r0,|L5.136|
00007c  f7fffffe          BL       __2printf
000080  e7ef              B        |L5.98|
;;;246    #endif
                          ENDP

000082  0000              DCW      0x0000
                  |L5.132|
                          DCD      0x000186a0
                  |L5.136|
000088  4e414e44          DCB      "NAND_WriteMultiSectors() Error! sector = %d, count = %d"
00008c  5f577269
000090  74654d75
000094  6c746953
000098  6563746f
00009c  72732829
0000a0  20457272
0000a4  6f722120
0000a8  73656374
0000ac  6f72203d
0000b0  2025642c
0000b4  20636f75
0000b8  6e74203d
0000bc  202564  
0000bf  200d0a00          DCB      " \r\n",0
0000c3  00                DCB      0

                          AREA ||i.get_fattime||, CODE, READONLY, ALIGN=2

                  get_fattime PROC
;;;335    */
;;;336    DWORD get_fattime (void)
000000  b510              PUSH     {r4,lr}
;;;337    {
;;;338    	/* 如果有全局时钟，可按下面的格式进行时钟转换. 这个例子是2014-07-02 00:00:00 */
;;;339    #if 1
;;;340    	RTC_ReadClock();
000002  f7fffffe          BL       RTC_ReadClock
;;;341    	return  ((DWORD)(g_tRTC.Year - 1980) << 25)		/* Year  */
000006  480a              LDR      r0,|L6.48|
000008  7801              LDRB     r1,[r0,#0]  ; g_tRTC
00000a  7882              LDRB     r2,[r0,#2]  ; g_tRTC
00000c  0649              LSLS     r1,r1,#25
00000e  f1a141f0          SUB      r1,r1,#0x78000000
000012  ea415142          ORR      r1,r1,r2,LSL #21
000016  78c2              LDRB     r2,[r0,#3]  ; g_tRTC
000018  ea414102          ORR      r1,r1,r2,LSL #16
00001c  7902              LDRB     r2,[r0,#4]  ; g_tRTC
00001e  ea4121c2          ORR      r1,r1,r2,LSL #11
000022  7942              LDRB     r2,[r0,#5]  ; g_tRTC
000024  7980              LDRB     r0,[r0,#6]  ; g_tRTC
000026  ea411142          ORR      r1,r1,r2,LSL #5
00002a  ea410050          ORR      r0,r1,r0,LSR #1
;;;342    			| ((DWORD)g_tRTC.Mon << 21)				/* Month   */
;;;343    			| ((DWORD)g_tRTC.Day << 16)				/* Day_m  1*/
;;;344    			| ((DWORD)g_tRTC.Hour << 11)			/* Hour  */
;;;345    			| ((DWORD)g_tRTC.Min << 5)				/* Min  */
;;;346    			| ((DWORD)g_tRTC.Sec >> 1);				/* Sec  */
;;;347    	
;;;348    #else
;;;349    	return	  ((DWORD)(2014 - 1980) << 25)	/* Year = 2014 */
;;;350    			| ((DWORD)7 << 21)				/* Month = 7 */
;;;351    			| ((DWORD)2 << 16)				/* Day_m = 2*/
;;;352    			| ((DWORD)0 << 11)				/* Hour = 0 */
;;;353    			| ((DWORD)0 << 5)				/* Min = 0 */
;;;354    			| ((DWORD)0 >> 1);				/* Sec = 0 */
;;;355    #endif	
;;;356    }
00002e  bd10              POP      {r4,pc}
;;;357    
                          ENDP

                  |L6.48|
                          DCD      g_tRTC

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\FatFS\\src\\diskio.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___8_diskio_c_fd8865f0____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___8_diskio_c_fd8865f0____REVSH|
#line 128
|__asm___8_diskio_c_fd8865f0____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
