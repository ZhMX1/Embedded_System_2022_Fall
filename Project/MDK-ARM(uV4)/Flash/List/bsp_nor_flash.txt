; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_nor_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_nor_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_nor_flash.crf ..\..\User\bsp\src\bsp_nor_flash.c]
                          THUMB

                          AREA ||i.NOR_CheckStatus||, CODE, READONLY, ALIGN=1

                  NOR_CheckStatus PROC
;;;308    */
;;;309    uint8_t NOR_CheckStatus(void)
000000  b570              PUSH     {r4-r6,lr}
;;;310    {
;;;311    	uint16_t val1 = 0x00;
;;;312    	uint16_t val2 = 0x00;
;;;313    	uint8_t status = NOR_ONGOING;
000002  2501              MOVS     r5,#1
;;;314    	uint32_t timeout = 10;
000004  260a              MOVS     r6,#0xa
;;;315    	
;;;316    	/*
;;;317    		- DQ 6 编程时跳变
;;;318    		- DQ 6 和 DQ 2 在擦除时跳变
;;;319    		- DQ 2 在擦除挂起时跳变
;;;320    		- DQ 1 在编程错误时置1
;;;321    		- DQ 5 在超时时置1
;;;322    	*/
;;;323    	/* 通过读取DQ6, DQ5 的数据位是否存在翻转现象判断NOR 内部操作是否完成。如果正忙，则第2次读和第1次读的数据不同 */
;;;324    	while ((timeout != 0x00) && (status != NOR_SUCCESS))
;;;325    	{
;;;326    		timeout--;
;;;327    
;;;328    		/* Read DQ6 */
;;;329    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000006  f04f44c8          MOV      r4,#0x64000000
                  |L1.10|
00000a  8820              LDRH     r0,[r4,#0]
;;;330    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
00000c  8821              LDRH     r1,[r4,#0]
;;;331    
;;;332    		/* If DQ6 did not toggle between the two reads then return NOR_Success */
;;;333    		if ((val1 & 0x0040) == (val2 & 0x0040))
00000e  f0000240          AND      r2,r0,#0x40
000012  f0010140          AND      r1,r1,#0x40
000016  1e76              SUBS     r6,r6,#1
000018  428a              CMP      r2,r1
00001a  d00a              BEQ      |L1.50|
;;;334    		{
;;;335    			return NOR_SUCCESS;
;;;336    		}
;;;337    
;;;338    		/* Read DQ2 */
;;;339    		if((val1 & 0x0020) != 0x0020)
00001c  0680              LSLS     r0,r0,#26
00001e  d400              BMI      |L1.34|
;;;340    		{
;;;341    			status = NOR_ONGOING;
000020  2501              MOVS     r5,#1
                  |L1.34|
;;;342    		}
;;;343    
;;;344    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000022  8820              LDRH     r0,[r4,#0]
;;;345    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000024  8821              LDRH     r1,[r4,#0]
;;;346    
;;;347    		if((val1 & 0x0040) == (val2 & 0x0040))
000026  f0000240          AND      r2,r0,#0x40
00002a  f0010140          AND      r1,r1,#0x40
00002e  428a              CMP      r2,r1
000030  d101              BNE      |L1.54|
                  |L1.50|
;;;348    		{
;;;349    			return NOR_SUCCESS;
000032  2000              MOVS     r0,#0
;;;350    		}
;;;351    		else if ((val1 & 0x0020) == 0x0020)
;;;352    		{
;;;353    			status = NOR_ERROR;
;;;354    			NOR_QuitToReadStatus();
;;;355    		}
;;;356    	}
;;;357    
;;;358    	if (timeout == 0x00)
;;;359    	{
;;;360    		status = NOR_TIMEOUT;
;;;361    		//NOR_QuitToReadStatus();
;;;362    	}
;;;363    
;;;364    	/* 返回操作状态 */
;;;365    	return (status);
;;;366    }
000034  bd70              POP      {r4-r6,pc}
                  |L1.54|
000036  0680              LSLS     r0,r0,#26             ;351
000038  d505              BPL      |L1.70|
00003a  2502              MOVS     r5,#2                 ;353
00003c  f7fffffe          BL       NOR_QuitToReadStatus
000040  2e00              CMP      r6,#0                 ;354
000042  d1e2              BNE      |L1.10|
000044  e003              B        |L1.78|
                  |L1.70|
000046  b116              CBZ      r6,|L1.78|
000048  2d00              CMP      r5,#0                 ;324
00004a  d1de              BNE      |L1.10|
00004c  e000              B        |L1.80|
                  |L1.78|
00004e  2503              MOVS     r5,#3                 ;360
                  |L1.80|
000050  4628              MOV      r0,r5                 ;365
000052  bd70              POP      {r4-r6,pc}
;;;367    
                          ENDP


                          AREA ||i.NOR_EraseChip||, CODE, READONLY, ALIGN=2

                  NOR_EraseChip PROC
;;;268    */
;;;269    uint8_t NOR_EraseChip(void)
000000  4808              LDR      r0,|L2.36|
;;;270    {
000002  b430              PUSH     {r4,r5}
;;;271    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  21aa              MOVS     r1,#0xaa
000006  8001              STRH     r1,[r0,#0]
;;;272    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4a07              LDR      r2,|L2.40|
00000a  2355              MOVS     r3,#0x55
00000c  8013              STRH     r3,[r2,#0]
;;;273    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
00000e  2480              MOVS     r4,#0x80
000010  8004              STRH     r4,[r0,#0]
;;;274    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000012  8001              STRH     r1,[r0,#0]
;;;275    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000014  8013              STRH     r3,[r2,#0]
;;;276    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0010);
000016  2110              MOVS     r1,#0x10
000018  8001              STRH     r1,[r0,#0]
;;;277    
;;;278    	return (NOR_GetStatus(ChipErase_Timeout));
00001a  bc30              POP      {r4,r5}
00001c  f04f5040          MOV      r0,#0x30000000
000020  f7ffbffe          B.W      NOR_GetStatus
;;;279    }
;;;280    
                          ENDP

                  |L2.36|
                          DCD      0x64000aaa
                  |L2.40|
                          DCD      0x64000554

                          AREA ||i.NOR_EraseSector||, CODE, READONLY, ALIGN=2

                  NOR_EraseSector PROC
;;;375    */
;;;376    uint8_t NOR_EraseSector(uint32_t _uiBlockAddr)
000000  4909              LDR      r1,|L3.40|
;;;377    {
000002  b430              PUSH     {r4,r5}
;;;378    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  22aa              MOVS     r2,#0xaa
000006  800a              STRH     r2,[r1,#0]
;;;379    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4c08              LDR      r4,|L3.44|
00000a  2355              MOVS     r3,#0x55
00000c  8023              STRH     r3,[r4,#0]
;;;380    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
00000e  2580              MOVS     r5,#0x80
000010  800d              STRH     r5,[r1,#0]
;;;381    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000012  800a              STRH     r2,[r1,#0]
;;;382    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000014  8023              STRH     r3,[r4,#0]
;;;383    	NOR_WRITE((NOR_FLASH_ADDR + _uiBlockAddr), 0x30);
000016  f10040c8          ADD      r0,r0,#0x64000000
00001a  2130              MOVS     r1,#0x30
00001c  8001              STRH     r1,[r0,#0]
;;;384    
;;;385    	return (NOR_GetStatus(BlockErase_Timeout));
00001e  bc30              POP      {r4,r5}
000020  f44f0020          MOV      r0,#0xa00000
000024  f7ffbffe          B.W      NOR_GetStatus
;;;386    }
;;;387    
                          ENDP

                  |L3.40|
                          DCD      0x64000aaa
                  |L3.44|
                          DCD      0x64000554

                          AREA ||i.NOR_GetStatus||, CODE, READONLY, ALIGN=2

                  NOR_GetStatus PROC
;;;188    */
;;;189    static uint8_t NOR_GetStatus(uint32_t Timeout)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;190    {
000004  4604              MOV      r4,r0
;;;191    	uint16_t val1 = 0x00;
;;;192    	uint16_t val2 = 0x00;
;;;193    	uint8_t status = NOR_ONGOING;
000006  2601              MOVS     r6,#1
;;;194    	uint32_t timeout = Timeout;
000008  4605              MOV      r5,r0
;;;195    
;;;196    	/* 等待NOR输出忙信号，高电平时等待。避免NOR的忙信号还未反映过来导致CPU提前认为不忙了 */
;;;197    	while ((!NOR_IS_BUSY()) && (timeout > 0))
00000a  4f1e              LDR      r7,|L4.132|
00000c  e000              B        |L4.16|
                  |L4.14|
00000e  1e6d              SUBS     r5,r5,#1              ;190
                  |L4.16|
000010  2140              MOVS     r1,#0x40
000012  4638              MOV      r0,r7
000014  f7fffffe          BL       GPIO_ReadInputDataBit
000018  b108              CBZ      r0,|L4.30|
00001a  2d00              CMP      r5,#0
00001c  d1f7              BNE      |L4.14|
                  |L4.30|
;;;198    	{
;;;199    		timeout--;
;;;200    	}
;;;201    
;;;202    	/* 等待NOR忙信号结束，低电平时等待 */
;;;203    	timeout = Timeout;
00001e  4625              MOV      r5,r4
;;;204    	while(NOR_IS_BUSY() && (timeout > 0))
;;;205    	{
;;;206    		timeout--;
;;;207    	}
;;;208    
;;;209    	/*
;;;210    		- DQ 6 编程时跳变
;;;211    		- DQ 6 和 DQ 2 在擦除时跳变
;;;212    		- DQ 2 在擦除挂起时跳变
;;;213    		- DQ 1 在编程错误时置1
;;;214    		- DQ 5 在超时时置1
;;;215    	*/
;;;216    	/* 通过读取DQ6, DQ5 的数据位是否存在翻转现象判断NOR 内部操作是否完成。如果正忙，则第2次读和第1次读的数据不同 */
;;;217    	while ((Timeout != 0x00) && (status != NOR_SUCCESS))
;;;218    	{
;;;219    		Timeout--;
;;;220    
;;;221    		/* Read DQ6 */
;;;222    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000020  f04f48c8          MOV      r8,#0x64000000
000024  e000              B        |L4.40|
                  |L4.38|
000026  1e6d              SUBS     r5,r5,#1              ;204
                  |L4.40|
000028  2140              MOVS     r1,#0x40              ;204
00002a  4638              MOV      r0,r7                 ;204
00002c  f7fffffe          BL       GPIO_ReadInputDataBit
000030  b908              CBNZ     r0,|L4.54|
000032  2d00              CMP      r5,#0                 ;204
000034  d1f7              BNE      |L4.38|
                  |L4.54|
000036  4645              MOV      r5,r8
                  |L4.56|
000038  b1f4              CBZ      r4,|L4.120|
00003a  b306              CBZ      r6,|L4.126|
                  |L4.60|
00003c  8828              LDRH     r0,[r5,#0]
;;;223    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
00003e  8829              LDRH     r1,[r5,#0]
;;;224    
;;;225    		/* If DQ6 did not toggle between the two reads then return NOR_Success */
;;;226    		if ((val1 & 0x0040) == (val2 & 0x0040))
000040  f0000240          AND      r2,r0,#0x40
000044  f0010140          AND      r1,r1,#0x40
000048  1e64              SUBS     r4,r4,#1
00004a  428a              CMP      r2,r1
00004c  d00a              BEQ      |L4.100|
;;;227    		{
;;;228    			return NOR_SUCCESS;
;;;229    		}
;;;230    
;;;231    		/* Read DQ2 */
;;;232    		if((val1 & 0x0020) != 0x0020)
00004e  0680              LSLS     r0,r0,#26
000050  d400              BMI      |L4.84|
;;;233    		{
;;;234    			status = NOR_ONGOING;
000052  2601              MOVS     r6,#1
                  |L4.84|
;;;235    		}
;;;236    
;;;237    		val1 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000054  8828              LDRH     r0,[r5,#0]
;;;238    		val2 = *(__IO uint16_t *)(NOR_FLASH_ADDR);
000056  8829              LDRH     r1,[r5,#0]
;;;239    
;;;240    		if((val1 & 0x0040) == (val2 & 0x0040))
000058  f0000240          AND      r2,r0,#0x40
00005c  f0010140          AND      r1,r1,#0x40
000060  428a              CMP      r2,r1
000062  d102              BNE      |L4.106|
                  |L4.100|
;;;241    		{
;;;242    			return NOR_SUCCESS;
000064  2000              MOVS     r0,#0
                  |L4.102|
;;;243    		}
;;;244    		else if ((val1 & 0x0020) == 0x0020)
;;;245    		{
;;;246    			status = NOR_ERROR;
;;;247    			NOR_QuitToReadStatus();
;;;248    		}
;;;249    	}
;;;250    
;;;251    	if (Timeout == 0x00)
;;;252    	{
;;;253    		status = NOR_TIMEOUT;
;;;254    		NOR_QuitToReadStatus();
;;;255    	}
;;;256    
;;;257    	/* 返回操作状态 */
;;;258    	return (status);
;;;259    }
000066  e8bd81f0          POP      {r4-r8,pc}
                  |L4.106|
00006a  0680              LSLS     r0,r0,#26             ;244
00006c  d5e4              BPL      |L4.56|
00006e  2602              MOVS     r6,#2                 ;246
000070  f7fffffe          BL       NOR_QuitToReadStatus
000074  2c00              CMP      r4,#0                 ;247
000076  d1e1              BNE      |L4.60|
                  |L4.120|
000078  2603              MOVS     r6,#3                 ;253
00007a  f7fffffe          BL       NOR_QuitToReadStatus
                  |L4.126|
00007e  4630              MOV      r0,r6                 ;258
000080  e7f1              B        |L4.102|
;;;260    
                          ENDP

000082  0000              DCW      0x0000
                  |L4.132|
                          DCD      0x40011400

                          AREA ||i.NOR_QuitToReadStatus||, CODE, READONLY, ALIGN=2

                  NOR_QuitToReadStatus PROC
;;;173    */
;;;174    static void NOR_QuitToReadStatus(void)
000000  4905              LDR      r1,|L5.24|
;;;175    {
;;;176    	NOR_WRITE(ADDR_SHIFT(0x00555), 0x00AA);
000002  20aa              MOVS     r0,#0xaa
000004  8008              STRH     r0,[r1,#0]
;;;177    	NOR_WRITE(ADDR_SHIFT(0x002AA), 0x0055);
000006  4905              LDR      r1,|L5.28|
000008  2055              MOVS     r0,#0x55
00000a  8008              STRH     r0,[r1,#0]
;;;178    	NOR_WRITE(NOR_FLASH_ADDR, 0x00F0 );
00000c  f04f41c8          MOV      r1,#0x64000000
000010  20f0              MOVS     r0,#0xf0
000012  8008              STRH     r0,[r1,#0]
;;;179    }
000014  4770              BX       lr
;;;180    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      0x64000aaa
                  |L5.28|
                          DCD      0x64000554

                          AREA ||i.NOR_ReadBuffer||, CODE, READONLY, ALIGN=2

                  NOR_ReadBuffer PROC
;;;421    */
;;;422    void NOR_ReadBuffer(uint8_t *_pBuf, uint32_t _uiWriteAddr, uint32_t _uiBytes)
000000  b530              PUSH     {r4,r5,lr}
;;;423    {
;;;424    	uint16_t usHalfWord;
;;;425    	uint16_t *pNor16;
;;;426    	uint32_t i;
;;;427    	uint32_t uiNum;
;;;428    
;;;429    	uiNum = _uiBytes;
000002  4613              MOV      r3,r2
;;;430    	/* 处理首字节 */
;;;431    	if (_uiWriteAddr % 2)	/* 奇数地址 */
000004  07cc              LSLS     r4,r1,#31
000006  d008              BEQ      |L6.26|
;;;432    	{
;;;433    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
000008  4c0f              LDR      r4,|L6.72|
;;;434    		*_pBuf++ = (usHalfWord >> 8);	/* 取高8Bit */
;;;435    		uiNum--;
00000a  1e53              SUBS     r3,r2,#1
00000c  440c              ADD      r4,r4,r1              ;433
00000e  f8b44fff          LDRH     r4,[r4,#0xfff]        ;433
000012  0a24              LSRS     r4,r4,#8              ;434
000014  f8004b01          STRB     r4,[r0],#1            ;434
000018  1c49              ADDS     r1,r1,#1
                  |L6.26|
;;;436    		_uiWriteAddr++;		/* 变为偶数 */
;;;437    	}
;;;438    
;;;439    	/* 按照双字节模式连续读取NOR数据至缓冲区_pBuf */
;;;440    	pNor16 = (uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
;;;441    	// for (i = 0; i < uiNum / 2; i++)
;;;442    	for (i = 0; i < _uiBytes / 2; i++)
00001a  2400              MOVS     r4,#0
00001c  f10141c8          ADD      r1,r1,#0x64000000
000020  e009              B        |L6.54|
;;;443    	{
;;;444    		usHalfWord = *pNor16++;
000022  bf00              NOP      
                  |L6.36|
000024  f8315b02          LDRH     r5,[r1],#2
;;;445    		*_pBuf++ = usHalfWord;
000028  f8005b01          STRB     r5,[r0],#1
;;;446    		*_pBuf++ = usHalfWord >> 8;
00002c  0a2d              LSRS     r5,r5,#8
00002e  1e9b              SUBS     r3,r3,#2
000030  f8005b01          STRB     r5,[r0],#1
000034  1c64              ADDS     r4,r4,#1
                  |L6.54|
000036  ebb40f52          CMP      r4,r2,LSR #1          ;442
00003a  d3f3              BCC      |L6.36|
;;;447    		uiNum -= 2;
;;;448    	}
;;;449    
;;;450    	/* 处理最后1个字节 */
;;;451    	if (uiNum == 1)
00003c  2b01              CMP      r3,#1
00003e  d101              BNE      |L6.68|
;;;452    	{
;;;453    		*_pBuf++ = *pNor16;
000040  7809              LDRB     r1,[r1,#0]
000042  7001              STRB     r1,[r0,#0]
                  |L6.68|
;;;454    	}
;;;455    }
000044  bd30              POP      {r4,r5,pc}
;;;456    
                          ENDP

000046  0000              DCW      0x0000
                  |L6.72|
                          DCD      0x63fff000

                          AREA ||i.NOR_ReadByte||, CODE, READONLY, ALIGN=2

                  NOR_ReadByte PROC
;;;395    */
;;;396    uint8_t NOR_ReadByte(uint32_t _uiWriteAddr)
000000  07c1              LSLS     r1,r0,#31
;;;397    {
000002  d005              BEQ      |L7.16|
;;;398    	uint16_t usHalfWord;
;;;399    
;;;400    	if (_uiWriteAddr % 2)	/* 奇数地址 */
;;;401    	{
;;;402    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
000004  4904              LDR      r1,|L7.24|
000006  4408              ADD      r0,r0,r1
000008  f8b00fff          LDRH     r0,[r0,#0xfff]
;;;403    		return (usHalfWord >> 8);	/* 取高8Bit */
00000c  0a00              LSRS     r0,r0,#8
;;;404    	}
;;;405    	else	/* 偶数地址 */
;;;406    	{
;;;407    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
;;;408    		return usHalfWord;	/* 取低8Bit */
;;;409    	}
;;;410    }
00000e  4770              BX       lr
                  |L7.16|
000010  f10040c8          ADD      r0,r0,#0x64000000
000014  7800              LDRB     r0,[r0,#0]            ;407
000016  4770              BX       lr
;;;411    
                          ENDP

                  |L7.24|
                          DCD      0x63fff000

                          AREA ||i.NOR_ReadID||, CODE, READONLY, ALIGN=2

                  NOR_ReadID PROC
;;;144    */
;;;145    uint32_t NOR_ReadID(void)
000000  480d              LDR      r0,|L8.56|
;;;146    {
000002  b510              PUSH     {r4,lr}
;;;147    	uint32_t uiID;
;;;148    	uint8_t id1, id2, id3, id4;
;;;149    
;;;150    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  21aa              MOVS     r1,#0xaa
000006  8001              STRH     r1,[r0,#0]
;;;151    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4a0c              LDR      r2,|L8.60|
00000a  2155              MOVS     r1,#0x55
00000c  8011              STRH     r1,[r2,#0]
;;;152    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0090);
00000e  2190              MOVS     r1,#0x90
000010  8001              STRH     r1,[r0,#0]
;;;153    
;;;154    	id1 = *(__IO uint16_t *) ADDR_SHIFT(0x0000);
000012  f04f41c8          MOV      r1,#0x64000000
000016  8808              LDRH     r0,[r1,#0]
;;;155    	id2 = *(__IO uint16_t *) ADDR_SHIFT(0x0001);
000018  884a              LDRH     r2,[r1,#2]
00001a  b2d3              UXTB     r3,r2
;;;156    	id3 = *(__IO uint16_t *) ADDR_SHIFT(0x000E);
00001c  8b8a              LDRH     r2,[r1,#0x1c]
;;;157    	id4 = *(__IO uint16_t *) ADDR_SHIFT(0x000F);
00001e  8bcc              LDRH     r4,[r1,#0x1e]
000020  b2d2              UXTB     r2,r2                 ;156
;;;158    
;;;159    	uiID = ((uint32_t)id1 << 24) | ((uint32_t)id2 << 16)  | ((uint32_t)id3 << 8) | id4;
000022  0600              LSLS     r0,r0,#24
000024  ea404003          ORR      r0,r0,r3,LSL #16
000028  b2e4              UXTB     r4,r4                 ;157
00002a  ea402002          ORR      r0,r0,r2,LSL #8
00002e  4320              ORRS     r0,r0,r4
;;;160    
;;;161    	NOR_WRITE(NOR_FLASH_ADDR, 0x00F0 );		/* 退出ID模式 */
000030  22f0              MOVS     r2,#0xf0
000032  800a              STRH     r2,[r1,#0]
;;;162    
;;;163    	return uiID;
;;;164    }
000034  bd10              POP      {r4,pc}
;;;165    
                          ENDP

000036  0000              DCW      0x0000
                  |L8.56|
                          DCD      0x64000aaa
                  |L8.60|
                          DCD      0x64000554

                          AREA ||i.NOR_StartEraseChip||, CODE, READONLY, ALIGN=2

                  NOR_StartEraseChip PROC
;;;288    */
;;;289    void NOR_StartEraseChip(void)
000000  4808              LDR      r0,|L9.36|
;;;290    {
000002  b430              PUSH     {r4,r5}
;;;291    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  21aa              MOVS     r1,#0xaa
000006  8001              STRH     r1,[r0,#0]
;;;292    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4a07              LDR      r2,|L9.40|
00000a  2355              MOVS     r3,#0x55
00000c  8013              STRH     r3,[r2,#0]
;;;293    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0080);
00000e  2480              MOVS     r4,#0x80
000010  8004              STRH     r4,[r0,#0]
;;;294    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000012  8001              STRH     r1,[r0,#0]
;;;295    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000014  8013              STRH     r3,[r2,#0]
;;;296    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x0010);
000016  2110              MOVS     r1,#0x10
000018  8001              STRH     r1,[r0,#0]
;;;297    	
;;;298    	NOR_GetStatus(1000);
00001a  bc30              POP      {r4,r5}
00001c  f44f707a          MOV      r0,#0x3e8
000020  f7ffbffe          B.W      NOR_GetStatus
;;;299    }
;;;300    
                          ENDP

                  |L9.36|
                          DCD      0x64000aaa
                  |L9.40|
                          DCD      0x64000554

                          AREA ||i.NOR_WriteBuffer||, CODE, READONLY, ALIGN=2

                  NOR_WriteBuffer PROC
;;;581    */
;;;582    uint8_t NOR_WriteBuffer(uint8_t *_pBuf, uint32_t _uiWriteAddr, uint32_t _uiBytes)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;583    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;584    	uint16_t usHalfWord;
;;;585    	uint32_t i;
;;;586    	uint32_t uiNum;
;;;587    	uint8_t ucStatus;
;;;588    
;;;589    	uiNum = _uiBytes;
000008  4616              MOV      r6,r2
;;;590    	/* 处理首字节 */
;;;591    	if (_uiWriteAddr % 2)	/* 奇数地址 */
00000a  07c8              LSLS     r0,r1,#31
00000c  d00e              BEQ      |L10.44|
;;;592    	{
;;;593    		/* 读出2字节数据，然后改写高字节，维持以前的低字节数据不变 */
;;;594    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
00000e  4819              LDR      r0,|L10.116|
;;;595    		usHalfWord &= 0x00FF;
;;;596    		usHalfWord |= ((*_pBuf++) << 8);
000010  f8141b01          LDRB     r1,[r4],#1
000014  4428              ADD      r0,r0,r5              ;594
000016  f8900fff          LDRB     r0,[r0,#0xfff]        ;594
00001a  ea402101          ORR      r1,r0,r1,LSL #8
;;;597    
;;;598    		ucStatus = NOR_WriteHalfWord(_uiWriteAddr - 1, usHalfWord);
00001e  1e68              SUBS     r0,r5,#1
000020  f7fffffe          BL       NOR_WriteHalfWord
;;;599    		if (ucStatus != NOR_SUCCESS)
000024  2800              CMP      r0,#0
000026  d122              BNE      |L10.110|
000028  1c6d              ADDS     r5,r5,#1
00002a  1e76              SUBS     r6,r6,#1
                  |L10.44|
;;;600    		{
;;;601    			goto err_quit;
;;;602    		}
;;;603    
;;;604    		uiNum--;
;;;605    		_uiWriteAddr++;		/* 变为偶数 */
;;;606    	}
;;;607    
;;;608    	/* 按照双字节模式连续编程NOR数据 */
;;;609    	for (i = 0; i < uiNum / 2; i++)
00002c  2700              MOVS     r7,#0
00002e  e00c              B        |L10.74|
                  |L10.48|
;;;610    	{
;;;611    		usHalfWord = *_pBuf++;
000030  f8140b01          LDRB     r0,[r4],#1
;;;612    		usHalfWord |= ((*_pBuf++) << 8);
000034  f8141b01          LDRB     r1,[r4],#1
000038  ea402101          ORR      r1,r0,r1,LSL #8
;;;613    
;;;614    		ucStatus = NOR_WriteHalfWord(_uiWriteAddr, usHalfWord);
00003c  4628              MOV      r0,r5
00003e  f7fffffe          BL       NOR_WriteHalfWord
;;;615    		if (ucStatus != NOR_SUCCESS)
000042  2800              CMP      r0,#0
000044  d113              BNE      |L10.110|
000046  1cad              ADDS     r5,r5,#2
000048  1c7f              ADDS     r7,r7,#1
                  |L10.74|
00004a  ebb70f56          CMP      r7,r6,LSR #1          ;609
00004e  d3ef              BCC      |L10.48|
;;;616    		{
;;;617    			goto err_quit;
;;;618    		}
;;;619    
;;;620    		_uiWriteAddr += 2;
;;;621    	}
;;;622    
;;;623    	/* 处理最后1个字节 */
;;;624    	if (uiNum % 2)
000050  07f0              LSLS     r0,r6,#31
000052  d00b              BEQ      |L10.108|
;;;625    	{
;;;626    		/* 读取NOR原始数据，保留高字节 */
;;;627    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
000054  f04f40c8          MOV      r0,#0x64000000
;;;628    		usHalfWord &= 0xFF00;
;;;629    		usHalfWord |= (*_pBuf++);
000058  7821              LDRB     r1,[r4,#0]
00005a  5b40              LDRH     r0,[r0,r5]            ;627
00005c  f400407f          AND      r0,r0,#0xff00         ;628
000060  4301              ORRS     r1,r1,r0
;;;630    
;;;631    		ucStatus = NOR_WriteHalfWord(_uiWriteAddr, usHalfWord);
000062  4628              MOV      r0,r5
000064  f7fffffe          BL       NOR_WriteHalfWord
;;;632    		if (ucStatus != NOR_SUCCESS)
000068  2800              CMP      r0,#0
00006a  d100              BNE      |L10.110|
                  |L10.108|
;;;633    		{
;;;634    			goto err_quit;
;;;635    		}
;;;636    	}
;;;637    	ucStatus = NOR_SUCCESS;
00006c  2000              MOVS     r0,#0
                  |L10.110|
;;;638    err_quit:
;;;639    	return 	ucStatus;
;;;640    }
00006e  e8bd81f0          POP      {r4-r8,pc}
;;;641    
                          ENDP

000072  0000              DCW      0x0000
                  |L10.116|
                          DCD      0x63fff000

                          AREA ||i.NOR_WriteByte||, CODE, READONLY, ALIGN=2

                  NOR_WriteByte PROC
;;;487    */
;;;488    uint8_t NOR_WriteByte(uint32_t _uiWriteAddr, uint8_t _ucByte)
000000  07c2              LSLS     r2,r0,#31
;;;489    {
000002  d006              BEQ      |L11.18|
;;;490    	uint16_t usHalfWord;
;;;491    
;;;492    	if (_uiWriteAddr % 2)	/* 奇数地址 */
;;;493    	{
;;;494    		/* 读出2字节数据，然后改写高字节，维持以前的低字节数据不变 */
;;;495    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr - 1);
000004  4a07              LDR      r2,|L11.36|
000006  4402              ADD      r2,r2,r0
000008  f8922fff          LDRB     r2,[r2,#0xfff]
;;;496    		usHalfWord &= 0x00FF;
;;;497    		usHalfWord |= (_ucByte << 8);
00000c  ea422101          ORR      r1,r2,r1,LSL #8
000010  e005              B        |L11.30|
                  |L11.18|
;;;498    	}
;;;499    	else
;;;500    	{
;;;501    		/* 读取NOR原始数据，保留高字节 */
;;;502    		usHalfWord = *(uint16_t *)(NOR_FLASH_ADDR + _uiWriteAddr);
000012  f04f42c8          MOV      r2,#0x64000000
000016  5a12              LDRH     r2,[r2,r0]
;;;503    		usHalfWord &= 0xFF00;
000018  f402427f          AND      r2,r2,#0xff00
;;;504    		usHalfWord |= _ucByte;
00001c  4311              ORRS     r1,r1,r2
                  |L11.30|
;;;505    	}
;;;506    	return NOR_WriteHalfWord(_uiWriteAddr, usHalfWord);
00001e  f7ffbffe          B.W      NOR_WriteHalfWord
;;;507    }
;;;508    
                          ENDP

000022  0000              DCW      0x0000
                  |L11.36|
                          DCD      0x63fff000

                          AREA ||i.NOR_WriteHalfWord||, CODE, READONLY, ALIGN=2

                  NOR_WriteHalfWord PROC
;;;467    */
;;;468    uint8_t NOR_WriteHalfWord(uint32_t _uiWriteAddr, uint16_t _usData)
000000  4a07              LDR      r2,|L12.32|
;;;469    {
000002  b430              PUSH     {r4,r5}
;;;470    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00AA);
000004  23aa              MOVS     r3,#0xaa
000006  8013              STRH     r3,[r2,#0]
;;;471    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
000008  4c06              LDR      r4,|L12.36|
00000a  2355              MOVS     r3,#0x55
00000c  8023              STRH     r3,[r4,#0]
;;;472    	NOR_WRITE(ADDR_SHIFT(0x0555), 0x00A0);
00000e  23a0              MOVS     r3,#0xa0
000010  8013              STRH     r3,[r2,#0]
000012  f10040c8          ADD      r0,r0,#0x64000000
;;;473    	NOR_WRITE(NOR_FLASH_ADDR + _uiWriteAddr, _usData);
000016  8001              STRH     r1,[r0,#0]
;;;474    
;;;475    	return (NOR_GetStatus(Program_Timeout));
000018  bc30              POP      {r4,r5}
00001a  0158              LSLS     r0,r3,#5
00001c  f7ffbffe          B.W      NOR_GetStatus
;;;476    }
;;;477    
                          ENDP

                  |L12.32|
                          DCD      0x64000aaa
                  |L12.36|
                          DCD      0x64000554

                          AREA ||i.NOR_WriteInPage||, CODE, READONLY, ALIGN=2

                  NOR_WriteInPage PROC
;;;519    */
;;;520    uint8_t NOR_WriteInPage(uint16_t *pBuffer, uint32_t _uiWriteAddr,  uint16_t _usNumHalfword)
000000  b4f0              PUSH     {r4-r7}
;;;521    {
;;;522    	uint32_t lastloadedaddress;
;;;523    	uint32_t currentaddress;
;;;524    	uint32_t endaddress;
;;;525    
;;;526    	/* pdf 表7.7 写入缓冲器编程
;;;527    
;;;528    		写入缓冲器编程允许系统在一个编程操作中写入最多32 个字。与标准的“ 字” 编程算法相比，这可以有效地
;;;529    		加快字编程速度。
;;;530    	*/
;;;531    	
;;;532    	if (_usNumHalfword > 32)
000002  2a20              CMP      r2,#0x20
000004  d801              BHI      |L13.10|
;;;533    	{
;;;534    		return NOR_ERROR;
;;;535    	}
;;;536    	
;;;537    	if ((_uiWriteAddr % 2) != 0)
000006  07cb              LSLS     r3,r1,#31
000008  d002              BEQ      |L13.16|
                  |L13.10|
;;;538    	{
;;;539    		return NOR_ERROR;
;;;540    	}
;;;541    	
;;;542    	_uiWriteAddr = _uiWriteAddr / 2;
;;;543    
;;;544    	currentaddress = _uiWriteAddr;
;;;545    	endaddress = _uiWriteAddr + _usNumHalfword - 1;
;;;546    	lastloadedaddress = _uiWriteAddr;
;;;547    
;;;548    	/* 解锁命令序列 */
;;;549    	NOR_WRITE(ADDR_SHIFT(0x00555), 0x00AA);
;;;550    	NOR_WRITE(ADDR_SHIFT(0x02AA), 0x0055);
;;;551    
;;;552    	/* Write Write Buffer Load Command */
;;;553    	NOR_WRITE(ADDR_SHIFT(_uiWriteAddr), 0x0025);
;;;554    	NOR_WRITE(ADDR_SHIFT(_uiWriteAddr), (_usNumHalfword - 1));
;;;555    
;;;556    	/*  Load Data into NOR Buffer */
;;;557    	while (currentaddress <= endaddress)
;;;558    	{
;;;559    		/* Store last loaded address & data value (for polling) */
;;;560    		lastloadedaddress = currentaddress;
;;;561    
;;;562    		NOR_WRITE(ADDR_SHIFT(currentaddress), *pBuffer++);
;;;563    		currentaddress += 1;
;;;564    	}
;;;565    
;;;566    	NOR_WRITE(ADDR_SHIFT(lastloadedaddress), 0x29);
;;;567    
;;;568    	return (NOR_GetStatus(Program_Timeout));
;;;569    }
00000a  bcf0              POP      {r4-r7}
00000c  2002              MOVS     r0,#2                 ;539
00000e  4770              BX       lr
                  |L13.16|
000010  0849              LSRS     r1,r1,#1              ;542
000012  4e12              LDR      r6,|L13.92|
000014  188c              ADDS     r4,r1,r2              ;545
000016  25aa              MOVS     r5,#0xaa              ;549
000018  460b              MOV      r3,r1                 ;546
00001a  8035              STRH     r5,[r6,#0]            ;549
00001c  4e10              LDR      r6,|L13.96|
00001e  2555              MOVS     r5,#0x55              ;550
000020  8035              STRH     r5,[r6,#0]            ;550
000022  2625              MOVS     r6,#0x25              ;553
000024  004d              LSLS     r5,r1,#1              ;553
000026  f10545c8          ADD      r5,r5,#0x64000000     ;553
00002a  802e              STRH     r6,[r5,#0]            ;553
00002c  1e52              SUBS     r2,r2,#1              ;553
00002e  802a              STRH     r2,[r5,#0]            ;554
000030  1e64              SUBS     r4,r4,#1              ;554
000032  e007              B        |L13.68|
                  |L13.52|
000034  004a              LSLS     r2,r1,#1              ;562
000036  f10242c8          ADD      r2,r2,#0x64000000     ;562
00003a  f8305b02          LDRH     r5,[r0],#2            ;562
00003e  460b              MOV      r3,r1                 ;560
000040  8015              STRH     r5,[r2,#0]            ;562
000042  1c49              ADDS     r1,r1,#1              ;563
                  |L13.68|
000044  42a1              CMP      r1,r4                 ;557
000046  d9f5              BLS      |L13.52|
000048  2129              MOVS     r1,#0x29              ;566
00004a  0058              LSLS     r0,r3,#1              ;566
00004c  f10040c8          ADD      r0,r0,#0x64000000     ;566
000050  8001              STRH     r1,[r0,#0]            ;566
000052  bcf0              POP      {r4-r7}               ;568
000054  f44f50a0          MOV      r0,#0x1400            ;568
000058  f7ffbffe          B.W      NOR_GetStatus
;;;570    
                          ENDP

                  |L13.92|
                          DCD      0x64000aaa
                  |L13.96|
                          DCD      0x64000554

                          AREA ||i.bsp_InitNorFlash||, CODE, READONLY, ALIGN=2

                  bsp_InitNorFlash PROC
;;;50     */
;;;51     void bsp_InitNorFlash(void)
000000  b570              PUSH     {r4-r6,lr}
;;;52     {
;;;53     	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;54     	FSMC_NORSRAMTimingInitTypeDef  p;
;;;55     	GPIO_InitTypeDef GPIO_InitStructure;
;;;56     
;;;57     	//新加上的///////////////////////////////////////////////////////////////
;;;58     	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  b098              SUB      sp,sp,#0x60           ;52
000006  0208              LSLS     r0,r1,#8
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;59     	
;;;60     	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | 
00000c  2101              MOVS     r1,#1
00000e  f44f70f0          MOV      r0,#0x1e0
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;61     						 RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG, ENABLE);
;;;62     
;;;63     	/*-- GPIO Configuration ------------------------------------------------------*/
;;;64     	/* NOR Data lines configuration */
;;;65     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_8 | GPIO_Pin_9 |
000016  f24c7003          MOV      r0,#0xc703
00001a  f8ad0058          STRH     r0,[sp,#0x58]
;;;66     								GPIO_Pin_10 | GPIO_Pin_14 | GPIO_Pin_15;
;;;67     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00001e  2018              MOVS     r0,#0x18
000020  f88d005b          STRB     r0,[sp,#0x5b]
;;;68     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000024  2003              MOVS     r0,#3
;;;69     	GPIO_Init(GPIOD, &GPIO_InitStructure);
000026  4c33              LDR      r4,|L14.244|
000028  f88d005a          STRB     r0,[sp,#0x5a]         ;68
00002c  a916              ADD      r1,sp,#0x58
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       GPIO_Init
;;;70     
;;;71     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
000034  f64f70e0          MOV      r0,#0xffe0
;;;72     								GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 |
;;;73     								GPIO_Pin_14 | GPIO_Pin_15;
;;;74     	GPIO_Init(GPIOE, &GPIO_InitStructure);
000038  4d2f              LDR      r5,|L14.248|
00003a  f8ad0058          STRH     r0,[sp,#0x58]         ;71
00003e  a916              ADD      r1,sp,#0x58
000040  4628              MOV      r0,r5
000042  f7fffffe          BL       GPIO_Init
;;;75     
;;;76     	/* NOR Address lines configuration */
;;;77     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 | GPIO_Pin_3 |
000046  f24f003f          MOV      r0,#0xf03f
00004a  f8ad0058          STRH     r0,[sp,#0x58]
;;;78     								GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_12 | GPIO_Pin_13 |
;;;79     								GPIO_Pin_14 | GPIO_Pin_15;
;;;80     	GPIO_Init(GPIOF, &GPIO_InitStructure);
00004e  a916              ADD      r1,sp,#0x58
000050  482a              LDR      r0,|L14.252|
000052  f7fffffe          BL       GPIO_Init
;;;81     
;;;82     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_2 |
000056  203f              MOVS     r0,#0x3f
;;;83     								GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5;                            
;;;84     	GPIO_Init(GPIOG, &GPIO_InitStructure);
000058  4e29              LDR      r6,|L14.256|
00005a  f8ad0058          STRH     r0,[sp,#0x58]         ;82
00005e  a916              ADD      r1,sp,#0x58
000060  4630              MOV      r0,r6
000062  f7fffffe          BL       GPIO_Init
;;;85     
;;;86     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13;
000066  f44f5060          MOV      r0,#0x3800
00006a  f8ad0058          STRH     r0,[sp,#0x58]
;;;87     	GPIO_Init(GPIOD, &GPIO_InitStructure);
00006e  a916              ADD      r1,sp,#0x58
000070  4620              MOV      r0,r4
000072  f7fffffe          BL       GPIO_Init
;;;88     
;;;89     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_3 | GPIO_Pin_4 | GPIO_Pin_5 | GPIO_Pin_6;
000076  2078              MOVS     r0,#0x78
000078  f8ad0058          STRH     r0,[sp,#0x58]
;;;90     	GPIO_Init(GPIOE, &GPIO_InitStructure);
00007c  a916              ADD      r1,sp,#0x58
00007e  4628              MOV      r0,r5
000080  f7fffffe          BL       GPIO_Init
;;;91     
;;;92     	/* NOE and NWE configuration */
;;;93     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_4 | GPIO_Pin_5;
000084  2030              MOVS     r0,#0x30
000086  f8ad0058          STRH     r0,[sp,#0x58]
;;;94     	GPIO_Init(GPIOD, &GPIO_InitStructure);
00008a  a916              ADD      r1,sp,#0x58
00008c  4620              MOV      r0,r4
00008e  f7fffffe          BL       GPIO_Init
;;;95     
;;;96     	/* NE2 configuration */
;;;97     	/* armfly : STM32F103ZE-EK 必须使能NE3,NE4, 否访问NOR 4M空间以上会出现异常 */
;;;98     	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_12;
000092  f44f50b0          MOV      r0,#0x1600
000096  f8ad0058          STRH     r0,[sp,#0x58]
;;;99     	GPIO_Init(GPIOG, &GPIO_InitStructure);
00009a  a916              ADD      r1,sp,#0x58
00009c  4630              MOV      r0,r6
00009e  f7fffffe          BL       GPIO_Init
;;;100    
;;;101    	/*-- FSMC Configuration ----------------------------------------------------*/
;;;102    	p.FSMC_AddressSetupTime = 0x05;
0000a2  2005              MOVS     r0,#5
;;;103    	//p.FSMC_AddressSetupTime = 0x07;
;;;104    	p.FSMC_AddressHoldTime = 0x00;
0000a4  900f              STR      r0,[sp,#0x3c]
0000a6  2000              MOVS     r0,#0
;;;105    	p.FSMC_DataSetupTime = 0x07;
0000a8  2107              MOVS     r1,#7
0000aa  e9cd0110          STRD     r0,r1,[sp,#0x40]
;;;106    	//p.FSMC_DataSetupTime = 0x09;
;;;107    	p.FSMC_BusTurnAroundDuration = 0x00;
;;;108    	p.FSMC_CLKDivision = 0x00;
;;;109    	p.FSMC_DataLatency = 0x00;
;;;110    	p.FSMC_AccessMode = FSMC_AccessMode_B;
0000ae  f04f5180          MOV      r1,#0x10000000
0000b2  e9cd0114          STRD     r0,r1,[sp,#0x50]
;;;111    
;;;112    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM2;
0000b6  2102              MOVS     r1,#2
0000b8  e9cd1000          STRD     r1,r0,[sp,#0]
;;;113    	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;114    	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_NOR;
0000bc  2108              MOVS     r1,#8
;;;115    	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
0000be  9102              STR      r1,[sp,#8]
0000c0  9012              STR      r0,[sp,#0x48]         ;108
0000c2  9013              STR      r0,[sp,#0x4c]         ;110
0000c4  2110              MOVS     r1,#0x10
0000c6  e9cd1003          STRD     r1,r0,[sp,#0xc]
;;;116    	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;117    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
;;;118    	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
0000ca  9006              STR      r0,[sp,#0x18]
;;;119    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;120    	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
0000cc  0209              LSLS     r1,r1,#8
0000ce  9007              STR      r0,[sp,#0x1c]
;;;121    	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;122    	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
0000d0  900a              STR      r0,[sp,#0x28]
0000d2  e9cd0108          STRD     r0,r1,[sp,#0x20]      ;120
;;;123    	//新加上的一个参数配置///////////////////////////////////////////////////////////////////
;;;124    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;  
0000d6  900b              STR      r0,[sp,#0x2c]
;;;125    	
;;;126    //	FSMC_NORSRAMInitStructure.FSMC_AsyncWait = FSMC_AsyncWait_Disable;
;;;127    	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
0000d8  9005              STR      r0,[sp,#0x14]
;;;128    	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
0000da  900c              STR      r0,[sp,#0x30]
0000dc  a80f              ADD      r0,sp,#0x3c
;;;129    	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
0000de  900d              STR      r0,[sp,#0x34]
;;;130    
;;;131    	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
0000e0  900e              STR      r0,[sp,#0x38]
0000e2  4668              MOV      r0,sp
0000e4  f7fffffe          BL       FSMC_NORSRAMInit
;;;132    
;;;133    	/* Enable FSMC Bank1_NOR Bank */
;;;134    	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM2, ENABLE);
0000e8  2101              MOVS     r1,#1
0000ea  2002              MOVS     r0,#2
0000ec  f7fffffe          BL       FSMC_NORSRAMCmd
;;;135    }
0000f0  b018              ADD      sp,sp,#0x60
0000f2  bd70              POP      {r4-r6,pc}
;;;136    
                          ENDP

                  |L14.244|
                          DCD      0x40011400
                  |L14.248|
                          DCD      0x40011800
                  |L14.252|
                          DCD      0x40011c00
                  |L14.256|
                          DCD      0x40012000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_nor_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_nor_flash_c_0115485a____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_bsp_nor_flash_c_0115485a____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_bsp_nor_flash_c_0115485a____REVSH|
#line 128
|__asm___15_bsp_nor_flash_c_0115485a____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
