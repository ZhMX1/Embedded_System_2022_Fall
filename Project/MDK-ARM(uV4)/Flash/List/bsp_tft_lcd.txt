; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_tft_lcd.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_tft_lcd.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_tft_lcd.crf ..\..\User\bsp\src\bsp_tft_lcd.c]
                          THUMB

                          AREA ||i.LCD_Blend565||, CODE, READONLY, ALIGN=2

                  LCD_Blend565 PROC
;;;1173   */
;;;1174   uint16_t LCD_Blend565(uint16_t src, uint16_t dst, uint8_t alpha)
000000  4b07              LDR      r3,|L1.32|
;;;1175   {
;;;1176   	uint32_t src2;
;;;1177   	uint32_t dst2;
;;;1178   
;;;1179   	src2 = ((src << 16) |src) & 0x07E0F81F;
000002  ea404000          ORR      r0,r0,r0,LSL #16
;;;1180   	dst2 = ((dst << 16) | dst) & 0x07E0F81F;
000006  ea414101          ORR      r1,r1,r1,LSL #16
00000a  4018              ANDS     r0,r0,r3              ;1179
00000c  4019              ANDS     r1,r1,r3
;;;1181   	dst2 = ((((dst2 - src2) * alpha) >> 5) + src2) & 0x07E0F81F;
00000e  1a09              SUBS     r1,r1,r0
000010  4351              MULS     r1,r2,r1
000012  eb001051          ADD      r0,r0,r1,LSR #5
000016  4018              ANDS     r0,r0,r3
;;;1182   	return (dst2 >> 16) | dst2;
000018  ea404010          ORR      r0,r0,r0,LSR #16
00001c  b280              UXTH     r0,r0
;;;1183   }
00001e  4770              BX       lr
;;;1184   
                          ENDP

                  |L1.32|
                          DCD      0x07e0f81f

                          AREA ||i.LCD_ButtonTouchDown||, CODE, READONLY, ALIGN=1

                  LCD_ButtonTouchDown PROC
;;;1905   */
;;;1906   uint8_t LCD_ButtonTouchDown(BUTTON_T *_btn, uint16_t _usX, uint16_t _usY)
000000  b510              PUSH     {r4,lr}
;;;1907   {
000002  4604              MOV      r4,r0
;;;1908   	if ((_usX > _btn->Left) && (_usX < _btn->Left + _btn->Width)
000004  8840              LDRH     r0,[r0,#2]
000006  4288              CMP      r0,r1
000008  d213              BCS      |L2.50|
00000a  8923              LDRH     r3,[r4,#8]
00000c  4418              ADD      r0,r0,r3
00000e  4288              CMP      r0,r1
000010  d90f              BLS      |L2.50|
;;;1909   		&& (_usY > _btn->Top) && (_usY < _btn->Top + _btn->Height))
000012  88a0              LDRH     r0,[r4,#4]
000014  4290              CMP      r0,r2
000016  d20c              BCS      |L2.50|
000018  88e1              LDRH     r1,[r4,#6]
00001a  4408              ADD      r0,r0,r1
00001c  4290              CMP      r0,r2
00001e  d908              BLS      |L2.50|
;;;1910   	{
;;;1911   		BUTTON_BEEP();	/* 按键提示音 bsp_tft_lcd.h 文件开头可以使能和关闭 */
000020  f7fffffe          BL       BEEP_KeyTone
;;;1912   		_btn->Focus = 1;
000024  2001              MOVS     r0,#1
000026  7520              STRB     r0,[r4,#0x14]
;;;1913   		LCD_DrawButton(_btn);
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       LCD_DrawButton
;;;1914   		return 1;
00002e  2001              MOVS     r0,#1
;;;1915   	}
;;;1916   	else
;;;1917   	{
;;;1918   		return 0;
;;;1919   	}
;;;1920   }
000030  bd10              POP      {r4,pc}
                  |L2.50|
000032  2000              MOVS     r0,#0                 ;1918
000034  bd10              POP      {r4,pc}
;;;1921   
                          ENDP


                          AREA ||i.LCD_ButtonTouchRelease||, CODE, READONLY, ALIGN=1

                  LCD_ButtonTouchRelease PROC
;;;1930   */
;;;1931   uint8_t LCD_ButtonTouchRelease(BUTTON_T *_btn, uint16_t _usX, uint16_t _usY)
000000  b570              PUSH     {r4-r6,lr}
;;;1932   {
000002  4604              MOV      r4,r0
;;;1933   	_btn->Focus = 0;
000004  2000              MOVS     r0,#0
000006  7520              STRB     r0,[r4,#0x14]
000008  4615              MOV      r5,r2                 ;1932
00000a  460e              MOV      r6,r1                 ;1932
;;;1934   	LCD_DrawButton(_btn);
00000c  4620              MOV      r0,r4
00000e  f7fffffe          BL       LCD_DrawButton
;;;1935   
;;;1936   	if ((_usX > _btn->Left) && (_usX < _btn->Left + _btn->Width)
000012  8860              LDRH     r0,[r4,#2]
000014  42b0              CMP      r0,r6
000016  d20c              BCS      |L3.50|
000018  8921              LDRH     r1,[r4,#8]
00001a  4408              ADD      r0,r0,r1
00001c  42b0              CMP      r0,r6
00001e  d908              BLS      |L3.50|
;;;1937   		&& (_usY > _btn->Top) && (_usY < _btn->Top + _btn->Height))
000020  88a0              LDRH     r0,[r4,#4]
000022  42a8              CMP      r0,r5
000024  d205              BCS      |L3.50|
000026  88e1              LDRH     r1,[r4,#6]
000028  4408              ADD      r0,r0,r1
00002a  42a8              CMP      r0,r5
00002c  d901              BLS      |L3.50|
;;;1938   	{
;;;1939   		return 1;
00002e  2001              MOVS     r0,#1
;;;1940   	}
;;;1941   	else
;;;1942   	{
;;;1943   		return 0;
;;;1944   	}
;;;1945   }
000030  bd70              POP      {r4-r6,pc}
                  |L3.50|
000032  2000              MOVS     r0,#0                 ;1943
000034  bd70              POP      {r4-r6,pc}
;;;1946   
                          ENDP


                          AREA ||i.LCD_ClrScr||, CODE, READONLY, ALIGN=2

                  LCD_ClrScr PROC
;;;266    */
;;;267    void LCD_ClrScr(uint16_t _usColor)
000000  4906              LDR      r1,|L4.28|
;;;268    {
;;;269    	if (g_ChipID == IC_8875)	/* RA8875 分支 */
000002  8849              LDRH     r1,[r1,#2]  ; g_ChipID
000004  2975              CMP      r1,#0x75
000006  d007              BEQ      |L4.24|
;;;270    	{
;;;271    		RA8875_ClrScr(_usColor);
;;;272    	}
;;;273    	else if (g_ChipID == IC_9488)
000008  f5a14214          SUB      r2,r1,#0x9400
00000c  3a88              SUBS     r2,r2,#0x88
00000e  d001              BEQ      |L4.20|
;;;274    	{
;;;275    		ILI9488_ClrScr(_usColor);
;;;276    	}
;;;277    	else	/* 5420，4001，61509 分支 */
;;;278    	{
;;;279    		SPFD5420_ClrScr(_usColor);
000010  f7ffbffe          B.W      SPFD5420_ClrScr
                  |L4.20|
000014  f7ffbffe          B.W      ILI9488_ClrScr
                  |L4.24|
000018  f7ffbffe          B.W      RA8875_ClrScr
;;;280    	}
;;;281    }
;;;282    
                          ENDP

                  |L4.28|
                          DCD      ||.data||

                          AREA ||i.LCD_DispControl||, CODE, READONLY, ALIGN=1

                  LCD_DispControl PROC
;;;1682   */
;;;1683   void LCD_DispControl(void *_pControl)
000000  7801              LDRB     r1,[r0,#0]
;;;1684   {
;;;1685   	uint8_t id;
;;;1686   
;;;1687   	id = *(uint8_t *)_pControl;	/* 读取ID */
;;;1688   
;;;1689   	switch (id)
000002  2908              CMP      r1,#8
000004  d211              BCS      |L5.42|
000006  e8dff001          TBB      [pc,r1]
00000a  1010              DCB      0x10,0x10
00000c  0406080a          DCB      0x04,0x06,0x08,0x0a
000010  0c0e              DCB      0x0c,0x0e
;;;1690   	{
;;;1691   		case ID_ICON:
;;;1692   			//void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode);
;;;1693   			break;
;;;1694   
;;;1695   		case ID_WIN:
;;;1696   			LCD_DrawWin((WIN_T *)_pControl);
000012  f7ffbffe          B.W      LCD_DrawWin
;;;1697   			break;
;;;1698   
;;;1699   		case ID_LABEL:
;;;1700   			LCD_DrawLabel((LABEL_T *)_pControl);
000016  f7ffbffe          B.W      LCD_DrawLabel
;;;1701   			break;
;;;1702   
;;;1703   		case ID_BUTTON:
;;;1704   			LCD_DrawButton((BUTTON_T *)_pControl);
00001a  f7ffbffe          B.W      LCD_DrawButton
;;;1705   			break;
;;;1706   
;;;1707   		case ID_CHECK:
;;;1708   			LCD_DrawCheckBox((CHECK_T *)_pControl);
00001e  f7ffbffe          B.W      LCD_DrawCheckBox
;;;1709   			break;
;;;1710   
;;;1711   		case ID_EDIT:
;;;1712   			LCD_DrawEdit((EDIT_T *)_pControl);
000022  f7ffbffe          B.W      LCD_DrawEdit
;;;1713   			break;
;;;1714   
;;;1715   		case ID_GROUP:
;;;1716   			LCD_DrawGroupBox((GROUP_T *)_pControl);
000026  f7ffbffe          B.W      LCD_DrawGroupBox
                  |L5.42|
;;;1717   			break;
;;;1718   	}
;;;1719   }
00002a  4770              BX       lr
;;;1720   
                          ENDP


                          AREA ||i.LCD_DispOff||, CODE, READONLY, ALIGN=2

                  LCD_DispOff PROC
;;;242    */
;;;243    void LCD_DispOff(void)
000000  4806              LDR      r0,|L6.28|
;;;244    {
;;;245    	if (g_ChipID == IC_8875)
000002  8840              LDRH     r0,[r0,#2]  ; g_ChipID
000004  2875              CMP      r0,#0x75
000006  d007              BEQ      |L6.24|
;;;246    	{
;;;247    		RA8875_DispOff();
;;;248    	}
;;;249    	else if (g_ChipID == IC_9488)
000008  f5a04114          SUB      r1,r0,#0x9400
00000c  3988              SUBS     r1,r1,#0x88
00000e  d001              BEQ      |L6.20|
;;;250    	{
;;;251    		ILI9488_DispOff();
;;;252    	}
;;;253    	else	/* 61509, 5420, 4001 */
;;;254    	{
;;;255    		SPFD5420_DispOff();
000010  f7ffbffe          B.W      SPFD5420_DispOff
                  |L6.20|
000014  f7ffbffe          B.W      ILI9488_DispOff
                  |L6.24|
000018  f7ffbffe          B.W      RA8875_DispOff
;;;256    	}
;;;257    }
;;;258    
                          ENDP

                  |L6.28|
                          DCD      ||.data||

                          AREA ||i.LCD_DispOn||, CODE, READONLY, ALIGN=2

                  LCD_DispOn PROC
;;;218    */
;;;219    void LCD_DispOn(void)
000000  4806              LDR      r0,|L7.28|
;;;220    {
;;;221    	if (g_ChipID == IC_8875)
000002  8840              LDRH     r0,[r0,#2]  ; g_ChipID
000004  2875              CMP      r0,#0x75
000006  d007              BEQ      |L7.24|
;;;222    	{
;;;223    		RA8875_DispOn();
;;;224    	}
;;;225    	else if (g_ChipID == IC_9488)
000008  f5a04114          SUB      r1,r0,#0x9400
00000c  3988              SUBS     r1,r1,#0x88
00000e  d001              BEQ      |L7.20|
;;;226    	{
;;;227    		ILI9488_DispOn();
;;;228    	}
;;;229    	else	/* 61509, 5420, 4001 */
;;;230    	{
;;;231    		SPFD5420_DispOn();
000010  f7ffbffe          B.W      SPFD5420_DispOn
                  |L7.20|
000014  f7ffbffe          B.W      ILI9488_DispOn
                  |L7.24|
000018  f7ffbffe          B.W      RA8875_DispOn
;;;232    	}
;;;233    }
;;;234    
                          ENDP

                  |L7.28|
                          DCD      ||.data||

                          AREA ||i.LCD_DispStr||, CODE, READONLY, ALIGN=1

                  LCD_DispStr PROC
;;;294    */
;;;295    void LCD_DispStr(uint16_t _usX, uint16_t _usY, char *_ptr, FONT_T *_tFont)
000000  b51c              PUSH     {r2-r4,lr}
;;;296    {
;;;297    	LCD_DispStrEx(_usX, _usY, _ptr, _tFont, 0, 0);
000002  2400              MOVS     r4,#0
000004  9400              STR      r4,[sp,#0]
000006  9401              STR      r4,[sp,#4]
000008  f7fffffe          BL       LCD_DispStrEx
;;;298    }
00000c  bd1c              POP      {r2-r4,pc}
;;;299    
                          ENDP


                          AREA ||i.LCD_DispStrEx||, CODE, READONLY, ALIGN=2

                  LCD_DispStrEx PROC
;;;620    */
;;;621    void LCD_DispStrEx(uint16_t _usX, uint16_t _usY, char *_ptr, FONT_T *_tFont, uint16_t _Width,
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;622    	uint8_t _Align)
;;;623    {
000004  b0a3              SUB      sp,sp,#0x8c
;;;624    	uint32_t i;
;;;625    	uint8_t code1;
;;;626    	uint8_t code2;
;;;627    	uint8_t buf[32 * 32 / 8];	/* 最大支持24点阵汉字 */
;;;628    	uint8_t width;
;;;629    	uint16_t m;
;;;630    	uint8_t font_width = 0;
000006  2500              MOVS     r5,#0
;;;631    	uint8_t font_height = 0;
;;;632    	uint16_t x, y;
;;;633    	uint16_t offset;
;;;634    	uint16_t str_width;	/* 字符串实际宽度  */
;;;635    	uint8_t ra8875_use = 0;
;;;636    	uint8_t ra8875_font_code = 0;
000008  f8dda0c0          LDR      r10,[sp,#0xc0]
00000c  4683              MOV      r11,r0                ;623
;;;637    
;;;638    	switch (_tFont->FontCode)
00000e  9521              STR      r5,[sp,#0x84]
000010  7818              LDRB     r0,[r3,#0]
000012  461c              MOV      r4,r3                 ;623
000014  462f              MOV      r7,r5                 ;631
000016  46a9              MOV      r9,r5                 ;635
000018  2807              CMP      r0,#7
00001a  d269              BCS      |L9.240|
00001c  e8dff000          TBB      [pc,r0]
000020  04070a0d          DCB      0x04,0x07,0x0a,0x0d
000024  10212300          DCB      0x10,0x21,0x23,0x00
;;;639    	{
;;;640    		case FC_ST_12:		/* 12点阵 */
;;;641    			font_height = 12;
000028  270c              MOVS     r7,#0xc
;;;642    			font_width = 12;
00002a  463d              MOV      r5,r7
;;;643    			break;
00002c  e00a              B        |L9.68|
;;;644    		
;;;645    		case FC_ST_16:
;;;646    			font_height = 16;
00002e  2710              MOVS     r7,#0x10
;;;647    			font_width = 16;
000030  463d              MOV      r5,r7
;;;648    			break;
000032  e007              B        |L9.68|
;;;649    
;;;650    		case FC_ST_24:
;;;651    			font_height = 24;
000034  2718              MOVS     r7,#0x18
;;;652    			font_width = 24;
000036  463d              MOV      r5,r7
;;;653    			break;
000038  e004              B        |L9.68|
;;;654    						
;;;655    		case FC_ST_32:	
;;;656    			font_height = 32;
00003a  2720              MOVS     r7,#0x20
;;;657    			font_width = 32;
00003c  463d              MOV      r5,r7
;;;658    			break;					
00003e  e001              B        |L9.68|
                  |L9.64|
;;;659    		
;;;660    		case FC_RA8875_16:
;;;661    			ra8875_font_code = RA_FONT_16;
;;;662    			ra8875_use = 1;	/* 表示用RA8875字库 */
000040  f04f0901          MOV      r9,#1
                  |L9.68|
;;;663    			break;
;;;664    			
;;;665    		case FC_RA8875_24:
;;;666    			ra8875_font_code = RA_FONT_24;
;;;667    			ra8875_use = 1;	/* 表示用RA8875字库 */
;;;668    			break;
;;;669    						
;;;670    		case FC_RA8875_32:
;;;671    			ra8875_font_code = RA_FONT_32;
;;;672    			ra8875_use = 1;	/* 表示用RA8875字库 */
;;;673    			break;
;;;674    		
;;;675    		default:
;;;676    			return;
;;;677    	}
;;;678    	
;;;679    	str_width = LCD_GetStrWidth(_ptr, _tFont);	/* 计算字符串实际宽度(RA8875内部ASCII点阵宽度为变长 */
000044  4619              MOV      r1,r3
000046  9825              LDR      r0,[sp,#0x94]
000048  f7fffffe          BL       LCD_GetStrWidth
00004c  4606              MOV      r6,r0
;;;680    	offset = 0;
00004e  f04f0800          MOV      r8,#0
;;;681    	if (_Width > str_width)
000052  45b2              CMP      r10,r6
000054  d926              BLS      |L9.164|
;;;682    	{
;;;683    		if (_Align == ALIGN_RIGHT)	/* 右对齐 */
000056  9831              LDR      r0,[sp,#0xc4]
000058  2802              CMP      r0,#2
00005a  d007              BEQ      |L9.108|
;;;684    		{
;;;685    			offset = _Width - str_width;
;;;686    		}
;;;687    		else if (_Align == ALIGN_CENTER)	/* 左对齐 */
00005c  2801              CMP      r0,#1
00005e  d009              BEQ      |L9.116|
000060  e020              B        |L9.164|
000062  2001              MOVS     r0,#1                 ;666
000064  e000              B        |L9.104|
000066  2002              MOVS     r0,#2                 ;671
                  |L9.104|
000068  9021              STR      r0,[sp,#0x84]         ;671
00006a  e7e9              B        |L9.64|
                  |L9.108|
00006c  ebaa0006          SUB      r0,r10,r6             ;685
000070  b280              UXTH     r0,r0                 ;685
000072  e005              B        |L9.128|
                  |L9.116|
;;;688    		{
;;;689    			offset = (_Width - str_width) / 2;
000074  ebaa0006          SUB      r0,r10,r6
000078  eb0070d0          ADD      r0,r0,r0,LSR #31
00007c  f3c0004f          UBFX     r0,r0,#1,#16
                  |L9.128|
000080  ea5f0800          MOVS     r8,r0
000084  d00e              BEQ      |L9.164|
;;;690    		}
;;;691    		else	/* 左对齐 ALIGN_LEFT */
;;;692    		{
;;;693    			;
;;;694    		}
;;;695    	}
;;;696    
;;;697    	/* 左侧填背景色, 中间对齐和右边对齐  */
;;;698    	if (offset > 0)
;;;699    	{
;;;700    		LCD_Fill_Rect(_usX, _usY, LCD_GetFontHeight(_tFont), offset,  _tFont->BackColor);
000086  4620              MOV      r0,r4
000088  f7fffffe          BL       LCD_GetFontHeight
00008c  88a1              LDRH     r1,[r4,#4]
00008e  4602              MOV      r2,r0
000090  9100              STR      r1,[sp,#0]
000092  4643              MOV      r3,r8
000094  4658              MOV      r0,r11
000096  9924              LDR      r1,[sp,#0x90]
000098  f7fffffe          BL       LCD_Fill_Rect
;;;701    		_usX += offset;
00009c  eb0b0008          ADD      r0,r11,r8
0000a0  fa1ffb80          UXTH     r11,r0
                  |L9.164|
;;;702    	}
;;;703    	
;;;704    	/* 右侧填背景色 */
;;;705    	if (_Width > str_width)
0000a4  45b2              CMP      r10,r6
0000a6  d910              BLS      |L9.202|
;;;706    	{
;;;707    		LCD_Fill_Rect(_usX + str_width, _usY, LCD_GetFontHeight(_tFont), _Width - str_width - offset,  _tFont->BackColor);
0000a8  4620              MOV      r0,r4
0000aa  f7fffffe          BL       LCD_GetFontHeight
0000ae  4602              MOV      r2,r0
0000b0  88a0              LDRH     r0,[r4,#4]
0000b2  ebaa0106          SUB      r1,r10,r6
0000b6  9000              STR      r0,[sp,#0]
0000b8  eba10008          SUB      r0,r1,r8
0000bc  b283              UXTH     r3,r0
0000be  eb0b0006          ADD      r0,r11,r6
0000c2  b280              UXTH     r0,r0
0000c4  9924              LDR      r1,[sp,#0x90]
0000c6  f7fffffe          BL       LCD_Fill_Rect
                  |L9.202|
;;;708    	}
;;;709    	
;;;710    	if (ra8875_use == 1)	/* 使用RA8875外挂的字库芯片 */
0000ca  f1b90f00          CMP      r9,#0
0000ce  d012              BEQ      |L9.246|
;;;711    	{
;;;712    		RA8875_SetFrontColor(_tFont->FrontColor);			/* 设置字体前景色 */
0000d0  8860              LDRH     r0,[r4,#2]
0000d2  f7fffffe          BL       RA8875_SetFrontColor
;;;713    		RA8875_SetBackColor(_tFont->BackColor);				/* 设置字体背景色 */
0000d6  88a0              LDRH     r0,[r4,#4]
0000d8  f7fffffe          BL       RA8875_SetBackColor
;;;714    		RA8875_SetFont(ra8875_font_code, 0, _tFont->Space);	/* 字体代码，行间距，字间距 */
0000dc  79a2              LDRB     r2,[r4,#6]
0000de  2100              MOVS     r1,#0
0000e0  9821              LDR      r0,[sp,#0x84]
0000e2  f7fffffe          BL       RA8875_SetFont
;;;715    		RA8875_DispStr(_usX, _usY, _ptr);
0000e6  e9dd1224          LDRD     r1,r2,[sp,#0x90]
0000ea  4658              MOV      r0,r11
0000ec  f7fffffe          BL       RA8875_DispStr
                  |L9.240|
;;;716    	}
;;;717    	else	/* 使用CPU内部字库. 点阵信息由CPU读取 */
;;;718    	{
;;;719    		/* 开始循环处理字符 */
;;;720    		while (*_ptr != 0)
;;;721    		{
;;;722    			code1 = *_ptr;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
;;;723    			if (code1 < 0x80)
;;;724    			{
;;;725    				/* 将ascii字符点阵复制到buf */
;;;726    				//memcpy(buf, &pAscDot[code1 * (font_bytes / 2)], (font_bytes / 2));
;;;727    				_LCD_ReadAsciiDot(code1, _tFont->FontCode, buf);	/* 读取ASCII字符点阵 */
;;;728    				width = font_width / 2;
;;;729    			}
;;;730    			else
;;;731    			{
;;;732    				code2 = *++_ptr;
;;;733    				if (code2 == 0)
;;;734    				{
;;;735    					break;
;;;736    				}
;;;737    				/* 读1个汉字的点阵 */
;;;738    				_LCD_ReadHZDot(code1, code2, _tFont->FontCode, buf);
;;;739    				width = font_width;
;;;740    			}
;;;741    	
;;;742    			y = _usY;
;;;743    			/* 开始刷LCD */
;;;744    			for (m = 0; m < font_height; m++)	/* 字符高度 */
;;;745    			{
;;;746    				x = _usX;
;;;747    				for (i = 0; i < width; i++)	/* 字符宽度 */
;;;748    				{
;;;749    					if ((buf[m * ((2 * width) / font_width) + i / 8] & (0x80 >> (i % 8 ))) != 0x00)
;;;750    					{
;;;751    						LCD_PutPixel(x, y, _tFont->FrontColor);	/* 设置像素颜色为文字色 */
;;;752    					}
;;;753    					else
;;;754    					{
;;;755    						if (_tFont->BackColor != CL_MASK)	/* 透明色 */
;;;756    						{
;;;757    							LCD_PutPixel(x, y, _tFont->BackColor);	/* 设置像素颜色为文字背景色 */
;;;758    						}
;;;759    					}
;;;760    	
;;;761    					x++;
;;;762    				}
;;;763    				y++;
;;;764    			}
;;;765    	
;;;766    			if (_tFont->Space > 0)
;;;767    			{
;;;768    				/* 如果文字底色按_tFont->usBackColor，并且字间距大于点阵的宽度，那么需要在文字之间填充(暂时未实现) */
;;;769    			}
;;;770    			_usX += width + _tFont->Space;	/* 列地址递增 */
;;;771    			_ptr++;			/* 指向下一个字符 */
;;;772    		}
;;;773    	}
;;;774    }
0000f0  b027              ADD      sp,sp,#0x9c
0000f2  e8bd8ff0          POP      {r4-r11,pc}
                  |L9.246|
0000f6  9825              LDR      r0,[sp,#0x94]         ;771
0000f8  e064              B        |L9.452|
                  |L9.250|
0000fa  2880              CMP      r0,#0x80              ;723
0000fc  d219              BCS      |L9.306|
0000fe  7822              LDRB     r2,[r4,#0]            ;727
000100  2600              MOVS     r6,#0                 ;727
000102  ab01              ADD      r3,sp,#4              ;727
000104  4631              MOV      r1,r6                 ;727
000106  2a07              CMP      r2,#7                 ;727
000108  d20a              BCS      |L9.288|
00010a  e8dff002          TBB      [pc,r2]               ;727
00010e  0407              DCB      0x04,0x07
000110  07070f0f          DCB      0x07,0x07,0x0f,0x0f
000114  0f00              DCB      0x0f,0x00
000116  2618              MOVS     r6,#0x18              ;727
000118  492c              LDR      r1,|L9.460|
00011a  e001              B        |L9.288|
00011c  492c              LDR      r1,|L9.464|
00011e  2620              MOVS     r6,#0x20              ;727
                  |L9.288|
000120  0872              LSRS     r2,r6,#1              ;727
000122  fb001102          MLA      r1,r0,r2,r1           ;727
000126  4618              MOV      r0,r3                 ;727
000128  f7fffffe          BL       __aeabi_memcpy
00012c  ea4f0955          LSR      r9,r5,#1              ;728
000130  e00a              B        |L9.328|
                  |L9.306|
000132  9925              LDR      r1,[sp,#0x94]         ;732
000134  1c49              ADDS     r1,r1,#1              ;732
000136  9125              STR      r1,[sp,#0x94]         ;732
000138  7809              LDRB     r1,[r1,#0]            ;732
00013a  2900              CMP      r1,#0                 ;733
00013c  d0d8              BEQ      |L9.240|
00013e  7822              LDRB     r2,[r4,#0]            ;738
000140  ab01              ADD      r3,sp,#4              ;738
000142  f7fffffe          BL       _LCD_ReadHZDot
000146  46a9              MOV      r9,r5                 ;739
                  |L9.328|
000148  9824              LDR      r0,[sp,#0x90]         ;742
00014a  9000              STR      r0,[sp,#0]            ;744
00014c  2000              MOVS     r0,#0                 ;744
00014e  e02d              B        |L9.428|
                  |L9.336|
000150  ea4f0049          LSL      r0,r9,#1              ;749
000154  46da              MOV      r10,r11               ;746
000156  2600              MOVS     r6,#0                 ;747
000158  9021              STR      r0,[sp,#0x84]         ;747
00015a  e01e              B        |L9.410|
                  |L9.348|
00015c  9821              LDR      r0,[sp,#0x84]         ;749
00015e  f0060207          AND      r2,r6,#7              ;749
000162  fbb0f1f5          UDIV     r1,r0,r5              ;749
000166  a801              ADD      r0,sp,#4              ;749
000168  fb01f108          MUL      r1,r1,r8              ;749
00016c  eb0000d6          ADD      r0,r0,r6,LSR #3       ;749
000170  5c09              LDRB     r1,[r1,r0]            ;749
000172  2080              MOVS     r0,#0x80              ;749
000174  40d0              LSRS     r0,r0,r2              ;749
000176  4201              TST      r1,r0                 ;749
000178  d001              BEQ      |L9.382|
00017a  8862              LDRH     r2,[r4,#2]            ;751
00017c  e004              B        |L9.392|
                  |L9.382|
00017e  88a2              LDRH     r2,[r4,#4]            ;755
000180  f5a24019          SUB      r0,r2,#0x9900         ;755
000184  3899              SUBS     r0,r0,#0x99           ;755
000186  d003              BEQ      |L9.400|
                  |L9.392|
000188  4650              MOV      r0,r10                ;757
00018a  9900              LDR      r1,[sp,#0]            ;757
00018c  f7fffffe          BL       LCD_PutPixel
                  |L9.400|
000190  f10a0001          ADD      r0,r10,#1             ;761
000194  fa1ffa80          UXTH     r10,r0                ;761
000198  1c76              ADDS     r6,r6,#1              ;761
                  |L9.410|
00019a  454e              CMP      r6,r9                 ;747
00019c  d3de              BCC      |L9.348|
00019e  9800              LDR      r0,[sp,#0]            ;763
0001a0  1c40              ADDS     r0,r0,#1              ;763
0001a2  b280              UXTH     r0,r0                 ;763
0001a4  9000              STR      r0,[sp,#0]            ;744
0001a6  f1080001          ADD      r0,r8,#1              ;744
0001aa  b280              UXTH     r0,r0                 ;744
                  |L9.428|
0001ac  4680              MOV      r8,r0                 ;744
0001ae  42b8              CMP      r0,r7                 ;744
0001b0  d3ce              BCC      |L9.336|
0001b2  88e2              LDRH     r2,[r4,#6]            ;770
0001b4  eb0b0009          ADD      r0,r11,r9             ;770
0001b8  4410              ADD      r0,r0,r2              ;770
0001ba  fa1ffb80          UXTH     r11,r0                ;770
0001be  9825              LDR      r0,[sp,#0x94]         ;771
0001c0  1c40              ADDS     r0,r0,#1              ;771
0001c2  9025              STR      r0,[sp,#0x94]         ;771
                  |L9.452|
0001c4  7800              LDRB     r0,[r0,#0]            ;720
0001c6  2800              CMP      r0,#0                 ;720
0001c8  d197              BNE      |L9.250|
0001ca  e791              B        |L9.240|
;;;775    
                          ENDP

                  |L9.460|
                          DCD      g_Ascii12
                  |L9.464|
                          DCD      g_Ascii16

                          AREA ||i.LCD_DrawBMP||, CODE, READONLY, ALIGN=2

                  LCD_DrawBMP PROC
;;;974    */
;;;975    void LCD_DrawBMP(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t *_ptr)
000000  b5f8              PUSH     {r3-r7,lr}
;;;976    {
;;;977    	if (g_ChipID == IC_8875)
000002  4d0a              LDR      r5,|L10.44|
000004  9c06              LDR      r4,[sp,#0x18]
000006  886d              LDRH     r5,[r5,#2]  ; g_ChipID
000008  2d75              CMP      r5,#0x75
00000a  d00a              BEQ      |L10.34|
;;;978    	{
;;;979    		RA8875_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
;;;980    	}
;;;981    	else if (g_ChipID == IC_9488)
00000c  f5a54614          SUB      r6,r5,#0x9400
000010  3e88              SUBS     r6,r6,#0x88
000012  9400              STR      r4,[sp,#0]
000014  d002              BEQ      |L10.28|
;;;982    	{
;;;983    		ILI9488_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
;;;984    	}
;;;985    	else
;;;986    	{
;;;987    		SPFD5420_DrawBMP(_usX, _usY, _usHeight, _usWidth, _ptr);
000016  f7fffffe          BL       SPFD5420_DrawBMP
;;;988    	}
;;;989    }
00001a  bdf8              POP      {r3-r7,pc}
                  |L10.28|
00001c  f7fffffe          BL       ILI9488_DrawBMP
000020  bdf8              POP      {r3-r7,pc}
                  |L10.34|
000022  9400              STR      r4,[sp,#0]            ;979
000024  f7fffffe          BL       RA8875_DrawBMP
000028  bdf8              POP      {r3-r7,pc}
;;;990    
                          ENDP

00002a  0000              DCW      0x0000
                  |L10.44|
                          DCD      ||.data||

                          AREA ||i.LCD_DrawBmp32||, CODE, READONLY, ALIGN=2

                  LCD_DrawBmp32 PROC
;;;1290   */
;;;1291   void LCD_DrawBmp32(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint8_t *_pBmp)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;1292   {
000004  b083              SUB      sp,sp,#0xc
000006  1e52              SUBS     r2,r2,#1
;;;1293   	const uint8_t *p;
;;;1294   	uint16_t usOldRGB, usNewRGB;
;;;1295   	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;1296   	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;1297   	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;1298   
;;;1299   	p = (const uint8_t *)_pBmp;
;;;1300   	p += 54;		/* 直接指向图像数据区 */
;;;1301   
;;;1302   	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;1303   	for (y = _usHeight - 1; y >= 0; y--)
000008  9c10              LDR      r4,[sp,#0x40]
00000a  4698              MOV      r8,r3                 ;1292
00000c  b217              SXTH     r7,r2
00000e  3436              ADDS     r4,r4,#0x36
000010  e054              B        |L11.188|
                  |L11.18|
;;;1304   	{
;;;1305   		for (x = 0; x < _usWidth; x++)
000012  2500              MOVS     r5,#0
000014  e04e              B        |L11.180|
;;;1306   		{
;;;1307   			B1 = *p++;
000016  bf00              NOP      
                  |L11.24|
000018  f814bb01          LDRB     r11,[r4],#1
;;;1308   			G1 = *p++;
00001c  f8149b01          LDRB     r9,[r4],#1
;;;1309   			R1 = *p++;
000020  f814ab02          LDRB     r10,[r4],#2
;;;1310   			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
000024  f8146c01          LDRB     r6,[r4,#-1]
;;;1311   
;;;1312   			if (A == 0x00)	/* 需要透明,显示背景 */
000028  b3f6              CBZ      r6,|L11.168|
;;;1313   			{
;;;1314   				;	/* 不用刷新背景 */
;;;1315   			}
;;;1316   			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
00002a  2eff              CMP      r6,#0xff
00002c  d04b              BEQ      |L11.198|
;;;1317   			{
;;;1318   				usNewRGB = RGB(R1, G1, B1);
;;;1319   				//if (_ucFocusMode == 1)
;;;1320   				//{
;;;1321   				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;1322   				//}
;;;1323   				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
;;;1324   			}
;;;1325   			else 	/* 半透明 */
;;;1326   			{
;;;1327   				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;1328   				usOldRGB = LCD_GetPixel(x + _usX, y + _usY);
00002e  9804              LDR      r0,[sp,#0x10]
000030  4438              ADD      r0,r0,r7
000032  b281              UXTH     r1,r0
000034  9001              STR      r0,[sp,#4]
000036  9803              LDR      r0,[sp,#0xc]
000038  4428              ADD      r0,r0,r5
00003a  9000              STR      r0,[sp,#0]
00003c  b280              UXTH     r0,r0
00003e  f7fffffe          BL       LCD_GetPixel
;;;1329   				R0 = RGB565_R(usOldRGB);
000042  21f8              MOVS     r1,#0xf8
000044  ea012310          AND      r3,r1,r0,LSR #8
;;;1330   				G0 = RGB565_G(usOldRGB);
000048  21fc              MOVS     r1,#0xfc
00004a  ea0102d0          AND      r2,r1,r0,LSR #3
;;;1331   				B0 = RGB565_B(usOldRGB);
00004e  06c0              LSLS     r0,r0,#27
000050  ea4f6e10          LSR      lr,r0,#24
;;;1332   
;;;1333   				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
000054  fb0af106          MUL      r1,r10,r6
000058  20ff              MOVS     r0,#0xff
00005a  fbb1fcf0          UDIV     r12,r1,r0
00005e  f1c601ff          RSB      r1,r6,#0xff
000062  434b              MULS     r3,r1,r3
000064  fbb3f3f0          UDIV     r3,r3,r0
000068  4463              ADD      r3,r3,r12
;;;1334   				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
00006a  434a              MULS     r2,r1,r2
00006c  fb09fc06          MUL      r12,r9,r6
000070  fbbcfcf0          UDIV     r12,r12,r0
000074  fbb2f2f0          UDIV     r2,r2,r0
000078  4462              ADD      r2,r2,r12
;;;1335   				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
00007a  fb0bfc06          MUL      r12,r11,r6
00007e  fbbcf6f0          UDIV     r6,r12,r0
000082  fb01f10e          MUL      r1,r1,lr
000086  fbb1f0f0          UDIV     r0,r1,r0
;;;1336   				usNewRGB = RGB(R1, G1, B1);
00008a  f3c301c4          UBFX     r1,r3,#3,#5
00008e  4430              ADD      r0,r0,r6              ;1335
000090  02c9              LSLS     r1,r1,#11
000092  f3c20285          UBFX     r2,r2,#2,#6
000096  b2c0              UXTB     r0,r0                 ;1335
000098  ea411142          ORR      r1,r1,r2,LSL #5
00009c  ea4102d0          ORR      r2,r1,r0,LSR #3
;;;1337   				//if (_ucFocusMode == 1)
;;;1338   				//{
;;;1339   				//	usNewRGB = Blend565(usNewRGB, CL_YELLOW, 10);
;;;1340   				//}
;;;1341   				LCD_PutPixel(x + _usX, y + _usY, usNewRGB);
0000a0  9801              LDR      r0,[sp,#4]
0000a2  b281              UXTH     r1,r0
0000a4  9800              LDR      r0,[sp,#0]
                  |L11.166|
0000a6  e000              B        |L11.170|
                  |L11.168|
0000a8  e002              B        |L11.176|
                  |L11.170|
0000aa  b280              UXTH     r0,r0                 ;1323
0000ac  f7fffffe          BL       LCD_PutPixel
                  |L11.176|
0000b0  1c6d              ADDS     r5,r5,#1              ;1323
0000b2  b22d              SXTH     r5,r5                 ;1305
                  |L11.180|
0000b4  4545              CMP      r5,r8                 ;1305
0000b6  dbaf              BLT      |L11.24|
0000b8  1e7f              SUBS     r7,r7,#1              ;1305
0000ba  b23f              SXTH     r7,r7                 ;1303
                  |L11.188|
0000bc  2f00              CMP      r7,#0                 ;1303
0000be  daa8              BGE      |L11.18|
;;;1342   			}
;;;1343   		}
;;;1344   	}
;;;1345   }
0000c0  b007              ADD      sp,sp,#0x1c
0000c2  e8bd8ff0          POP      {r4-r11,pc}
                  |L11.198|
0000c6  ea4f00da          LSR      r0,r10,#3             ;1318
0000ca  02c1              LSLS     r1,r0,#11             ;1318
0000cc  ea4f0099          LSR      r0,r9,#2              ;1318
0000d0  ea411140          ORR      r1,r1,r0,LSL #5       ;1318
0000d4  9804              LDR      r0,[sp,#0x10]         ;1323
0000d6  ea4102db          ORR      r2,r1,r11,LSR #3      ;1318
0000da  4438              ADD      r0,r0,r7              ;1323
0000dc  b281              UXTH     r1,r0                 ;1323
0000de  9803              LDR      r0,[sp,#0xc]          ;1323
0000e0  4428              ADD      r0,r0,r5              ;1323
0000e2  e7e0              B        |L11.166|
;;;1346   
                          ENDP


                          AREA ||i.LCD_DrawButton||, CODE, READONLY, ALIGN=2

                  LCD_DrawButton PROC
;;;1539   */
;;;1540   void LCD_DrawButton(BUTTON_T *_pBtn)
000000  e92d41ff          PUSH     {r0-r8,lr}
;;;1541   {
000004  4604              MOV      r4,r0
;;;1542   #if 1
;;;1543   	uint16_t x, y, h;
;;;1544   	FONT_T font;	/* 按钮激活时，需要更改字体设置，因此需要一个变量来保存 */
;;;1545   
;;;1546   	font.FontCode = _pBtn->Font->FontCode;
000006  68c0              LDR      r0,[r0,#0xc]
000008  7801              LDRB     r1,[r0,#0]
00000a  f88d1008          STRB     r1,[sp,#8]
;;;1547   	font.FrontColor = _pBtn->Font->FrontColor;
00000e  8840              LDRH     r0,[r0,#2]
000010  f8ad000a          STRH     r0,[sp,#0xa]
;;;1548   	font.BackColor = _pBtn->Font->BackColor;
000014  68e0              LDR      r0,[r4,#0xc]
000016  8880              LDRH     r0,[r0,#4]
000018  f8ad000c          STRH     r0,[sp,#0xc]
;;;1549   	font.Space = _pBtn->Font->Space;	
00001c  68e0              LDR      r0,[r4,#0xc]
00001e  88c0              LDRH     r0,[r0,#6]
000020  f8ad000e          STRH     r0,[sp,#0xe]
;;;1550   			
;;;1551   	if (_pBtn->Focus == 1)
000024  7d20              LDRB     r0,[r4,#0x14]
000026  2801              CMP      r0,#1
000028  d058              BEQ      |L12.220|
;;;1552   	{
;;;1553   		font.BackColor = BUTTON_ACTIVE_COLOR;
;;;1554   	}
;;;1555   	else
;;;1556   	{
;;;1557   		/* 按钮的背景色统一管理，不能单独指定 */
;;;1558   		font.BackColor = BUTTON_BACK_COLOR;
00002a  f64c6059          MOV      r0,#0xce59
00002e  bf00              NOP      
                  |L12.48|
000030  f8ad000c          STRH     r0,[sp,#0xc]
;;;1559   	}
;;;1560   	
;;;1561   	/* 仿XP风格，平面编辑框 */
;;;1562   	LCD_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
000034  2010              MOVS     r0,#0x10
000036  9000              STR      r0,[sp,#0]
000038  8923              LDRH     r3,[r4,#8]
00003a  88e2              LDRH     r2,[r4,#6]
00003c  88a1              LDRH     r1,[r4,#4]
00003e  8860              LDRH     r0,[r4,#2]
000040  f7fffffe          BL       LCD_DrawRect
;;;1563   	LCD_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
000044  f64f70ff          MOV      r0,#0xffff
000048  9000              STR      r0,[sp,#0]
00004a  8920              LDRH     r0,[r4,#8]
00004c  1e80              SUBS     r0,r0,#2
00004e  b283              UXTH     r3,r0
000050  88e0              LDRH     r0,[r4,#6]
000052  1e80              SUBS     r0,r0,#2
000054  b282              UXTH     r2,r0
000056  88a0              LDRH     r0,[r4,#4]
000058  1c40              ADDS     r0,r0,#1
00005a  b281              UXTH     r1,r0
00005c  8860              LDRH     r0,[r4,#2]
00005e  1c40              ADDS     r0,r0,#1
000060  b280              UXTH     r0,r0
000062  f7fffffe          BL       LCD_DrawRect
;;;1564   	LCD_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
000066  f24940b2          MOV      r0,#0x94b2
00006a  9000              STR      r0,[sp,#0]
00006c  8920              LDRH     r0,[r4,#8]
00006e  1f00              SUBS     r0,r0,#4
000070  b283              UXTH     r3,r0
000072  88e0              LDRH     r0,[r4,#6]
000074  1f00              SUBS     r0,r0,#4
000076  b282              UXTH     r2,r0
000078  88a0              LDRH     r0,[r4,#4]
00007a  1c80              ADDS     r0,r0,#2
00007c  b281              UXTH     r1,r0
00007e  8860              LDRH     r0,[r4,#2]
000080  1c80              ADDS     r0,r0,#2
000082  b280              UXTH     r0,r0
000084  f7fffffe          BL       LCD_DrawRect
;;;1565   
;;;1566   	h =  LCD_GetFontHeight(&font);
000088  a802              ADD      r0,sp,#8
00008a  f7fffffe          BL       LCD_GetFontHeight
00008e  4603              MOV      r3,r0
;;;1567   	x = _pBtn->Left + 3;
;;;1568   	y = _pBtn->Top + _pBtn->Height / 2 - h / 2;		
000090  88a0              LDRH     r0,[r4,#4]
000092  88e2              LDRH     r2,[r4,#6]
000094  8861              LDRH     r1,[r4,#2]            ;1567
000096  eb000552          ADD      r5,r0,r2,LSR #1
00009a  eba50353          SUB      r3,r5,r3,LSR #1
00009e  b29d              UXTH     r5,r3
;;;1569   	
;;;1570   	LCD_Fill_Rect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, font.BackColor);	/* 选中后的底色 */
0000a0  f8bd300c          LDRH     r3,[sp,#0xc]
0000a4  9300              STR      r3,[sp,#0]
0000a6  1cc9              ADDS     r1,r1,#3              ;1567
0000a8  8923              LDRH     r3,[r4,#8]
0000aa  1cc0              ADDS     r0,r0,#3
0000ac  b287              UXTH     r7,r0
0000ae  b28e              UXTH     r6,r1                 ;1567
0000b0  1f9b              SUBS     r3,r3,#6
0000b2  1f92              SUBS     r2,r2,#6
0000b4  b288              UXTH     r0,r1
0000b6  b29b              UXTH     r3,r3
0000b8  b292              UXTH     r2,r2
0000ba  4639              MOV      r1,r7
0000bc  f7fffffe          BL       LCD_Fill_Rect
;;;1571   	LCD_DispStrEx(x, y, _pBtn->pCaption, &font, _pBtn->Width - 6, ALIGN_CENTER);	/* 水平居中 */		
0000c0  8920              LDRH     r0,[r4,#8]
0000c2  2101              MOVS     r1,#1
0000c4  1f80              SUBS     r0,r0,#6
0000c6  b280              UXTH     r0,r0
0000c8  e9cd0100          STRD     r0,r1,[sp,#0]
0000cc  ab02              ADD      r3,sp,#8
0000ce  4629              MOV      r1,r5
0000d0  4630              MOV      r0,r6
0000d2  6922              LDR      r2,[r4,#0x10]
0000d4  f7fffffe          BL       LCD_DispStrEx
;;;1572   
;;;1573   #else
;;;1574   	if (g_ChipID == IC_8875)
;;;1575   	{
;;;1576   		uint16_t len, x, y;
;;;1577   
;;;1578   		if (_pBtn->Focus == 1)
;;;1579   		{
;;;1580   			/* 仿XP风格，平面编辑框 */
;;;1581   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1582   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1583   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1584   
;;;1585   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_ACTIVE_COLOR);
;;;1586   
;;;1587   			RA8875_SetBackColor(BUTTON_ACTIVE_COLOR);
;;;1588   		}
;;;1589   		else
;;;1590   		{
;;;1591   			/* 仿XP风格，平面编辑框 */
;;;1592   			RA8875_DrawRect(_pBtn->Left, _pBtn->Top, _pBtn->Height, _pBtn->Width, BUTTON_BORDER_COLOR);
;;;1593   			RA8875_DrawRect(_pBtn->Left + 1, _pBtn->Top + 1, _pBtn->Height - 2, _pBtn->Width - 2, BUTTON_BORDER1_COLOR);
;;;1594   			RA8875_DrawRect(_pBtn->Left + 2, _pBtn->Top + 2, _pBtn->Height - 4, _pBtn->Width - 4, BUTTON_BORDER2_COLOR);
;;;1595   
;;;1596   			RA8875_FillRect(_pBtn->Left + 3, _pBtn->Top + 3, _pBtn->Height - 6, _pBtn->Width - 6, BUTTON_BACK_COLOR);
;;;1597   
;;;1598   			RA8875_SetBackColor(BUTTON_BACK_COLOR);
;;;1599   		}
;;;1600   
;;;1601   		#if 1	/* 按钮文字字体和颜色固定 */
;;;1602   			if (strcmp(_pBtn->Caption, "←") == 0)	/* 退格键特殊处理 */
;;;1603   			{
;;;1604   				/* 退格键符号是单像素笔画，太细了不协调，因此特殊处理 */
;;;1605   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1606   				RA8875_SetFrontColor(CL_BLACK);
;;;1607   				RA8875_SetTextZoom(RA_SIZE_X2, RA_SIZE_X2);	/* 放大2倍 */
;;;1608   			}
;;;1609   			else
;;;1610   			{
;;;1611   				RA8875_SetFont(RA_FONT_16, 0, 0);
;;;1612   				RA8875_SetFrontColor(CL_BLACK);
;;;1613   				RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 放大1倍 */
;;;1614   			}
;;;1615   		#else	/* 按钮文字字体和颜色有应用程序指定 */
;;;1616   			RA8875_SetFont(_pBtn->Font.FontCode, 0, 0);
;;;1617   			RA8875_SetFrontColor(_pBtn->Font.FrontColor);
;;;1618   		#endif
;;;1619   
;;;1620   		/* 文字居中 */
;;;1621   		len = strlen(_pBtn->Caption);
;;;1622   
;;;1623   		/* 此处统计不等宽字符有问题。暂时特殊处理下 */
;;;1624   		if (len != 3)
;;;1625   		{
;;;1626   			x = _pBtn->Left + (_pBtn->Width - len * 16) / 2;
;;;1627   		}
;;;1628   		else
;;;1629   		{
;;;1630   			x = _pBtn->Left + (_pBtn->Width - len * 20) / 2;
;;;1631   		}
;;;1632   
;;;1633   		/* 对特殊字符特殊处理 */
;;;1634   		if ((len == 1) && (_pBtn->Caption[0] == '.'))
;;;1635   		{
;;;1636   			y = _pBtn->Top + 3;
;;;1637   			x += 3;
;;;1638   		}
;;;1639   		else
;;;1640   		{
;;;1641   			y = _pBtn->Top + 3;
;;;1642   		}
;;;1643   
;;;1644   		RA8875_DispStr(x, y, _pBtn->Caption);
;;;1645   
;;;1646   		RA8875_SetTextZoom(RA_SIZE_X1, RA_SIZE_X1);	/* 还原放大1倍 */
;;;1647   	}
;;;1648   #endif
;;;1649   }
0000d8  e8bd81ff          POP      {r0-r8,pc}
                  |L12.220|
0000dc  f64770ff          MOV      r0,#0x7fff            ;1553
0000e0  e7a6              B        |L12.48|
;;;1650   
                          ENDP


                          AREA ||i.LCD_DrawCheckBox||, CODE, READONLY, ALIGN=2

                  LCD_DrawCheckBox PROC
;;;1406   */
;;;1407   void LCD_DrawCheckBox(CHECK_T *_pCheckBox)
000000  b57c              PUSH     {r2-r6,lr}
;;;1408   {
;;;1409   #if 1
;;;1410   	uint16_t x, y;
;;;1411   
;;;1412   	/* 目前只做了16点阵汉字的大小 */
;;;1413   
;;;1414   	/* 绘制外框 */
;;;1415   	x = _pCheckBox->Left;
000002  8845              LDRH     r5,[r0,#2]
;;;1416   	LCD_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
000004  2610              MOVS     r6,#0x10
000006  9600              STR      r6,[sp,#0]
000008  4604              MOV      r4,r0                 ;1408
00000a  8881              LDRH     r1,[r0,#4]
00000c  2318              MOVS     r3,#0x18
00000e  461a              MOV      r2,r3
000010  4628              MOV      r0,r5
000012  f7fffffe          BL       LCD_DrawRect
;;;1417   	LCD_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
000016  9600              STR      r6,[sp,#0]
000018  88a0              LDRH     r0,[r4,#4]
00001a  2316              MOVS     r3,#0x16
00001c  1c40              ADDS     r0,r0,#1
00001e  b281              UXTH     r1,r0
000020  1c68              ADDS     r0,r5,#1
000022  b280              UXTH     r0,r0
000024  461a              MOV      r2,r3
000026  f7fffffe          BL       LCD_DrawRect
;;;1418   	LCD_Fill_Rect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
00002a  f64c6059          MOV      r0,#0xce59
00002e  9000              STR      r0,[sp,#0]
000030  88a0              LDRH     r0,[r4,#4]
000032  1cad              ADDS     r5,r5,#2
000034  1c80              ADDS     r0,r0,#2
000036  b281              UXTH     r1,r0
000038  2314              MOVS     r3,#0x14
00003a  b2a8              UXTH     r0,r5
00003c  461a              MOV      r2,r3
00003e  f7fffffe          BL       LCD_Fill_Rect
;;;1419   
;;;1420   	/* 绘制文本标签 */
;;;1421   	x = _pCheckBox->Left + CHECK_BOX_W + 2;
000042  8860              LDRH     r0,[r4,#2]
;;;1422   	y = _pCheckBox->Top + CHECK_BOX_H / 2 - 8;
000044  88a1              LDRH     r1,[r4,#4]
000046  e9d43203          LDRD     r3,r2,[r4,#0xc]
00004a  301a              ADDS     r0,r0,#0x1a           ;1421
00004c  1d09              ADDS     r1,r1,#4
00004e  b280              UXTH     r0,r0                 ;1421
000050  b289              UXTH     r1,r1
;;;1423   	LCD_DispStr(x, y, _pCheckBox->pCaption, _pCheckBox->Font);
000052  f7fffffe          BL       LCD_DispStr
;;;1424   
;;;1425   	if (_pCheckBox->Checked)
000056  7d20              LDRB     r0,[r4,#0x14]
000058  2800              CMP      r0,#0
00005a  d017              BEQ      |L13.140|
;;;1426   	{
;;;1427   		FONT_T font;
;;;1428   
;;;1429   	    font.FontCode = FC_ST_16;
00005c  2001              MOVS     r0,#1
00005e  f88d0000          STRB     r0,[sp,#0]
;;;1430   		font.BackColor = CL_MASK;
000062  f6491099          MOV      r0,#0x9999
000066  f8ad0004          STRH     r0,[sp,#4]
;;;1431   		font.FrontColor = CHECK_BOX_CHECKED_COLOR;	/* 钩的颜色 */
00006a  f44f4078          MOV      r0,#0xf800
00006e  f8ad0002          STRH     r0,[sp,#2]
;;;1432   		font.Space = 0;
000072  2000              MOVS     r0,#0
000074  f8ad0006          STRH     r0,[sp,#6]
;;;1433   		x = _pCheckBox->Left;
000078  8860              LDRH     r0,[r4,#2]
;;;1434   		LCD_DispStr(x + 3, _pCheckBox->Top + 3, "√", &font);
00007a  88a1              LDRH     r1,[r4,#4]
00007c  1cc0              ADDS     r0,r0,#3
00007e  1cc9              ADDS     r1,r1,#3
000080  b289              UXTH     r1,r1
000082  b280              UXTH     r0,r0
000084  466b              MOV      r3,sp
000086  a202              ADR      r2,|L13.144|
000088  f7fffffe          BL       LCD_DispStr
                  |L13.140|
;;;1435   	}
;;;1436   #else
;;;1437   	if (g_ChipID == IC_8875)
;;;1438   	{
;;;1439   		uint16_t x;
;;;1440   
;;;1441   		RA8875_SetFont(_pCheckBox->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1442   
;;;1443   		/* 绘制标签 */
;;;1444   		//RA8875_SetBackColor(_pCheckBox->Font.BackColor);
;;;1445   		RA8875_SetBackColor(WIN_BODY_COLOR);
;;;1446   		RA8875_SetFrontColor(_pCheckBox->Font.FrontColor);
;;;1447   		RA8875_DispStr(_pCheckBox->Left, _pCheckBox->Top, _pCheckBox->Caption);
;;;1448   
;;;1449   		/* 绘制外框 */
;;;1450   		x = _pCheckBox->Left + _pCheckBox->Width - CHECK_BOX_W;
;;;1451   		RA8875_DrawRect(x, _pCheckBox->Top, CHECK_BOX_H, CHECK_BOX_W, CHECK_BOX_BORDER_COLOR);
;;;1452   		RA8875_DrawRect(x + 1, _pCheckBox->Top + 1, CHECK_BOX_H - 2, CHECK_BOX_W - 2, CHECK_BOX_BORDER_COLOR);
;;;1453   		RA8875_FillRect(x + 2, _pCheckBox->Top + 2, CHECK_BOX_H - 4, CHECK_BOX_W - 4, CHECK_BOX_BACK_COLOR);
;;;1454   
;;;1455   		if (_pCheckBox->Checked)
;;;1456   		{
;;;1457   			RA8875_SetBackColor(CHECK_BOX_BACK_COLOR);
;;;1458   			RA8875_SetFrontColor(CL_RED);
;;;1459   			RA8875_DispStr(x + 3, _pCheckBox->Top + 3, "√");
;;;1460   		}
;;;1461   	}
;;;1462   	else
;;;1463   	{
;;;1464   
;;;1465   	}
;;;1466   #endif
;;;1467   
;;;1468   }
00008c  bd7c              POP      {r2-r6,pc}
;;;1469   
                          ENDP

00008e  0000              DCW      0x0000
                  |L13.144|
000090  a1cc00            DCB      161,204,0
000093  00                DCB      0

                          AREA ||i.LCD_DrawCircle||, CODE, READONLY, ALIGN=2

                  LCD_DrawCircle PROC
;;;946    */
;;;947    void LCD_DrawCircle(uint16_t _usX, uint16_t _usY, uint16_t _usRadius, uint16_t _usColor)
000000  b430              PUSH     {r4,r5}
;;;948    {
;;;949    	if (g_ChipID == IC_8875)
000002  4c08              LDR      r4,|L14.36|
000004  8864              LDRH     r4,[r4,#2]  ; g_ChipID
000006  2c75              CMP      r4,#0x75
000008  d009              BEQ      |L14.30|
;;;950    	{
;;;951    		RA8875_DrawCircle(_usX, _usY, _usRadius, _usColor);
;;;952    	}
;;;953    	else if (g_ChipID == IC_9488)
00000a  f5a44514          SUB      r5,r4,#0x9400
00000e  3d88              SUBS     r5,r5,#0x88
000010  d002              BEQ      |L14.24|
;;;954    	{
;;;955    		ILI9488_DrawCircle(_usX, _usY, _usRadius, _usColor);
;;;956    	}
;;;957    	else
;;;958    	{
;;;959    		SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
000012  bc30              POP      {r4,r5}
000014  f7ffbffe          B.W      SPFD5420_DrawCircle
                  |L14.24|
000018  bc30              POP      {r4,r5}               ;955
00001a  f7ffbffe          B.W      ILI9488_DrawCircle
                  |L14.30|
00001e  bc30              POP      {r4,r5}               ;951
000020  f7ffbffe          B.W      RA8875_DrawCircle
;;;960    	}
;;;961    }
;;;962    
                          ENDP

                  |L14.36|
                          DCD      ||.data||

                          AREA ||i.LCD_DrawEdit||, CODE, READONLY, ALIGN=1

                  LCD_DrawEdit PROC
;;;1477   */
;;;1478   void LCD_DrawEdit(EDIT_T *_pEdit)
000000  b538              PUSH     {r3-r5,lr}
;;;1479   {
000002  4604              MOV      r4,r0
;;;1480   #if 1
;;;1481   	uint16_t len, x, y;
;;;1482   	uint8_t width;
;;;1483   
;;;1484   	/* 仿XP风格，平面编辑框 */
;;;1485   	LCD_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
000004  2010              MOVS     r0,#0x10
000006  9000              STR      r0,[sp,#0]
000008  8923              LDRH     r3,[r4,#8]
00000a  88e2              LDRH     r2,[r4,#6]
00000c  88a1              LDRH     r1,[r4,#4]
00000e  8860              LDRH     r0,[r4,#2]
000010  f7fffffe          BL       LCD_DrawRect
;;;1486   	LCD_Fill_Rect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
000014  f64f70ff          MOV      r0,#0xffff
000018  9000              STR      r0,[sp,#0]
00001a  8920              LDRH     r0,[r4,#8]
00001c  1e80              SUBS     r0,r0,#2
00001e  b283              UXTH     r3,r0
000020  88e0              LDRH     r0,[r4,#6]
000022  1e80              SUBS     r0,r0,#2
000024  b282              UXTH     r2,r0
000026  88a0              LDRH     r0,[r4,#4]
000028  1c40              ADDS     r0,r0,#1
00002a  b281              UXTH     r1,r0
00002c  8860              LDRH     r0,[r4,#2]
00002e  1c40              ADDS     r0,r0,#1
000030  b280              UXTH     r0,r0
000032  f7fffffe          BL       LCD_Fill_Rect
;;;1487   
;;;1488   	/* 文字居中 */
;;;1489   	if (_pEdit->Font->FontCode == FC_ST_12)
000036  68e0              LDR      r0,[r4,#0xc]
000038  7800              LDRB     r0,[r0,#0]
00003a  b1d0              CBZ      r0,|L15.114|
;;;1490   	{
;;;1491   		width = 6;
;;;1492   	}
;;;1493   	else
;;;1494   	{
;;;1495   		width = 8;
00003c  2508              MOVS     r5,#8
                  |L15.62|
;;;1496   	}
;;;1497   	len = strlen(_pEdit->pCaption);
00003e  6920              LDR      r0,[r4,#0x10]
000040  f7fffffe          BL       strlen
;;;1498   	x = _pEdit->Left +  (_pEdit->Width - len * width) / 2;
000044  8921              LDRH     r1,[r4,#8]
000046  b280              UXTH     r0,r0                 ;1497
000048  fb001015          MLS      r0,r0,r5,r1
00004c  8861              LDRH     r1,[r4,#2]
00004e  eb0070d0          ADD      r0,r0,r0,LSR #31
000052  eb010060          ADD      r0,r1,r0,ASR #1
;;;1499   	y = _pEdit->Top + _pEdit->Height / 2 - width;
000056  88a1              LDRH     r1,[r4,#4]
000058  88e2              LDRH     r2,[r4,#6]
00005a  b280              UXTH     r0,r0                 ;1498
00005c  eb010152          ADD      r1,r1,r2,LSR #1
000060  e9d43203          LDRD     r3,r2,[r4,#0xc]
000064  1b49              SUBS     r1,r1,r5
;;;1500   
;;;1501   	LCD_DispStr(x, y, _pEdit->pCaption, _pEdit->Font);
000066  b001              ADD      sp,sp,#4
000068  b289              UXTH     r1,r1                 ;1499
00006a  e8bd4030          POP      {r4,r5,lr}
00006e  f7ffbffe          B.W      LCD_DispStr
                  |L15.114|
000072  2506              MOVS     r5,#6                 ;1491
000074  e7e3              B        |L15.62|
;;;1502   #else
;;;1503   	if (g_ChipID == IC_8875)
;;;1504   	{
;;;1505   		uint16_t len, x;
;;;1506   
;;;1507   		/* 仿XP风格，平面编辑框 */
;;;1508   		RA8875_DrawRect(_pEdit->Left, _pEdit->Top, _pEdit->Height, _pEdit->Width, EDIT_BORDER_COLOR);
;;;1509   		RA8875_FillRect(_pEdit->Left + 1, _pEdit->Top + 1, _pEdit->Height - 2, _pEdit->Width - 2, EDIT_BACK_COLOR);
;;;1510   
;;;1511   		RA8875_SetFont(_pEdit->Font.FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1512   		RA8875_SetFrontColor(_pEdit->Font.FrontColor);
;;;1513   		RA8875_SetBackColor(EDIT_BACK_COLOR);
;;;1514   
;;;1515   		/* 文字居中 */
;;;1516   		len = strlen(_pEdit->Caption);
;;;1517   		x = (_pEdit->Width - len * 16) / 2;
;;;1518   
;;;1519   		RA8875_DispStr(_pEdit->Left + x, _pEdit->Top + 3, _pEdit->Caption);
;;;1520   	}
;;;1521   	else
;;;1522   	{
;;;1523   		//SPFD5420_DrawCircle(_usX, _usY, _usRadius, _usColor);
;;;1524   	}
;;;1525   #endif
;;;1526   }
;;;1527   
                          ENDP


                          AREA ||i.LCD_DrawGroupBox||, CODE, READONLY, ALIGN=1

                  LCD_DrawGroupBox PROC
;;;1658   */
;;;1659   void LCD_DrawGroupBox(GROUP_T *_pBox)
000000  b538              PUSH     {r3-r5,lr}
;;;1660   {
000002  4604              MOV      r4,r0
;;;1661   	uint16_t x, y;
;;;1662   
;;;1663   	/* 画阴影线 */
;;;1664   	LCD_DrawRect(_pBox->Left + 1, _pBox->Top + 5, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER2);
000004  f64f70ff          MOV      r0,#0xffff
000008  9000              STR      r0,[sp,#0]
00000a  8920              LDRH     r0,[r4,#8]
00000c  88e2              LDRH     r2,[r4,#6]
00000e  1e40              SUBS     r0,r0,#1
000010  b283              UXTH     r3,r0
000012  88a0              LDRH     r0,[r4,#4]
000014  1d40              ADDS     r0,r0,#5
000016  b281              UXTH     r1,r0
000018  8860              LDRH     r0,[r4,#2]
00001a  1c40              ADDS     r0,r0,#1
00001c  b280              UXTH     r0,r0
00001e  f7fffffe          BL       LCD_DrawRect
;;;1665   
;;;1666   	/* 画主框线 */
;;;1667   	LCD_DrawRect(_pBox->Left, _pBox->Top + 4, _pBox->Height, _pBox->Width - 1, CL_BOX_BORDER1);
000022  f64a5053          MOV      r0,#0xad53
000026  9000              STR      r0,[sp,#0]
000028  8920              LDRH     r0,[r4,#8]
00002a  88e2              LDRH     r2,[r4,#6]
00002c  1e40              SUBS     r0,r0,#1
00002e  b283              UXTH     r3,r0
000030  88a0              LDRH     r0,[r4,#4]
000032  1d00              ADDS     r0,r0,#4
000034  b281              UXTH     r1,r0
000036  8860              LDRH     r0,[r4,#2]
000038  f7fffffe          BL       LCD_DrawRect
;;;1668   
;;;1669   	/* 显示分组框标题（文字在左上角） */
;;;1670   	x = _pBox->Left + 9;
00003c  8860              LDRH     r0,[r4,#2]
;;;1671   	y = _pBox->Top;
00003e  e9d43203          LDRD     r3,r2,[r4,#0xc]
000042  88a1              LDRH     r1,[r4,#4]
;;;1672   	LCD_DispStr(x, y, _pBox->pCaption, _pBox->Font);
000044  b001              ADD      sp,sp,#4
000046  3009              ADDS     r0,r0,#9              ;1670
000048  e8bd4030          POP      {r4,r5,lr}
00004c  b280              UXTH     r0,r0                 ;1670
00004e  f7ffbffe          B.W      LCD_DispStr
;;;1673   }
;;;1674   
                          ENDP


                          AREA ||i.LCD_DrawIcon||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon PROC
;;;1059   */
;;;1060   void LCD_DrawIcon(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1061   {
000004  4691              MOV      r9,r2
000006  4688              MOV      r8,r1
000008  4606              MOV      r6,r0
;;;1062   	const uint16_t *p;
;;;1063   	uint16_t usNewRGB;
;;;1064   	uint16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;1065   
;;;1066   	p = _tIcon->pBmp;
;;;1067   	for (y = 0; y < _tIcon->Height; y++)
00000a  2500              MOVS     r5,#0
00000c  68c7              LDR      r7,[r0,#0xc]          ;1061
00000e  e081              B        |L17.276|
                  |L17.16|
;;;1068   	{
;;;1069   		for (x = 0; x < _tIcon->Width; x++)
000010  2400              MOVS     r4,#0
000012  e07a              B        |L17.266|
                  |L17.20|
;;;1070   		{
;;;1071   			usNewRGB = *p++;	/* 读取图标的颜色值后指针加1 */
000014  f8372b02          LDRH     r2,[r7],#2
;;;1072   			/* 将图标的4个直角切割为弧角，弧角外是背景图标 */
;;;1073   			if ((y == 0 && (x < 6 || x > _tIcon->Width - 7)) ||
000018  b155              CBZ      r5,|L17.48|
;;;1074   				(y == 1 && (x < 4 || x > _tIcon->Width - 5)) ||
00001a  2d01              CMP      r5,#1
00001c  d00c              BEQ      |L17.56|
;;;1075   				(y == 2 && (x < 3 || x > _tIcon->Width - 4)) ||
00001e  2d02              CMP      r5,#2
000020  d00e              BEQ      |L17.64|
;;;1076   				(y == 3 && (x < 2 || x > _tIcon->Width - 3)) ||
000022  2d03              CMP      r5,#3
000024  d010              BEQ      |L17.72|
;;;1077   				(y == 4 && (x < 1 || x > _tIcon->Width - 2)) ||
000026  2d04              CMP      r5,#4
000028  d012              BEQ      |L17.80|
;;;1078   				(y == 5 && (x < 1 || x > _tIcon->Width - 2))	||
00002a  2d05              CMP      r5,#5
00002c  d010              BEQ      |L17.80|
00002e  e013              B        |L17.88|
                  |L17.48|
000030  2c06              CMP      r4,#6                 ;1073
000032  d368              BCC      |L17.262|
000034  1fc1              SUBS     r1,r0,#7              ;1073
000036  e00d              B        |L17.84|
                  |L17.56|
000038  2c04              CMP      r4,#4                 ;1074
00003a  d364              BCC      |L17.262|
00003c  1f41              SUBS     r1,r0,#5              ;1074
00003e  e009              B        |L17.84|
                  |L17.64|
000040  2c03              CMP      r4,#3                 ;1075
000042  d360              BCC      |L17.262|
000044  1f01              SUBS     r1,r0,#4              ;1075
000046  e005              B        |L17.84|
                  |L17.72|
000048  2c02              CMP      r4,#2                 ;1076
00004a  d35c              BCC      |L17.262|
00004c  1ec1              SUBS     r1,r0,#3              ;1076
00004e  e001              B        |L17.84|
                  |L17.80|
000050  b3f4              CBZ      r4,|L17.208|
000052  1e81              SUBS     r1,r0,#2
                  |L17.84|
000054  42a1              CMP      r1,r4                 ;1077
000056  db56              BLT      |L17.262|
                  |L17.88|
;;;1079   
;;;1080   				(y == _tIcon->Height - 1 && (x < 6 || x > _tIcon->Width - 7)) ||
000058  88f1              LDRH     r1,[r6,#6]
00005a  1e4b              SUBS     r3,r1,#1
00005c  42ab              CMP      r3,r5
00005e  d104              BNE      |L17.106|
000060  2c06              CMP      r4,#6
000062  d350              BCC      |L17.262|
000064  1fc3              SUBS     r3,r0,#7
000066  42a3              CMP      r3,r4
000068  db4d              BLT      |L17.262|
                  |L17.106|
;;;1081   				(y == _tIcon->Height - 2 && (x < 4 || x > _tIcon->Width - 5)) ||
00006a  1e8b              SUBS     r3,r1,#2
00006c  42ab              CMP      r3,r5
00006e  d104              BNE      |L17.122|
000070  2c04              CMP      r4,#4
000072  d348              BCC      |L17.262|
000074  1f43              SUBS     r3,r0,#5
000076  42a3              CMP      r3,r4
000078  db45              BLT      |L17.262|
                  |L17.122|
;;;1082   				(y == _tIcon->Height - 3 && (x < 3 || x > _tIcon->Width - 4)) ||
00007a  1ecb              SUBS     r3,r1,#3
00007c  42ab              CMP      r3,r5
00007e  d104              BNE      |L17.138|
000080  2c03              CMP      r4,#3
000082  d340              BCC      |L17.262|
000084  1f03              SUBS     r3,r0,#4
000086  42a3              CMP      r3,r4
000088  db3d              BLT      |L17.262|
                  |L17.138|
;;;1083   				(y == _tIcon->Height - 4 && (x < 2 || x > _tIcon->Width - 3)) ||
00008a  1f0b              SUBS     r3,r1,#4
00008c  42ab              CMP      r3,r5
00008e  d104              BNE      |L17.154|
000090  2c02              CMP      r4,#2
000092  d338              BCC      |L17.262|
000094  1ec3              SUBS     r3,r0,#3
000096  42a3              CMP      r3,r4
000098  db35              BLT      |L17.262|
                  |L17.154|
;;;1084   				(y == _tIcon->Height - 5 && (x < 1 || x > _tIcon->Width - 2)) ||
00009a  1f4b              SUBS     r3,r1,#5
00009c  42ab              CMP      r3,r5
00009e  d103              BNE      |L17.168|
0000a0  b1b4              CBZ      r4,|L17.208|
0000a2  1e83              SUBS     r3,r0,#2
0000a4  42a3              CMP      r3,r4
0000a6  db2e              BLT      |L17.262|
                  |L17.168|
0000a8  1f89              SUBS     r1,r1,#6
;;;1085   				(y == _tIcon->Height - 6 && (x < 1 || x > _tIcon->Width - 2))
0000aa  42a9              CMP      r1,r5
0000ac  d103              BNE      |L17.182|
0000ae  b17c              CBZ      r4,|L17.208|
0000b0  1e80              SUBS     r0,r0,#2
0000b2  42a0              CMP      r0,r4
0000b4  db27              BLT      |L17.262|
                  |L17.182|
;;;1086   				)
;;;1087   			{
;;;1088   				;
;;;1089   			}
;;;1090   			else
;;;1091   			{
;;;1092   				if (_ucFocusMode != 0)	/* 1表示选中的图标 */
0000b6  f1b90f00          CMP      r9,#0
0000ba  d01c              BEQ      |L17.246|
;;;1093   				{
;;;1094   					/* 降低原始像素的亮度，实现图标被激活选中的效果 */
;;;1095   					uint16_t R,G,B;
;;;1096   					uint16_t bright = 15;
;;;1097   
;;;1098   					/* rrrr rggg gggb bbbb */
;;;1099   					R = (usNewRGB & 0xF800) >> 11;
0000bc  0ad0              LSRS     r0,r2,#11
;;;1100   					G = (usNewRGB & 0x07E0) >> 5;
0000be  f3c21145          UBFX     r1,r2,#5,#6
;;;1101   					B =  usNewRGB & 0x001F;
0000c2  f002021f          AND      r2,r2,#0x1f
;;;1102   					if (R > bright)
0000c6  280f              CMP      r0,#0xf
0000c8  d903              BLS      |L17.210|
0000ca  380f              SUBS     r0,r0,#0xf
;;;1103   					{
;;;1104   						R -= bright;
0000cc  b280              UXTH     r0,r0
0000ce  e001              B        |L17.212|
                  |L17.208|
0000d0  e019              B        |L17.262|
                  |L17.210|
;;;1105   					}
;;;1106   					else
;;;1107   					{
;;;1108   						R = 0;
0000d2  2000              MOVS     r0,#0
                  |L17.212|
;;;1109   					}
;;;1110   					if (G > 2 * bright)
0000d4  291e              CMP      r1,#0x1e
0000d6  d902              BLS      |L17.222|
0000d8  391e              SUBS     r1,r1,#0x1e
;;;1111   					{
;;;1112   						G -= 2 * bright;
0000da  b289              UXTH     r1,r1
0000dc  e000              B        |L17.224|
                  |L17.222|
;;;1113   					}
;;;1114   					else
;;;1115   					{
;;;1116   						G = 0;
0000de  2100              MOVS     r1,#0
                  |L17.224|
;;;1117   					}
;;;1118   					if (B > bright)
0000e0  2a0f              CMP      r2,#0xf
0000e2  d902              BLS      |L17.234|
0000e4  3a0f              SUBS     r2,r2,#0xf
;;;1119   					{
;;;1120   						B -= bright;
0000e6  b292              UXTH     r2,r2
0000e8  e000              B        |L17.236|
                  |L17.234|
;;;1121   					}
;;;1122   					else
;;;1123   					{
;;;1124   						B = 0;
0000ea  2200              MOVS     r2,#0
                  |L17.236|
;;;1125   					}
;;;1126   					usNewRGB = (R << 11) + (G << 5) + B;
0000ec  02c0              LSLS     r0,r0,#11
0000ee  eb001041          ADD      r0,r0,r1,LSL #5
0000f2  4410              ADD      r0,r0,r2
0000f4  b282              UXTH     r2,r0
                  |L17.246|
;;;1127   				}
;;;1128   
;;;1129   				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
0000f6  88b0              LDRH     r0,[r6,#4]
0000f8  4428              ADD      r0,r0,r5
0000fa  b281              UXTH     r1,r0
0000fc  8870              LDRH     r0,[r6,#2]
0000fe  4420              ADD      r0,r0,r4
000100  b280              UXTH     r0,r0
000102  f7fffffe          BL       LCD_PutPixel
                  |L17.262|
000106  1c64              ADDS     r4,r4,#1
000108  b2a4              UXTH     r4,r4                 ;1069
                  |L17.266|
00010a  8930              LDRH     r0,[r6,#8]            ;1069
00010c  42a0              CMP      r0,r4                 ;1069
00010e  d881              BHI      |L17.20|
000110  1c6d              ADDS     r5,r5,#1              ;1069
000112  b2ad              UXTH     r5,r5                 ;1067
                  |L17.276|
000114  88f0              LDRH     r0,[r6,#6]            ;1067
000116  42a8              CMP      r0,r5                 ;1067
000118  f63faf7a          BHI      |L17.16|
;;;1130   			}
;;;1131   		}
;;;1132   	}
;;;1133   
;;;1134   	/* 绘制图标下的文字 */
;;;1135   	{
;;;1136   		uint16_t len;
;;;1137   		uint16_t width;
;;;1138   
;;;1139   		len = strlen(_tIcon->Text);
00011c  f1060010          ADD      r0,r6,#0x10
000120  4604              MOV      r4,r0
000122  f7fffffe          BL       strlen
000126  0400              LSLS     r0,r0,#16
000128  0c00              LSRS     r0,r0,#16
;;;1140   
;;;1141   		if  (len == 0)
00012a  d021              BEQ      |L17.368|
;;;1142   		{
;;;1143   			return;	/* 如果图标文本长度为0，则不显示 */
;;;1144   		}
;;;1145   
;;;1146   		/* 计算文本的总宽度 */
;;;1147   		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
00012c  f8982000          LDRB     r2,[r8,#0]
;;;1148   		{
;;;1149   			width = 6 * (len + _tFont->Space);
000130  f64f71ff          MOV      r1,#0xffff
000134  2a00              CMP      r2,#0                 ;1147
;;;1150   		}
;;;1151   		else	/* FC_ST_16 */
;;;1152   		{
;;;1153   			width = 8 * (len + _tFont->Space);
000136  f8b82006          LDRH     r2,[r8,#6]
00013a  4410              ADD      r0,r0,r2
00013c  d013              BEQ      |L17.358|
00013e  ea0100c0          AND      r0,r1,r0,LSL #3
                  |L17.322|
;;;1154   		}
;;;1155   
;;;1156   
;;;1157   		/* 水平居中 */
;;;1158   		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
000142  8871              LDRH     r1,[r6,#2]
000144  8932              LDRH     r2,[r6,#8]
;;;1159   		y = _tIcon->Top + _tIcon->Height + 2;
;;;1160   		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
000146  4643              MOV      r3,r8
000148  eb010152          ADD      r1,r1,r2,LSR #1       ;1158
00014c  eba10050          SUB      r0,r1,r0,LSR #1       ;1158
000150  88b1              LDRH     r1,[r6,#4]            ;1159
000152  88f2              LDRH     r2,[r6,#6]            ;1159
000154  b280              UXTH     r0,r0                 ;1158
000156  4411              ADD      r1,r1,r2              ;1159
000158  4622              MOV      r2,r4
00015a  e8bd47f0          POP      {r4-r10,lr}
00015e  1c89              ADDS     r1,r1,#2              ;1159
000160  b289              UXTH     r1,r1                 ;1159
000162  f7ffbffe          B.W      LCD_DispStr
                  |L17.358|
000166  eb000040          ADD      r0,r0,r0,LSL #1       ;1149
00016a  ea010040          AND      r0,r1,r0,LSL #1       ;1149
00016e  e7e8              B        |L17.322|
                  |L17.368|
;;;1161   	}
;;;1162   }
000170  e8bd87f0          POP      {r4-r10,pc}
;;;1163   
                          ENDP


                          AREA ||i.LCD_DrawIcon32||, CODE, READONLY, ALIGN=1

                  LCD_DrawIcon32 PROC
;;;1194   */
;;;1195   void LCD_DrawIcon32(const ICON_T *_tIcon, FONT_T *_tFont, uint8_t _ucFocusMode)
000000  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;1196   {
000004  4605              MOV      r5,r0
;;;1197   	const uint8_t *p;
;;;1198   	uint16_t usOldRGB, usNewRGB;
;;;1199   	int16_t x, y;		/* 用于记录窗口内的相对坐标 */
;;;1200   	uint8_t R1,G1,B1,A;	/* 新像素色彩分量 */
;;;1201   	uint8_t R0,G0,B0;	/* 旧像素色彩分量 */
;;;1202   
;;;1203   	p = (const uint8_t *)_tIcon->pBmp;
;;;1204   	p += 54;		/* 直接指向图像数据区 */
;;;1205   
;;;1206   	/* 按照BMP位图次序，从左至右，从上至下扫描 */
;;;1207   	for (y = _tIcon->Height - 1; y >= 0; y--)
000006  68c4              LDR      r4,[r0,#0xc]
000008  88c0              LDRH     r0,[r0,#6]
00000a  b082              SUB      sp,sp,#8              ;1196
00000c  1e40              SUBS     r0,r0,#1
00000e  4689              MOV      r9,r1                 ;1196
000010  fa0ff880          SXTH     r8,r0
000014  3436              ADDS     r4,r4,#0x36
000016  e06b              B        |L18.240|
                  |L18.24|
;;;1208   	{
;;;1209   		for (x = 0; x < _tIcon->Width; x++)
000018  2600              MOVS     r6,#0
00001a  e062              B        |L18.226|
                  |L18.28|
;;;1210   		{
;;;1211   			B1 = *p++;
00001c  f814bb01          LDRB     r11,[r4],#1
;;;1212   			G1 = *p++;
000020  f8140b01          LDRB     r0,[r4],#1
;;;1213   			R1 = *p++;
000024  9000              STR      r0,[sp,#0]
000026  f814ab02          LDRB     r10,[r4],#2
;;;1214   			A = *p++;	/* Alpha 值(透明度)，0-255, 0表示透明，1表示不透明, 中间值表示透明度 */
00002a  f8147c01          LDRB     r7,[r4,#-1]
;;;1215   
;;;1216   			if (A == 0x00)	/* 需要透明,显示背景 */
00002e  b3ef              CBZ      r7,|L18.172|
;;;1217   			{
;;;1218   				;	/* 不用刷新背景 */
;;;1219   			}
;;;1220   			else if (A == 0xFF)	/* 完全不透明， 显示新像素 */
000030  2fff              CMP      r7,#0xff
000032  d03f              BEQ      |L18.180|
;;;1221   			{
;;;1222   				usNewRGB = RGB(R1, G1, B1);
;;;1223   				if (_ucFocusMode == 1)
;;;1224   				{
;;;1225   					usNewRGB = LCD_Blend565(usNewRGB, CL_YELLOW, 10);
;;;1226   				}
;;;1227   				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
;;;1228   			}
;;;1229   			else 	/* 半透明 */
;;;1230   			{
;;;1231   				/* 计算公式： 实际显示颜色 = 前景颜色 * Alpha / 255 + 背景颜色 * (255-Alpha) / 255 */
;;;1232   				usOldRGB = LCD_GetPixel(x + _tIcon->Left, y + _tIcon->Top);
000034  88a9              LDRH     r1,[r5,#4]
000036  eb010008          ADD      r0,r1,r8
00003a  b281              UXTH     r1,r0
00003c  8868              LDRH     r0,[r5,#2]
00003e  4430              ADD      r0,r0,r6
000040  b280              UXTH     r0,r0
000042  f7fffffe          BL       LCD_GetPixel
;;;1233   				//usOldRGB = 0xFFFF;
;;;1234   				R0 = RGB565_R(usOldRGB);
000046  21f8              MOVS     r1,#0xf8
000048  ea012310          AND      r3,r1,r0,LSR #8
;;;1235   				G0 = RGB565_G(usOldRGB);
00004c  21fc              MOVS     r1,#0xfc
00004e  ea0102d0          AND      r2,r1,r0,LSR #3
;;;1236   				B0 = RGB565_B(usOldRGB);
000052  06c0              LSLS     r0,r0,#27
000054  ea4f6e10          LSR      lr,r0,#24
;;;1237   
;;;1238   				R1 = (R1 * A) / 255 + R0 * (255 - A) / 255;
000058  fb0af107          MUL      r1,r10,r7
00005c  20ff              MOVS     r0,#0xff
00005e  fbb1fcf0          UDIV     r12,r1,r0
000062  f1c701ff          RSB      r1,r7,#0xff
000066  434b              MULS     r3,r1,r3
000068  fbb3f3f0          UDIV     r3,r3,r0
00006c  4463              ADD      r3,r3,r12
;;;1239   				G1 = (G1 * A) / 255 + G0 * (255 - A) / 255;
00006e  f8ddc000          LDR      r12,[sp,#0]
000072  434a              MULS     r2,r1,r2
000074  fb0cfc07          MUL      r12,r12,r7
000078  fbbcfcf0          UDIV     r12,r12,r0
00007c  fbb2f2f0          UDIV     r2,r2,r0
000080  4462              ADD      r2,r2,r12
;;;1240   				B1 = (B1 * A) / 255 + B0 * (255 - A) / 255;
000082  fb0bfc07          MUL      r12,r11,r7
000086  fbbcf7f0          UDIV     r7,r12,r0
00008a  fb01f10e          MUL      r1,r1,lr
00008e  fbb1f0f0          UDIV     r0,r1,r0
;;;1241   				usNewRGB = RGB(R1, G1, B1);
000092  f3c301c4          UBFX     r1,r3,#3,#5
000096  4438              ADD      r0,r0,r7              ;1240
000098  02c9              LSLS     r1,r1,#11
00009a  f3c20285          UBFX     r2,r2,#2,#6
00009e  b2c0              UXTB     r0,r0                 ;1240
0000a0  ea411142          ORR      r1,r1,r2,LSL #5
0000a4  ea4100d0          ORR      r0,r1,r0,LSR #3
                  |L18.168|
;;;1242   				if (_ucFocusMode == 1)
0000a8  9904              LDR      r1,[sp,#0x10]
0000aa  e000              B        |L18.174|
                  |L18.172|
0000ac  e017              B        |L18.222|
                  |L18.174|
0000ae  2901              CMP      r1,#1
0000b0  d047              BEQ      |L18.322|
0000b2  e009              B        |L18.200|
                  |L18.180|
0000b4  ea4f00da          LSR      r0,r10,#3             ;1222
0000b8  02c1              LSLS     r1,r0,#11             ;1222
0000ba  9800              LDR      r0,[sp,#0]            ;1222
0000bc  0880              LSRS     r0,r0,#2              ;1222
0000be  ea411140          ORR      r1,r1,r0,LSL #5       ;1222
0000c2  ea4100db          ORR      r0,r1,r11,LSR #3      ;1222
0000c6  e7ef              B        |L18.168|
                  |L18.200|
0000c8  88aa              LDRH     r2,[r5,#4]            ;1227
0000ca  eb020108          ADD      r1,r2,r8              ;1227
0000ce  886a              LDRH     r2,[r5,#2]            ;1227
0000d0  b289              UXTH     r1,r1                 ;1227
0000d2  4432              ADD      r2,r2,r6              ;1227
0000d4  b293              UXTH     r3,r2                 ;1227
0000d6  4602              MOV      r2,r0                 ;1227
0000d8  4618              MOV      r0,r3                 ;1227
0000da  f7fffffe          BL       LCD_PutPixel
                  |L18.222|
0000de  1c76              ADDS     r6,r6,#1              ;1227
0000e0  b236              SXTH     r6,r6                 ;1209
                  |L18.226|
0000e2  8928              LDRH     r0,[r5,#8]            ;1209
0000e4  42b0              CMP      r0,r6                 ;1209
0000e6  dc99              BGT      |L18.28|
0000e8  f1a80001          SUB      r0,r8,#1              ;1207
0000ec  fa0ff880          SXTH     r8,r0                 ;1207
                  |L18.240|
0000f0  f1b80f00          CMP      r8,#0                 ;1207
0000f4  da90              BGE      |L18.24|
;;;1243   				{
;;;1244   					usNewRGB = LCD_Blend565(usNewRGB, CL_YELLOW, 10);
;;;1245   				}
;;;1246   				LCD_PutPixel(x + _tIcon->Left, y + _tIcon->Top, usNewRGB);
;;;1247   			}
;;;1248   		}
;;;1249   	}
;;;1250   
;;;1251   	/* 绘制图标下的文字 */
;;;1252   	{
;;;1253   		uint16_t len;
;;;1254   		uint16_t width;
;;;1255   
;;;1256   		len = strlen(_tIcon->Text);
0000f6  f1050010          ADD      r0,r5,#0x10
0000fa  4604              MOV      r4,r0
0000fc  f7fffffe          BL       strlen
000100  0400              LSLS     r0,r0,#16
000102  0c00              LSRS     r0,r0,#16
;;;1257   
;;;1258   		if  (len == 0)
000104  d028              BEQ      |L18.344|
;;;1259   		{
;;;1260   			return;	/* 如果图标文本长度为0，则不显示 */
;;;1261   		}
;;;1262   
;;;1263   		/* 计算文本的总宽度 */
;;;1264   		if (_tFont->FontCode == FC_ST_12)		/* 12点阵 */
000106  f8992000          LDRB     r2,[r9,#0]
;;;1265   		{
;;;1266   			width = 6 * (len + _tFont->Space);
00010a  f64f71ff          MOV      r1,#0xffff
00010e  2a00              CMP      r2,#0                 ;1264
;;;1267   		}
;;;1268   		else	/* FC_ST_16 */
;;;1269   		{
;;;1270   			width = 8 * (len + _tFont->Space);
000110  f8b92006          LDRH     r2,[r9,#6]
000114  4410              ADD      r0,r0,r2
000116  d01a              BEQ      |L18.334|
000118  ea0100c0          AND      r0,r1,r0,LSL #3
                  |L18.284|
;;;1271   		}
;;;1272   
;;;1273   
;;;1274   		/* 水平居中 */
;;;1275   		x = (_tIcon->Left + _tIcon->Width / 2) - width / 2;
00011c  8869              LDRH     r1,[r5,#2]
00011e  892a              LDRH     r2,[r5,#8]
;;;1276   		y = _tIcon->Top + _tIcon->Height + 2;
;;;1277   		LCD_DispStr(x, y, (char *)_tIcon->Text, _tFont);
000120  464b              MOV      r3,r9
000122  eb010152          ADD      r1,r1,r2,LSR #1       ;1275
000126  eba10050          SUB      r0,r1,r0,LSR #1       ;1275
00012a  88a9              LDRH     r1,[r5,#4]            ;1276
00012c  88ea              LDRH     r2,[r5,#6]            ;1276
00012e  b005              ADD      sp,sp,#0x14
000130  4411              ADD      r1,r1,r2              ;1276
000132  4622              MOV      r2,r4
000134  e8bd4ff0          POP      {r4-r11,lr}
000138  1c89              ADDS     r1,r1,#2              ;1276
00013a  b289              UXTH     r1,r1
00013c  b280              UXTH     r0,r0
00013e  f7ffbffe          B.W      LCD_DispStr
                  |L18.322|
000142  220a              MOVS     r2,#0xa               ;1244
000144  f64f71e0          MOV      r1,#0xffe0            ;1244
000148  f7fffffe          BL       LCD_Blend565
00014c  e7bc              B        |L18.200|
                  |L18.334|
00014e  eb000040          ADD      r0,r0,r0,LSL #1       ;1266
000152  ea010040          AND      r0,r1,r0,LSL #1       ;1266
000156  e7e1              B        |L18.284|
                  |L18.344|
;;;1278   	}
;;;1279   }
000158  b005              ADD      sp,sp,#0x14
00015a  e8bd8ff0          POP      {r4-r11,pc}
;;;1280   
                          ENDP


                          AREA ||i.LCD_DrawLabel||, CODE, READONLY, ALIGN=1

                  LCD_DrawLabel PROC
;;;1354   */
;;;1355   void LCD_DrawLabel(LABEL_T *_pLabel)
000000  b530              PUSH     {r4,r5,lr}
;;;1356   {
000002  4604              MOV      r4,r0
000004  b0c1              SUB      sp,sp,#0x104
;;;1357   #if 1
;;;1358   	char dispbuf[256];
;;;1359   	uint16_t i;
;;;1360   	uint16_t NewLen;
;;;1361   
;;;1362   	NewLen = strlen(_pLabel->pCaption);
000006  6900              LDR      r0,[r0,#0x10]
000008  f7fffffe          BL       strlen
00000c  b285              UXTH     r5,r0
;;;1363   
;;;1364   	if (NewLen > _pLabel->MaxLen)
00000e  8960              LDRH     r0,[r4,#0xa]
000010  42a8              CMP      r0,r5
000012  d208              BCS      |L19.38|
000014  e9d43203          LDRD     r3,r2,[r4,#0xc]
;;;1365   	{
;;;1366   		LCD_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->pCaption, _pLabel->Font);
000018  88a1              LDRH     r1,[r4,#4]
00001a  8860              LDRH     r0,[r4,#2]
00001c  f7fffffe          BL       LCD_DispStr
;;;1367   		_pLabel->MaxLen = NewLen;
000020  8165              STRH     r5,[r4,#0xa]
                  |L19.34|
;;;1368   	}
;;;1369   	else
;;;1370   	{
;;;1371   		for (i = 0; i < NewLen; i++)
;;;1372   		{
;;;1373   			dispbuf[i] = _pLabel->pCaption[i];
;;;1374   		}
;;;1375   		for (; i < _pLabel->MaxLen; i++)
;;;1376   		{
;;;1377   			dispbuf[i] = ' ';		/* 末尾填充空格 */
;;;1378   		}
;;;1379   		dispbuf[i] = 0;
;;;1380   		LCD_DispStr(_pLabel->Left, _pLabel->Top, dispbuf, _pLabel->Font);
;;;1381   	}
;;;1382   #else
;;;1383   	if (g_ChipID == IC_8875)
;;;1384   	{
;;;1385   		RA8875_SetFont(_pLabel->Font->FontCode, 0, 0);	/* 设置32点阵字体，行间距=0，字间距=0 */
;;;1386   
;;;1387   		RA8875_SetBackColor(_pLabel->Font->BackColor);
;;;1388   		RA8875_SetFrontColor(_pLabel->Font->FrontColor);
;;;1389   
;;;1390   		RA8875_DispStr(_pLabel->Left, _pLabel->Top, _pLabel->Caption);
;;;1391   	}
;;;1392   	else
;;;1393   	{
;;;1394   
;;;1395   	}
;;;1396   #endif
;;;1397   }
000022  b041              ADD      sp,sp,#0x104
000024  bd30              POP      {r4,r5,pc}
                  |L19.38|
000026  2000              MOVS     r0,#0                 ;1371
000028  4669              MOV      r1,sp                 ;1358
00002a  e004              B        |L19.54|
                  |L19.44|
00002c  6922              LDR      r2,[r4,#0x10]         ;1373
00002e  5c12              LDRB     r2,[r2,r0]            ;1373
000030  540a              STRB     r2,[r1,r0]            ;1373
000032  1c40              ADDS     r0,r0,#1              ;1373
000034  b280              UXTH     r0,r0                 ;1371
                  |L19.54|
000036  42a8              CMP      r0,r5                 ;1371
000038  d3f8              BCC      |L19.44|
00003a  2220              MOVS     r2,#0x20              ;1377
                  |L19.60|
00003c  8963              LDRH     r3,[r4,#0xa]          ;1375
00003e  4283              CMP      r3,r0                 ;1375
000040  d903              BLS      |L19.74|
000042  540a              STRB     r2,[r1,r0]            ;1377
000044  1c40              ADDS     r0,r0,#1              ;1377
000046  b280              UXTH     r0,r0                 ;1375
000048  e7f8              B        |L19.60|
                  |L19.74|
00004a  2200              MOVS     r2,#0                 ;1379
00004c  540a              STRB     r2,[r1,r0]            ;1379
00004e  88a1              LDRH     r1,[r4,#4]            ;1380
000050  8860              LDRH     r0,[r4,#2]            ;1380
000052  466a              MOV      r2,sp                 ;1380
000054  68e3              LDR      r3,[r4,#0xc]          ;1380
000056  f7fffffe          BL       LCD_DispStr
00005a  e7e2              B        |L19.34|
;;;1398   
                          ENDP


                          AREA ||i.LCD_DrawLine||, CODE, READONLY, ALIGN=2

                  LCD_DrawLine PROC
;;;842    */
;;;843    void LCD_DrawLine(uint16_t _usX1 , uint16_t _usY1 , uint16_t _usX2 , uint16_t _usY2 , uint16_t _usColor)
000000  b5f8              PUSH     {r3-r7,lr}
;;;844    {
;;;845    	if (g_ChipID == IC_8875)
000002  4d0a              LDR      r5,|L20.44|
000004  9c06              LDR      r4,[sp,#0x18]
000006  886d              LDRH     r5,[r5,#2]  ; g_ChipID
000008  2d75              CMP      r5,#0x75
00000a  d00a              BEQ      |L20.34|
;;;846    	{
;;;847    		RA8875_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
;;;848    	}
;;;849    	else if (g_ChipID == IC_9488)
00000c  f5a54614          SUB      r6,r5,#0x9400
000010  3e88              SUBS     r6,r6,#0x88
000012  9400              STR      r4,[sp,#0]
000014  d002              BEQ      |L20.28|
;;;850    	{
;;;851    		ILI9488_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
;;;852    	}
;;;853    	else
;;;854    	{
;;;855    		SPFD5420_DrawLine(_usX1 , _usY1 , _usX2, _usY2 , _usColor);
000016  f7fffffe          BL       SPFD5420_DrawLine
;;;856    	}
;;;857    }
00001a  bdf8              POP      {r3-r7,pc}
                  |L20.28|
00001c  f7fffffe          BL       ILI9488_DrawLine
000020  bdf8              POP      {r3-r7,pc}
                  |L20.34|
000022  9400              STR      r4,[sp,#0]            ;847
000024  f7fffffe          BL       RA8875_DrawLine
000028  bdf8              POP      {r3-r7,pc}
;;;858    
                          ENDP

00002a  0000              DCW      0x0000
                  |L20.44|
                          DCD      ||.data||

                          AREA ||i.LCD_DrawPoints||, CODE, READONLY, ALIGN=1

                  LCD_DrawPoints PROC
;;;868    */
;;;869    void LCD_DrawPoints(uint16_t *x, uint16_t *y, uint16_t _usSize, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;870    {
;;;871    	uint16_t i;
;;;872    
;;;873    	for (i = 0 ; i < _usSize - 1; i++)
000004  2400              MOVS     r4,#0
000006  4698              MOV      r8,r3                 ;870
000008  460e              MOV      r6,r1                 ;870
00000a  4607              MOV      r7,r0                 ;870
00000c  1e55              SUBS     r5,r2,#1
00000e  e00f              B        |L21.48|
                  |L21.16|
;;;874    	{
;;;875    		LCD_DrawLine(x[i], y[i], x[i + 1], y[i + 1], _usColor);
000010  eb060044          ADD      r0,r6,r4,LSL #1
000014  f8cd8000          STR      r8,[sp,#0]
000018  8843              LDRH     r3,[r0,#2]
00001a  eb070044          ADD      r0,r7,r4,LSL #1
00001e  f8361014          LDRH     r1,[r6,r4,LSL #1]
000022  8842              LDRH     r2,[r0,#2]
000024  f8370014          LDRH     r0,[r7,r4,LSL #1]
000028  f7fffffe          BL       LCD_DrawLine
00002c  1c64              ADDS     r4,r4,#1
00002e  b2a4              UXTH     r4,r4                 ;873
                  |L21.48|
000030  42ac              CMP      r4,r5                 ;873
000032  dbed              BLT      |L21.16|
;;;876    	}
;;;877    }
000034  e8bd83f8          POP      {r3-r9,pc}
;;;878    
                          ENDP


                          AREA ||i.LCD_DrawRect||, CODE, READONLY, ALIGN=2

                  LCD_DrawRect PROC
;;;889    */
;;;890    void LCD_DrawRect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  b5f8              PUSH     {r3-r7,lr}
;;;891    {
;;;892    	if (g_ChipID == IC_8875)
000002  4d0a              LDR      r5,|L22.44|
000004  9c06              LDR      r4,[sp,#0x18]
000006  886d              LDRH     r5,[r5,#2]  ; g_ChipID
000008  2d75              CMP      r5,#0x75
00000a  d00b              BEQ      |L22.36|
;;;893    	{
;;;894    		RA8875_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
;;;895    	}
;;;896    	else if (g_ChipID == IC_9488)
00000c  f5a54614          SUB      r6,r5,#0x9400
000010  3e88              SUBS     r6,r6,#0x88
000012  9400              STR      r4,[sp,#0]
000014  d003              BEQ      |L22.30|
;;;897    	{
;;;898    		ILI9488_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
;;;899    	}
;;;900    	else
;;;901    	{
;;;902    		SPFD5420_DrawRect(_usX, _usY, _usHeight, _usWidth, _usColor);
000016  b2d2              UXTB     r2,r2
000018  f7fffffe          BL       SPFD5420_DrawRect
;;;903    	}
;;;904    }
00001c  bdf8              POP      {r3-r7,pc}
                  |L22.30|
00001e  f7fffffe          BL       ILI9488_DrawRect
000022  bdf8              POP      {r3-r7,pc}
                  |L22.36|
000024  9400              STR      r4,[sp,#0]            ;894
000026  f7fffffe          BL       RA8875_DrawRect
00002a  bdf8              POP      {r3-r7,pc}
;;;905    
                          ENDP

                  |L22.44|
                          DCD      ||.data||

                          AREA ||i.LCD_DrawWin||, CODE, READONLY, ALIGN=1

                  LCD_DrawWin PROC
;;;998    */
;;;999    void LCD_DrawWin(WIN_T *_pWin)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1000   {
;;;1001   #if 1
;;;1002   	uint16_t TitleHegiht;
;;;1003   
;;;1004   	TitleHegiht = 20;
;;;1005   
;;;1006   	/* 绘制窗口外框 */
;;;1007   	LCD_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
000002  f44f7604          MOV      r6,#0x210
000006  9600              STR      r6,[sp,#0]
000008  4604              MOV      r4,r0                 ;1000
00000a  8903              LDRH     r3,[r0,#8]
00000c  88c2              LDRH     r2,[r0,#6]
00000e  8881              LDRH     r1,[r0,#4]
000010  2514              MOVS     r5,#0x14              ;1004
000012  8840              LDRH     r0,[r0,#2]
000014  f7fffffe          BL       LCD_DrawRect
;;;1008   	LCD_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
000018  9600              STR      r6,[sp,#0]
00001a  8920              LDRH     r0,[r4,#8]
00001c  1e80              SUBS     r0,r0,#2
00001e  b283              UXTH     r3,r0
000020  88e0              LDRH     r0,[r4,#6]
000022  1e80              SUBS     r0,r0,#2
000024  b282              UXTH     r2,r0
000026  88a0              LDRH     r0,[r4,#4]
000028  1c40              ADDS     r0,r0,#1
00002a  b281              UXTH     r1,r0
00002c  8860              LDRH     r0,[r4,#2]
00002e  1c40              ADDS     r0,r0,#1
000030  b280              UXTH     r0,r0
000032  f7fffffe          BL       LCD_DrawRect
;;;1009   
;;;1010   	/* 窗口标题栏 */
;;;1011   	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
000036  f244203f          MOV      r0,#0x423f
00003a  9000              STR      r0,[sp,#0]
00003c  8920              LDRH     r0,[r4,#8]
00003e  462a              MOV      r2,r5
000040  1f00              SUBS     r0,r0,#4
000042  b283              UXTH     r3,r0
000044  88a0              LDRH     r0,[r4,#4]
000046  1c80              ADDS     r0,r0,#2
000048  b281              UXTH     r1,r0
00004a  8860              LDRH     r0,[r4,#2]
00004c  1c80              ADDS     r0,r0,#2
00004e  b280              UXTH     r0,r0
000050  f7fffffe          BL       LCD_Fill_Rect
;;;1012   
;;;1013   	/* 窗体填充 */
;;;1014   	LCD_Fill_Rect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht,
000054  f24b50b6          MOV      r0,#0xb5b6
000058  9000              STR      r0,[sp,#0]
00005a  8920              LDRH     r0,[r4,#8]
00005c  1f00              SUBS     r0,r0,#4
00005e  b283              UXTH     r3,r0
000060  88e0              LDRH     r0,[r4,#6]
000062  3818              SUBS     r0,r0,#0x18
000064  b282              UXTH     r2,r0
000066  88a0              LDRH     r0,[r4,#4]
000068  3016              ADDS     r0,r0,#0x16
00006a  b281              UXTH     r1,r0
00006c  8860              LDRH     r0,[r4,#2]
00006e  1c80              ADDS     r0,r0,#2
000070  b280              UXTH     r0,r0
000072  f7fffffe          BL       LCD_Fill_Rect
;;;1015   		_pWin->Width - 4, WIN_BODY_COLOR);
;;;1016   
;;;1017   	LCD_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->pCaption, _pWin->Font);
000076  88a0              LDRH     r0,[r4,#4]
000078  e9d43203          LDRD     r3,r2,[r4,#0xc]       ;1014
00007c  1c80              ADDS     r0,r0,#2
00007e  b281              UXTH     r1,r0
000080  8860              LDRH     r0,[r4,#2]
000082  b001              ADD      sp,sp,#4
000084  1cc0              ADDS     r0,r0,#3
000086  e8bd40f0          POP      {r4-r7,lr}
00008a  b280              UXTH     r0,r0
00008c  f7ffbffe          B.W      LCD_DispStr
;;;1018   #else
;;;1019   	if (g_ChipID == IC_8875)
;;;1020   	{
;;;1021   		uint16_t TitleHegiht;
;;;1022   
;;;1023   		TitleHegiht = 28;
;;;1024   
;;;1025   		/* 绘制窗口外框 */
;;;1026   		RA8875_DrawRect(_pWin->Left, _pWin->Top, _pWin->Height, _pWin->Width, WIN_BORDER_COLOR);
;;;1027   		RA8875_DrawRect(_pWin->Left + 1, _pWin->Top + 1, _pWin->Height - 2, _pWin->Width - 2, WIN_BORDER_COLOR);
;;;1028   
;;;1029   		/* 窗口标题栏 */
;;;1030   		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + 2, TitleHegiht, _pWin->Width - 4, WIN_TITLE_COLOR);
;;;1031   
;;;1032   		/* 窗体填充 */
;;;1033   		RA8875_FillRect(_pWin->Left + 2, _pWin->Top + TitleHegiht + 2, _pWin->Height - 4 - TitleHegiht, _pWin->Width - 4, WIN_BODY_COLOR);
;;;1034   
;;;1035   		//RA8875_SetFont(_pWin->Font.FontCode, 0, 0);
;;;1036   		RA8875_SetFont(RA_FONT_24, 0, 0);
;;;1037   
;;;1038   		RA8875_SetBackColor(WIN_TITLE_COLOR);
;;;1039   		RA8875_SetFrontColor(WIN_CAPTION_COLOR);
;;;1040   		RA8875_DispStr(_pWin->Left + 3, _pWin->Top + 2, _pWin->Caption);
;;;1041   	}
;;;1042   	else
;;;1043   	{
;;;1044   		;
;;;1045   	}
;;;1046   #endif
;;;1047   }
;;;1048   
                          ENDP


                          AREA ||i.LCD_FSMCConfig||, CODE, READONLY, ALIGN=1

                  LCD_FSMCConfig PROC
;;;1773   */
;;;1774   static void LCD_FSMCConfig(void)
000000  b500              PUSH     {lr}
;;;1775   {
000002  b097              SUB      sp,sp,#0x5c
;;;1776   	FSMC_NORSRAMInitTypeDef  init;
;;;1777   	FSMC_NORSRAMTimingInitTypeDef  timing;
;;;1778   
;;;1779   	/*-- FSMC Configuration ------------------------------------------------------*/
;;;1780   	/*----------------------- SRAM Bank 4 ----------------------------------------*/
;;;1781   	/* FSMC_Bank1_NORSRAM4 configuration */
;;;1782   	timing.FSMC_AddressSetupTime = 1;
000004  2001              MOVS     r0,#1
;;;1783   	timing.FSMC_AddressHoldTime = 0;
000006  900f              STR      r0,[sp,#0x3c]
000008  2000              MOVS     r0,#0
;;;1784   	timing.FSMC_DataSetupTime = 2;
00000a  2102              MOVS     r1,#2
00000c  e9cd0110          STRD     r0,r1,[sp,#0x40]
;;;1785   	timing.FSMC_BusTurnAroundDuration = 0;
;;;1786   	timing.FSMC_CLKDivision = 0;
;;;1787   	timing.FSMC_DataLatency = 0;
;;;1788   	timing.FSMC_AccessMode = FSMC_AccessMode_A;
000010  9014              STR      r0,[sp,#0x50]
;;;1789   
;;;1790   	/*
;;;1791   	 LCD configured as follow:
;;;1792   	    - Data/Address MUX = Disable
;;;1793   	    - Memory Type = SRAM
;;;1794   	    - Data Width = 16bit
;;;1795   	    - Write Operation = Enable
;;;1796   	    - Extended Mode = Enable
;;;1797   	    - Asynchronous Wait = Disable
;;;1798   	*/
;;;1799   	init.FSMC_Bank = FSMC_Bank1_NORSRAM4;
000012  2106              MOVS     r1,#6
000014  9015              STR      r0,[sp,#0x54]
000016  e9cd1000          STRD     r1,r0,[sp,#0]
00001a  9012              STR      r0,[sp,#0x48]         ;1786
;;;1800   	init.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;1801   	init.FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;1802   	init.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
00001c  2110              MOVS     r1,#0x10
00001e  e9cd0102          STRD     r0,r1,[sp,#8]
000022  9013              STR      r0,[sp,#0x4c]         ;1787
;;;1803   	init.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;1804   	init.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;	/* 注意旧库无这个成员 */
000024  9004              STR      r0,[sp,#0x10]
;;;1805   	init.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000026  9005              STR      r0,[sp,#0x14]
;;;1806   	init.FSMC_WrapMode = FSMC_WrapMode_Disable;
000028  9006              STR      r0,[sp,#0x18]
;;;1807   	init.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;1808   	init.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
00002a  0209              LSLS     r1,r1,#8
00002c  9007              STR      r0,[sp,#0x1c]
00002e  e9cd0108          STRD     r0,r1,[sp,#0x20]
;;;1809   	init.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;1810   	init.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000032  900a              STR      r0,[sp,#0x28]
;;;1811   	init.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000034  900b              STR      r0,[sp,#0x2c]
;;;1812   
;;;1813   	init.FSMC_ReadWriteTimingStruct = &timing;
000036  900c              STR      r0,[sp,#0x30]
000038  a80f              ADD      r0,sp,#0x3c
;;;1814   	init.FSMC_WriteTimingStruct = &timing;
00003a  900d              STR      r0,[sp,#0x34]
;;;1815   
;;;1816   	FSMC_NORSRAMInit(&init);
00003c  900e              STR      r0,[sp,#0x38]
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       FSMC_NORSRAMInit
;;;1817   
;;;1818   	/* - BANK 3 (of NOR/SRAM Bank 1~4) is enabled */
;;;1819   	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);
000044  2101              MOVS     r1,#1
000046  2006              MOVS     r0,#6
000048  f7fffffe          BL       FSMC_NORSRAMCmd
;;;1820   }
00004c  b017              ADD      sp,sp,#0x5c
00004e  bd00              POP      {pc}
;;;1821   
                          ENDP


                          AREA ||i.LCD_Fill_Rect||, CODE, READONLY, ALIGN=2

                  LCD_Fill_Rect PROC
;;;916    */
;;;917    void LCD_Fill_Rect(uint16_t _usX, uint16_t _usY, uint16_t _usHeight, uint16_t _usWidth, uint16_t _usColor)
000000  e92d43f8          PUSH     {r3-r9,lr}
;;;918    {
000004  4607              MOV      r7,r0
;;;919    	if (g_ChipID == IC_8875)
000006  4815              LDR      r0,|L25.92|
000008  f8dd8020          LDR      r8,[sp,#0x20]
00000c  4615              MOV      r5,r2                 ;918
00000e  8840              LDRH     r0,[r0,#2]  ; g_ChipID
000010  460e              MOV      r6,r1                 ;918
000012  2875              CMP      r0,#0x75
000014  d010              BEQ      |L25.56|
;;;920    	{
;;;921    		RA8875_FillRect(_usX, _usY, _usHeight, _usWidth, _usColor);
;;;922    	}
;;;923    	else if (g_ChipID == IC_9488)
000016  f5a04114          SUB      r1,r0,#0x9400
00001a  3988              SUBS     r1,r1,#0x88
00001c  d004              BEQ      |L25.40|
;;;924    	{
;;;925    		ILI9488_FillRect(_usX, _usY, _usHeight, _usWidth, _usColor);
;;;926    	}
;;;927    	else
;;;928    	{
;;;929    		uint32_t i;
;;;930    		for (i = 0; i < _usHeight; i++)
00001e  2400              MOVS     r4,#0
;;;931    		{
;;;932    			SPFD5420_DrawHLine(_usX, _usY + i, _usX + _usWidth - 1, _usColor);
000020  18f8              ADDS     r0,r7,r3
000022  f1a00901          SUB      r9,r0,#1
000026  e016              B        |L25.86|
                  |L25.40|
000028  4631              MOV      r1,r6                 ;925
00002a  4638              MOV      r0,r7                 ;925
00002c  f8cd8000          STR      r8,[sp,#0]            ;925
000030  f7fffffe          BL       ILI9488_FillRect
                  |L25.52|
;;;933    		}
;;;934    	}
;;;935    }
000034  e8bd83f8          POP      {r3-r9,pc}
                  |L25.56|
000038  4638              MOV      r0,r7                 ;921
00003a  f8cd8000          STR      r8,[sp,#0]            ;921
00003e  f7fffffe          BL       RA8875_FillRect
000042  e7f7              B        |L25.52|
                  |L25.68|
000044  1930              ADDS     r0,r6,r4              ;932
000046  b281              UXTH     r1,r0                 ;932
000048  fa1ff289          UXTH     r2,r9                 ;932
00004c  4643              MOV      r3,r8                 ;932
00004e  4638              MOV      r0,r7                 ;932
000050  f7fffffe          BL       SPFD5420_DrawHLine
000054  1c64              ADDS     r4,r4,#1              ;932
                  |L25.86|
000056  42ac              CMP      r4,r5                 ;930
000058  d3f4              BCC      |L25.68|
00005a  e7eb              B        |L25.52|
;;;936    
                          ENDP

                  |L25.92|
                          DCD      ||.data||

                          AREA ||i.LCD_GetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_GetBackLight PROC
;;;1869   */
;;;1870   uint8_t LCD_GetBackLight(void)
000000  4801              LDR      r0,|L26.8|
;;;1871   {
;;;1872   	return s_ucBright;
000002  7800              LDRB     r0,[r0,#0]  ; s_ucBright
;;;1873   }
000004  4770              BX       lr
;;;1874   /*
                          ENDP

000006  0000              DCW      0x0000
                  |L26.8|
                          DCD      ||.data||

                          AREA ||i.LCD_GetChipDescribe||, CODE, READONLY, ALIGN=2

                  LCD_GetChipDescribe PROC
;;;154    */
;;;155    void LCD_GetChipDescribe(char *_str)
000000  4911              LDR      r1,|L27.72|
;;;156    {
;;;157    	switch (g_ChipID)
000002  f2454320          MOV      r3,#0x5420
000006  884a              LDRH     r2,[r1,#2]  ; g_ChipID
000008  1ad1              SUBS     r1,r2,r3
00000a  429a              CMP      r2,r3
00000c  d014              BEQ      |L27.56|
00000e  dc07              BGT      |L27.32|
000010  2a75              CMP      r2,#0x75
000012  d013              BEQ      |L27.60|
000014  f46f4180          MVN      r1,#0x4000
000018  42ca              CMN      r2,r1
00001a  d10b              BNE      |L27.52|
;;;158    	{
;;;159    		case IC_5420:
;;;160    			strcpy(_str, CHIP_STR_5420);
;;;161    			break;
;;;162    
;;;163    		case IC_4001:
;;;164    			strcpy(_str, CHIP_STR_4001);
00001c  a10b              ADR      r1,|L27.76|
;;;165    			break;
00001e  e010              B        |L27.66|
                  |L27.32|
000020  3968              SUBS     r1,r1,#0x68
000022  f5b14180          SUBS     r1,r1,#0x4000
000026  d00b              BEQ      |L27.64|
000028  f46f5202          MVN      r2,#0x2080            ;157
00002c  42d1              CMN      r1,r2                 ;157
00002e  d101              BNE      |L27.52|
;;;166    
;;;167    		case IC_61509:
;;;168    			strcpy(_str, CHIP_STR_61509);
000030  a109              ADR      r1,|L27.88|
;;;169    			break;
000032  e006              B        |L27.66|
                  |L27.52|
;;;170    
;;;171    		case IC_8875:
;;;172    			strcpy(_str, CHIP_STR_8875);
;;;173    			break;
;;;174    
;;;175    		case IC_9488:
;;;176    			strcpy(_str, CHIP_STR_9488);
;;;177    			break;
;;;178    
;;;179    		default:
;;;180    			strcpy(_str, "Unknow");
000034  a10a              ADR      r1,|L27.96|
;;;181    			break;
000036  e004              B        |L27.66|
                  |L27.56|
000038  a10b              ADR      r1,|L27.104|
00003a  e002              B        |L27.66|
                  |L27.60|
00003c  a10d              ADR      r1,|L27.116|
00003e  e000              B        |L27.66|
                  |L27.64|
000040  a10e              ADR      r1,|L27.124|
                  |L27.66|
000042  f7ffbffe          B.W      strcpy
;;;182    	}
;;;183    }
;;;184    
                          ENDP

000046  0000              DCW      0x0000
                  |L27.72|
                          DCD      ||.data||
                  |L27.76|
00004c  4f544d34          DCB      "OTM4001A",0
000050  30303141
000054  00      
000055  00                DCB      0
000056  00                DCB      0
000057  00                DCB      0
                  |L27.88|
000058  52363135          DCB      "R61509V",0
00005c  30395600
                  |L27.96|
000060  556e6b6e          DCB      "Unknow",0
000064  6f7700  
000067  00                DCB      0
                  |L27.104|
000068  53504644          DCB      "SPFD5420A",0
00006c  35343230
000070  4100    
000072  00                DCB      0
000073  00                DCB      0
                  |L27.116|
000074  52413838          DCB      "RA8875",0
000078  373500  
00007b  00                DCB      0
                  |L27.124|
00007c  494c4939          DCB      "ILI9488",0
000080  34383800

                          AREA ||i.LCD_GetFontHeight||, CODE, READONLY, ALIGN=1

                  LCD_GetFontHeight PROC
;;;345    */
;;;346    uint16_t LCD_GetFontHeight(FONT_T *_tFont)
000000  4601              MOV      r1,r0
;;;347    {
;;;348    	uint16_t height = 16;
000002  2010              MOVS     r0,#0x10
;;;349    
;;;350    	switch (_tFont->FontCode)
000004  7809              LDRB     r1,[r1,#0]
000006  2907              CMP      r1,#7
000008  d206              BCS      |L28.24|
00000a  e8dff001          TBB      [pc,r1]
00000e  0405              DCB      0x04,0x05
000010  06080506          DCB      0x06,0x08,0x05,0x06
000014  0800              DCB      0x08,0x00
;;;351    	{
;;;352    		case FC_ST_12:
;;;353    			height = 12;
000016  200c              MOVS     r0,#0xc
                  |L28.24|
;;;354    			break;
;;;355    
;;;356    		case FC_ST_16:
;;;357    		case FC_RA8875_16:			
;;;358    			height = 16;
;;;359    			break;
;;;360    			
;;;361    		case FC_RA8875_24:			
;;;362    		case FC_ST_24:
;;;363    			height = 24;
;;;364    			break;
;;;365    			
;;;366    		case FC_ST_32:
;;;367    		case FC_RA8875_32:	
;;;368    			height = 32;
;;;369    			break;			
;;;370    	}
;;;371    	return height;
;;;372    }
000018  4770              BX       lr
00001a  2018              MOVS     r0,#0x18              ;363
00001c  4770              BX       lr
00001e  2020              MOVS     r0,#0x20              ;368
000020  4770              BX       lr
;;;373    
                          ENDP


                          AREA ||i.LCD_GetFontWidth||, CODE, READONLY, ALIGN=1

                  LCD_GetFontWidth PROC
;;;308    */
;;;309    uint16_t LCD_GetFontWidth(FONT_T *_tFont)
000000  4601              MOV      r1,r0
;;;310    {
;;;311    	uint16_t font_width = 16;
000002  2010              MOVS     r0,#0x10
;;;312    
;;;313    	switch (_tFont->FontCode)
000004  7809              LDRB     r1,[r1,#0]
000006  2907              CMP      r1,#7
000008  d206              BCS      |L29.24|
00000a  e8dff001          TBB      [pc,r1]
00000e  0405              DCB      0x04,0x05
000010  06080506          DCB      0x06,0x08,0x05,0x06
000014  0800              DCB      0x08,0x00
;;;314    	{
;;;315    		case FC_ST_12:
;;;316    			font_width = 12;
000016  200c              MOVS     r0,#0xc
                  |L29.24|
;;;317    			break;
;;;318    
;;;319    		case FC_ST_16:
;;;320    		case FC_RA8875_16:			
;;;321    			font_width = 16;
;;;322    			break;
;;;323    			
;;;324    		case FC_RA8875_24:			
;;;325    		case FC_ST_24:
;;;326    			font_width = 24;
;;;327    			break;
;;;328    			
;;;329    		case FC_ST_32:
;;;330    		case FC_RA8875_32:	
;;;331    			font_width = 32;
;;;332    			break;			
;;;333    	}
;;;334    	return font_width;
;;;335    }
000018  4770              BX       lr
00001a  2018              MOVS     r0,#0x18              ;326
00001c  4770              BX       lr
00001e  2020              MOVS     r0,#0x20              ;331
000020  4770              BX       lr
;;;336    
                          ENDP


                          AREA ||i.LCD_GetHeight||, CODE, READONLY, ALIGN=2

                  LCD_GetHeight PROC
;;;192    */
;;;193    uint16_t LCD_GetHeight(void)
000000  4801              LDR      r0,|L30.8|
;;;194    {
;;;195    	return g_LcdHeight;
000002  8880              LDRH     r0,[r0,#4]  ; g_LcdHeight
;;;196    }
000004  4770              BX       lr
;;;197    
                          ENDP

000006  0000              DCW      0x0000
                  |L30.8|
                          DCD      ||.data||

                          AREA ||i.LCD_GetPixel||, CODE, READONLY, ALIGN=2

                  LCD_GetPixel PROC
;;;811    */
;;;812    uint16_t LCD_GetPixel(uint16_t _usX, uint16_t _usY)
000000  4a06              LDR      r2,|L31.28|
;;;813    {
;;;814    	uint16_t usRGB;
;;;815    
;;;816    	if (g_ChipID == IC_8875)
000002  8852              LDRH     r2,[r2,#2]  ; g_ChipID
000004  2a75              CMP      r2,#0x75
000006  d007              BEQ      |L31.24|
;;;817    	{
;;;818    		usRGB = RA8875_GetPixel(_usX, _usY);
;;;819    	}
;;;820    	else if (g_ChipID == IC_9488)
000008  f5a24314          SUB      r3,r2,#0x9400
00000c  3b88              SUBS     r3,r3,#0x88
00000e  d001              BEQ      |L31.20|
;;;821    	{
;;;822    		usRGB = ILI9488_GetPixel(_usX, _usY);
;;;823    	}
;;;824    	else
;;;825    	{
;;;826    		usRGB = SPFD5420_GetPixel(_usX, _usY);
000010  f7ffbffe          B.W      SPFD5420_GetPixel
                  |L31.20|
000014  f7ffbffe          B.W      ILI9488_GetPixel
                  |L31.24|
000018  f7ffbffe          B.W      RA8875_GetPixel
;;;827    	}
;;;828    
;;;829    	return usRGB;
;;;830    }
;;;831    
                          ENDP

                  |L31.28|
                          DCD      ||.data||

                          AREA ||i.LCD_GetStrWidth||, CODE, READONLY, ALIGN=2

                  LCD_GetStrWidth PROC
;;;383    */
;;;384    uint16_t LCD_GetStrWidth(char *_ptr, FONT_T *_tFont)
000000  b530              PUSH     {r4,r5,lr}
;;;385    {
;;;386    	char *p = _ptr;
000002  4603              MOV      r3,r0
000004  460d              MOV      r5,r1                 ;385
;;;387    	uint16_t width = 0;
000006  2400              MOVS     r4,#0
;;;388    	uint8_t code1, code2;
;;;389    	uint16_t font_width;
;;;390    
;;;391    	font_width = LCD_GetFontWidth(_tFont);
000008  4608              MOV      r0,r1
00000a  f7fffffe          BL       LCD_GetFontWidth
;;;392    
;;;393    	while (*p != 0)
00000e  e024              B        |L32.90|
                  |L32.16|
;;;394    	{
;;;395    		code1 = *p;	/* 读取字符串数据， 该数据可能是ascii代码，也可能汉字代码的高字节 */
;;;396    		if (code1 < 0x80)	/* ASCII */
000010  2880              CMP      r0,#0x80
000012  d219              BCS      |L32.72|
;;;397    		{
;;;398    			switch(_tFont->FontCode)
000014  7829              LDRB     r1,[r5,#0]
000016  2907              CMP      r1,#7
000018  d214              BCS      |L32.68|
00001a  e8dff001          TBB      [pc,r1]
00001e  0d13              DCB      0x0d,0x13
000020  0f110406          DCB      0x0f,0x11,0x04,0x06
000024  0800              DCB      0x08,0x00
;;;399    			{
;;;400    				case FC_RA8875_16:
;;;401    					font_width = g_RA8875_Ascii16_width[code1 - 0x20];
000026  490f              LDR      r1,|L32.100|
;;;402    					break;
000028  e002              B        |L32.48|
;;;403    				
;;;404    				case FC_RA8875_24:
;;;405    					font_width = g_RA8875_Ascii24_width[code1 - 0x20];
00002a  490f              LDR      r1,|L32.104|
;;;406    					break;
00002c  e000              B        |L32.48|
;;;407    				
;;;408    				case FC_RA8875_32:
;;;409    					font_width = g_RA8875_Ascii32_width[code1 - 0x20];
00002e  490f              LDR      r1,|L32.108|
                  |L32.48|
000030  4408              ADD      r0,r0,r1
000032  f8100c20          LDRB     r0,[r0,#-0x20]
000036  e00d              B        |L32.84|
;;;410    					break;
;;;411    				
;;;412    				case FC_ST_12:
;;;413    					font_width = 6;
000038  2006              MOVS     r0,#6
;;;414    					break;
00003a  e00b              B        |L32.84|
;;;415    
;;;416    				case FC_ST_16:		
;;;417    					font_width = 8;
;;;418    					break;
;;;419    					
;;;420    				case FC_ST_24:			
;;;421    					font_width = 12;
00003c  200c              MOVS     r0,#0xc
;;;422    					break;
00003e  e009              B        |L32.84|
;;;423    					
;;;424    				case FC_ST_32:
;;;425    					font_width = 16;
000040  2010              MOVS     r0,#0x10
;;;426    					break;
000042  e007              B        |L32.84|
                  |L32.68|
;;;427    				
;;;428    				default:
;;;429    					font_width = 8;
000044  2008              MOVS     r0,#8
;;;430    					break;					
000046  e005              B        |L32.84|
                  |L32.72|
;;;431    			}
;;;432    			
;;;433    		}
;;;434    		else	/* 汉字 */
;;;435    		{
;;;436    			code2 = *++p;
000048  f8130f01          LDRB     r0,[r3,#1]!
;;;437    			if (code2 == 0)
00004c  b140              CBZ      r0,|L32.96|
;;;438    			{
;;;439    				break;
;;;440    			}
;;;441    			font_width = LCD_GetFontWidth(_tFont);
00004e  4628              MOV      r0,r5
000050  f7fffffe          BL       LCD_GetFontWidth
                  |L32.84|
;;;442    			
;;;443    		}
;;;444    		width += font_width;
000054  4420              ADD      r0,r0,r4
000056  b284              UXTH     r4,r0
000058  1c5b              ADDS     r3,r3,#1
                  |L32.90|
00005a  7818              LDRB     r0,[r3,#0]            ;393
00005c  2800              CMP      r0,#0                 ;393
00005e  d1d7              BNE      |L32.16|
                  |L32.96|
;;;445    		p++;
;;;446    	}
;;;447    
;;;448    	return width;
000060  4620              MOV      r0,r4
;;;449    }
000062  bd30              POP      {r4,r5,pc}
;;;450    
                          ENDP

                  |L32.100|
                          DCD      g_RA8875_Ascii16_width
                  |L32.104|
                          DCD      g_RA8875_Ascii24_width
                  |L32.108|
                          DCD      g_RA8875_Ascii32_width

                          AREA ||i.LCD_GetWidth||, CODE, READONLY, ALIGN=2

                  LCD_GetWidth PROC
;;;205    */
;;;206    uint16_t LCD_GetWidth(void)
000000  4801              LDR      r0,|L33.8|
;;;207    {
;;;208    	return g_LcdWidth;
000002  88c0              LDRH     r0,[r0,#6]  ; g_LcdWidth
;;;209    }
000004  4770              BX       lr
;;;210    
                          ENDP

000006  0000              DCW      0x0000
                  |L33.8|
                          DCD      ||.data||

                          AREA ||i.LCD_InitButton||, CODE, READONLY, ALIGN=1

                  LCD_InitButton PROC
;;;1957   */
;;;1958   void LCD_InitButton(BUTTON_T *_btn, uint16_t _x, uint16_t _y, uint16_t _h, uint16_t _w, char *_pCaption, FONT_T *_pFont)
000000  b570              PUSH     {r4-r6,lr}
;;;1959   {
000002  f10d0c10          ADD      r12,sp,#0x10
000006  e89c0070          LDM      r12,{r4-r6}
;;;1960   	_btn->Left = _x;
00000a  8041              STRH     r1,[r0,#2]
;;;1961   	_btn->Top = _y;
00000c  8082              STRH     r2,[r0,#4]
;;;1962   	_btn->Height = _h;
00000e  80c3              STRH     r3,[r0,#6]
;;;1963   	_btn->Width = _w;
000010  8104              STRH     r4,[r0,#8]
;;;1964   	_btn->pCaption = _pCaption;	
;;;1965   	_btn->Font = _pFont;
;;;1966   	_btn->Focus = 0;
000012  e9c06503          STRD     r6,r5,[r0,#0xc]
000016  2100              MOVS     r1,#0
000018  7501              STRB     r1,[r0,#0x14]
;;;1967   }
00001a  bd70              POP      {r4-r6,pc}
;;;1968   
                          ENDP


                          AREA ||i.LCD_InitHard||, CODE, READONLY, ALIGN=2

                  LCD_InitHard PROC
;;;73     */
;;;74     void LCD_InitHard(void)
000000  b538              PUSH     {r3-r5,lr}
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
00000a  2101              MOVS     r1,#1
00000c  f24010e1          MOV      r0,#0x1e1
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
000014  f24c7033          MOV      r0,#0xc733
000018  f8ad0000          STRH     r0,[sp,#0]
00001c  2003              MOVS     r0,#3
00001e  f88d0002          STRB     r0,[sp,#2]
000022  2018              MOVS     r0,#0x18
000024  f88d0003          STRB     r0,[sp,#3]
000028  4669              MOV      r1,sp
00002a  4826              LDR      r0,|L35.196|
00002c  f7fffffe          BL       GPIO_Init
000030  f64f7098          MOV      r0,#0xff98
000034  f8ad0000          STRH     r0,[sp,#0]
000038  4669              MOV      r1,sp
00003a  4823              LDR      r0,|L35.200|
00003c  f7fffffe          BL       GPIO_Init
000040  2001              MOVS     r0,#1
000042  f8ad0000          STRH     r0,[sp,#0]
000046  4669              MOV      r1,sp
000048  4820              LDR      r0,|L35.204|
00004a  f7fffffe          BL       GPIO_Init
00004e  f44f5080          MOV      r0,#0x1000
000052  f8ad0000          STRH     r0,[sp,#0]
000056  4669              MOV      r1,sp
000058  481d              LDR      r0,|L35.208|
00005a  f7fffffe          BL       GPIO_Init
;;;75     {
;;;76     	uint32_t id;
;;;77     
;;;78     	/* 配置LCD控制口线GPIO */
;;;79     	LCD_CtrlLinesConfig();
;;;80     
;;;81     	/* 配置FSMC接口，数据总线 */
;;;82     	LCD_FSMCConfig();
00005e  f7fffffe          BL       LCD_FSMCConfig
;;;83     
;;;84     	LCD_HardReset();	/* 硬件复位 （STM32-V5 无需），针对其他GPIO控制LCD复位的产品 */
;;;85     	
;;;86     	/* FSMC重置后必须加延迟才能访问总线设备  */
;;;87     	bsp_DelayMS(20);
000062  2014              MOVS     r0,#0x14
000064  f7fffffe          BL       bsp_DelayMS
;;;88     
;;;89     	id = ILI9488_ReadID();
000068  f7fffffe          BL       ILI9488_ReadID
;;;90     	if (id == 0x548066)		/* 3.5寸屏 */
;;;91     	{
;;;92     		g_ChipID = IC_9488;
00006c  4c19              LDR      r4,|L35.212|
00006e  f5a001a9          SUB      r1,r0,#0x548000       ;90
000072  3966              SUBS     r1,r1,#0x66           ;90
000074  d01c              BEQ      |L35.176|
;;;93     		ILI9488_InitHard();
;;;94     	}
;;;95     	else
;;;96     	{
;;;97     		id = SPFD5420_ReadID();  	/* 读取LCD驱动芯片ID */
000076  f7fffffe          BL       SPFD5420_ReadID
;;;98     		if ((id == 0x5420) || (id ==  0xB509) || (id == 0x5520))
00007a  f5a041a8          SUB      r1,r0,#0x5400
00007e  3920              SUBS     r1,r1,#0x20
000080  d01c              BEQ      |L35.188|
000082  f5a04135          SUB      r1,r0,#0xb500
000086  3909              SUBS     r1,r1,#9
000088  d018              BEQ      |L35.188|
00008a  f5a041aa          SUB      r1,r0,#0x5500
00008e  3920              SUBS     r1,r1,#0x20
000090  d014              BEQ      |L35.188|
;;;99     		{
;;;100    			SPFD5420_InitHard();	/* 初始化5420和4001屏硬件 */
;;;101    			/* g_ChipID 在函数内部设置了 */
;;;102    		}
;;;103    		else
;;;104    		{
;;;105    			g_ChipID = IC_8875;
000092  2075              MOVS     r0,#0x75
000094  8060              STRH     r0,[r4,#2]
;;;106    			RA8875_InitHard();	/* 初始化RA8875芯片 */
000096  f7fffffe          BL       RA8875_InitHard
                  |L35.154|
;;;107    		}
;;;108    	}
;;;109    
;;;110    	LCD_SetDirection(0);
00009a  2000              MOVS     r0,#0
00009c  f7fffffe          BL       LCD_SetDirection
;;;111    
;;;112    	LCD_ClrScr(CL_BLACK);	/* 清屏，显示全黑 */
0000a0  2000              MOVS     r0,#0
0000a2  f7fffffe          BL       LCD_ClrScr
;;;113    
;;;114    	LCD_SetBackLight(BRIGHT_DEFAULT);	 /* 打开背光，设置为缺省亮度 */
0000a6  e8bd4038          POP      {r3-r5,lr}
0000aa  20c8              MOVS     r0,#0xc8
0000ac  f7ffbffe          B.W      LCD_SetBackLight
                  |L35.176|
0000b0  f2494088          MOV      r0,#0x9488            ;92
0000b4  8060              STRH     r0,[r4,#2]            ;92
0000b6  f7fffffe          BL       ILI9488_InitHard
0000ba  e7ee              B        |L35.154|
                  |L35.188|
0000bc  f7fffffe          BL       SPFD5420_InitHard
0000c0  e7eb              B        |L35.154|
;;;115    }
;;;116    
                          ENDP

0000c2  0000              DCW      0x0000
                  |L35.196|
                          DCD      0x40011400
                  |L35.200|
                          DCD      0x40011800
                  |L35.204|
                          DCD      0x40011c00
                  |L35.208|
                          DCD      0x40012000
                  |L35.212|
                          DCD      ||.data||

                          AREA ||i.LCD_PutPixel||, CODE, READONLY, ALIGN=2

                  LCD_PutPixel PROC
;;;785    */
;;;786    void LCD_PutPixel(uint16_t _usX, uint16_t _usY, uint16_t _usColor)
000000  4b08              LDR      r3,|L36.36|
;;;787    {
000002  b430              PUSH     {r4,r5}
;;;788    	if (g_ChipID == IC_8875)
000004  885b              LDRH     r3,[r3,#2]  ; g_ChipID
000006  2b75              CMP      r3,#0x75
000008  d009              BEQ      |L36.30|
;;;789    	{
;;;790    		RA8875_PutPixel(_usX, _usY, _usColor);
;;;791    	}
;;;792    	else if (g_ChipID == IC_9488)
00000a  f5a34414          SUB      r4,r3,#0x9400
00000e  3c88              SUBS     r4,r4,#0x88
000010  d002              BEQ      |L36.24|
;;;793    	{
;;;794    		ILI9488_PutPixel(_usX, _usY, _usColor);
;;;795    	}
;;;796    	else
;;;797    	{
;;;798    		SPFD5420_PutPixel(_usX, _usY, _usColor);
000012  bc30              POP      {r4,r5}
000014  f7ffbffe          B.W      SPFD5420_PutPixel
                  |L36.24|
000018  bc30              POP      {r4,r5}               ;794
00001a  f7ffbffe          B.W      ILI9488_PutPixel
                  |L36.30|
00001e  bc30              POP      {r4,r5}               ;790
000020  f7ffbffe          B.W      RA8875_PutPixel
;;;799    	}
;;;800    }
;;;801    
                          ENDP

                  |L36.36|
                          DCD      ||.data||

                          AREA ||i.LCD_SetBackLight||, CODE, READONLY, ALIGN=2

                  LCD_SetBackLight PROC
;;;1847   */
;;;1848   void LCD_SetBackLight(uint8_t _bright)
000000  4904              LDR      r1,|L37.20|
;;;1849   {
;;;1850   	s_ucBright =  _bright;	/* 保存背光值 */
000002  7008              STRB     r0,[r1,#0]
;;;1851   
;;;1852   	if (g_ChipID == IC_8875)
000004  8849              LDRH     r1,[r1,#2]  ; g_ChipID
000006  2975              CMP      r1,#0x75
000008  d001              BEQ      |L37.14|
;;;1853   	{
;;;1854   		RA8875_SetBackLight(_bright);
;;;1855   	}
;;;1856   	else
;;;1857   	{
;;;1858   		LCD_SetPwmBackLight(_bright);
00000a  f7ffbffe          B.W      LCD_SetPwmBackLight
                  |L37.14|
00000e  f7ffbffe          B.W      RA8875_SetBackLight
;;;1859   	}
;;;1860   }
;;;1861   
                          ENDP

000012  0000              DCW      0x0000
                  |L37.20|
                          DCD      ||.data||

                          AREA ||i.LCD_SetDirection||, CODE, READONLY, ALIGN=2

                  LCD_SetDirection PROC
;;;1881   */
;;;1882   void LCD_SetDirection(uint8_t _dir)
000000  4904              LDR      r1,|L38.20|
;;;1883   {
;;;1884   	g_LcdDirection =  _dir;		/* 保存在全局变量 */
000002  7048              STRB     r0,[r1,#1]
;;;1885   
;;;1886   	if (g_ChipID == IC_8875)
000004  8849              LDRH     r1,[r1,#2]  ; g_ChipID
000006  2975              CMP      r1,#0x75
000008  d001              BEQ      |L38.14|
;;;1887   	{
;;;1888   		RA8875_SetDirection(_dir);
;;;1889   	}
;;;1890   	else
;;;1891   	{
;;;1892   		ILI9488_SetDirection(_dir);
00000a  f7ffbffe          B.W      ILI9488_SetDirection
                  |L38.14|
00000e  f7ffbffe          B.W      RA8875_SetDirection
;;;1893   	}
;;;1894   }
;;;1895   
                          ENDP

000012  0000              DCW      0x0000
                  |L38.20|
                          DCD      ||.data||

                          AREA ||i.LCD_SetPwmBackLight||, CODE, READONLY, ALIGN=2

                  LCD_SetPwmBackLight PROC
;;;1831   */
;;;1832   void LCD_SetPwmBackLight(uint8_t _bright)
000000  f2427110          MOV      r1,#0x2710
;;;1833   {
;;;1834   	/* STM32-V4开发板，PB1/TIM3_CH4/TIM8_CH3N 控制背光PWM ； 因为 TIM3用于红外解码。因此用TIM8_CH3N做背光PWM */
;;;1835   	//bsp_SetTIMOutPWM(GPIOB, GPIO_Pin_1, TIM3, 4, 100, (_bright * 10000) /255);	// TIM3_CH4
;;;1836   	bsp_SetTIMOutPWM_N(GPIOB, GPIO_Pin_1, TIM8, 3, 100, (_bright * 10000) /255);	// TIM8_CH3N
000004  4348              MULS     r0,r1,r0
000006  21ff              MOVS     r1,#0xff
000008  b51c              PUSH     {r2-r4,lr}            ;1833
00000a  fbb0f0f1          UDIV     r0,r0,r1
00000e  2164              MOVS     r1,#0x64
000010  e9cd1000          STRD     r1,r0,[sp,#0]
000014  2303              MOVS     r3,#3
000016  4a03              LDR      r2,|L39.36|
000018  2102              MOVS     r1,#2
00001a  4803              LDR      r0,|L39.40|
00001c  f7fffffe          BL       bsp_SetTIMOutPWM_N
;;;1837   }
000020  bd1c              POP      {r2-r4,pc}
;;;1838   
                          ENDP

000022  0000              DCW      0x0000
                  |L39.36|
                          DCD      0x40013400
                  |L39.40|
                          DCD      0x40010c00

                          AREA ||i._LCD_ReadHZDot||, CODE, READONLY, ALIGN=2

                  _LCD_ReadHZDot PROC
;;;503    */
;;;504    static void _LCD_ReadHZDot(uint8_t _code1, uint8_t _code2,  uint8_t _fontcode, uint8_t *_pBuf)
000000  b4f0              PUSH     {r4-r7}
;;;505    {
000002  460c              MOV      r4,r1
000004  4615              MOV      r5,r2
;;;506    	#ifdef USE_SMALL_FONT	/* 使用CPU 内部Flash 小字库 */
;;;507    		uint8_t *pDot;
;;;508    		uint8_t font_bytes = 0;
;;;509    		uint32_t address;
;;;510    		uint16_t m;
;;;511    
;;;512    		pDot = 0;	/* 仅仅用于避免告警 */
;;;513    		switch (_fontcode)
;;;514    		{
;;;515    			case FC_ST_12:		/* 12点阵 */
;;;516    				font_bytes = 24;
;;;517    				pDot = (uint8_t *)g_Hz12;	
;;;518    				break;
;;;519    			
;;;520    			case FC_ST_16:
;;;521    				font_bytes = 32;
;;;522    				pDot = (uint8_t *)g_Hz16;
;;;523    				break;
;;;524    	
;;;525    			case FC_ST_24:
;;;526    				font_bytes = 72;
;;;527    				pDot = (uint8_t *)g_Hz24;
;;;528    				break;			
;;;529    				
;;;530    			case FC_ST_32:	
;;;531    				font_bytes = 128;
;;;532    				pDot = (uint8_t *)g_Hz32;
;;;533    				break;						
;;;534    			
;;;535    			case FC_RA8875_16:
;;;536    			case FC_RA8875_24:
;;;537    			case FC_RA8875_32:
;;;538    				return;
;;;539    		}	
;;;540    
;;;541    		m = 0;
;;;542    		while(1)
;;;543    		{
;;;544    			address = m * (font_bytes + 2);
;;;545    			m++;
;;;546    			if ((_code1 == pDot[address + 0]) && (_code2 == pDot[address + 1]))
;;;547    			{
;;;548    				address += 2;
;;;549    				memcpy(_pBuf, &pDot[address], font_bytes);
;;;550    				break;
;;;551    			}
;;;552    			else if ((pDot[address + 0] == 0xFF) && (pDot[address + 1] == 0xFF))
;;;553    			{
;;;554    				/* 字库搜索完毕，未找到，则填充全FF */
;;;555    				memset(_pBuf, 0xFF, font_bytes);
;;;556    				break;
;;;557    			}
;;;558    		}
;;;559    	#else	/* 用全字库 */
;;;560    		uint8_t *pDot = 0;
000006  2100              MOVS     r1,#0
;;;561    		uint8_t font_bytes = 0;
000008  460a              MOV      r2,r1
;;;562    			
;;;563    		switch (_fontcode)
00000a  2d07              CMP      r5,#7
00000c  d211              BCS      |L40.50|
00000e  e8dff005          TBB      [pc,r5]
000012  0408              DCB      0x04,0x08
000014  0b0e3131          DCB      0x0b,0x0e,0x31,0x31
000018  3100              DCB      0x31,0x00
;;;564    		{
;;;565    			case FC_ST_12:		/* 12点阵 */
;;;566    				font_bytes = 24;
00001a  2218              MOVS     r2,#0x18
;;;567    				pDot = (uint8_t *)HZK12_ADDR;	
00001c  f04f41c8          MOV      r1,#0x64000000
;;;568    				break;
000020  e007              B        |L40.50|
;;;569    			
;;;570    			case FC_ST_16:
;;;571    				font_bytes = 32;
000022  2220              MOVS     r2,#0x20
;;;572    				pDot = (uint8_t *)HZK16_ADDR;
000024  4914              LDR      r1,|L40.120|
;;;573    				break;
000026  e004              B        |L40.50|
;;;574    	
;;;575    			case FC_ST_24:
;;;576    				font_bytes = 72;
000028  2248              MOVS     r2,#0x48
;;;577    				pDot = (uint8_t *)HZK24_ADDR;
00002a  4914              LDR      r1,|L40.124|
;;;578    				break;			
00002c  e001              B        |L40.50|
;;;579    				
;;;580    			case FC_ST_32:	
;;;581    				font_bytes = 128;
;;;582    				pDot = (uint8_t *)HZK32_ADDR;
00002e  4914              LDR      r1,|L40.128|
000030  2280              MOVS     r2,#0x80              ;581
                  |L40.50|
;;;583    				break;						
;;;584    			
;;;585    			case FC_RA8875_16:
;;;586    			case FC_RA8875_24:
;;;587    			case FC_RA8875_32:
;;;588    				return;
;;;589    		}			
;;;590    	
;;;591    		/* 此处需要根据字库文件存放位置进行修改 */
;;;592    		if (_code1 >=0xA1 && _code1 <= 0xA9 && _code2 >=0xA1)
000032  f1a005a1          SUB      r5,r0,#0xa1
000036  2d08              CMP      r5,#8
000038  d809              BHI      |L40.78|
00003a  2ca1              CMP      r4,#0xa1
00003c  d307              BCC      |L40.78|
;;;593    		{
;;;594    			pDot += ((_code1 - 0xA1) * 94 + (_code2 - 0xA1)) * font_bytes;
00003e  ebc51005          RSB      r0,r5,r5,LSL #4
000042  eb001045          ADD      r0,r0,r5,LSL #5
000046  eb040040          ADD      r0,r4,r0,LSL #1
00004a  38a1              SUBS     r0,r0,#0xa1
00004c  e00c              B        |L40.104|
                  |L40.78|
00004e  38b0              SUBS     r0,r0,#0xb0
;;;595    		}
;;;596    		else if (_code1 >=0xB0 && _code1 <= 0xF7 && _code2 >=0xA1)
000050  2847              CMP      r0,#0x47
000052  d80b              BHI      |L40.108|
000054  2ca1              CMP      r4,#0xa1
000056  d309              BCC      |L40.108|
;;;597    		{
;;;598    			pDot += ((_code1 - 0xB0) * 94 + (_code2 - 0xA1) + 846) * font_bytes;
000058  ebc01500          RSB      r5,r0,r0,LSL #4
00005c  eb051040          ADD      r0,r5,r0,LSL #5
000060  eb040040          ADD      r0,r4,r0,LSL #1
000064  f20020ad          ADD      r0,r0,#0x2ad
                  |L40.104|
000068  fb001102          MLA      r1,r0,r2,r1
                  |L40.108|
;;;599    		}
;;;600    		memcpy(_pBuf, pDot, font_bytes);
00006c  bcf0              POP      {r4-r7}
00006e  4618              MOV      r0,r3
000070  f7ffbffe          B.W      __aeabi_memcpy
;;;601    	#endif
;;;602    }
000074  bcf0              POP      {r4-r7}
000076  4770              BX       lr
;;;603    			
                          ENDP

                  |L40.120|
                          DCD      0x6402c9d0
                  |L40.124|
                          DCD      0x64068190
                  |L40.128|
                          DCD      0x640edf00

                          AREA ||.data||, DATA, ALIGN=1

                  s_ucBright
000000  00                DCB      0x00
                  g_LcdDirection
000001  00                DCB      0x00
                  g_ChipID
000002  4001              DCW      0x4001
                  g_LcdHeight
000004  00f0              DCW      0x00f0
                  g_LcdWidth
000006  0190              DCW      0x0190

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_tft_lcd.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_tft_lcd_c_g_ChipID____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH|
#line 128
|__asm___13_bsp_tft_lcd_c_g_ChipID____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
