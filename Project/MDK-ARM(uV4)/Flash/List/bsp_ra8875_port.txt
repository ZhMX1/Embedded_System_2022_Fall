; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ra8875_port.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ra8875_port.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_ra8875_port.crf ..\..\User\bsp\src\bsp_ra8875_port.c]
                          THUMB

                          AREA ||i.RA8875_ConfigGPIO||, CODE, READONLY, ALIGN=2

                  RA8875_ConfigGPIO PROC
;;;30     */
;;;31     void RA8875_ConfigGPIO(void)
000000  b538              PUSH     {r3-r5,lr}
;;;32     {
;;;33     	static uint8_t s_run_first = 0;
;;;34     	
;;;35     	/* 如果已经运行过，则不再执行 */
;;;36     	if (s_run_first == 1)
000002  4c13              LDR      r4,|L1.80|
000004  7860              LDRB     r0,[r4,#1]  ; s_run_first
000006  2801              CMP      r0,#1
000008  d020              BEQ      |L1.76|
;;;37     	{
;;;38     		return;
;;;39     	}
;;;40     	
;;;41     	s_run_first = 1;
00000a  2001              MOVS     r0,#1
00000c  7060              STRB     r0,[r4,#1]
;;;42     	
;;;43     	/* FSMC在 bsp_tft_lcd.c中已经配置好 */
;;;44     	
;;;45     	
;;;46     	/* RA8875按照SPI接口设置后，通过总线方式依然可以读到0X75的特征，因此不能用来自动识别SPI模式 */
;;;47     	{
;;;48     		uint8_t value;
;;;49     		
;;;50     		g_RA8875_IF = RA_HARD_8080_16;	
00000e  2503              MOVS     r5,#3
000010  7025              STRB     r5,[r4,#0]
;;;51     		RA8875_WriteReg(0x60, 0x1A);	/* 60H寄存器背景色寄存器红色[4:0]低5位有效 */
000012  211a              MOVS     r1,#0x1a
000014  2060              MOVS     r0,#0x60
000016  f7fffffe          BL       RA8875_WriteReg
;;;52     		value = RA8875_ReadReg(0x60);
00001a  2060              MOVS     r0,#0x60
00001c  f7fffffe          BL       RA8875_ReadReg
;;;53     		if (value != 0x1A)
000020  281a              CMP      r0,#0x1a
000022  d003              BEQ      |L1.44|
;;;54     		{
;;;55     			RA8875_InitSPI();				/* 配置好SPI接口  */
000024  f7fffffe          BL       RA8875_InitSPI
;;;56     			g_RA8875_IF = RA_HARD_SPI;		/* 识别为 SPI总线 */
000028  2002              MOVS     r0,#2
00002a  7020              STRB     r0,[r4,#0]
                  |L1.44|
;;;57     		}
;;;58     	}
;;;59     	
;;;60     	#ifdef USE_WAIT_PIN
;;;61     	{
;;;62     		GPIO_InitTypeDef GPIO_InitStructure;
;;;63     		
;;;64     		/* 使能 GPIO时钟 */
;;;65     		RCC_APB2PeriphClockCmd(RCC_WAIT, ENABLE);
00002c  2101              MOVS     r1,#1
00002e  2008              MOVS     r0,#8
000030  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;66     		
;;;67     		/* 连接到RA8875的BUSY引脚，用GPIO 识别芯片内忙 */
;;;68     		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000034  f88d5002          STRB     r5,[sp,#2]
;;;69     		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;		/*　输入上拉　*/
000038  2048              MOVS     r0,#0x48
00003a  f88d0003          STRB     r0,[sp,#3]
;;;70     		GPIO_InitStructure.GPIO_Pin = PIN_WAIT;
00003e  2020              MOVS     r0,#0x20
000040  f8ad0000          STRH     r0,[sp,#0]
;;;71     		GPIO_Init(PORT_WAIT, &GPIO_InitStructure);
000044  4669              MOV      r1,sp
000046  4803              LDR      r0,|L1.84|
000048  f7fffffe          BL       GPIO_Init
                  |L1.76|
;;;72     	}
;;;73     	#endif
;;;74     }
00004c  bd38              POP      {r3-r5,pc}
;;;75     
                          ENDP

00004e  0000              DCW      0x0000
                  |L1.80|
                          DCD      ||.data||
                  |L1.84|
                          DCD      0x40010c00

                          AREA ||i.RA8875_Delaly1ms||, CODE, READONLY, ALIGN=1

                  RA8875_Delaly1ms PROC
;;;116    */
;;;117    void RA8875_Delaly1ms(void)
000000  2000              MOVS     r0,#0
;;;118    {
;;;119    	uint16_t i;
;;;120    
;;;121    	for (i = 0; i < 5000; i++);	/* 延迟, 不准 */
000002  f2413188          MOV      r1,#0x1388
                  |L2.6|
000006  1c40              ADDS     r0,r0,#1
000008  b280              UXTH     r0,r0
00000a  4288              CMP      r0,r1
00000c  d3fb              BCC      |L2.6|
;;;122    }
00000e  4770              BX       lr
;;;123    
                          ENDP


                          AREA ||i.RA8875_Delaly1us||, CODE, READONLY, ALIGN=1

                  RA8875_Delaly1us PROC
;;;101    */
;;;102    void RA8875_Delaly1us(void)
000000  2000              MOVS     r0,#0
                  |L3.2|
;;;103    {
;;;104    	uint8_t i;
;;;105    
;;;106    	for (i = 0; i < 10; i++);	/* 延迟, 不准 */
000002  1c40              ADDS     r0,r0,#1
000004  b2c0              UXTB     r0,r0
000006  280a              CMP      r0,#0xa
000008  d3fb              BCC      |L3.2|
;;;107    }
00000a  4770              BX       lr
;;;108    
                          ENDP


                          AREA ||i.RA8875_GetDispMemAddr||, CODE, READONLY, ALIGN=2

                  RA8875_GetDispMemAddr PROC
;;;291    */
;;;292    uint32_t RA8875_GetDispMemAddr(void)
000000  4805              LDR      r0,|L4.24|
;;;293    {
;;;294    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000002  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000004  2802              CMP      r0,#2
000006  d001              BEQ      |L4.12|
;;;295    	{
;;;296    		return 0;
;;;297    	}
;;;298    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
000008  2803              CMP      r0,#3
00000a  d001              BEQ      |L4.16|
                  |L4.12|
;;;299    	{
;;;300    		return RA8875_RAM_ADDR;
;;;301    	}
;;;302    	return 0;
00000c  2000              MOVS     r0,#0
;;;303    }
00000e  4770              BX       lr
                  |L4.16|
000010  f04f40d8          MOV      r0,#0x6c000000        ;300
000014  4770              BX       lr
;;;304    
                          ENDP

000016  0000              DCW      0x0000
                  |L4.24|
                          DCD      ||.data||

                          AREA ||i.RA8875_HighSpeedSPI||, CODE, READONLY, ALIGN=2

                  RA8875_HighSpeedSPI PROC
;;;392    */
;;;393    void RA8875_HighSpeedSPI(void)
000000  b510              PUSH     {r4,lr}
;;;394    {
;;;395    	SPI_InitTypeDef  SPI_InitStructure;
;;;396    
;;;397    	/* 打开SPI时钟 */
;;;398    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;394
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;399    
;;;400    	/* 配置SPI硬件参数 */
;;;401    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
00000c  2000              MOVS     r0,#0
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;402    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
000012  f44f7182          MOV      r1,#0x104
000016  f8ad1002          STRH     r1,[sp,#2]
;;;403    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
00001a  f8ad0004          STRH     r0,[sp,#4]
;;;404    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;405    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;406    	*/
;;;407    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
00001e  2102              MOVS     r1,#2
000020  f8ad1006          STRH     r1,[sp,#6]
;;;408    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
000024  2101              MOVS     r1,#1
000026  f8ad1008          STRH     r1,[sp,#8]
;;;409    	//SPI_InitStructure.SPI_CPOL = SPI_CPOL_Low;			/* 时钟上升沿采样数据 */
;;;410    	//SPI_InitStructure.SPI_CPHA = SPI_CPHA_1Edge;		/* 时钟的第2个边沿采样数据 */	
;;;411    	
;;;412    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
00002a  0249              LSLS     r1,r1,#9
00002c  f8ad100a          STRH     r1,[sp,#0xa]
;;;413    
;;;414    	/*
;;;415    	
;;;416    		示波器实测频率 (STM32F103ZE 上测试)
;;;417    		SPI_BaudRatePrescaler_4 时， SCK = 18M  (显示正常，触摸不正常)
;;;418    		SPI_BaudRatePrescaler_8 时， SCK = 9M   (显示和触摸都正常)
;;;419    		
;;;420    		F407 的 SP1时钟=84M, 需要 8分频 = 10.5M
;;;421    	*/
;;;422    	
;;;423    	/* 设置波特率预分频系数 */
;;;424    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_16;
000030  2118              MOVS     r1,#0x18
000032  f8ad100c          STRH     r1,[sp,#0xc]
;;;425    
;;;426    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000036  f8ad000e          STRH     r0,[sp,#0xe]
;;;427    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
00003a  2007              MOVS     r0,#7
;;;428    	SPI_Init(SPI1, &SPI_InitStructure);
00003c  4c08              LDR      r4,|L5.96|
00003e  f8ad0010          STRH     r0,[sp,#0x10]         ;427
000042  4669              MOV      r1,sp
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_Init
;;;429    
;;;430    	SPI_Cmd(SPI1, DISABLE);			/* 先禁止SPI  */
00004a  2100              MOVS     r1,#0
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       SPI_Cmd
;;;431    
;;;432    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000052  2101              MOVS     r1,#1
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       SPI_Cmd
;;;433    }
00005a  b006              ADD      sp,sp,#0x18
00005c  bd10              POP      {r4,pc}
;;;434    
                          ENDP

00005e  0000              DCW      0x0000
                  |L5.96|
                          DCD      0x40013000

                          AREA ||i.RA8875_InitSPI||, CODE, READONLY, ALIGN=2

                  RA8875_InitSPI PROC
;;;314    */
;;;315    void RA8875_InitSPI(void)
000000  b538              PUSH     {r3-r5,lr}
;;;316    {
;;;317    	/*
;;;318    		安富莱STM32-V5 开发板口线分配：  串行Flash型号为 W25Q64BVSSIG (80MHz)
;;;319    		PA5/SPI1_SCK
;;;320    		PA6/SPI1_MISO
;;;321    		PA7/SPI1_MOSI
;;;322    		PG11/TP_NCS			--- 触摸芯片的片选		(RA8875屏无需SPI接口触摸芯片）
;;;323    	*/
;;;324    	{
;;;325    		GPIO_InitTypeDef GPIO_InitStructure;
;;;326    
;;;327    		/* 使能GPIO 时钟 */
;;;328    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_GPIOG, ENABLE);
000002  2101              MOVS     r1,#1
000004  f44f7082          MOV      r0,#0x104
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;329    
;;;330    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
00000c  2018              MOVS     r0,#0x18
00000e  f88d0003          STRB     r0,[sp,#3]
;;;331    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000012  2403              MOVS     r4,#3
000014  f88d4002          STRB     r4,[sp,#2]
;;;332    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_5 | GPIO_Pin_6 | GPIO_Pin_7;
000018  20e0              MOVS     r0,#0xe0
00001a  f8ad0000          STRH     r0,[sp,#0]
;;;333    		GPIO_Init(GPIOA, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  480a              LDR      r0,|L6.76|
000022  f7fffffe          BL       GPIO_Init
;;;334    
;;;335    		/* 配置片选口线为推挽输出模式 */
;;;336    		RA8875_CS_1();		/* 片选置高，不选中 */
000026  480a              LDR      r0,|L6.80|
000028  f44f6100          MOV      r1,#0x800
00002c  6101              STR      r1,[r0,#0x10]
;;;337    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_PP;
00002e  2210              MOVS     r2,#0x10
000030  f88d2003          STRB     r2,[sp,#3]
;;;338    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000034  f88d4002          STRB     r4,[sp,#2]
;;;339    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_11;
000038  f8ad1000          STRH     r1,[sp,#0]
;;;340    		GPIO_Init(GPIOG, &GPIO_InitStructure);
00003c  4669              MOV      r1,sp
00003e  f7fffffe          BL       GPIO_Init
;;;341    	}
;;;342    	
;;;343    	RA8875_LowSpeedSPI();
000042  e8bd4038          POP      {r3-r5,lr}
000046  f7ffbffe          B.W      RA8875_LowSpeedSPI
;;;344    }
;;;345    
                          ENDP

00004a  0000              DCW      0x0000
                  |L6.76|
                          DCD      0x40010800
                  |L6.80|
                          DCD      0x40012000

                          AREA ||i.RA8875_LowSpeedSPI||, CODE, READONLY, ALIGN=2

                  RA8875_LowSpeedSPI PROC
;;;353    */
;;;354    void RA8875_LowSpeedSPI(void)
000000  b510              PUSH     {r4,lr}
;;;355    {
;;;356    	SPI_InitTypeDef  SPI_InitStructure;
;;;357    
;;;358    	/* 打开SPI时钟 */
;;;359    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_SPI1, ENABLE);
000002  2101              MOVS     r1,#1
000004  b086              SUB      sp,sp,#0x18           ;355
000006  0308              LSLS     r0,r1,#12
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;360    
;;;361    	/* 配置SPI硬件参数 */
;;;362    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
00000c  2000              MOVS     r0,#0
00000e  f8ad0000          STRH     r0,[sp,#0]
;;;363    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
000012  f44f7182          MOV      r1,#0x104
000016  f8ad1002          STRH     r1,[sp,#2]
;;;364    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
00001a  f8ad0004          STRH     r0,[sp,#4]
;;;365    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;366    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;367    	*/
;;;368    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
00001e  2102              MOVS     r1,#2
000020  f8ad1006          STRH     r1,[sp,#6]
;;;369    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
000024  2101              MOVS     r1,#1
000026  f8ad1008          STRH     r1,[sp,#8]
;;;370    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
00002a  0249              LSLS     r1,r1,#9
00002c  f8ad100a          STRH     r1,[sp,#0xa]
;;;371    
;;;372    	/* 设置波特率预分频系数 */
;;;373    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
000030  2128              MOVS     r1,#0x28
000032  f8ad100c          STRH     r1,[sp,#0xc]
;;;374    
;;;375    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
000036  f8ad000e          STRH     r0,[sp,#0xe]
;;;376    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
00003a  2007              MOVS     r0,#7
;;;377    	SPI_Init(SPI1, &SPI_InitStructure);
00003c  4c08              LDR      r4,|L7.96|
00003e  f8ad0010          STRH     r0,[sp,#0x10]         ;376
000042  4669              MOV      r1,sp
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_Init
;;;378    
;;;379    	SPI_Cmd(SPI1, DISABLE);			/* 先禁止SPI  */
00004a  2100              MOVS     r1,#0
00004c  4620              MOV      r0,r4
00004e  f7fffffe          BL       SPI_Cmd
;;;380    
;;;381    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000052  2101              MOVS     r1,#1
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       SPI_Cmd
;;;382    }
00005a  b006              ADD      sp,sp,#0x18
00005c  bd10              POP      {r4,pc}
;;;383    
                          ENDP

00005e  0000              DCW      0x0000
                  |L7.96|
                          DCD      0x40013000

                          AREA ||i.RA8875_ReadBusy||, CODE, READONLY, ALIGN=2

                  RA8875_ReadBusy PROC
;;;84     */
;;;85     uint8_t RA8875_ReadBusy(void)
000000  4803              LDR      r0,|L8.16|
;;;86     {
;;;87     	if ((PORT_WAIT->IDR & PIN_WAIT) == 0) 
000002  6800              LDR      r0,[r0,#0]
000004  0680              LSLS     r0,r0,#26
000006  d401              BMI      |L8.12|
;;;88     		return 1;
000008  2001              MOVS     r0,#1
;;;89     	else 
;;;90     		return 0;
;;;91     }
00000a  4770              BX       lr
                  |L8.12|
00000c  2000              MOVS     r0,#0                 ;90
00000e  4770              BX       lr
;;;92     #endif
                          ENDP

                  |L8.16|
                          DCD      0x40010c08

                          AREA ||i.RA8875_ReadData||, CODE, READONLY, ALIGN=2

                  RA8875_ReadData PROC
;;;177    */
;;;178    uint8_t RA8875_ReadData(void)
000000  b570              PUSH     {r4-r6,lr}
;;;179    {
;;;180    	uint8_t value = 0;
;;;181    	
;;;182    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000002  490c              LDR      r1,|L9.52|
000004  2000              MOVS     r0,#0                 ;180
000006  7809              LDRB     r1,[r1,#0]  ; g_RA8875_IF
000008  2902              CMP      r1,#2
00000a  d006              BEQ      |L9.26|
;;;183    	{
;;;184    		RA8875_CS_0();
;;;185    		SPI_ShiftByte(SPI_READ_DATA);
;;;186    		value = SPI_ShiftByte(0x00);
;;;187    		RA8875_CS_1();
;;;188    	}
;;;189    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00000c  2903              CMP      r1,#3
00000e  d103              BNE      |L9.24|
;;;190    	{
;;;191    		value = RA8875_RAM;		/* 读取寄存器值 */
000010  f04f40d8          MOV      r0,#0x6c000000
000014  8800              LDRH     r0,[r0,#0]
000016  b2c0              UXTB     r0,r0
                  |L9.24|
;;;192    	}
;;;193    
;;;194    	return value;	
;;;195    }
000018  bd70              POP      {r4-r6,pc}
                  |L9.26|
00001a  4d07              LDR      r5,|L9.56|
00001c  f44f6400          MOV      r4,#0x800             ;184
000020  616c              STR      r4,[r5,#0x14]         ;184
000022  2040              MOVS     r0,#0x40              ;185
000024  f7fffffe          BL       SPI_ShiftByte
000028  2000              MOVS     r0,#0                 ;186
00002a  f7fffffe          BL       SPI_ShiftByte
00002e  612c              STR      r4,[r5,#0x10]         ;187
000030  bd70              POP      {r4-r6,pc}
;;;196    
                          ENDP

000032  0000              DCW      0x0000
                  |L9.52|
                          DCD      ||.data||
                  |L9.56|
                          DCD      0x40012000

                          AREA ||i.RA8875_ReadData16||, CODE, READONLY, ALIGN=2

                  RA8875_ReadData16 PROC
;;;236    */
;;;237    uint16_t RA8875_ReadData16(void)
000000  b570              PUSH     {r4-r6,lr}
;;;238    {
;;;239    	uint16_t value;
;;;240    	
;;;241    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000002  490f              LDR      r1,|L10.64|
000004  7809              LDRB     r1,[r1,#0]  ; g_RA8875_IF
000006  2902              CMP      r1,#2
000008  d005              BEQ      |L10.22|
;;;242    	{
;;;243    		RA8875_CS_0();
;;;244    		SPI_ShiftByte(SPI_READ_DATA);
;;;245    		value = SPI_ShiftByte(0x00);
;;;246    		value <<= 8;
;;;247    		value += SPI_ShiftByte(0x00);
;;;248    		RA8875_CS_1();
;;;249    	}
;;;250    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00000a  2903              CMP      r1,#3
00000c  d102              BNE      |L10.20|
;;;251    	{
;;;252    		value = RA8875_RAM;		/* 读取寄存器值 */
00000e  f04f40d8          MOV      r0,#0x6c000000
000012  8800              LDRH     r0,[r0,#0]
                  |L10.20|
;;;253    	}
;;;254    
;;;255    	return value;	
;;;256    }
000014  bd70              POP      {r4-r6,pc}
                  |L10.22|
000016  4d0b              LDR      r5,|L10.68|
000018  f44f6400          MOV      r4,#0x800             ;243
00001c  616c              STR      r4,[r5,#0x14]         ;243
00001e  2040              MOVS     r0,#0x40              ;244
000020  f7fffffe          BL       SPI_ShiftByte
000024  2000              MOVS     r0,#0                 ;245
000026  f7fffffe          BL       SPI_ShiftByte
00002a  f64f71ff          MOV      r1,#0xffff            ;246
00002e  ea012600          AND      r6,r1,r0,LSL #8       ;246
000032  2000              MOVS     r0,#0                 ;247
000034  f7fffffe          BL       SPI_ShiftByte
000038  4430              ADD      r0,r0,r6              ;247
00003a  b280              UXTH     r0,r0                 ;247
00003c  612c              STR      r4,[r5,#0x10]         ;248
00003e  bd70              POP      {r4-r6,pc}
;;;257    
                          ENDP

                  |L10.64|
                          DCD      ||.data||
                  |L10.68|
                          DCD      0x40012000

                          AREA ||i.RA8875_ReadStatus||, CODE, READONLY, ALIGN=2

                  RA8875_ReadStatus PROC
;;;265    */
;;;266    uint8_t RA8875_ReadStatus(void)
000000  b570              PUSH     {r4-r6,lr}
;;;267    {
;;;268    	uint8_t value = 0;
;;;269    	
;;;270    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000002  490c              LDR      r1,|L11.52|
000004  2000              MOVS     r0,#0                 ;268
000006  7809              LDRB     r1,[r1,#0]  ; g_RA8875_IF
000008  2902              CMP      r1,#2
00000a  d006              BEQ      |L11.26|
;;;271    	{
;;;272    		RA8875_CS_0();
;;;273    		SPI_ShiftByte(SPI_READ_STATUS);
;;;274    		value = SPI_ShiftByte(0x00);
;;;275    		RA8875_CS_1();
;;;276    	}
;;;277    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00000c  2903              CMP      r1,#3
00000e  d103              BNE      |L11.24|
;;;278    	{
;;;279    		value = RA8875_REG;
000010  f04f40d8          MOV      r0,#0x6c000000
000014  8840              LDRH     r0,[r0,#2]
000016  b2c0              UXTB     r0,r0
                  |L11.24|
;;;280    	}
;;;281    	return value;	
;;;282    }
000018  bd70              POP      {r4-r6,pc}
                  |L11.26|
00001a  4d07              LDR      r5,|L11.56|
00001c  f44f6400          MOV      r4,#0x800             ;272
000020  616c              STR      r4,[r5,#0x14]         ;272
000022  20c0              MOVS     r0,#0xc0              ;273
000024  f7fffffe          BL       SPI_ShiftByte
000028  2000              MOVS     r0,#0                 ;274
00002a  f7fffffe          BL       SPI_ShiftByte
00002e  612c              STR      r4,[r5,#0x10]         ;275
000030  bd70              POP      {r4-r6,pc}
;;;283    
                          ENDP

000032  0000              DCW      0x0000
                  |L11.52|
                          DCD      ||.data||
                  |L11.56|
                          DCD      0x40012000

                          AREA ||i.RA8875_WriteCmd||, CODE, READONLY, ALIGN=2

                  RA8875_WriteCmd PROC
;;;131    */
;;;132    void RA8875_WriteCmd(uint8_t _ucRegAddr)
000000  b570              PUSH     {r4-r6,lr}
;;;133    {
000002  4604              MOV      r4,r0
;;;134    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  480a              LDR      r0,|L12.48|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L12.24|
;;;135    	{
;;;136    		RA8875_CS_0();
;;;137    		SPI_ShiftByte(SPI_WRITE_CMD);
;;;138    		SPI_ShiftByte(_ucRegAddr);
;;;139    		RA8875_CS_1();
;;;140    	}
;;;141    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00000c  2803              CMP      r0,#3
00000e  d102              BNE      |L12.22|
;;;142    	{
;;;143    		RA8875_REG = _ucRegAddr;	/* 设置寄存器地址 */
000010  f04f40d8          MOV      r0,#0x6c000000
000014  8044              STRH     r4,[r0,#2]
                  |L12.22|
;;;144    	}
;;;145    }
000016  bd70              POP      {r4-r6,pc}
                  |L12.24|
000018  4e06              LDR      r6,|L12.52|
00001a  f44f6500          MOV      r5,#0x800             ;136
00001e  6175              STR      r5,[r6,#0x14]         ;136
000020  2080              MOVS     r0,#0x80              ;137
000022  f7fffffe          BL       SPI_ShiftByte
000026  4620              MOV      r0,r4                 ;138
000028  f7fffffe          BL       SPI_ShiftByte
00002c  6135              STR      r5,[r6,#0x10]         ;139
00002e  bd70              POP      {r4-r6,pc}
;;;146    
                          ENDP

                  |L12.48|
                          DCD      ||.data||
                  |L12.52|
                          DCD      0x40012000

                          AREA ||i.RA8875_WriteData||, CODE, READONLY, ALIGN=2

                  RA8875_WriteData PROC
;;;154    */
;;;155    void RA8875_WriteData(uint8_t _ucRegValue)
000000  b570              PUSH     {r4-r6,lr}
;;;156    {
000002  4604              MOV      r4,r0
;;;157    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  480a              LDR      r0,|L13.48|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L13.24|
;;;158    	{
;;;159    		RA8875_CS_0();
;;;160    		SPI_ShiftByte(SPI_WRITE_DATA);
;;;161    		SPI_ShiftByte(_ucRegValue);
;;;162    		RA8875_CS_1();
;;;163    	}
;;;164    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00000c  2803              CMP      r0,#3
00000e  d102              BNE      |L13.22|
;;;165    	{
;;;166    		RA8875_RAM = _ucRegValue;	/* 设置寄存器地址 */
000010  f04f40d8          MOV      r0,#0x6c000000
000014  8004              STRH     r4,[r0,#0]
                  |L13.22|
;;;167    	}
;;;168    }
000016  bd70              POP      {r4-r6,pc}
                  |L13.24|
000018  4e06              LDR      r6,|L13.52|
00001a  f44f6500          MOV      r5,#0x800             ;159
00001e  6175              STR      r5,[r6,#0x14]         ;159
000020  2000              MOVS     r0,#0                 ;160
000022  f7fffffe          BL       SPI_ShiftByte
000026  4620              MOV      r0,r4                 ;161
000028  f7fffffe          BL       SPI_ShiftByte
00002c  6135              STR      r5,[r6,#0x10]         ;162
00002e  bd70              POP      {r4-r6,pc}
;;;169    
                          ENDP

                  |L13.48|
                          DCD      ||.data||
                  |L13.52|
                          DCD      0x40012000

                          AREA ||i.RA8875_WriteData16||, CODE, READONLY, ALIGN=2

                  RA8875_WriteData16 PROC
;;;204    */
;;;205    void RA8875_WriteData16(uint16_t _usRGB)
000000  b570              PUSH     {r4-r6,lr}
;;;206    {
000002  4606              MOV      r6,r0
;;;207    	if (g_RA8875_IF == RA_HARD_SPI)	/* 硬件SPI接口 */
000004  480f              LDR      r0,|L14.68|
000006  7800              LDRB     r0,[r0,#0]  ; g_RA8875_IF
000008  2802              CMP      r0,#2
00000a  d005              BEQ      |L14.24|
;;;208    	{
;;;209    		RA8875_CS_0();
;;;210    		SPI_ShiftByte(SPI_WRITE_DATA);
;;;211    		SPI_ShiftByte(_usRGB >> 8);
;;;212    		RA8875_CS_1();
;;;213    		
;;;214    		/* 必须增加一些延迟，否则连续写像素可能出错 */
;;;215    		RA8875_CS_1();
;;;216    		RA8875_CS_1();
;;;217    		
;;;218    		RA8875_CS_0();
;;;219    		SPI_ShiftByte(SPI_WRITE_DATA);
;;;220    		SPI_ShiftByte(_usRGB);
;;;221    		RA8875_CS_1();
;;;222    	}
;;;223    	else if (g_RA8875_IF == RA_HARD_8080_16)	/* 8080硬件总线16bit */
00000c  2803              CMP      r0,#3
00000e  d102              BNE      |L14.22|
;;;224    	{
;;;225    		RA8875_RAM = _usRGB;	/* 设置寄存器地址 */
000010  f04f40d8          MOV      r0,#0x6c000000
000014  8006              STRH     r6,[r0,#0]
                  |L14.22|
;;;226    	}
;;;227    }
000016  bd70              POP      {r4-r6,pc}
                  |L14.24|
000018  4d0b              LDR      r5,|L14.72|
00001a  f44f6400          MOV      r4,#0x800             ;209
00001e  616c              STR      r4,[r5,#0x14]         ;209
000020  2000              MOVS     r0,#0                 ;210
000022  f7fffffe          BL       SPI_ShiftByte
000026  0a30              LSRS     r0,r6,#8              ;211
000028  f7fffffe          BL       SPI_ShiftByte
00002c  612c              STR      r4,[r5,#0x10]         ;212
00002e  612c              STR      r4,[r5,#0x10]         ;215
000030  612c              STR      r4,[r5,#0x10]         ;216
000032  616c              STR      r4,[r5,#0x14]         ;218
000034  2000              MOVS     r0,#0                 ;219
000036  f7fffffe          BL       SPI_ShiftByte
00003a  b2f0              UXTB     r0,r6                 ;220
00003c  f7fffffe          BL       SPI_ShiftByte
000040  612c              STR      r4,[r5,#0x10]         ;221
000042  bd70              POP      {r4-r6,pc}
;;;228    
                          ENDP

                  |L14.68|
                          DCD      ||.data||
                  |L14.72|
                          DCD      0x40012000

                          AREA ||i.SPI_ShiftByte||, CODE, READONLY, ALIGN=2

                  SPI_ShiftByte PROC
;;;442    */
;;;443    static uint8_t SPI_ShiftByte(uint8_t _ucByte)
000000  b570              PUSH     {r4-r6,lr}
;;;444    {
;;;445    	uint8_t ucRxByte;
;;;446    
;;;447    	/* 等待发送缓冲区空 */
;;;448    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_TXE) == RESET);
000002  4c0b              LDR      r4,|L15.48|
000004  4605              MOV      r5,r0                 ;444
                  |L15.6|
000006  2102              MOVS     r1,#2
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       SPI_I2S_GetFlagStatus
00000e  2800              CMP      r0,#0
000010  d0f9              BEQ      |L15.6|
;;;449    
;;;450    	/* 发送一个字节 */
;;;451    	SPI_I2S_SendData(SPI1, _ucByte);
000012  4629              MOV      r1,r5
000014  4620              MOV      r0,r4
000016  f7fffffe          BL       SPI_I2S_SendData
                  |L15.26|
;;;452    
;;;453    	/* 等待数据接收完毕 */
;;;454    	while(SPI_I2S_GetFlagStatus(SPI1, SPI_I2S_FLAG_RXNE) == RESET);
00001a  2101              MOVS     r1,#1
00001c  4620              MOV      r0,r4
00001e  f7fffffe          BL       SPI_I2S_GetFlagStatus
000022  2800              CMP      r0,#0
000024  d0f9              BEQ      |L15.26|
;;;455    
;;;456    	/* 读取接收到的数据 */
;;;457    	ucRxByte = SPI_I2S_ReceiveData(SPI1);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       SPI_I2S_ReceiveData
00002c  b2c0              UXTB     r0,r0
;;;458    
;;;459    	/* 返回读到的数据 */
;;;460    	return ucRxByte;
;;;461    }
00002e  bd70              POP      {r4-r6,pc}
;;;462    
                          ENDP

                  |L15.48|
                          DCD      0x40013000

                          AREA ||.data||, DATA, ALIGN=0

                  g_RA8875_IF
000000  03                DCB      0x03
                  s_run_first
000001  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_ra8875_port.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_ra8875_port_c_9d513f85____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___17_bsp_ra8875_port_c_9d513f85____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_bsp_ra8875_port_c_9d513f85____REVSH|
#line 128
|__asm___17_bsp_ra8875_port_c_9d513f85____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
