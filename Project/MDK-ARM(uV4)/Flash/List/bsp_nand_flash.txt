; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_nand_flash.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_nand_flash.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_nand_flash.crf ..\..\User\bsp\src\bsp_nand_flash.c]
                          THUMB

                          AREA ||i.FSMC_NAND_EraseBlock||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_EraseBlock PROC
;;;750    */
;;;751    static uint8_t FSMC_NAND_EraseBlock(uint32_t _ulBlockNo)
000000  4905              LDR      r1,|L1.24|
;;;752    {
;;;753    	/* HY27UF081G2A  (128MB)
;;;754    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;755    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;756    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;757    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12    A18以上是块号
;;;758    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;759    
;;;760    		H27U4G8F2DTR (512MB)
;;;761    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;762    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;763    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;764    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12    A18以上是块号
;;;765    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;766    		第5字节： A28  A29  A30  A31  0    0    0    0
;;;767    	*/
;;;768    
;;;769    	/* 发送擦除命令 */
;;;770    	NAND_CMD_AREA = NAND_CMD_ERASE0;
000002  2260              MOVS     r2,#0x60
000004  700a              STRB     r2,[r1,#0]
;;;771    
;;;772    	_ulBlockNo <<= 6;	/* 块号转换为页编号 */
;;;773    
;;;774    	#if NAND_ADDR_5 == 0	/* 128MB的 */
;;;775    		NAND_ADDR_AREA = _ulBlockNo;
000006  4a05              LDR      r2,|L1.28|
000008  0180              LSLS     r0,r0,#6              ;772
00000a  7010              STRB     r0,[r2,#0]
;;;776    		NAND_ADDR_AREA = _ulBlockNo >> 8;
00000c  0a00              LSRS     r0,r0,#8
00000e  7010              STRB     r0,[r2,#0]
;;;777    	#else		/* 512MB的 */
;;;778    		NAND_ADDR_AREA = _ulBlockNo;
;;;779    		NAND_ADDR_AREA = _ulBlockNo >> 8;
;;;780    		NAND_ADDR_AREA = _ulBlockNo >> 16;
;;;781    	#endif
;;;782    
;;;783    	NAND_CMD_AREA = NAND_CMD_ERASE1;
000010  20d0              MOVS     r0,#0xd0
000012  7008              STRB     r0,[r1,#0]
;;;784    
;;;785    	return (FSMC_NAND_GetStatus());
000014  f7ffbffe          B.W      FSMC_NAND_GetStatus
;;;786    }
;;;787    
                          ENDP

                  |L1.24|
                          DCD      0x70010000
                  |L1.28|
                          DCD      0x70020000

                          AREA ||i.FSMC_NAND_GetStatus||, CODE, READONLY, ALIGN=1

                  FSMC_NAND_GetStatus PROC
;;;854    */
;;;855    static uint8_t FSMC_NAND_GetStatus(void)
000000  b510              PUSH     {r4,lr}
;;;856    {
;;;857    	uint32_t ulTimeout = 0x10000;
000002  f44f3480          MOV      r4,#0x10000
;;;858    	uint8_t ucStatus = NAND_READY;
;;;859    
;;;860    	ucStatus = FSMC_NAND_ReadStatus();
000006  f7fffffe          BL       FSMC_NAND_ReadStatus
;;;861    
;;;862    	/* 等待NAND操作结束，超时后会退出 */
;;;863    	while ((ucStatus != NAND_READY) &&( ulTimeout != 0x00))
00000a  e002              B        |L2.18|
                  |L2.12|
;;;864    	{
;;;865    		ucStatus = FSMC_NAND_ReadStatus();
00000c  f7fffffe          BL       FSMC_NAND_ReadStatus
000010  1e64              SUBS     r4,r4,#1
                  |L2.18|
000012  2840              CMP      r0,#0x40              ;863
000014  d002              BEQ      |L2.28|
000016  2c00              CMP      r4,#0                 ;863
000018  d1f8              BNE      |L2.12|
00001a  e001              B        |L2.32|
                  |L2.28|
;;;866    		ulTimeout--;
;;;867    	}
;;;868    
;;;869    	if(ulTimeout == 0x00)
00001c  2c00              CMP      r4,#0
00001e  d100              BNE      |L2.34|
                  |L2.32|
;;;870    	{
;;;871    		ucStatus =  NAND_TIMEOUT_ERROR;
000020  2080              MOVS     r0,#0x80
                  |L2.34|
;;;872    	}
;;;873    
;;;874    	/* 返回操作状态 */
;;;875    	return (ucStatus);
;;;876    }
000022  bd10              POP      {r4,pc}
;;;877    
                          ENDP


                          AREA ||i.FSMC_NAND_Init||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_Init PROC
;;;147    */
;;;148    static void FSMC_NAND_Init(void)
000000  b530              PUSH     {r4,r5,lr}
;;;149    {
;;;150    	GPIO_InitTypeDef GPIO_InitStructure; 
;;;151    	FSMC_NANDInitTypeDef FSMC_NANDInitStructure;
;;;152    	FSMC_NAND_PCCARDTimingInitTypeDef  p;
;;;153    	
;;;154    	/* 使能 FSMC 时钟 */
;;;155    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  b08f              SUB      sp,sp,#0x3c           ;149
000006  0208              LSLS     r0,r1,#8
000008  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;156    	
;;;157    	/* 使能GPIOD、GPIOE、GPIOF、GPIOG 时钟 */
;;;158    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE | 
00000c  2101              MOVS     r1,#1
00000e  f44f70f0          MOV      r0,#0x1e0
000012  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;159    	                     RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG, ENABLE);
;;;160    	
;;;161    	/* GPIO 配置 */
;;;162    	/* 控制线CLE, ALE, D0-D3, NOE, NWE 和 NCE2  NAND 引脚配置为复用功能（即用于FSMC)  */
;;;163    	GPIO_InitStructure.GPIO_Pin =  GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_14 | GPIO_Pin_15 |  
000016  f64d00b3          MOV      r0,#0xd8b3
00001a  f8ad0034          STRH     r0,[sp,#0x34]
;;;164    	                             GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 | 
;;;165    	                             GPIO_Pin_7;                                  
;;;166    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001e  2403              MOVS     r4,#3
000020  f88d4036          STRB     r4,[sp,#0x36]
;;;167    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000024  2018              MOVS     r0,#0x18
000026  f88d0037          STRB     r0,[sp,#0x37]
;;;168    	GPIO_Init(GPIOD, &GPIO_InitStructure); 
00002a  a90d              ADD      r1,sp,#0x34
00002c  4819              LDR      r0,|L3.148|
00002e  f7fffffe          BL       GPIO_Init
;;;169    	
;;;170    	/* 数据线 D4-D7 引脚配置为复用功能 */  
;;;171    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10;
000032  f44f60f0          MOV      r0,#0x780
000036  f8ad0034          STRH     r0,[sp,#0x34]
;;;172    	GPIO_Init(GPIOE, &GPIO_InitStructure);
00003a  a90d              ADD      r1,sp,#0x34
00003c  4816              LDR      r0,|L3.152|
00003e  f7fffffe          BL       GPIO_Init
;;;173    	
;;;174    	/* NWAIT 引脚配置. 安富莱STM32-V4开发板缺省未使用NWAIT引脚作为忙信号，使用的是INT2
;;;175    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;   							 
;;;176    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
;;;177    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;
;;;178    	GPIO_Init(GPIOD, &GPIO_InitStructure); 
;;;179    	*/
;;;180    	
;;;181    	/* INT2 引脚配置为内部上来输入，用于忙信号 */  
;;;182    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6;   
000042  2540              MOVS     r5,#0x40
000044  f8ad5034          STRH     r5,[sp,#0x34]
;;;183    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000048  f88d4036          STRB     r4,[sp,#0x36]
;;;184    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IPU;								 
00004c  2048              MOVS     r0,#0x48
00004e  f88d0037          STRB     r0,[sp,#0x37]
;;;185    	GPIO_Init(GPIOG, &GPIO_InitStructure);
000052  a90d              ADD      r1,sp,#0x34
000054  4811              LDR      r0,|L3.156|
000056  f7fffffe          BL       GPIO_Init
;;;186    	
;;;187    	/* FSMC 配置 */
;;;188    	p.FSMC_SetupTime = 0x1;
00005a  2001              MOVS     r0,#1
;;;189    	p.FSMC_WaitSetupTime = 0x3;
;;;190    	p.FSMC_HoldSetupTime = 0x2;
00005c  e9cd0409          STRD     r0,r4,[sp,#0x24]
000060  2102              MOVS     r1,#2
000062  e9cd100b          STRD     r1,r0,[sp,#0x2c]
;;;191    	p.FSMC_HiZSetupTime = 0x1;
;;;192    	
;;;193    	FSMC_NANDInitStructure.FSMC_Bank = FSMC_Bank2_NAND;							/* 定义FSMC BANK 号 */
000066  2010              MOVS     r0,#0x10
000068  e9cd0100          STRD     r0,r1,[sp,#0]
;;;194    	FSMC_NANDInitStructure.FSMC_Waitfeature = FSMC_Waitfeature_Enable;			/* 插入等待时序使能 */
;;;195    	FSMC_NANDInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;		/* 数据宽度 8bit */
00006c  2000              MOVS     r0,#0
;;;196    	FSMC_NANDInitStructure.FSMC_ECC = FSMC_ECC_Enable;							/* ECC错误检查和纠正功能使能 */
;;;197    	FSMC_NANDInitStructure.FSMC_ECCPageSize = FSMC_ECCPageSize_2048Bytes;		/* ECC 页面大小 */
00006e  0461              LSLS     r1,r4,#17
000070  e9cd0502          STRD     r0,r5,[sp,#8]
000074  e9cd1004          STRD     r1,r0,[sp,#0x10]
;;;198    	FSMC_NANDInitStructure.FSMC_TCLRSetupTime = 0x00;
;;;199    	FSMC_NANDInitStructure.FSMC_TARSetupTime = 0x00;
;;;200    	FSMC_NANDInitStructure.FSMC_CommonSpaceTimingStruct = &p;
000078  9006              STR      r0,[sp,#0x18]
00007a  a809              ADD      r0,sp,#0x24
;;;201    	FSMC_NANDInitStructure.FSMC_AttributeSpaceTimingStruct = &p;
00007c  9007              STR      r0,[sp,#0x1c]
;;;202    	
;;;203    	FSMC_NANDInit(&FSMC_NANDInitStructure);
00007e  9008              STR      r0,[sp,#0x20]
000080  4668              MOV      r0,sp
000082  f7fffffe          BL       FSMC_NANDInit
;;;204    	
;;;205    	/* FSMC NAND Bank 使能 */
;;;206    	FSMC_NANDCmd(FSMC_Bank2_NAND, ENABLE);
000086  2101              MOVS     r1,#1
000088  2010              MOVS     r0,#0x10
00008a  f7fffffe          BL       FSMC_NANDCmd
;;;207    }
00008e  b00f              ADD      sp,sp,#0x3c
000090  bd30              POP      {r4,r5,pc}
;;;208    
                          ENDP

000092  0000              DCW      0x0000
                  |L3.148|
                          DCD      0x40011400
                  |L3.152|
                          DCD      0x40011800
                  |L3.156|
                          DCD      0x40012000

                          AREA ||i.FSMC_NAND_PageCopyBack||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  FSMC_NAND_PageCopyBack PROC
;;;247    */
;;;248    static uint8_t FSMC_NAND_PageCopyBack(uint32_t _ulSrcPageNo, uint32_t _ulTarPageNo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;249    {
000004  460d              MOV      r5,r1
000006  4606              MOV      r6,r0
;;;250    	uint8_t i;
;;;251    
;;;252    	if ((_ulSrcPageNo & 0x40) != (_ulTarPageNo & 0x40))
000008  f0000040          AND      r0,r0,#0x40
00000c  f0010140          AND      r1,r1,#0x40
000010  4288              CMP      r0,r1
000012  d003              BEQ      |L4.28|
;;;253    	{
;;;254    		printf_err("Error : FSMC_NAND_PageCopyBackEx(src=%d, tar=%d) \r\n", _ulSrcPageNo, _ulTarPageNo);
000014  462a              MOV      r2,r5
000016  4631              MOV      r1,r6
000018  a01b              ADR      r0,|L4.136|
;;;255    		return NAND_FAIL;
00001a  e02d              B        |L4.120|
                  |L4.28|
;;;256    	}
;;;257    
;;;258    	NAND_CMD_AREA = NAND_CMD_COPYBACK_A;
00001c  4f27              LDR      r7,|L4.188|
00001e  f04f0800          MOV      r8,#0
000022  f8878000          STRB     r8,[r7,#0]
;;;259    
;;;260    	/* 发送源页地址 ， 对于 HY27UF081G2A
;;;261    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;262    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;263    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;264    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;265    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;266    
;;;267    		H27U4G8F2DTR (512MB)
;;;268    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;269    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;270    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;271    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;272    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;273    		第5字节： A28  A29  A30  A31  0    0    0    0
;;;274    	*/
;;;275    	NAND_ADDR_AREA = 0;
000026  4c26              LDR      r4,|L4.192|
000028  f8848000          STRB     r8,[r4,#0]
;;;276    	NAND_ADDR_AREA = 0;
00002c  f8848000          STRB     r8,[r4,#0]
;;;277    	NAND_ADDR_AREA = _ulSrcPageNo;
000030  7026              STRB     r6,[r4,#0]
;;;278    	NAND_ADDR_AREA = (_ulSrcPageNo & 0xFF00) >> 8;
000032  0a30              LSRS     r0,r6,#8
000034  7020              STRB     r0,[r4,#0]
;;;279    
;;;280    	#if NAND_ADDR_5 == 1
;;;281    		NAND_ADDR_AREA = (_ulSrcPageNo & 0xFF0000) >> 16;
;;;282    	#endif
;;;283    
;;;284    	NAND_CMD_AREA = NAND_CMD_COPYBACK_B;
000036  2035              MOVS     r0,#0x35
000038  7038              STRB     r0,[r7,#0]
;;;285    
;;;286    	/* 必须等待，否则读出数据异常, 此处应该判断超时 */
;;;287    	for (i = 0; i < 20; i++);
00003a  4640              MOV      r0,r8
                  |L4.60|
00003c  1c40              ADDS     r0,r0,#1
00003e  b2c0              UXTB     r0,r0
000040  2814              CMP      r0,#0x14
000042  d3fb              BCC      |L4.60|
;;;288    	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0 );
000044  f8df907c          LDR      r9,|L4.196|
                  |L4.72|
000048  2140              MOVS     r1,#0x40
00004a  4648              MOV      r0,r9
00004c  f7fffffe          BL       GPIO_ReadInputDataBit
000050  2800              CMP      r0,#0
000052  d0f9              BEQ      |L4.72|
;;;289    
;;;290    	NAND_CMD_AREA = NAND_CMD_COPYBACK_C;
000054  2085              MOVS     r0,#0x85
000056  7038              STRB     r0,[r7,#0]
;;;291    
;;;292    	/* 发送目标页地址 ， 对于 HY27UF081G2A
;;;293    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;294    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;295    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;296    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;297    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;298    
;;;299    		H27U4G8F2DTR (512MB)
;;;300    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;301    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;302    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;303    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12    --- A18 是plane地址
;;;304    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;305    		第5字节： A28  A29  A30  A31  0    0    0    0
;;;306    
;;;307    		Source and Destination page in the copy back program sequence must belong to the same device plane （A18）
;;;308    		源地址和目标地址的 A18必须相同
;;;309    	*/
;;;310    	NAND_ADDR_AREA = 0;
000058  f8848000          STRB     r8,[r4,#0]
;;;311    	NAND_ADDR_AREA = 0;
00005c  f8848000          STRB     r8,[r4,#0]
;;;312    	NAND_ADDR_AREA = _ulTarPageNo;
000060  7025              STRB     r5,[r4,#0]
;;;313    	NAND_ADDR_AREA = (_ulTarPageNo & 0xFF00) >> 8;
000062  0a28              LSRS     r0,r5,#8
000064  7020              STRB     r0,[r4,#0]
;;;314    
;;;315    	#if NAND_ADDR_5 == 1
;;;316    		NAND_ADDR_AREA = (_ulTarPageNo & 0xFF0000) >> 16;
;;;317    	#endif
;;;318    
;;;319    	NAND_CMD_AREA = NAND_CMD_COPYBACK_D;
000066  2010              MOVS     r0,#0x10
000068  7038              STRB     r0,[r7,#0]
;;;320    
;;;321    	/* 检查操作状态 */
;;;322    	if (FSMC_NAND_GetStatus() == NAND_READY)
00006a  f7fffffe          BL       FSMC_NAND_GetStatus
00006e  2840              CMP      r0,#0x40
000070  d007              BEQ      |L4.130|
;;;323    	{
;;;324    		return NAND_OK;
;;;325    	}
;;;326    
;;;327    	printf_err("Error: FSMC_NAND_PageCopyBack(%d, %d)\r\n", _ulSrcPageNo, _ulTarPageNo);
000072  462a              MOV      r2,r5
000074  4631              MOV      r1,r6
000076  a014              ADR      r0,|L4.200|
                  |L4.120|
000078  f7fffffe          BL       __2printf
;;;328    	return NAND_FAIL;
00007c  2001              MOVS     r0,#1
                  |L4.126|
;;;329    }
00007e  e8bd87f0          POP      {r4-r10,pc}
                  |L4.130|
000082  2000              MOVS     r0,#0                 ;324
000084  e7fb              B        |L4.126|
;;;330    
                          ENDP

000086  0000              DCW      0x0000
                  |L4.136|
000088  4572726f          DCB      "Error : FSMC_NAND_PageCopyBackEx(src=%d, tar=%d) \r\n",0
00008c  72203a20
000090  46534d43
000094  5f4e414e
000098  445f5061
00009c  6765436f
0000a0  70794261
0000a4  636b4578
0000a8  28737263
0000ac  3d25642c
0000b0  20746172
0000b4  3d256429
0000b8  200d0a00
                  |L4.188|
                          DCD      0x70010000
                  |L4.192|
                          DCD      0x70020000
                  |L4.196|
                          DCD      0x40012000
                  |L4.200|
0000c8  4572726f          DCB      "Error: FSMC_NAND_PageCopyBack(%d, %d)\r\n",0
0000cc  723a2046
0000d0  534d435f
0000d4  4e414e44
0000d8  5f506167
0000dc  65436f70
0000e0  79426163
0000e4  6b282564
0000e8  2c202564
0000ec  290d0a00

                          AREA ||i.FSMC_NAND_PageCopyBackEx||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  FSMC_NAND_PageCopyBackEx PROC
;;;347    */
;;;348    static uint8_t FSMC_NAND_PageCopyBackEx(uint32_t _ulSrcPageNo, uint32_t _ulTarPageNo, uint8_t *_pBuf, 
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;349    	uint16_t _usOffset, uint16_t _usSize)
;;;350    {
000004  460c              MOV      r4,r1
000006  4605              MOV      r5,r0
;;;351    	uint16_t i;
;;;352    
;;;353    	if ((_ulSrcPageNo & 0x40) != (_ulTarPageNo & 0x40))
000008  f0000040          AND      r0,r0,#0x40
00000c  f0010140          AND      r1,r1,#0x40
000010  9f0a              LDR      r7,[sp,#0x28]
000012  461e              MOV      r6,r3                 ;350
000014  4693              MOV      r11,r2                ;350
000016  4288              CMP      r0,r1
000018  d005              BEQ      |L5.38|
;;;354    	{
;;;355    		printf_err("Error A18 not same:  FSMC_NAND_PageCopyBackEx(src=%d, tar=%d) \r\n", _ulSrcPageNo, _ulTarPageNo);
00001a  4622              MOV      r2,r4
00001c  4629              MOV      r1,r5
00001e  482a              LDR      r0,|L5.200|
000020  f7fffffe          BL       __2printf
;;;356    		return NAND_FAIL;
000024  e04a              B        |L5.188|
                  |L5.38|
;;;357    	}
;;;358    
;;;359    	NAND_CMD_AREA = NAND_CMD_COPYBACK_A;
000026  f8df80a4          LDR      r8,|L5.204|
00002a  f04f0900          MOV      r9,#0
00002e  f8889000          STRB     r9,[r8,#0]
;;;360    
;;;361    	/* 发送源页地址 ， 对于 HY27UF081G2A
;;;362    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;363    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;364    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;365    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;366    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;367    
;;;368    		H27U4G8F2DTR (512MB)
;;;369    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;370    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;371    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;372    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;373    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;374    		第5字节： A28  A29  A30  A31  0    0    0    0
;;;375    	*/
;;;376    	NAND_ADDR_AREA = 0;
000032  f8dfa09c          LDR      r10,|L5.208|
000036  f88a9000          STRB     r9,[r10,#0]
;;;377    	NAND_ADDR_AREA = 0;
00003a  f88a9000          STRB     r9,[r10,#0]
;;;378    	NAND_ADDR_AREA = _ulSrcPageNo;
00003e  f88a5000          STRB     r5,[r10,#0]
;;;379    	NAND_ADDR_AREA = (_ulSrcPageNo & 0xFF00) >> 8;
000042  0a29              LSRS     r1,r5,#8
000044  f88a1000          STRB     r1,[r10,#0]
;;;380    
;;;381    	#if NAND_ADDR_5 == 1
;;;382    		NAND_ADDR_AREA = (_ulSrcPageNo & 0xFF0000) >> 16;
;;;383    	#endif
;;;384    
;;;385    	NAND_CMD_AREA = NAND_CMD_COPYBACK_B;
000048  2035              MOVS     r0,#0x35
00004a  f8880000          STRB     r0,[r8,#0]
;;;386    
;;;387    	/* 必须等待，否则读出数据异常, 此处应该判断超时 */
;;;388    	for (i = 0; i < 20; i++);
00004e  4648              MOV      r0,r9
                  |L5.80|
000050  1c40              ADDS     r0,r0,#1
000052  b280              UXTH     r0,r0
000054  2814              CMP      r0,#0x14
000056  d3fb              BCC      |L5.80|
                  |L5.88|
;;;389    	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0 );
000058  2140              MOVS     r1,#0x40
00005a  481e              LDR      r0,|L5.212|
00005c  f7fffffe          BL       GPIO_ReadInputDataBit
000060  2800              CMP      r0,#0
000062  d0f9              BEQ      |L5.88|
;;;390    
;;;391    	NAND_CMD_AREA = NAND_CMD_COPYBACK_C;
000064  2385              MOVS     r3,#0x85
000066  4641              MOV      r1,r8
000068  f8883000          STRB     r3,[r8,#0]
;;;392    
;;;393    	/* 发送目标页地址 ， 对于 HY27UF081G2A
;;;394    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;395    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;396    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;397    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;398    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;399    
;;;400    		H27U4G8F2DTR (512MB)
;;;401    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;402    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;403    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;404    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;405    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;406    		第5字节： A28  A29  A30  A31  0    0    0    0
;;;407    	*/
;;;408    	NAND_ADDR_AREA = 0;
00006c  f88a9000          STRB     r9,[r10,#0]
;;;409    	NAND_ADDR_AREA = 0;
000070  f88a9000          STRB     r9,[r10,#0]
;;;410    	NAND_ADDR_AREA = _ulTarPageNo;
000074  f88a4000          STRB     r4,[r10,#0]
;;;411    	NAND_ADDR_AREA = (_ulTarPageNo & 0xFF00) >> 8;
000078  0a22              LSRS     r2,r4,#8
00007a  f88a2000          STRB     r2,[r10,#0]
;;;412    
;;;413    	#if NAND_ADDR_5 == 1
;;;414    		NAND_ADDR_AREA = (_ulTarPageNo & 0xFF0000) >> 16;
;;;415    	#endif
;;;416    
;;;417    	/* 中间无需带数据, 也无需等待 */
;;;418    
;;;419    	NAND_CMD_AREA = NAND_CMD_COPYBACK_C;
00007e  f8883000          STRB     r3,[r8,#0]
;;;420    
;;;421    	NAND_ADDR_AREA = _usOffset;
000082  f88a6000          STRB     r6,[r10,#0]
;;;422    	NAND_ADDR_AREA = _usOffset >> 8;
000086  0a32              LSRS     r2,r6,#8
000088  f88a2000          STRB     r2,[r10,#0]
;;;423    
;;;424    	/* 发送数据 */
;;;425    	for(i = 0; i < _usSize; i++)
00008c  2000              MOVS     r0,#0
;;;426    	{
;;;427    		NAND_DATA_AREA = _pBuf[i];
00008e  f04f42e0          MOV      r2,#0x70000000
000092  e004              B        |L5.158|
                  |L5.148|
000094  f81b3000          LDRB     r3,[r11,r0]
000098  7013              STRB     r3,[r2,#0]
00009a  1c40              ADDS     r0,r0,#1
00009c  b280              UXTH     r0,r0                 ;425
                  |L5.158|
00009e  42b8              CMP      r0,r7                 ;425
0000a0  d3f8              BCC      |L5.148|
;;;428    	}
;;;429    
;;;430    	NAND_CMD_AREA = NAND_CMD_COPYBACK_D;
0000a2  2010              MOVS     r0,#0x10
0000a4  7008              STRB     r0,[r1,#0]
;;;431    
;;;432    	/* 检查操作状态 */
;;;433    	if (FSMC_NAND_GetStatus() == NAND_READY)
0000a6  f7fffffe          BL       FSMC_NAND_GetStatus
0000aa  2840              CMP      r0,#0x40
0000ac  d009              BEQ      |L5.194|
;;;434    	{
;;;435    		return NAND_OK;
;;;436    	}
;;;437    
;;;438    	printf_err("Error: FSMC_NAND_PageCopyBackEx(src=%d, tar=%d, offset=%d, size=%d)\r\n",
0000ae  4633              MOV      r3,r6
0000b0  4622              MOV      r2,r4
0000b2  4629              MOV      r1,r5
0000b4  4808              LDR      r0,|L5.216|
0000b6  9700              STR      r7,[sp,#0]
0000b8  f7fffffe          BL       __2printf
                  |L5.188|
;;;439    			_ulSrcPageNo, _ulTarPageNo, _usOffset, _usSize);
;;;440    	return NAND_FAIL;
0000bc  2001              MOVS     r0,#1
                  |L5.190|
;;;441    }
0000be  e8bd8ff8          POP      {r3-r11,pc}
                  |L5.194|
0000c2  2000              MOVS     r0,#0                 ;435
0000c4  e7fb              B        |L5.190|
;;;442    
                          ENDP

0000c6  0000              DCW      0x0000
                  |L5.200|
                          DCD      ||.conststring||
                  |L5.204|
                          DCD      0x70010000
                  |L5.208|
                          DCD      0x70020000
                  |L5.212|
                          DCD      0x40012000
                  |L5.216|
                          DCD      ||.conststring||+0x44

                          AREA ||i.FSMC_NAND_ReadData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  FSMC_NAND_ReadData PROC
;;;729    */
;;;730    static uint8_t FSMC_NAND_ReadData(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  b510              PUSH     {r4,lr}
;;;731    {
;;;732    	if (_usByteCount > NAND_PAGE_SIZE)
000002  f5b36f00          CMP      r3,#0x800
000006  d905              BLS      |L6.20|
;;;733    	{
;;;734    		printf_err("Error: FSMC_NAND_ReadData() %d\r\n",_usByteCount);
000008  4619              MOV      r1,r3
00000a  a004              ADR      r0,|L6.28|
00000c  f7fffffe          BL       __2printf
;;;735    		return NAND_FAIL;
000010  2001              MOVS     r0,#1
;;;736    	}
;;;737    
;;;738    	return FSMC_NAND_ReadPage(_pBuffer, _ulPageNo, _usAddrInPage, _usByteCount);
;;;739    }
000012  bd10              POP      {r4,pc}
                  |L6.20|
000014  e8bd4010          POP      {r4,lr}               ;738
000018  f7ffbffe          B.W      FSMC_NAND_ReadPage
;;;740    
                          ENDP

                  |L6.28|
00001c  4572726f          DCB      "Error: FSMC_NAND_ReadData() %d\r\n",0
000020  723a2046
000024  534d435f
000028  4e414e44
00002c  5f526561
000030  64446174
000034  61282920
000038  25640d0a
00003c  00      
00003d  00                DCB      0
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.FSMC_NAND_ReadPage||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_ReadPage PROC
;;;536    */
;;;537    static uint8_t FSMC_NAND_ReadPage(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  b570              PUSH     {r4-r6,lr}
;;;538    {
000002  461c              MOV      r4,r3
;;;539    	uint16_t i;
;;;540    
;;;541        /* 发送页面读命令 */
;;;542        NAND_CMD_AREA = NAND_CMD_AREA_A;
000004  4b12              LDR      r3,|L7.80|
000006  4605              MOV      r5,r0                 ;538
000008  2000              MOVS     r0,#0
00000a  7018              STRB     r0,[r3,#0]
;;;543    
;;;544    	/* 发送页内地址 ， 对于 HY27UF081G2A  (128MB)
;;;545    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;546    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;547    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;548    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;549    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;550    
;;;551    		H27U4G8F2DTR (512MB)
;;;552    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;553    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;554    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;555    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;556    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;557    		第5字节： A28  A29  A30  A31  0    0    0    0
;;;558    	*/
;;;559    	NAND_ADDR_AREA = _usAddrInPage;
00000c  4811              LDR      r0,|L7.84|
00000e  7002              STRB     r2,[r0,#0]
;;;560    	NAND_ADDR_AREA = _usAddrInPage >> 8;
000010  0a12              LSRS     r2,r2,#8
000012  7002              STRB     r2,[r0,#0]
;;;561    	NAND_ADDR_AREA = _ulPageNo;
000014  7001              STRB     r1,[r0,#0]
;;;562    	NAND_ADDR_AREA = (_ulPageNo & 0xFF00) >> 8;
000016  0a09              LSRS     r1,r1,#8
000018  7001              STRB     r1,[r0,#0]
;;;563    
;;;564    	#if NAND_ADDR_5 == 1
;;;565    		NAND_ADDR_AREA = (_ulPageNo & 0xFF0000) >> 16;
;;;566    	#endif
;;;567    
;;;568    	NAND_CMD_AREA = NAND_CMD_AREA_TRUE1;
00001a  2030              MOVS     r0,#0x30
00001c  7018              STRB     r0,[r3,#0]
;;;569    
;;;570    	 /* 必须等待，否则读出数据异常, 此处应该判断超时 */
;;;571    	for (i = 0; i < 20; i++);
00001e  2100              MOVS     r1,#0
                  |L7.32|
000020  1c49              ADDS     r1,r1,#1
000022  b289              UXTH     r1,r1
000024  2914              CMP      r1,#0x14
000026  d3fb              BCC      |L7.32|
;;;572    	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0);
000028  4e0b              LDR      r6,|L7.88|
                  |L7.42|
00002a  2140              MOVS     r1,#0x40
00002c  4630              MOV      r0,r6
00002e  f7fffffe          BL       GPIO_ReadInputDataBit
000032  2800              CMP      r0,#0
000034  d0f9              BEQ      |L7.42|
;;;573    
;;;574    	/* 读数据到缓冲区pBuffer */
;;;575    	for(i = 0; i < _usByteCount; i++)
000036  2100              MOVS     r1,#0
;;;576    	{
;;;577    		_pBuffer[i] = NAND_DATA_AREA;
000038  f04f40e0          MOV      r0,#0x70000000
00003c  e003              B        |L7.70|
                  |L7.62|
00003e  7802              LDRB     r2,[r0,#0]
000040  546a              STRB     r2,[r5,r1]
000042  1c49              ADDS     r1,r1,#1
000044  b289              UXTH     r1,r1                 ;575
                  |L7.70|
000046  42a1              CMP      r1,r4                 ;575
000048  d3f9              BCC      |L7.62|
;;;578    	}
;;;579    
;;;580    	return NAND_OK;
00004a  2000              MOVS     r0,#0
;;;581    }
00004c  bd70              POP      {r4-r6,pc}
;;;582    
                          ENDP

00004e  0000              DCW      0x0000
                  |L7.80|
                          DCD      0x70010000
                  |L7.84|
                          DCD      0x70020000
                  |L7.88|
                          DCD      0x40012000

                          AREA ||i.FSMC_NAND_ReadSpare||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  FSMC_NAND_ReadSpare PROC
;;;681    */
;;;682    static uint8_t FSMC_NAND_ReadSpare(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInSpare, uint16_t _usByteCount)
000000  b510              PUSH     {r4,lr}
;;;683    {
;;;684    	if (_usByteCount > NAND_SPARE_AREA_SIZE)
000002  2b40              CMP      r3,#0x40
000004  d905              BLS      |L8.18|
;;;685    	{
;;;686    		printf_err("Error: FSMC_NAND_ReadSpare() %d\r\n",_usByteCount);
000006  4619              MOV      r1,r3
000008  a005              ADR      r0,|L8.32|
00000a  f7fffffe          BL       __2printf
;;;687    		return NAND_FAIL;
00000e  2001              MOVS     r0,#1
;;;688    	}
;;;689    
;;;690    	return FSMC_NAND_ReadPage(_pBuffer, _ulPageNo, NAND_PAGE_SIZE + _usAddrInSpare, _usByteCount);
;;;691    }
000010  bd10              POP      {r4,pc}
                  |L8.18|
000012  f5026200          ADD      r2,r2,#0x800
000016  e8bd4010          POP      {r4,lr}               ;690
00001a  b292              UXTH     r2,r2                 ;690
00001c  f7ffbffe          B.W      FSMC_NAND_ReadPage
;;;692    
                          ENDP

                  |L8.32|
000020  4572726f          DCB      "Error: FSMC_NAND_ReadSpare() %d\r\n",0
000024  723a2046
000028  534d435f
00002c  4e414e44
000030  5f526561
000034  64537061
000038  72652829
00003c  2025640d
000040  0a00    
000042  00                DCB      0
000043  00                DCB      0

                          AREA ||i.FSMC_NAND_ReadStatus||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_ReadStatus PROC
;;;819    */
;;;820    static uint8_t FSMC_NAND_ReadStatus(void)
000000  4a06              LDR      r2,|L9.28|
;;;821    {
;;;822    	uint8_t ucData;
;;;823    	uint8_t ucStatus = NAND_BUSY;
000002  2000              MOVS     r0,#0
;;;824    
;;;825    	/* 读状态操作 */
;;;826    	NAND_CMD_AREA = NAND_CMD_STATUS;
000004  2170              MOVS     r1,#0x70
000006  7011              STRB     r1,[r2,#0]
;;;827    	ucData = *(__IO uint8_t *)(Bank_NAND_ADDR);
000008  0609              LSLS     r1,r1,#24
00000a  7809              LDRB     r1,[r1,#0]
;;;828    
;;;829    	if((ucData & NAND_ERROR) == NAND_ERROR)
00000c  07ca              LSLS     r2,r1,#31
00000e  d001              BEQ      |L9.20|
;;;830    	{
;;;831    		ucStatus = NAND_ERROR;
000010  2001              MOVS     r0,#1
                  |L9.18|
;;;832    	}
;;;833    	else if((ucData & NAND_READY) == NAND_READY)
;;;834    	{
;;;835    		ucStatus = NAND_READY;
;;;836    	}
;;;837    	else
;;;838    	{
;;;839    		ucStatus = NAND_BUSY;
;;;840    	}
;;;841    
;;;842    	return (ucStatus);
;;;843    }
000012  4770              BX       lr
                  |L9.20|
000014  0649              LSLS     r1,r1,#25             ;833
000016  d5fc              BPL      |L9.18|
000018  2040              MOVS     r0,#0x40              ;835
00001a  4770              BX       lr
;;;844    
                          ENDP

                  |L9.28|
                          DCD      0x70010000

                          AREA ||i.FSMC_NAND_Reset||, CODE, READONLY, ALIGN=2

                  FSMC_NAND_Reset PROC
;;;795    */
;;;796    static uint8_t FSMC_NAND_Reset(void)
000000  4905              LDR      r1,|L10.24|
;;;797    {
000002  b510              PUSH     {r4,lr}
;;;798    	NAND_CMD_AREA = NAND_CMD_RESET;
000004  20ff              MOVS     r0,#0xff
000006  7008              STRB     r0,[r1,#0]
;;;799    
;;;800    		/* 检查操作状态 */
;;;801    	if (FSMC_NAND_GetStatus() == NAND_READY)
000008  f7fffffe          BL       FSMC_NAND_GetStatus
00000c  2840              CMP      r0,#0x40
00000e  d001              BEQ      |L10.20|
;;;802    	{
;;;803    		return NAND_OK;
;;;804    	}
;;;805    
;;;806    	return NAND_FAIL;
000010  2001              MOVS     r0,#1
;;;807    }
000012  bd10              POP      {r4,pc}
                  |L10.20|
000014  2000              MOVS     r0,#0                 ;803
000016  bd10              POP      {r4,pc}
;;;808    
                          ENDP

                  |L10.24|
                          DCD      0x70010000

                          AREA ||i.FSMC_NAND_WriteData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  FSMC_NAND_WriteData PROC
;;;705    */
;;;706    static uint8_t FSMC_NAND_WriteData(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  b510              PUSH     {r4,lr}
;;;707    {
;;;708    	if (_usByteCount > NAND_PAGE_SIZE)
000002  f5b36f00          CMP      r3,#0x800
000006  d905              BLS      |L11.20|
;;;709    	{
;;;710    		printf_err("Error: FSMC_NAND_WriteData() %d\r\n",_usByteCount);
000008  4619              MOV      r1,r3
00000a  a004              ADR      r0,|L11.28|
00000c  f7fffffe          BL       __2printf
;;;711    		return NAND_FAIL;
000010  2001              MOVS     r0,#1
;;;712    	}
;;;713    
;;;714    	return FSMC_NAND_WritePage(_pBuffer, _ulPageNo, _usAddrInPage, _usByteCount);
;;;715    }
000012  bd10              POP      {r4,pc}
                  |L11.20|
000014  e8bd4010          POP      {r4,lr}               ;714
000018  f7ffbffe          B.W      FSMC_NAND_WritePage
;;;716    
                          ENDP

                  |L11.28|
00001c  4572726f          DCB      "Error: FSMC_NAND_WriteData() %d\r\n",0
000020  723a2046
000024  534d435f
000028  4e414e44
00002c  5f577269
000030  74654461
000034  74612829
000038  2025640d
00003c  0a00    
00003e  00                DCB      0
00003f  00                DCB      0

                          AREA ||i.FSMC_NAND_WritePage||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  FSMC_NAND_WritePage PROC
;;;455    */
;;;456    static uint8_t FSMC_NAND_WritePage(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInPage, uint16_t _usByteCount)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;457    {
000004  460d              MOV      r5,r1
;;;458    	uint16_t i;
;;;459    
;;;460    	/* 发送页写命令 */
;;;461    	NAND_CMD_AREA = NAND_CMD_WRITE0;
000006  4923              LDR      r1,|L12.148|
000008  4607              MOV      r7,r0                 ;457
00000a  2080              MOVS     r0,#0x80
00000c  461e              MOV      r6,r3                 ;457
00000e  4614              MOV      r4,r2                 ;457
000010  7008              STRB     r0,[r1,#0]
;;;462    
;;;463    	/* 发送页内地址 ， 对于 HY27UF081G2A
;;;464    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;465    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;466    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;467    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;468    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;469    
;;;470    		H27U4G8F2DTR (512MB)
;;;471    				  Bit7 Bit6 Bit5 Bit4 Bit3 Bit2 Bit1 Bit0
;;;472    		第1字节： A7   A6   A5   A4   A3   A2   A1   A0		(_usPageAddr 的bit7 - bit0)
;;;473    		第2字节： 0    0    0    0    A11  A10  A9   A8		(_usPageAddr 的bit11 - bit8, 高4bit必须是0)
;;;474    		第3字节： A19  A18  A17  A16  A15  A14  A13  A12
;;;475    		第4字节： A27  A26  A25  A24  A23  A22  A21  A20
;;;476    		第5字节： A28  A29  A30  A31  0    0    0    0
;;;477    	*/
;;;478    	NAND_ADDR_AREA = _usAddrInPage;
000012  4821              LDR      r0,|L12.152|
000014  7002              STRB     r2,[r0,#0]
;;;479    	NAND_ADDR_AREA = _usAddrInPage >> 8;
000016  0a12              LSRS     r2,r2,#8
000018  7002              STRB     r2,[r0,#0]
;;;480    	NAND_ADDR_AREA = _ulPageNo;
00001a  7005              STRB     r5,[r0,#0]
;;;481    	NAND_ADDR_AREA = (_ulPageNo & 0xFF00) >> 8;
00001c  0a2a              LSRS     r2,r5,#8
00001e  7002              STRB     r2,[r0,#0]
;;;482    
;;;483    	#if NAND_ADDR_5 == 1
;;;484    		NAND_ADDR_AREA = (_ulPageNo & 0xFF0000) >> 16;
;;;485    	#endif
;;;486    
;;;487    	/* tADL = 100ns,  Address to Data Loading */
;;;488    	for (i = 0; i < 20; i++);	/* 需要大于 100ns */
000020  2000              MOVS     r0,#0
                  |L12.34|
000022  1c40              ADDS     r0,r0,#1
000024  b280              UXTH     r0,r0
000026  2814              CMP      r0,#0x14
000028  d3fb              BCC      |L12.34|
;;;489    
;;;490    	/* 写数据 */
;;;491    	for(i = 0; i < _usByteCount; i++)
00002a  2000              MOVS     r0,#0
;;;492    	{
;;;493    		NAND_DATA_AREA = _pBuffer[i];
00002c  f04f42e0          MOV      r2,#0x70000000
000030  e003              B        |L12.58|
                  |L12.50|
000032  5c3b              LDRB     r3,[r7,r0]
000034  7013              STRB     r3,[r2,#0]
000036  1c40              ADDS     r0,r0,#1
000038  b280              UXTH     r0,r0                 ;491
                  |L12.58|
00003a  42b0              CMP      r0,r6                 ;491
00003c  d3f9              BCC      |L12.50|
;;;494    	}
;;;495    	NAND_CMD_AREA = NAND_CMD_WRITE_TRUE1;
00003e  2010              MOVS     r0,#0x10
000040  7008              STRB     r0,[r1,#0]
;;;496    
;;;497    	/* WE High to Busy , 100ns */
;;;498    	for (i = 0; i < 20; i++);	/* 需要大于 100ns */
000042  2000              MOVS     r0,#0
                  |L12.68|
000044  1c40              ADDS     r0,r0,#1
000046  b280              UXTH     r0,r0
000048  2814              CMP      r0,#0x14
00004a  d3fb              BCC      |L12.68|
;;;499    	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0 );
00004c  f8df804c          LDR      r8,|L12.156|
                  |L12.80|
000050  2140              MOVS     r1,#0x40
000052  4640              MOV      r0,r8
000054  f7fffffe          BL       GPIO_ReadInputDataBit
000058  2800              CMP      r0,#0
00005a  d0f9              BEQ      |L12.80|
;;;500    	
;;;501    	/* 检查操作状态 */
;;;502    	if (FSMC_NAND_GetStatus() == NAND_READY)
00005c  f7fffffe          BL       FSMC_NAND_GetStatus
000060  2840              CMP      r0,#0x40
;;;503    	{
;;;504    			/* 读出数据进行校验 */
;;;505    		#ifdef WRITE_PAGE_VERIFY_EN
;;;506    			FSMC_NAND_ReadPage (s_ucTempBuf, _ulPageNo, _usAddrInPage, _usByteCount);
;;;507    			if (memcmp(s_ucTempBuf,  _pBuffer, _usByteCount) != 0)
;;;508    			{
;;;509    				printf_err("Error1: FSMC_NAND_WritePage(page=%d, addr=%d, count=%d)\r\n",
;;;510    					_ulPageNo, _usAddrInPage, _usByteCount);				
;;;511    				return NAND_FAIL;	
;;;512    			}			
;;;513    		#endif
;;;514    		
;;;515    		return NAND_OK;
;;;516    	}
;;;517    
;;;518    	printf_err("Error2: FSMC_NAND_WritePage(page=%d, addr=%d, count=%d)\r\n",
000062  4633              MOV      r3,r6
000064  4622              MOV      r2,r4
000066  4629              MOV      r1,r5
000068  d001              BEQ      |L12.110|
00006a  a00d              ADR      r0,|L12.160|
;;;519    		_ulPageNo, _usAddrInPage, _usByteCount);
;;;520    	
;;;521    	return NAND_FAIL;
00006c  e00d              B        |L12.138|
                  |L12.110|
00006e  481b              LDR      r0,|L12.220|
000070  f7fffffe          BL       FSMC_NAND_ReadPage
000074  4632              MOV      r2,r6                 ;507
000076  4639              MOV      r1,r7                 ;507
000078  4818              LDR      r0,|L12.220|
00007a  f7fffffe          BL       memcmp
00007e  2800              CMP      r0,#0                 ;507
000080  d006              BEQ      |L12.144|
000082  4633              MOV      r3,r6                 ;509
000084  4622              MOV      r2,r4                 ;509
000086  4629              MOV      r1,r5                 ;509
000088  a015              ADR      r0,|L12.224|
                  |L12.138|
00008a  f7fffffe          BL       __2printf
00008e  2001              MOVS     r0,#1
                  |L12.144|
;;;522    }
000090  e8bd81f0          POP      {r4-r8,pc}
;;;523    
                          ENDP

                  |L12.148|
                          DCD      0x70010000
                  |L12.152|
                          DCD      0x70020000
                  |L12.156|
                          DCD      0x40012000
                  |L12.160|
0000a0  4572726f          DCB      "Error2: FSMC_NAND_WritePage(page=%d, addr=%d, count=%d)"
0000a4  72323a20
0000a8  46534d43
0000ac  5f4e414e
0000b0  445f5772
0000b4  69746550
0000b8  61676528
0000bc  70616765
0000c0  3d25642c
0000c4  20616464
0000c8  723d2564
0000cc  2c20636f
0000d0  756e743d
0000d4  256429  
0000d7  0d0a00            DCB      "\r\n",0
0000da  00                DCB      0
0000db  00                DCB      0
                  |L12.220|
                          DCD      ||.bss||+0x800
                  |L12.224|
0000e0  4572726f          DCB      "Error1: FSMC_NAND_WritePage(page=%d, addr=%d, count=%d)"
0000e4  72313a20
0000e8  46534d43
0000ec  5f4e414e
0000f0  445f5772
0000f4  69746550
0000f8  61676528
0000fc  70616765
000100  3d25642c
000104  20616464
000108  723d2564
00010c  2c20636f
000110  756e743d
000114  256429  
000117  0d0a00            DCB      "\r\n",0
00011a  00                DCB      0
00011b  00                DCB      0

                          AREA ||i.FSMC_NAND_WriteSpare||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  FSMC_NAND_WriteSpare PROC
;;;657    */
;;;658    static uint8_t FSMC_NAND_WriteSpare(uint8_t *_pBuffer, uint32_t _ulPageNo, uint16_t _usAddrInSpare, uint16_t _usByteCount)
000000  b510              PUSH     {r4,lr}
;;;659    {
;;;660    	if (_usByteCount > NAND_SPARE_AREA_SIZE)
000002  2b40              CMP      r3,#0x40
000004  d905              BLS      |L13.18|
;;;661    	{
;;;662    		printf_err("Error: FSMC_NAND_WriteSpare() %d\r\n",_usByteCount);
000006  4619              MOV      r1,r3
000008  a005              ADR      r0,|L13.32|
00000a  f7fffffe          BL       __2printf
;;;663    		return NAND_FAIL;
00000e  2001              MOVS     r0,#1
;;;664    	}
;;;665    
;;;666    	return FSMC_NAND_WritePage(_pBuffer, _ulPageNo, NAND_PAGE_SIZE + _usAddrInSpare, _usByteCount);
;;;667    }
000010  bd10              POP      {r4,pc}
                  |L13.18|
000012  f5026200          ADD      r2,r2,#0x800
000016  e8bd4010          POP      {r4,lr}               ;666
00001a  b292              UXTH     r2,r2                 ;666
00001c  f7ffbffe          B.W      FSMC_NAND_WritePage
;;;668    
                          ENDP

                  |L13.32|
000020  4572726f          DCB      "Error: FSMC_NAND_WriteSpare() %d\r\n",0
000024  723a2046
000028  534d435f
00002c  4e414e44
000030  5f577269
000034  74655370
000038  61726528
00003c  29202564
000040  0d0a00  
000043  00                DCB      0

                          AREA ||i.NAND_AddrToPhyBlockNo||, CODE, READONLY, ALIGN=2

                  NAND_AddrToPhyBlockNo PROC
;;;1345   */
;;;1346   static uint16_t NAND_AddrToPhyBlockNo(uint32_t _ulMemAddr)
000000  4905              LDR      r1,|L14.24|
;;;1347   {
;;;1348   	uint16_t usLBN;		/* 逻辑块号 */
;;;1349   	uint16_t usPBN;		/* 物理块号 */
;;;1350   
;;;1351   	usLBN = _ulMemAddr / (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);	/* 计算逻辑块号 */
000002  0c40              LSRS     r0,r0,#17
;;;1352   	/* 如果逻辑块号大于有效的数据块个数则固定返回0xFFFF, 调用该函数的代码应该检查出这种错误 */
;;;1353   	if (usLBN >= s_usValidDataBlockCount)
000004  8809              LDRH     r1,[r1,#0]  ; s_usValidDataBlockCount
000006  4288              CMP      r0,r1
000008  d302              BCC      |L14.16|
;;;1354   	{
;;;1355   		return 0xFFFF;
00000a  f64f70ff          MOV      r0,#0xffff
;;;1356   	}
;;;1357   	/* 查询LUT表，获得物理块号 */
;;;1358   	usPBN = s_usLUT[usLBN];
;;;1359   	return usPBN;
;;;1360   }
00000e  4770              BX       lr
                  |L14.16|
000010  4902              LDR      r1,|L14.28|
000012  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;1358
000016  4770              BX       lr
;;;1361   
                          ENDP

                  |L14.24|
                          DCD      ||.data||
                  |L14.28|
                          DCD      ||.bss||

                          AREA ||i.NAND_BuildLUT||, CODE, READONLY, ALIGN=2

                  NAND_BuildLUT PROC
;;;1278   */
;;;1279   static uint8_t NAND_BuildLUT(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1280   {
;;;1281   	uint16_t i;
;;;1282   	uint8_t buf[VALID_SPARE_SIZE];
;;;1283   	uint16_t usLBN;	/* 逻辑块号 */
;;;1284   
;;;1285   	/* */
;;;1286   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
;;;1287   	{
;;;1288   		s_usLUT[i] = 0xFFFF;	/* 填充无效值，用于重建LUT后，判断LUT是否合理 */
000002  4c23              LDR      r4,|L15.144|
000004  2000              MOVS     r0,#0                 ;1286
000006  f44f6680          MOV      r6,#0x400             ;1286
00000a  f64f75ff          MOV      r5,#0xffff
00000e  bf00              NOP      
                  |L15.16|
000010  f8245010          STRH     r5,[r4,r0,LSL #1]
000014  1c40              ADDS     r0,r0,#1
000016  b280              UXTH     r0,r0                 ;1286
000018  42b0              CMP      r0,r6                 ;1286
00001a  d3f9              BCC      |L15.16|
;;;1289   	}
;;;1290   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
00001c  2700              MOVS     r7,#0
                  |L15.30|
;;;1291   	{
;;;1292   		/* 读每个块的第1个PAGE，偏移地址为LBN0_OFFSET的数据 */
;;;1293   		FSMC_NAND_ReadSpare(buf, i * NAND_BLOCK_SIZE, 0, VALID_SPARE_SIZE);
00001e  01b9              LSLS     r1,r7,#6
000020  2304              MOVS     r3,#4
000022  2200              MOVS     r2,#0
000024  4668              MOV      r0,sp
000026  f7fffffe          BL       FSMC_NAND_ReadSpare
;;;1294   
;;;1295   		/* 如果是好块，则记录LBN0 LBN1 */
;;;1296   		if (buf[BI_OFFSET] == 0xFF)
00002a  f89d0000          LDRB     r0,[sp,#0]
00002e  28ff              CMP      r0,#0xff
000030  d10e              BNE      |L15.80|
;;;1297   		{
;;;1298   			usLBN = buf[LBN0_OFFSET] + buf[LBN1_OFFSET] * 256;	/* 计算读出的逻辑块号 */
000032  f89d0002          LDRB     r0,[sp,#2]
000036  f89d1003          LDRB     r1,[sp,#3]
00003a  eb002001          ADD      r0,r0,r1,LSL #8
00003e  b280              UXTH     r0,r0
;;;1299   			if (usLBN < NAND_BLOCK_COUNT)
000040  42b0              CMP      r0,r6
000042  d205              BCS      |L15.80|
;;;1300   			{
;;;1301   				/* 如果已经登记过了，则判定为异常 */
;;;1302   				if (s_usLUT[usLBN] != 0xFFFF)
000044  f8341010          LDRH     r1,[r4,r0,LSL #1]
000048  42a9              CMP      r1,r5
00004a  d119              BNE      |L15.128|
;;;1303   				{
;;;1304   					return NAND_FAIL;
;;;1305   				}
;;;1306   
;;;1307   				s_usLUT[usLBN] = i;	/* 更新LUT表 */
00004c  f8247010          STRH     r7,[r4,r0,LSL #1]
                  |L15.80|
000050  1c7f              ADDS     r7,r7,#1
000052  b2bf              UXTH     r7,r7                 ;1290
000054  42b7              CMP      r7,r6                 ;1290
000056  d3e2              BCC      |L15.30|
;;;1308   			}
;;;1309   		}
;;;1310   	}
;;;1311   
;;;1312   	/* LUT建立完毕，检查是否合理 */
;;;1313   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
;;;1314   	{
;;;1315   		if (s_usLUT[i] >= NAND_BLOCK_COUNT)
;;;1316   		{
;;;1317   			s_usValidDataBlockCount = i;
000058  490e              LDR      r1,|L15.148|
00005a  2000              MOVS     r0,#0                 ;1313
                  |L15.92|
00005c  f8342010          LDRH     r2,[r4,r0,LSL #1]     ;1315
000060  42b2              CMP      r2,r6                 ;1315
000062  d301              BCC      |L15.104|
000064  8008              STRH     r0,[r1,#0]
;;;1318   			break;
000066  e003              B        |L15.112|
                  |L15.104|
000068  1c40              ADDS     r0,r0,#1
00006a  b280              UXTH     r0,r0                 ;1313
00006c  42b0              CMP      r0,r6                 ;1313
00006e  d3f5              BCC      |L15.92|
                  |L15.112|
;;;1319   		}
;;;1320   	}
;;;1321   	if (s_usValidDataBlockCount < 100)
000070  8809              LDRH     r1,[r1,#0]  ; s_usValidDataBlockCount
000072  2964              CMP      r1,#0x64
000074  d304              BCC      |L15.128|
000076  e007              B        |L15.136|
                  |L15.120|
;;;1322   	{
;;;1323   		/* 错误： 最大的有效逻辑块号小于100。可能是没有格式化 */
;;;1324   		return NAND_FAIL;
;;;1325   	}
;;;1326   	for (; i < s_usValidDataBlockCount; i++)
;;;1327   	{
;;;1328   		if (s_usLUT[i] != 0xFFFF)
000078  f8342010          LDRH     r2,[r4,r0,LSL #1]
00007c  42aa              CMP      r2,r5
00007e  d001              BEQ      |L15.132|
                  |L15.128|
;;;1329   		{
;;;1330   			return NAND_FAIL;	/* 错误：LUT表逻辑块号存在跳跃现象，可能是没有格式化 */
000080  2001              MOVS     r0,#1
;;;1331   		}
;;;1332   	}
;;;1333   
;;;1334   	/* 重建LUT正常 */
;;;1335   	return NAND_OK;
;;;1336   }
000082  bdf8              POP      {r3-r7,pc}
                  |L15.132|
000084  1c40              ADDS     r0,r0,#1
000086  b280              UXTH     r0,r0                 ;1326
                  |L15.136|
000088  4288              CMP      r0,r1                 ;1326
00008a  d3f5              BCC      |L15.120|
00008c  2000              MOVS     r0,#0                 ;1335
00008e  bdf8              POP      {r3-r7,pc}
;;;1337   
                          ENDP

                  |L15.144|
                          DCD      ||.bss||
                  |L15.148|
                          DCD      ||.data||

                          AREA ||i.NAND_DispBadBlockInfo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_DispBadBlockInfo PROC
;;;1772   */
;;;1773   void NAND_DispBadBlockInfo(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1774   {
000004  b0c0              SUB      sp,sp,#0x100
;;;1775   	uint32_t id;
;;;1776   	uint32_t i;
;;;1777   	uint32_t n;
;;;1778   	uint32_t used = 0;
000006  2700              MOVS     r7,#0
;;;1779   	uint16_t bad_no[128];
;;;1780   
;;;1781   	FSMC_NAND_Init();	/* 初始化FSMC */
000008  f7fffffe          BL       FSMC_NAND_Init
;;;1782   
;;;1783   	id = NAND_ReadID();
00000c  f7fffffe          BL       NAND_ReadID
000010  4605              MOV      r5,r0
;;;1784   
;;;1785   	printf("NAND Flash ID = 0x%04X, Type = ", id);
000012  4601              MOV      r1,r0
000014  a039              ADR      r0,|L16.252|
000016  f7fffffe          BL       __2printf
;;;1786   	if (id == HY27UF081G2A)
00001a  4840              LDR      r0,|L16.284|
;;;1787   	{
;;;1788   		printf("HY27UF081G2A\r\n  1024 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
;;;1789   	}
;;;1790   	else if (id == K9F1G08U0A)
;;;1791   	{
;;;1792   		printf("K9F1G08U0A\r\n  1024 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
;;;1793   	}
;;;1794   	else if (id == K9F1G08U0B)
;;;1795   	{
;;;1796   		printf("K9F1G08U0B\r\n  1024 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
;;;1797   	}
;;;1798   	else if (id == H27U4G8F2DTR)
00001c  f8df8100          LDR      r8,|L16.288|
000020  4285              CMP      r5,r0                 ;1786
000022  d101              BNE      |L16.40|
000024  483f              LDR      r0,|L16.292|
000026  e011              B        |L16.76|
                  |L16.40|
000028  483f              LDR      r0,|L16.296|
00002a  4285              CMP      r5,r0                 ;1790
00002c  d101              BNE      |L16.50|
00002e  483f              LDR      r0,|L16.300|
000030  e00c              B        |L16.76|
                  |L16.50|
000032  483f              LDR      r0,|L16.304|
000034  4285              CMP      r5,r0                 ;1794
000036  d101              BNE      |L16.60|
000038  483e              LDR      r0,|L16.308|
00003a  e007              B        |L16.76|
                  |L16.60|
00003c  4545              CMP      r5,r8
00003e  d101              BNE      |L16.68|
;;;1799   	{
;;;1800   		printf("H27U4G8F2DTR\r\n  4096 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
000040  483d              LDR      r0,|L16.312|
000042  e003              B        |L16.76|
                  |L16.68|
;;;1801   	}
;;;1802   	else if (id == H27U1G8F2BTR)
000044  483d              LDR      r0,|L16.316|
000046  4285              CMP      r5,r0
000048  d10d              BNE      |L16.102|
;;;1803   	{
;;;1804   		printf("H27U1G8F2BTR\r\n  1024 Blocks, 64 pages per block, 2048 + 64 bytes per page\r\n");
00004a  483d              LDR      r0,|L16.320|
                  |L16.76|
00004c  f7fffffe          BL       __2printf
;;;1805   	}	
;;;1806   	else
;;;1807   	{
;;;1808   		printf("unkonow\r\n");
;;;1809   		return;
;;;1810   	}
;;;1811   
;;;1812   	FSMC_NAND_Reset();
000050  f7fffffe          BL       FSMC_NAND_Reset
;;;1813   
;;;1814   	printf("Block Info : 0 is OK, * is Bad, - is Used\r\n");
000054  a03b              ADR      r0,|L16.324|
000056  f7fffffe          BL       __2printf
;;;1815   	n = 0;	/* 坏块统计 */
00005a  2600              MOVS     r6,#0
;;;1816   	used = 0; /* 已用块统计 */
;;;1817   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
00005c  4634              MOV      r4,r6
00005e  f44f6980          MOV      r9,#0x400
000062  46ea              MOV      r10,sp                ;1779
000064  e001              B        |L16.106|
                  |L16.102|
000066  a042              ADR      r0,|L16.368|
000068  e043              B        |L16.242|
                  |L16.106|
;;;1818   	{
;;;1819   		if (NAND_IsBadBlock(i))
00006a  4620              MOV      r0,r4
00006c  f7fffffe          BL       NAND_IsBadBlock
000070  b140              CBZ      r0,|L16.132|
;;;1820   		{
;;;1821   			if (n < sizeof(bad_no) / 2)
000072  2e80              CMP      r6,#0x80
000074  d201              BCS      |L16.122|
;;;1822   			{
;;;1823   				bad_no[n] = i;	/* 记录坏块号 */
000076  f82a4016          STRH     r4,[r10,r6,LSL #1]
                  |L16.122|
;;;1824   			}
;;;1825   			printf("*");
00007a  a040              ADR      r0,|L16.380|
00007c  f7fffffe          BL       __2printf
000080  1c76              ADDS     r6,r6,#1
;;;1826   			n++;
000082  e00b              B        |L16.156|
                  |L16.132|
;;;1827   		}
;;;1828   		else
;;;1829   		{
;;;1830   			if (NAND_IsFreeBlock(i))
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       NAND_IsFreeBlock
00008a  b118              CBZ      r0,|L16.148|
;;;1831   			{
;;;1832   				printf("0");
00008c  a03c              ADR      r0,|L16.384|
00008e  f7fffffe          BL       __2printf
000092  e003              B        |L16.156|
                  |L16.148|
;;;1833   			}
;;;1834   			else
;;;1835   			{
;;;1836   				printf("-");	/* 已用块 */
000094  a03b              ADR      r0,|L16.388|
000096  f7fffffe          BL       __2printf
00009a  1c7f              ADDS     r7,r7,#1
                  |L16.156|
;;;1837   				used++;
;;;1838   			}
;;;1839   		}
;;;1840   
;;;1841   		if (((i + 1) % 8) == 0)
00009c  0760              LSLS     r0,r4,#29
00009e  f1b04f60          CMP      r0,#0xe0000000
0000a2  d102              BNE      |L16.170|
;;;1842   		{
;;;1843   			printf(" ");
0000a4  a038              ADR      r0,|L16.392|
0000a6  f7fffffe          BL       __2printf
                  |L16.170|
;;;1844   		}
;;;1845   
;;;1846   		if (((i + 1) % 64) == 0)
0000aa  06a0              LSLS     r0,r4,#26
0000ac  f1b04f7c          CMP      r0,#0xfc000000
0000b0  d102              BNE      |L16.184|
;;;1847   		{
;;;1848   			printf("\r\n");
0000b2  a036              ADR      r0,|L16.396|
0000b4  f7fffffe          BL       __2printf
                  |L16.184|
0000b8  1c64              ADDS     r4,r4,#1
0000ba  454c              CMP      r4,r9                 ;1817
0000bc  d3d5              BCC      |L16.106|
;;;1849   		}
;;;1850   	}
;;;1851   
;;;1852   	if (id == H27U4G8F2DTR)
0000be  4545              CMP      r5,r8
0000c0  d105              BNE      |L16.206|
;;;1853   	{
;;;1854   		printf("Bad Block Count = %d  ( < 80 is OK), Used = %d \r\n", n, used);
0000c2  463a              MOV      r2,r7
0000c4  4631              MOV      r1,r6
0000c6  a032              ADR      r0,|L16.400|
0000c8  f7fffffe          BL       __2printf
0000cc  e003              B        |L16.214|
                  |L16.206|
;;;1855   	}
;;;1856   	else
;;;1857   	{
;;;1858   		printf("Bad Block Count = %d\r\n", n);
0000ce  4631              MOV      r1,r6
0000d0  a03c              ADR      r0,|L16.452|
0000d2  f7fffffe          BL       __2printf
                  |L16.214|
;;;1859   	}
;;;1860   	
;;;1861   	/* 打印坏块序号 */
;;;1862   	if (n > 0)
0000d6  2e00              CMP      r6,#0
0000d8  d00d              BEQ      |L16.246|
;;;1863   	{
;;;1864   		for (i = 0; i < n; i++)
0000da  2400              MOVS     r4,#0
0000dc  4655              MOV      r5,r10                ;1779
0000de  e005              B        |L16.236|
                  |L16.224|
;;;1865   		{
;;;1866   			printf("%4d ",  bad_no[i]);
0000e0  f8351014          LDRH     r1,[r5,r4,LSL #1]
0000e4  a03d              ADR      r0,|L16.476|
0000e6  f7fffffe          BL       __2printf
0000ea  1c64              ADDS     r4,r4,#1
                  |L16.236|
0000ec  42b4              CMP      r4,r6                 ;1864
0000ee  d3f7              BCC      |L16.224|
;;;1867   		}
;;;1868   		
;;;1869   		printf("\r\n\r\n");
0000f0  a03c              ADR      r0,|L16.484|
                  |L16.242|
0000f2  f7fffffe          BL       __2printf
                  |L16.246|
;;;1870   	}
;;;1871   }
0000f6  b040              ADD      sp,sp,#0x100
0000f8  e8bd87f0          POP      {r4-r10,pc}
;;;1872   
                          ENDP

                  |L16.252|
0000fc  4e414e44          DCB      "NAND Flash ID = 0x%04X, Type = ",0
000100  20466c61
000104  73682049
000108  44203d20
00010c  30782530
000110  34582c20
000114  54797065
000118  203d2000
                  |L16.284|
                          DCD      0xadf1801d
                  |L16.288|
                          DCD      0xaddc9095
                  |L16.292|
                          DCD      ||.conststring||+0x114
                  |L16.296|
                          DCD      0xecf18015
                  |L16.300|
                          DCD      ||.conststring||+0x160
                  |L16.304|
                          DCD      0xecf10095
                  |L16.308|
                          DCD      ||.conststring||+0x1ac
                  |L16.312|
                          DCD      ||.conststring||+0x1f8
                  |L16.316|
                          DCD      0xadf1001d
                  |L16.320|
                          DCD      ||.conststring||+0x244
                  |L16.324|
000144  426c6f63          DCB      "Block Info : 0 is OK, * is Bad, - is Used\r\n",0
000148  6b20496e
00014c  666f203a
000150  20302069
000154  73204f4b
000158  2c202a20
00015c  69732042
000160  61642c20
000164  2d206973
000168  20557365
00016c  640d0a00
                  |L16.368|
000170  756e6b6f          DCB      "unkonow\r\n",0
000174  6e6f770d
000178  0a00    
00017a  00                DCB      0
00017b  00                DCB      0
                  |L16.380|
00017c  2a00              DCB      "*",0
00017e  00                DCB      0
00017f  00                DCB      0
                  |L16.384|
000180  3000              DCB      "0",0
000182  00                DCB      0
000183  00                DCB      0
                  |L16.388|
000184  2d00              DCB      "-",0
000186  00                DCB      0
000187  00                DCB      0
                  |L16.392|
000188  2000              DCB      " ",0
00018a  00                DCB      0
00018b  00                DCB      0
                  |L16.396|
00018c  0d0a00            DCB      "\r\n",0
00018f  00                DCB      0
                  |L16.400|
000190  42616420          DCB      "Bad Block Count = %d  ( < 80 is OK), Used = %d \r\n",0
000194  426c6f63
000198  6b20436f
00019c  756e7420
0001a0  3d202564
0001a4  20202820
0001a8  3c203830
0001ac  20697320
0001b0  4f4b292c
0001b4  20557365
0001b8  64203d20
0001bc  2564200d
0001c0  0a00    
0001c2  00                DCB      0
0001c3  00                DCB      0
                  |L16.452|
0001c4  42616420          DCB      "Bad Block Count = %d\r\n",0
0001c8  426c6f63
0001cc  6b20436f
0001d0  756e7420
0001d4  3d202564
0001d8  0d0a00  
0001db  00                DCB      0
                  |L16.476|
0001dc  25346420          DCB      "%4d ",0
0001e0  00      
0001e1  00                DCB      0
0001e2  00                DCB      0
0001e3  00                DCB      0
                  |L16.484|
0001e4  0d0a0d0a          DCB      "\r\n\r\n",0
0001e8  00      
0001e9  00                DCB      0
0001ea  00                DCB      0
0001eb  00                DCB      0

                          AREA ||i.NAND_DispLogicPageData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_DispLogicPageData PROC
;;;2017   */
;;;2018   void NAND_DispLogicPageData(uint32_t _uiLogicPageNo)
000000  b570              PUSH     {r4-r6,lr}
;;;2019   {
000002  4604              MOV      r4,r0
;;;2020   	uint32_t uiPhyPageNo;
;;;2021   	uint16_t usLBN;	/* 逻辑块号 */
;;;2022   	uint16_t usPBN;	/* 物理块号 */
;;;2023   
;;;2024   	usLBN = _uiLogicPageNo / NAND_BLOCK_SIZE;
000004  f3c0108f          UBFX     r0,r0,#6,#16
;;;2025   	usPBN = NAND_LBNtoPBN(usLBN);	/* 查询LUT表获得物理块号 */
000008  f7fffffe          BL       NAND_LBNtoPBN
00000c  4605              MOV      r5,r0
;;;2026   	if (usPBN >= NAND_BLOCK_COUNT)
00000e  f5b06f80          CMP      r0,#0x400
000012  d20b              BCS      |L17.44|
;;;2027   	{
;;;2028   		/* 没有格式化，usPBN = 0xFFFF */
;;;2029   		return;
;;;2030   	}
;;;2031   
;;;2032   	printf("LogicBlock = %d, PhyBlock = %d\r\n", _uiLogicPageNo, usPBN);
000014  4602              MOV      r2,r0
000016  4621              MOV      r1,r4
000018  a005              ADR      r0,|L17.48|
00001a  f7fffffe          BL       __2printf
;;;2033   
;;;2034   	/* 计算物理页号 */
;;;2035   	uiPhyPageNo = usPBN * NAND_BLOCK_SIZE + _uiLogicPageNo % NAND_BLOCK_SIZE;
00001e  f365149f          BFI      r4,r5,#6,#26
000022  4620              MOV      r0,r4
;;;2036   	NAND_DispPhyPageData(uiPhyPageNo);	/* 显示指定页数据 */
000024  e8bd4070          POP      {r4-r6,lr}
000028  f7ffbffe          B.W      NAND_DispPhyPageData
                  |L17.44|
;;;2037   }
00002c  bd70              POP      {r4-r6,pc}
;;;2038   
                          ENDP

00002e  0000              DCW      0x0000
                  |L17.48|
000030  4c6f6769          DCB      "LogicBlock = %d, PhyBlock = %d\r\n",0
000034  63426c6f
000038  636b203d
00003c  2025642c
000040  20506879
000044  426c6f63
000048  6b203d20
00004c  25640d0a
000050  00      
000051  00                DCB      0
000052  00                DCB      0
000053  00                DCB      0

                          AREA ||i.NAND_DispParamPage||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_c
                          REQUIRE _printf_str
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  NAND_DispParamPage PROC
;;;2098   */
;;;2099   void NAND_DispParamPage(void)
000000  b510              PUSH     {r4,lr}
;;;2100   {
000002  b0ca              SUB      sp,sp,#0x128
;;;2101   	PARAM_PAGE_T tPage;
;;;2102   	char buf[32];
;;;2103   
;;;2104   	FSMC_NAND_Reset();
000004  f7fffffe          BL       FSMC_NAND_Reset
;;;2105   
;;;2106   	NAND_ReadParamPage(&tPage);
000008  a801              ADD      r0,sp,#4
00000a  f7fffffe          BL       NAND_ReadParamPage
;;;2107   
;;;2108   #if 0
;;;2109   	uint8_t Sign[4];		/* = "ONFI" */
;;;2110   	uint16_t Revision; 		/* Bit1 = 1 表示支持 ONFI Ver 1.0 */
;;;2111   	uint16_t Features;		/* */
;;;2112   	uint16_t OptionalCommands;
;;;2113   #endif
;;;2114   
;;;2115   	printf("\r\n");
00000e  a024              ADR      r0,|L18.160|
000010  f7fffffe          BL       __2printf
;;;2116   	printf("Read Parameter Page Data :\r\n");
000014  a023              ADR      r0,|L18.164|
000016  f7fffffe          BL       __2printf
;;;2117   	printf("Sign = %c%c%c%c\r\n", tPage.Sign[0], tPage.Sign[1], tPage.Sign[2], tPage.Sign[3]);
00001a  f89d0007          LDRB     r0,[sp,#7]
00001e  9000              STR      r0,[sp,#0]
000020  f89d3006          LDRB     r3,[sp,#6]
000024  f89d2005          LDRB     r2,[sp,#5]
000028  f89d1004          LDRB     r1,[sp,#4]
00002c  a025              ADR      r0,|L18.196|
00002e  f7fffffe          BL       __2printf
;;;2118   	printf("Revision = %04X\r\n", tPage.Revision);
000032  f8bd1008          LDRH     r1,[sp,#8]
000036  a028              ADR      r0,|L18.216|
000038  f7fffffe          BL       __2printf
;;;2119   	printf("Features = %04X\r\n", tPage.Features);
00003c  f8bd100a          LDRH     r1,[sp,#0xa]
000040  a02a              ADR      r0,|L18.236|
000042  f7fffffe          BL       __2printf
;;;2120   	printf("OptionalCommands = %04X\r\n", tPage.OptionalCommands);
000046  f8bd100c          LDRH     r1,[sp,#0xc]
00004a  a02d              ADR      r0,|L18.256|
00004c  f7fffffe          BL       __2printf
000050  ab09              ADD      r3,sp,#0x24
;;;2121   
;;;2122   	/* Manufacturer information block */
;;;2123   	memcpy(buf, tPage.Manufacturer, 12);
;;;2124   	buf[12] = 0;
000052  2400              MOVS     r4,#0
000054  e8930007          LDM      r3,{r0-r2}            ;2120
000058  ab41              ADD      r3,sp,#0x104
00005a  e8830007          STM      r3,{r0-r2}
00005e  f88d4110          STRB     r4,[sp,#0x110]
;;;2125   	printf("Manufacturer = %s\r\n", buf);	/* 制造商 */
000062  a941              ADD      r1,sp,#0x104
000064  a02d              ADR      r0,|L18.284|
000066  f7fffffe          BL       __2printf
;;;2126   
;;;2127   	memcpy(buf, tPage.Model, 20);
00006a  2214              MOVS     r2,#0x14
00006c  a90c              ADD      r1,sp,#0x30
00006e  a841              ADD      r0,sp,#0x104
000070  f7fffffe          BL       __aeabi_memcpy4
;;;2128   	buf[20] = 0;
000074  f88d4118          STRB     r4,[sp,#0x118]
;;;2129   	printf("Model = %s\r\n", buf);	/* 型号 */
000078  a941              ADD      r1,sp,#0x104
00007a  a02d              ADR      r0,|L18.304|
00007c  f7fffffe          BL       __2printf
;;;2130   
;;;2131   	printf("JEDEC_ID = %02X\r\n", tPage.JEDEC_ID);	/* AD */
000080  f89d1044          LDRB     r1,[sp,#0x44]
000084  a02e              ADR      r0,|L18.320|
000086  f7fffffe          BL       __2printf
;;;2132   	printf("DateCode = %04X\r\n", tPage.DateCode);
00008a  f8bd1045          LDRH     r1,[sp,#0x45]
00008e  a031              ADR      r0,|L18.340|
000090  f7fffffe          BL       __2printf
;;;2133   
;;;2134   #if 0
;;;2135   	/* Memory organization block */
;;;2136   	uint32_t PageDataSize;
;;;2137   	uint16_t PageSpareSize;
;;;2138   	uint32_t PartialPageDataSize;
;;;2139   	uint16_t PartialPageSpareSize;
;;;2140   	uint32_t BlockSize;
;;;2141   	uint32_t LogicalUnitSize;
;;;2142   	uint8_t LogicalUnitNumber;
;;;2143   	uint8_t AddressCycles;
;;;2144   	uint8_t CellBits;
;;;2145   	uint16_t BadBlockMax;
;;;2146   	uint16_t BlockEndurance;
;;;2147   	uint8_t ValidBlocksBegin;	/* 最前面保证有效的块个数 */
;;;2148   	uint16_t BlockEndurance2;	/* Block endurance for guaranteed valid blocks */
;;;2149   	uint8_t  ProgramsPerPage;	/* Number of programs per page */
;;;2150   	uint8_t PartialProgram;
;;;2151   	uint8_t ECCcorrectBits;
;;;2152   	uint8_t InterleavedAddrBits;	/* 交错的地址位 */
;;;2153   	uint8_t InterleavedOperaton;
;;;2154   	uint8_t Rsv3[13];
;;;2155   #endif
;;;2156   
;;;2157   	printf("\r\n");
000094  a002              ADR      r0,|L18.160|
000096  f7fffffe          BL       __2printf
;;;2158   
;;;2159   }
00009a  b04a              ADD      sp,sp,#0x128
00009c  bd10              POP      {r4,pc}
;;;2160   
                          ENDP

00009e  0000              DCW      0x0000
                  |L18.160|
0000a0  0d0a00            DCB      "\r\n",0
0000a3  00                DCB      0
                  |L18.164|
0000a4  52656164          DCB      "Read Parameter Page Data :\r\n",0
0000a8  20506172
0000ac  616d6574
0000b0  65722050
0000b4  61676520
0000b8  44617461
0000bc  203a0d0a
0000c0  00      
0000c1  00                DCB      0
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L18.196|
0000c4  5369676e          DCB      "Sign = %c%c%c%c\r\n",0
0000c8  203d2025
0000cc  63256325
0000d0  6325630d
0000d4  0a00    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L18.216|
0000d8  52657669          DCB      "Revision = %04X\r\n",0
0000dc  73696f6e
0000e0  203d2025
0000e4  3034580d
0000e8  0a00    
0000ea  00                DCB      0
0000eb  00                DCB      0
                  |L18.236|
0000ec  46656174          DCB      "Features = %04X\r\n",0
0000f0  75726573
0000f4  203d2025
0000f8  3034580d
0000fc  0a00    
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L18.256|
000100  4f707469          DCB      "OptionalCommands = %04X\r\n",0
000104  6f6e616c
000108  436f6d6d
00010c  616e6473
000110  203d2025
000114  3034580d
000118  0a00    
00011a  00                DCB      0
00011b  00                DCB      0
                  |L18.284|
00011c  4d616e75          DCB      "Manufacturer = %s\r\n",0
000120  66616374
000124  75726572
000128  203d2025
00012c  730d0a00
                  |L18.304|
000130  4d6f6465          DCB      "Model = %s\r\n",0
000134  6c203d20
000138  25730d0a
00013c  00      
00013d  00                DCB      0
00013e  00                DCB      0
00013f  00                DCB      0
                  |L18.320|
000140  4a454445          DCB      "JEDEC_ID = %02X\r\n",0
000144  435f4944
000148  203d2025
00014c  3032580d
000150  0a00    
000152  00                DCB      0
000153  00                DCB      0
                  |L18.340|
000154  44617465          DCB      "DateCode = %04X\r\n",0
000158  436f6465
00015c  203d2025
000160  3034580d
000164  0a00    
000166  00                DCB      0
000167  00                DCB      0

                          AREA ||i.NAND_DispPhyPageData||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  NAND_DispPhyPageData PROC
;;;1961   */
;;;1962   void NAND_DispPhyPageData(uint32_t _uiPhyPageNo)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1963   {
;;;1964   	uint32_t i, n;
;;;1965   	uint32_t ulBlockNo;
;;;1966   	uint16_t usOffsetPageNo;
;;;1967   
;;;1968   	ulBlockNo = _uiPhyPageNo / NAND_BLOCK_SIZE;		/* 根据物理页号反推块号 */
000004  0984              LSRS     r4,r0,#6
;;;1969   	usOffsetPageNo = _uiPhyPageNo % NAND_BLOCK_SIZE;	/* 根据物理页号计算物理页号在块内偏移页号 */
000006  f000053f          AND      r5,r0,#0x3f
;;;1970   
;;;1971   	if (NAND_OK != FSMC_NAND_ReadPage(s_ucTempBuf, _uiPhyPageNo, 0, NAND_PAGE_TOTAL_SIZE))
00000a  4601              MOV      r1,r0
00000c  f44f6304          MOV      r3,#0x840
000010  2200              MOVS     r2,#0
000012  4820              LDR      r0,|L19.148|
000014  f7fffffe          BL       FSMC_NAND_ReadPage
000018  b120              CBZ      r0,|L19.36|
;;;1972   	{
;;;1973   		printf("FSMC_NAND_ReadPage Failed() \r\n");
00001a  e8bd41f0          POP      {r4-r8,lr}
00001e  a01e              ADR      r0,|L19.152|
000020  f7ffbffe          B.W      __2printf
                  |L19.36|
;;;1974   		return;
;;;1975   	}
;;;1976   
;;;1977   	printf("Block = %d, Page = %d\r\n", ulBlockNo, usOffsetPageNo);
000024  462a              MOV      r2,r5
000026  4621              MOV      r1,r4
000028  a023              ADR      r0,|L19.184|
00002a  f7fffffe          BL       __2printf
00002e  4e19              LDR      r6,|L19.148|
;;;1978   
;;;1979   	/* 打印前面 2048字节数据，每512字节空一行 */
;;;1980   	for (n = 0; n < 4; n++)
000030  2500              MOVS     r5,#0
;;;1981   	{
;;;1982   		for (i = 0; i < 512; i++)
000032  f44f7700          MOV      r7,#0x200
                  |L19.54|
000036  2400              MOVS     r4,#0
                  |L19.56|
;;;1983   		{
;;;1984   			printf(" %02X", s_ucTempBuf[i + n * 512]);
000038  eb042045          ADD      r0,r4,r5,LSL #9
00003c  5c31              LDRB     r1,[r6,r0]
00003e  a024              ADR      r0,|L19.208|
000040  f7fffffe          BL       __2printf
;;;1985   
;;;1986   			if ((i & 31) == 31)
000044  43e0              MVNS     r0,r4
000046  06c0              LSLS     r0,r0,#27
000048  d004              BEQ      |L19.84|
;;;1987   			{
;;;1988   				printf("\r\n");	/* 每行显示32字节数据 */
;;;1989   			}
;;;1990   			else if ((i & 31) == 15)
00004a  f004001f          AND      r0,r4,#0x1f
00004e  280f              CMP      r0,#0xf
000050  d002              BEQ      |L19.88|
000052  e004              B        |L19.94|
                  |L19.84|
000054  a017              ADR      r0,|L19.180|
000056  e000              B        |L19.90|
                  |L19.88|
;;;1991   			{
;;;1992   				printf(" - ");
000058  a01f              ADR      r0,|L19.216|
                  |L19.90|
00005a  f7fffffe          BL       __2printf
                  |L19.94|
00005e  1c64              ADDS     r4,r4,#1
000060  42bc              CMP      r4,r7                 ;1982
000062  d3e9              BCC      |L19.56|
;;;1993   			}
;;;1994   		}
;;;1995   		printf("\r\n");
000064  a013              ADR      r0,|L19.180|
000066  f7fffffe          BL       __2printf
00006a  1c6d              ADDS     r5,r5,#1
00006c  2d04              CMP      r5,#4                 ;1980
00006e  d3e2              BCC      |L19.54|
;;;1996   	}
;;;1997   
;;;1998   	/* 打印前面 2048字节数据，每512字节空一行 */
;;;1999   	for (i = 0; i < 64; i++)
000070  2400              MOVS     r4,#0
                  |L19.114|
;;;2000   	{
;;;2001   		printf(" %02X", s_ucTempBuf[i + 2048]);
000072  1930              ADDS     r0,r6,r4
000074  f8901800          LDRB     r1,[r0,#0x800]
000078  a015              ADR      r0,|L19.208|
00007a  f7fffffe          BL       __2printf
;;;2002   
;;;2003   		if ((i & 15) == 15)
00007e  43e0              MVNS     r0,r4
000080  0700              LSLS     r0,r0,#28
000082  d102              BNE      |L19.138|
;;;2004   		{
;;;2005   			printf("\r\n");	/* 每行显示32字节数据 */
000084  a00b              ADR      r0,|L19.180|
000086  f7fffffe          BL       __2printf
                  |L19.138|
00008a  1c64              ADDS     r4,r4,#1
00008c  2c40              CMP      r4,#0x40              ;1999
00008e  d3f0              BCC      |L19.114|
;;;2006   		}
;;;2007   	}
;;;2008   }
000090  e8bd81f0          POP      {r4-r8,pc}
;;;2009   
                          ENDP

                  |L19.148|
                          DCD      ||.bss||+0x800
                  |L19.152|
000098  46534d43          DCB      "FSMC_NAND_ReadPage Failed() "
00009c  5f4e414e
0000a0  445f5265
0000a4  61645061
0000a8  67652046
0000ac  61696c65
0000b0  64282920
                  |L19.180|
0000b4  0d0a00            DCB      "\r\n",0
0000b7  00                DCB      0
                  |L19.184|
0000b8  426c6f63          DCB      "Block = %d, Page = %d\r\n",0
0000bc  6b203d20
0000c0  25642c20
0000c4  50616765
0000c8  203d2025
0000cc  640d0a00
                  |L19.208|
0000d0  20253032          DCB      " %02X",0
0000d4  5800    
0000d6  00                DCB      0
0000d7  00                DCB      0
                  |L19.216|
0000d8  202d2000          DCB      " - ",0

                          AREA ||i.NAND_Format||, CODE, READONLY, ALIGN=1

                  NAND_Format PROC
;;;1695   */
;;;1696   uint8_t NAND_Format(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;1697   {
;;;1698   	uint16_t i, n;
;;;1699   	uint16_t usGoodBlockCount;
;;;1700   
;;;1701   	/* 擦除每个块 */
;;;1702   	usGoodBlockCount = 0;
000002  2400              MOVS     r4,#0
;;;1703   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
000004  4625              MOV      r5,r4
000006  f44f6680          MOV      r6,#0x400
                  |L20.10|
;;;1704   	{
;;;1705   		/* 如果是好块，则擦除 */
;;;1706   		if (!NAND_IsBadBlock(i))
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       NAND_IsBadBlock
000010  b920              CBNZ     r0,|L20.28|
;;;1707   		{
;;;1708   			FSMC_NAND_EraseBlock(i);
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       FSMC_NAND_EraseBlock
000018  1c64              ADDS     r4,r4,#1
;;;1709   			usGoodBlockCount++;
00001a  b2a4              UXTH     r4,r4
                  |L20.28|
00001c  1c6d              ADDS     r5,r5,#1
00001e  b2ad              UXTH     r5,r5                 ;1703
000020  42b5              CMP      r5,r6                 ;1703
000022  d3f2              BCC      |L20.10|
;;;1710   		}
;;;1711   	}
;;;1712   
;;;1713   	/* 如果好块的数量少于100，则NAND Flash报废 */
;;;1714   	if (usGoodBlockCount < 100)
000024  2c64              CMP      r4,#0x64
000026  d314              BCC      |L20.82|
;;;1715   	{
;;;1716   		return NAND_FAIL;
;;;1717   	}
;;;1718   
;;;1719   	usGoodBlockCount = (usGoodBlockCount * 98) / 100;	/* 98%的好块用于存储数据 */
000028  2062              MOVS     r0,#0x62
00002a  4344              MULS     r4,r0,r4
00002c  2064              MOVS     r0,#0x64
00002e  fbb4f0f0          UDIV     r0,r4,r0
000032  b285              UXTH     r5,r0
;;;1720   
;;;1721   	/* 重新搜索一次 */
;;;1722   	n = 0; /* 统计已标注的好块 */
000034  2000              MOVS     r0,#0
000036  f8ad0000          STRH     r0,[sp,#0]
;;;1723   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
00003a  4604              MOV      r4,r0
                  |L20.60|
;;;1724   	{
;;;1725   		if (!NAND_IsBadBlock(i))
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       NAND_IsBadBlock
000042  b980              CBNZ     r0,|L20.102|
;;;1726   		{
;;;1727   			/* 如果是好块，则在该块的第1个PAGE的LBN0 LBN1处写入n值 (前面已经执行了块擦除） */
;;;1728   			if (FSMC_NAND_WriteSpare((uint8_t *)&n, i * NAND_BLOCK_SIZE, LBN0_OFFSET, 2) != NAND_OK)
000044  2302              MOVS     r3,#2
000046  01a1              LSLS     r1,r4,#6
000048  461a              MOV      r2,r3
00004a  4668              MOV      r0,sp
00004c  f7fffffe          BL       FSMC_NAND_WriteSpare
000050  b108              CBZ      r0,|L20.86|
                  |L20.82|
;;;1729   			{
;;;1730   				return NAND_FAIL;
000052  2001              MOVS     r0,#1
;;;1731   			}
;;;1732   			n++;
;;;1733   
;;;1734   			/* 计算并写入每个扇区的ECC值 （暂时未作）*/
;;;1735   
;;;1736   			if (n == usGoodBlockCount)
;;;1737   			{
;;;1738   				break;
;;;1739   			}
;;;1740   		}
;;;1741   	}
;;;1742   
;;;1743   	NAND_BuildLUT();	/* 初始化LUT表 */
;;;1744   	return NAND_OK;
;;;1745   }
000054  bdf8              POP      {r3-r7,pc}
                  |L20.86|
000056  f8bd0000          LDRH     r0,[sp,#0]            ;1732
00005a  1c40              ADDS     r0,r0,#1              ;1732
00005c  b280              UXTH     r0,r0                 ;1732
00005e  f8ad0000          STRH     r0,[sp,#0]            ;1732
000062  42a8              CMP      r0,r5                 ;1736
000064  d003              BEQ      |L20.110|
                  |L20.102|
000066  1c64              ADDS     r4,r4,#1              ;1736
000068  b2a4              UXTH     r4,r4                 ;1723
00006a  42b4              CMP      r4,r6                 ;1723
00006c  d3e6              BCC      |L20.60|
                  |L20.110|
00006e  f7fffffe          BL       NAND_BuildLUT
000072  2000              MOVS     r0,#0                 ;1744
000074  bdf8              POP      {r3-r7,pc}
;;;1746   
                          ENDP


                          AREA ||i.NAND_FormatCapacity||, CODE, READONLY, ALIGN=2

                  NAND_FormatCapacity PROC
;;;1754   */
;;;1755   uint32_t NAND_FormatCapacity(void)
000000  4804              LDR      r0,|L21.20|
;;;1756   {
;;;1757   	uint16_t usCount;
;;;1758   
;;;1759   	/* 计算用于存储数据的数据块个数，按照总有效块数的98%来计算 */
;;;1760   	usCount = (s_usValidDataBlockCount * DATA_BLOCK_PERCENT) / 100;
000002  2162              MOVS     r1,#0x62
000004  8800              LDRH     r0,[r0,#0]  ; s_usValidDataBlockCount
000006  4348              MULS     r0,r1,r0
000008  2164              MOVS     r1,#0x64
00000a  fbb0f0f1          UDIV     r0,r0,r1
;;;1761   
;;;1762   	return (usCount * NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
00000e  0440              LSLS     r0,r0,#17
;;;1763   }
000010  4770              BX       lr
;;;1764   
                          ENDP

000012  0000              DCW      0x0000
                  |L21.20|
                          DCD      ||.data||

                          AREA ||i.NAND_GetBlockInfo||, CODE, READONLY, ALIGN=2

                  NAND_GetBlockInfo PROC
;;;1880   */
;;;1881   uint8_t NAND_GetBlockInfo(NAND_BLOCK_INFO_T *_pInfo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1882   {
;;;1883   	uint32_t id;
;;;1884   	uint32_t i;
;;;1885   	uint32_t n;
;;;1886   	uint32_t used = 0;
000004  f04f0800          MOV      r8,#0
000008  4604              MOV      r4,r0                 ;1882
;;;1887   	uint32_t free = 0;
00000a  4646              MOV      r6,r8
;;;1888   
;;;1889   	FSMC_NAND_Init();	/* 初始化FSMC */
00000c  f7fffffe          BL       FSMC_NAND_Init
;;;1890   
;;;1891   	id = NAND_ReadID();
000010  f7fffffe          BL       NAND_ReadID
;;;1892   	
;;;1893   	_pInfo->ChipID = id;
;;;1894   	if (id == HY27UF081G2A)
000014  4920              LDR      r1,|L22.152|
000016  6020              STR      r0,[r4,#0]
000018  4288              CMP      r0,r1
00001a  d102              BNE      |L22.34|
;;;1895   	{
;;;1896   		_pInfo->ChipID = HY27UF081G2A;
;;;1897   		strcpy(_pInfo->ChipName, "HY27UF081G2A");
00001c  6021              STR      r1,[r4,#0]
00001e  a11f              ADR      r1,|L22.156|
000020  e016              B        |L22.80|
                  |L22.34|
;;;1898   	}
;;;1899   	else if (id == K9F1G08U0A)
000022  4922              LDR      r1,|L22.172|
000024  4288              CMP      r0,r1
000026  d102              BNE      |L22.46|
;;;1900   	{
;;;1901   		_pInfo->ChipID = K9F1G08U0A;
;;;1902   		strcpy(_pInfo->ChipName, "K9F1G08U0A");
000028  6021              STR      r1,[r4,#0]
00002a  a121              ADR      r1,|L22.176|
00002c  e010              B        |L22.80|
                  |L22.46|
;;;1903   	}
;;;1904   	else if (id == K9F1G08U0B)
00002e  4923              LDR      r1,|L22.188|
000030  4288              CMP      r0,r1
000032  d102              BNE      |L22.58|
;;;1905   	{
;;;1906   		_pInfo->ChipID = K9F1G08U0B;
;;;1907   		strcpy(_pInfo->ChipName, "K9F1G08U0B");
000034  6021              STR      r1,[r4,#0]
000036  a122              ADR      r1,|L22.192|
000038  e00a              B        |L22.80|
                  |L22.58|
;;;1908   	}
;;;1909   	else if (id == H27U4G8F2DTR)
00003a  4924              LDR      r1,|L22.204|
00003c  4288              CMP      r0,r1
00003e  d102              BNE      |L22.70|
;;;1910   	{
;;;1911   		_pInfo->ChipID = H27U4G8F2DTR;
;;;1912   		strcpy(_pInfo->ChipName, "H27U4G8F2DTR");
000040  6021              STR      r1,[r4,#0]
000042  a123              ADR      r1,|L22.208|
000044  e004              B        |L22.80|
                  |L22.70|
;;;1913   	}
;;;1914   	else if (id == H27U1G8F2BTR)
000046  4926              LDR      r1,|L22.224|
000048  4288              CMP      r0,r1
00004a  d10b              BNE      |L22.100|
;;;1915   	{
;;;1916   		_pInfo->ChipID = H27U1G8F2BTR;
;;;1917   		strcpy(_pInfo->ChipName, "H27U1G8F2BTR");
00004c  6021              STR      r1,[r4,#0]
00004e  a125              ADR      r1,|L22.228|
                  |L22.80|
000050  1d20              ADDS     r0,r4,#4
000052  f7fffffe          BL       strcpy
;;;1918   	}	
;;;1919   	else
;;;1920   	{		
;;;1921   		return 0;
;;;1922   	}
;;;1923   
;;;1924   	FSMC_NAND_Reset();
000056  f7fffffe          BL       FSMC_NAND_Reset
;;;1925   
;;;1926   	n = 0;	/* 坏块统计 */
00005a  2700              MOVS     r7,#0
;;;1927   	used = 0; /* 已用块统计 */
;;;1928   	free = 0; /* 未用的好块 */
;;;1929   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
00005c  463d              MOV      r5,r7
00005e  f44f6980          MOV      r9,#0x400
000062  e002              B        |L22.106|
                  |L22.100|
000064  2000              MOVS     r0,#0                 ;1921
                  |L22.102|
;;;1930   	{
;;;1931   		if (NAND_IsBadBlock(i))
;;;1932   		{
;;;1933   			n++;			/* 记录坏块 */
;;;1934   		}
;;;1935   		else
;;;1936   		{
;;;1937   			if (NAND_IsFreeBlock(i))
;;;1938   			{
;;;1939   				free++;
;;;1940   			}
;;;1941   			else
;;;1942   			{	
;;;1943   				used++;		/* 已用块 */
;;;1944   			}
;;;1945   		}
;;;1946   	}
;;;1947   
;;;1948   	_pInfo->Bad = n;
;;;1949   	_pInfo->Used = used;
;;;1950   	_pInfo->Free = free;
;;;1951   	return 1;
;;;1952   }
000066  e8bd87f0          POP      {r4-r10,pc}
                  |L22.106|
00006a  4628              MOV      r0,r5                 ;1931
00006c  f7fffffe          BL       NAND_IsBadBlock
000070  b108              CBZ      r0,|L22.118|
000072  1c7f              ADDS     r7,r7,#1              ;1931
000074  e007              B        |L22.134|
                  |L22.118|
000076  4628              MOV      r0,r5                 ;1937
000078  f7fffffe          BL       NAND_IsFreeBlock
00007c  b108              CBZ      r0,|L22.130|
00007e  1c76              ADDS     r6,r6,#1              ;1937
000080  e001              B        |L22.134|
                  |L22.130|
000082  f1080801          ADD      r8,r8,#1              ;1943
                  |L22.134|
000086  1c6d              ADDS     r5,r5,#1              ;1943
000088  454d              CMP      r5,r9                 ;1929
00008a  d3ee              BCC      |L22.106|
00008c  f8c4801c          STR      r8,[r4,#0x1c]         ;1949
000090  e9c47605          STRD     r7,r6,[r4,#0x14]      ;1949
000094  2001              MOVS     r0,#1                 ;1951
000096  e7e6              B        |L22.102|
;;;1953   
                          ENDP

                  |L22.152|
                          DCD      0xadf1801d
                  |L22.156|
00009c  48593237          DCB      "HY27UF081G2A",0
0000a0  55463038
0000a4  31473241
0000a8  00      
0000a9  00                DCB      0
0000aa  00                DCB      0
0000ab  00                DCB      0
                  |L22.172|
                          DCD      0xecf18015
                  |L22.176|
0000b0  4b394631          DCB      "K9F1G08U0A",0
0000b4  47303855
0000b8  304100  
0000bb  00                DCB      0
                  |L22.188|
                          DCD      0xecf10095
                  |L22.192|
0000c0  4b394631          DCB      "K9F1G08U0B",0
0000c4  47303855
0000c8  304200  
0000cb  00                DCB      0
                  |L22.204|
                          DCD      0xaddc9095
                  |L22.208|
0000d0  48323755          DCB      "H27U4G8F2DTR",0
0000d4  34473846
0000d8  32445452
0000dc  00      
0000dd  00                DCB      0
0000de  00                DCB      0
0000df  00                DCB      0
                  |L22.224|
                          DCD      0xadf1001d
                  |L22.228|
0000e4  48323755          DCB      "H27U1G8F2BTR",0
0000e8  31473846
0000ec  32425452
0000f0  00      
0000f1  00                DCB      0
0000f2  00                DCB      0
0000f3  00                DCB      0

                          AREA ||i.NAND_Init||, CODE, READONLY, ALIGN=1

                  NAND_Init PROC
;;;887    */
;;;888    uint8_t NAND_Init(void)
000000  b510              PUSH     {r4,lr}
;;;889    {
;;;890    	uint8_t Status;
;;;891    
;;;892    	FSMC_NAND_Init();			/* 配置FSMC和GPIO用于NAND Flash接口 */
000002  f7fffffe          BL       FSMC_NAND_Init
;;;893    
;;;894    	FSMC_NAND_Reset();			/* 通过复位命令复位NAND Flash到读状态 */
000006  f7fffffe          BL       FSMC_NAND_Reset
;;;895    
;;;896    	Status = NAND_BuildLUT();	/* 建立块管理表 LUT = Look up table */
00000a  e8bd4010          POP      {r4,lr}
00000e  f7ffbffe          B.W      NAND_BuildLUT
;;;897    	return Status;
;;;898    }
;;;899    
                          ENDP


                          AREA ||i.NAND_IsBadBlock||, CODE, READONLY, ALIGN=1

                  NAND_IsBadBlock PROC
;;;1459   */
;;;1460    uint8_t NAND_IsBadBlock(uint32_t _ulBlockNo)
000000  b538              PUSH     {r3-r5,lr}
;;;1461   {
000002  4604              MOV      r4,r0
;;;1462   	uint8_t ucFlag;
;;;1463   
;;;1464   	/* 如果NAND Flash出厂前已经标注为坏块了，则就认为是坏块 */
;;;1465   	FSMC_NAND_ReadSpare(&ucFlag, _ulBlockNo * NAND_BLOCK_SIZE, BI_OFFSET, 1);
000004  0181              LSLS     r1,r0,#6
000006  2301              MOVS     r3,#1
000008  2200              MOVS     r2,#0
00000a  4668              MOV      r0,sp
00000c  f7fffffe          BL       FSMC_NAND_ReadSpare
;;;1466   	if (ucFlag != 0xFF)
000010  f89d0000          LDRB     r0,[sp,#0]
000014  28ff              CMP      r0,#0xff
000016  d10b              BNE      |L24.48|
;;;1467   	{
;;;1468   		return 1;
;;;1469   	}
;;;1470   
;;;1471   	FSMC_NAND_ReadSpare(&ucFlag, _ulBlockNo * NAND_BLOCK_SIZE + 1, BI_OFFSET, 1);
000018  2001              MOVS     r0,#1
00001a  eb001184          ADD      r1,r0,r4,LSL #6
00001e  4603              MOV      r3,r0
000020  2200              MOVS     r2,#0
000022  4668              MOV      r0,sp
000024  f7fffffe          BL       FSMC_NAND_ReadSpare
;;;1472   	if (ucFlag != 0xFF)
000028  f89d0000          LDRB     r0,[sp,#0]
00002c  28ff              CMP      r0,#0xff
00002e  d001              BEQ      |L24.52|
                  |L24.48|
;;;1473   	{
;;;1474   		return 1;
000030  2001              MOVS     r0,#1
;;;1475   	}
;;;1476   	return 0;	/* 是好块 */
;;;1477   }
000032  bd38              POP      {r3-r5,pc}
                  |L24.52|
000034  2000              MOVS     r0,#0                 ;1476
000036  bd38              POP      {r3-r5,pc}
;;;1478   
                          ENDP


                          AREA ||i.NAND_IsBufOk||, CODE, READONLY, ALIGN=1

                  NAND_IsBufOk PROC
;;;1436   */
;;;1437   static uint8_t NAND_IsBufOk(uint8_t *_pBuf, uint32_t _ulLen, uint8_t _ucValue)
000000  b510              PUSH     {r4,lr}
;;;1438   {
;;;1439   	uint32_t i;
;;;1440   
;;;1441   	for (i = 0; i < _ulLen; i++)
000002  2300              MOVS     r3,#0
000004  e005              B        |L25.18|
                  |L25.6|
;;;1442   	{
;;;1443   		if (_pBuf[i] != _ucValue)
000006  5cc4              LDRB     r4,[r0,r3]
000008  4294              CMP      r4,r2
00000a  d001              BEQ      |L25.16|
;;;1444   		{
;;;1445   			return 0;
00000c  2000              MOVS     r0,#0
;;;1446   		}
;;;1447   	}
;;;1448   
;;;1449   	return 1;
;;;1450   }
00000e  bd10              POP      {r4,pc}
                  |L25.16|
000010  1c5b              ADDS     r3,r3,#1
                  |L25.18|
000012  428b              CMP      r3,r1                 ;1441
000014  d3f7              BCC      |L25.6|
000016  2001              MOVS     r0,#1                 ;1449
000018  bd10              POP      {r4,pc}
;;;1451   
                          ENDP


                          AREA ||i.NAND_IsFreeBlock||, CODE, READONLY, ALIGN=1

                  NAND_IsFreeBlock PROC
;;;1486   */
;;;1487   static uint8_t NAND_IsFreeBlock(uint32_t _ulBlockNo)
000000  b538              PUSH     {r3-r5,lr}
;;;1488   {
000002  4604              MOV      r4,r0
;;;1489   	uint8_t ucFlag;
;;;1490   
;;;1491   	/* 如果NAND Flash出厂前已经标注为坏块了，则就认为是坏块 */
;;;1492   	if (NAND_IsBadBlock(_ulBlockNo))
000004  f7fffffe          BL       NAND_IsBadBlock
000008  b948              CBNZ     r0,|L26.30|
;;;1493   	{
;;;1494   		return 0;
;;;1495   	}
;;;1496   
;;;1497   	//FSMC_NAND_ReadPage(&ucFlag, _ulBlockNo * NAND_BLOCK_SIZE, USED_OFFSET, 1);  2014-05-03 bug
;;;1498   	FSMC_NAND_ReadSpare(&ucFlag, _ulBlockNo * NAND_BLOCK_SIZE, USED_OFFSET, 1);
00000a  2301              MOVS     r3,#1
00000c  01a1              LSLS     r1,r4,#6
00000e  461a              MOV      r2,r3
000010  4668              MOV      r0,sp
000012  f7fffffe          BL       FSMC_NAND_ReadSpare
;;;1499   	if (ucFlag == 0xFF)
000016  f89d0000          LDRB     r0,[sp,#0]
00001a  28ff              CMP      r0,#0xff
00001c  d001              BEQ      |L26.34|
                  |L26.30|
;;;1500   	{
;;;1501   		return 1;
;;;1502   	}
;;;1503   	return 0;
00001e  2000              MOVS     r0,#0
;;;1504   }
000020  bd38              POP      {r3-r5,pc}
                  |L26.34|
000022  2001              MOVS     r0,#1                 ;1501
000024  bd38              POP      {r3-r5,pc}
;;;1505   
                          ENDP


                          AREA ||i.NAND_LBNtoPBN||, CODE, READONLY, ALIGN=2

                  NAND_LBNtoPBN PROC
;;;1369   */
;;;1370   static uint16_t NAND_LBNtoPBN(uint32_t _uiLBN)
000000  4905              LDR      r1,|L27.24|
;;;1371   {
;;;1372   	uint16_t usPBN;		/* 物理块号 */
;;;1373   
;;;1374   	/* 如果逻辑块号大于有效的数据块个数则固定返回0xFFFF, 调用该函数的代码应该检查出这种错误 */
;;;1375   	if (_uiLBN >= s_usValidDataBlockCount)
000002  8809              LDRH     r1,[r1,#0]  ; s_usValidDataBlockCount
000004  4288              CMP      r0,r1
000006  d302              BCC      |L27.14|
;;;1376   	{
;;;1377   		return 0xFFFF;
000008  f64f70ff          MOV      r0,#0xffff
;;;1378   	}
;;;1379   	/* 查询LUT表，获得物理块号 */
;;;1380   	usPBN = s_usLUT[_uiLBN];
;;;1381   	return usPBN;
;;;1382   }
00000c  4770              BX       lr
                  |L27.14|
00000e  4903              LDR      r1,|L27.28|
000010  f8310010          LDRH     r0,[r1,r0,LSL #1]     ;1380
000014  4770              BX       lr
;;;1383   
                          ENDP

000016  0000              DCW      0x0000
                  |L27.24|
                          DCD      ||.data||
                  |L27.28|
                          DCD      ||.bss||

                          AREA ||i.NAND_MarkBadBlock||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_MarkBadBlock PROC
;;;1642   */
;;;1643   void NAND_MarkBadBlock(uint32_t _ulBlockNo)
000000  b538              PUSH     {r3-r5,lr}
;;;1644   {
000002  4604              MOV      r4,r0
;;;1645   	uint32_t ulPageNo;
;;;1646   	uint8_t ucFlag;
;;;1647   
;;;1648   	printf_err("NAND_MarkBadBlock(%d)\r\n", _ulBlockNo);
000004  4601              MOV      r1,r0
000006  a00b              ADR      r0,|L28.52|
000008  f7fffffe          BL       __2printf
;;;1649   
;;;1650   	/* 计算块的第1个页号 */
;;;1651   	ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
;;;1652   
;;;1653   	/* 块内第1个page备用区的第BI_OFFSET个字节写入非0xFF数据表示坏块 */
;;;1654   	ucFlag = NAND_BAD_BLOCK_FLAG;
00000c  2000              MOVS     r0,#0
00000e  01a4              LSLS     r4,r4,#6              ;1651
000010  f88d0000          STRB     r0,[sp,#0]
;;;1655   	if (FSMC_NAND_WriteSpare(&ucFlag, ulPageNo, BI_OFFSET, 1) == NAND_FAIL)
000014  4602              MOV      r2,r0
000016  2301              MOVS     r3,#1
000018  4621              MOV      r1,r4
00001a  4668              MOV      r0,sp
00001c  f7fffffe          BL       FSMC_NAND_WriteSpare
000020  2801              CMP      r0,#1
000022  d105              BNE      |L28.48|
;;;1656   	{
;;;1657   		/* 如果第1个页标记失败，则在第2个页标记 */
;;;1658   		FSMC_NAND_WriteSpare(&ucFlag, ulPageNo + 1, BI_OFFSET, 1);
000024  2301              MOVS     r3,#1
000026  2200              MOVS     r2,#0
000028  1c61              ADDS     r1,r4,#1
00002a  4668              MOV      r0,sp
00002c  f7fffffe          BL       FSMC_NAND_WriteSpare
                  |L28.48|
;;;1659   	}
;;;1660   }
000030  bd38              POP      {r3-r5,pc}
;;;1661   
                          ENDP

000032  0000              DCW      0x0000
                  |L28.52|
000034  4e414e44          DCB      "NAND_MarkBadBlock(%d)\r\n",0
000038  5f4d6172
00003c  6b426164
000040  426c6f63
000044  6b282564
000048  290d0a00

                          AREA ||i.NAND_MarkUsedBlock||, CODE, READONLY, ALIGN=1

                  NAND_MarkUsedBlock PROC
;;;1616   */
;;;1617   static uint8_t NAND_MarkUsedBlock(uint32_t _ulBlockNo)
000000  b508              PUSH     {r3,lr}
;;;1618   {
;;;1619   	uint32_t ulPageNo;
;;;1620   	uint8_t ucFlag;
;;;1621   
;;;1622   	/* 计算块的第1个页号 */
;;;1623   	ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
000002  0181              LSLS     r1,r0,#6
;;;1624   
;;;1625   	/* 块内第1个page备用区的第USED_OFFSET个字节写入非0xFF数据表示已用块 */
;;;1626   	ucFlag = NAND_USED_BLOCK_FLAG;
000004  20f0              MOVS     r0,#0xf0
000006  f88d0000          STRB     r0,[sp,#0]
;;;1627   	if (FSMC_NAND_WriteSpare(&ucFlag, ulPageNo, USED_OFFSET, 1) == NAND_FAIL)
00000a  2301              MOVS     r3,#1
00000c  461a              MOV      r2,r3
00000e  4668              MOV      r0,sp
000010  f7fffffe          BL       FSMC_NAND_WriteSpare
000014  2801              CMP      r0,#1
000016  d000              BEQ      |L29.26|
;;;1628   	{
;;;1629   		/* 如果标记失败，则需要标注这个块为坏块 */
;;;1630   		return NAND_FAIL;
;;;1631   	}
;;;1632   	return NAND_OK;
000018  2000              MOVS     r0,#0
                  |L29.26|
;;;1633   }
00001a  bd08              POP      {r3,pc}
;;;1634   
                          ENDP


                          AREA ||i.NAND_Read||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_Read PROC
;;;1073   */
;;;1074   uint8_t NAND_Read(uint32_t _ulMemAddr, uint32_t *_pReadBuf, uint16_t _usSize)
000000  b570              PUSH     {r4-r6,lr}
;;;1075   {
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
000006  4614              MOV      r4,r2
;;;1076   	uint16_t usPBN;			/* 物理块号 */
;;;1077   	uint32_t ulPhyPageNo;	/* 物理页号 */
;;;1078   	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;1079   	uint32_t ulTemp;
;;;1080   
;;;1081   	/* 数据长度必须是4字节整数倍 */
;;;1082   	if ((_usSize % 4) != 0)
000008  0790              LSLS     r0,r2,#30
00000a  d002              BEQ      |L30.18|
;;;1083   	{
;;;1084   		printf_err("Error:1 NAND_Read(_usSize)  %d\r\n",_usSize);
00000c  4611              MOV      r1,r2
00000e  a00e              ADR      r0,|L30.72|
;;;1085   		return NAND_FAIL;
000010  e007              B        |L30.34|
                  |L30.18|
;;;1086   	}
;;;1087   
;;;1088   	usPBN = NAND_AddrToPhyBlockNo(_ulMemAddr);	/* 查询LUT表获得物理块号 */
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       NAND_AddrToPhyBlockNo
000018  4601              MOV      r1,r0
;;;1089   	if (usPBN >= NAND_BLOCK_COUNT)
00001a  f5b06f80          CMP      r0,#0x400
00001e  d304              BCC      |L30.42|
;;;1090   	{
;;;1091   		/* 没有格式化，usPBN = 0xFFFF */
;;;1092   		printf_err("Error:1 NAND_Write() usPBN %d\r\n",usPBN);
000020  a012              ADR      r0,|L30.108|
                  |L30.34|
000022  f7fffffe          BL       __2printf
;;;1093   		return NAND_FAIL;
000026  2001              MOVS     r0,#1
                  |L30.40|
;;;1094   	}
;;;1095   
;;;1096   	ulTemp = _ulMemAddr % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;1097   	ulPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
;;;1098   	usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
;;;1099   
;;;1100   	if (FSMC_NAND_ReadData((uint8_t *)_pReadBuf, ulPhyPageNo, usAddrInPage, _usSize) == NAND_FAIL)
;;;1101   	{
;;;1102   		return NAND_FAIL;	/* 读NAND Flash失败 */
;;;1103   	}
;;;1104   
;;;1105   	/* 成功 */
;;;1106   	return NAND_OK;
;;;1107   }
000028  bd70              POP      {r4-r6,pc}
                  |L30.42|
00002a  f3c60010          UBFX     r0,r6,#0,#17          ;1096
00002e  0189              LSLS     r1,r1,#6              ;1097
000030  eb0121d0          ADD      r1,r1,r0,LSR #11      ;1097
000034  f3c0020a          UBFX     r2,r0,#0,#11          ;1098
000038  4623              MOV      r3,r4                 ;1100
00003a  4628              MOV      r0,r5                 ;1100
00003c  f7fffffe          BL       FSMC_NAND_ReadData
000040  2801              CMP      r0,#1                 ;1100
000042  d0f1              BEQ      |L30.40|
000044  2000              MOVS     r0,#0                 ;1106
000046  bd70              POP      {r4-r6,pc}
;;;1108   
                          ENDP

                  |L30.72|
000048  4572726f          DCB      "Error:1 NAND_Read(_usSize)  %d\r\n",0
00004c  723a3120
000050  4e414e44
000054  5f526561
000058  64285f75
00005c  7353697a
000060  65292020
000064  25640d0a
000068  00      
000069  00                DCB      0
00006a  00                DCB      0
00006b  00                DCB      0
                  |L30.108|
00006c  4572726f          DCB      "Error:1 NAND_Write() usPBN %d\r\n",0
000070  723a3120
000074  4e414e44
000078  5f577269
00007c  74652829
000080  20757350
000084  424e2025
000088  640d0a00

                          AREA ||i.NAND_ReadID||, CODE, READONLY, ALIGN=2

                  NAND_ReadID PROC
;;;216    */
;;;217    uint32_t NAND_ReadID(void)
000000  4905              LDR      r1,|L31.24|
;;;218    {
;;;219    	uint32_t data = 0;
;;;220    
;;;221    	/* 发送命令 Command to the command area */
;;;222    	NAND_CMD_AREA = 0x90;
000002  2090              MOVS     r0,#0x90
000004  7008              STRB     r0,[r1,#0]
;;;223    	NAND_ADDR_AREA = 0x00;
000006  4905              LDR      r1,|L31.28|
000008  2000              MOVS     r0,#0
00000a  7008              STRB     r0,[r1,#0]
;;;224    
;;;225    	/* 顺序读取NAND Flash的ID */
;;;226    	data = *(__IO uint32_t *)(Bank_NAND_ADDR | DATA_AREA);
00000c  f04f40e0          MOV      r0,#0x70000000
000010  6800              LDR      r0,[r0,#0]
;;;227    	data =  ((data << 24) & 0xFF000000) |
000012  ba00              REV      r0,r0
;;;228    			((data << 8 ) & 0x00FF0000) |
;;;229    			((data >> 8 ) & 0x0000FF00) |
;;;230    			((data >> 24) & 0x000000FF) ;
;;;231    	return data;
;;;232    }
000014  4770              BX       lr
;;;233    
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      0x70010000
                  |L31.28|
                          DCD      0x70020000

                          AREA ||i.NAND_ReadMultiSectors||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_ReadMultiSectors PROC
;;;1225   */
;;;1226   uint8_t NAND_ReadMultiSectors(uint8_t *_pBuf, uint32_t _SectorNo, uint16_t _SectorSize, uint32_t _SectorCount)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1227   {
000004  461e              MOV      r6,r3
000006  4615              MOV      r5,r2
000008  4688              MOV      r8,r1
00000a  4682              MOV      r10,r0
;;;1228   	uint32_t i;
;;;1229   	uint32_t usLBN;			/* 逻辑块号 */
;;;1230   	uint32_t usPBN;			/* 物理块号 */
;;;1231   	uint32_t uiPhyPageNo;	/* 物理页号 */
;;;1232   	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;1233   	uint32_t ulTemp;
;;;1234   
;;;1235   	/*
;;;1236   		HY27UF081G2A = 128M Flash.  有 1024个BLOCK, 每个BLOCK包含64个PAGE， 每个PAGE包含2048+64字节，
;;;1237   		擦除最小单位是BLOCK， 编程最小单位是字节。
;;;1238   
;;;1239   		每个PAGE在逻辑上可以分为4个512字节扇区。
;;;1240   	*/
;;;1241   
;;;1242   	for (i = 0; i < _SectorCount; i++)
00000c  2400              MOVS     r4,#0
00000e  e025              B        |L32.92|
                  |L32.16|
;;;1243   	{
;;;1244   		/* 根据逻辑扇区号和扇区大小计算逻辑块号 */
;;;1245   		//usLBN = (_SectorNo * _SectorSize) / (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;1246   		/* (_SectorNo * _SectorSize) 乘积可能大于32位，因此换下面这种写法 */
;;;1247   		usLBN = (_SectorNo + i) / (NAND_BLOCK_SIZE * (NAND_PAGE_SIZE / _SectorSize));
000010  f44f6000          MOV      r0,#0x800
000014  fbb0f0f5          UDIV     r0,r0,r5
000018  0181              LSLS     r1,r0,#6
00001a  eb080704          ADD      r7,r8,r4
00001e  fbb7f0f1          UDIV     r0,r7,r1
;;;1248   		usPBN = NAND_LBNtoPBN(usLBN);	/* 查询LUT表获得物理块号 */
000022  f7fffffe          BL       NAND_LBNtoPBN
000026  4601              MOV      r1,r0
;;;1249   		if (usPBN >= NAND_BLOCK_COUNT)
000028  f5b06f80          CMP      r0,#0x400
00002c  d303              BCC      |L32.54|
;;;1250   		{
;;;1251   			printf_err("Error: NAND_ReadMultiSectors(), not format, usPBN = %d\r\n", usPBN);
00002e  a011              ADR      r0,|L32.116|
000030  f7fffffe          BL       __2printf
;;;1252   			/* 没有格式化，usPBN = 0xFFFF */
;;;1253   			return NAND_FAIL;
000034  e01c              B        |L32.112|
                  |L32.54|
;;;1254   		}
;;;1255   
;;;1256   		ulTemp = ((uint64_t)(_SectorNo + i) * _SectorSize) % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
000036  fba70205          UMULL    r0,r2,r7,r5
00003a  f3c00010          UBFX     r0,r0,#0,#17
;;;1257   		uiPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
00003e  0189              LSLS     r1,r1,#6
000040  eb0121d0          ADD      r1,r1,r0,LSR #11
;;;1258   		usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
000044  f3c0070a          UBFX     r7,r0,#0,#11
;;;1259   
;;;1260   		if (FSMC_NAND_ReadData((uint8_t *)&_pBuf[i * _SectorSize], uiPhyPageNo, usAddrInPage, _SectorSize) == NAND_FAIL)
000048  fb04a005          MLA      r0,r4,r5,r10
00004c  4689              MOV      r9,r1                 ;1257
00004e  462b              MOV      r3,r5
000050  463a              MOV      r2,r7
000052  f7fffffe          BL       FSMC_NAND_ReadData
000056  2801              CMP      r0,#1
000058  d005              BEQ      |L32.102|
00005a  1c64              ADDS     r4,r4,#1
                  |L32.92|
00005c  42b4              CMP      r4,r6                 ;1242
00005e  d3d7              BCC      |L32.16|
;;;1261   		{
;;;1262   			printf_err("Error: NAND_ReadMultiSectors(), ReadData(page = %d, addr = %d)\r\n", uiPhyPageNo, usAddrInPage);
;;;1263   			return NAND_FAIL;	/* 读NAND Flash失败 */
;;;1264   		}
;;;1265   	}
;;;1266   
;;;1267   	/* 成功 */
;;;1268   	return NAND_OK;
000060  2000              MOVS     r0,#0
                  |L32.98|
;;;1269   }
000062  e8bd87f0          POP      {r4-r10,pc}
                  |L32.102|
000066  463a              MOV      r2,r7                 ;1262
000068  4649              MOV      r1,r9                 ;1262
00006a  4811              LDR      r0,|L32.176|
00006c  f7fffffe          BL       __2printf
                  |L32.112|
000070  2001              MOVS     r0,#1                 ;1263
000072  e7f6              B        |L32.98|
;;;1270   
                          ENDP

                  |L32.116|
000074  4572726f          DCB      "Error: NAND_ReadMultiSectors(), not format, usPBN = %d\r"
000078  723a204e
00007c  414e445f
000080  52656164
000084  4d756c74
000088  69536563
00008c  746f7273
000090  28292c20
000094  6e6f7420
000098  666f726d
00009c  61742c20
0000a0  75735042
0000a4  4e203d20
0000a8  25640d  
0000ab  0a00              DCB      "\n",0
0000ad  00                DCB      0
0000ae  00                DCB      0
0000af  00                DCB      0
                  |L32.176|
                          DCD      ||.conststring||+0xd0

                          AREA ||i.NAND_ReadONFI||, CODE, READONLY, ALIGN=2

                  NAND_ReadONFI PROC
;;;2046   */
;;;2047   void NAND_ReadONFI(uint8_t *_pBuf)
000000  4a07              LDR      r2,|L33.32|
;;;2048   {
;;;2049   	uint16_t i;
;;;2050   
;;;2051   	/* 发送命令 Command to the command area */
;;;2052   	NAND_CMD_AREA = 0x90;
000002  2190              MOVS     r1,#0x90
000004  7011              STRB     r1,[r2,#0]
;;;2053   	NAND_ADDR_AREA = 0x20;
000006  4a07              LDR      r2,|L33.36|
000008  2120              MOVS     r1,#0x20
00000a  7011              STRB     r1,[r2,#0]
;;;2054   
;;;2055   	/* 读数据到缓冲区pBuffer */
;;;2056   	for(i = 0; i < 256; i++)
00000c  2100              MOVS     r1,#0
;;;2057   	{
;;;2058   		_pBuf[i] = NAND_DATA_AREA;
00000e  f04f42e0          MOV      r2,#0x70000000
                  |L33.18|
000012  7813              LDRB     r3,[r2,#0]
000014  5443              STRB     r3,[r0,r1]
000016  1c49              ADDS     r1,r1,#1
000018  b289              UXTH     r1,r1                 ;2056
00001a  29ff              CMP      r1,#0xff              ;2056
00001c  d9f9              BLS      |L33.18|
;;;2059   	}
;;;2060   }
00001e  4770              BX       lr
;;;2061   
                          ENDP

                  |L33.32|
                          DCD      0x70010000
                  |L33.36|
                          DCD      0x70020000

                          AREA ||i.NAND_ReadParamPage||, CODE, READONLY, ALIGN=2

                  NAND_ReadParamPage PROC
;;;2069   */
;;;2070   void NAND_ReadParamPage(PARAM_PAGE_T *_pData)
000000  b570              PUSH     {r4-r6,lr}
;;;2071   {
;;;2072   	uint16_t i;
;;;2073   	uint8_t *_pBuf = (uint8_t *)_pData;
;;;2074   
;;;2075   	/* 发送命令 Command to the command area */
;;;2076   	NAND_CMD_AREA = 0xEC;
000002  490e              LDR      r1,|L34.60|
000004  4604              MOV      r4,r0                 ;2073
000006  20ec              MOVS     r0,#0xec
000008  7008              STRB     r0,[r1,#0]
;;;2077   	NAND_ADDR_AREA = 0x00;
00000a  490d              LDR      r1,|L34.64|
00000c  2000              MOVS     r0,#0
00000e  7008              STRB     r0,[r1,#0]
;;;2078   
;;;2079   	 /* 必须等待，否则读出数据异常, 此处应该判断超时 */
;;;2080   	for (i = 0; i < 20; i++);
000010  4601              MOV      r1,r0
                  |L34.18|
000012  1c49              ADDS     r1,r1,#1
000014  b289              UXTH     r1,r1
000016  2914              CMP      r1,#0x14
000018  d3fb              BCC      |L34.18|
;;;2081   	while( GPIO_ReadInputDataBit(GPIOG, GPIO_Pin_6) == 0);
00001a  4d0a              LDR      r5,|L34.68|
                  |L34.28|
00001c  2140              MOVS     r1,#0x40
00001e  4628              MOV      r0,r5
000020  f7fffffe          BL       GPIO_ReadInputDataBit
000024  2800              CMP      r0,#0
000026  d0f9              BEQ      |L34.28|
;;;2082   
;;;2083   	/* 读数据到缓冲区pBuffer */
;;;2084   	for(i = 0; i < 256; i++)
000028  2100              MOVS     r1,#0
;;;2085   	{
;;;2086   		_pBuf[i] = NAND_DATA_AREA;
00002a  f04f40e0          MOV      r0,#0x70000000
                  |L34.46|
00002e  7802              LDRB     r2,[r0,#0]
000030  5462              STRB     r2,[r4,r1]
000032  1c49              ADDS     r1,r1,#1
000034  b289              UXTH     r1,r1                 ;2084
000036  29ff              CMP      r1,#0xff              ;2084
000038  d9f9              BLS      |L34.46|
;;;2087   	}
;;;2088   
;;;2089   }
00003a  bd70              POP      {r4-r6,pc}
;;;2090   
                          ENDP

                  |L34.60|
                          DCD      0x70010000
                  |L34.64|
                          DCD      0x70020000
                  |L34.68|
                          DCD      0x40012000

                          AREA ||i.NAND_ScanAllBadBlock||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_ScanAllBadBlock PROC
;;;1669   */
;;;1670   void NAND_ScanAllBadBlock(void)
000000  b570              PUSH     {r4-r6,lr}
;;;1671   {
;;;1672   	uint32_t i;
;;;1673   	
;;;1674   	for (i = 0; i < NAND_BLOCK_COUNT; i++)
000002  2400              MOVS     r4,#0
000004  f44f6580          MOV      r5,#0x400
                  |L35.8|
;;;1675   	{
;;;1676   		if (NAND_ScanBlock(i) == NAND_OK)
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       NAND_ScanBlock
00000e  2800              CMP      r0,#0
;;;1677   		{
;;;1678   			printf("Scan Block %d (%d%%), Ok\r\n", i, i * 100 / NAND_BLOCK_COUNT);
;;;1679   		}
;;;1680   		else
;;;1681   		{
;;;1682   			printf("Scan Block %d (%d%%), Err\r\n", i, i * 100 / NAND_BLOCK_COUNT);
000010  f04f0064          MOV      r0,#0x64
000014  fb04f000          MUL      r0,r4,r0
000018  ea4f2290          LSR      r2,r0,#10
00001c  4621              MOV      r1,r4
00001e  d009              BEQ      |L35.52|
000020  a006              ADR      r0,|L35.60|
000022  f7fffffe          BL       __2printf
;;;1683   			NAND_MarkBadBlock(i);
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       NAND_MarkBadBlock
                  |L35.44|
00002c  1c64              ADDS     r4,r4,#1
00002e  42ac              CMP      r4,r5                 ;1674
000030  d3ea              BCC      |L35.8|
;;;1684   		}
;;;1685   	}
;;;1686   }
000032  bd70              POP      {r4-r6,pc}
                  |L35.52|
000034  a008              ADR      r0,|L35.88|
000036  f7fffffe          BL       __2printf
00003a  e7f7              B        |L35.44|
;;;1687   
                          ENDP

                  |L35.60|
00003c  5363616e          DCB      "Scan Block %d (%d%%), Err\r\n",0
000040  20426c6f
000044  636b2025
000048  64202825
00004c  64252529
000050  2c204572
000054  720d0a00
                  |L35.88|
000058  5363616e          DCB      "Scan Block %d (%d%%), Ok\r\n",0
00005c  20426c6f
000060  636b2025
000064  64202825
000068  64252529
00006c  2c204f6b
000070  0d0a00  
000073  00                DCB      0

                          AREA ||i.NAND_ScanBlock||, CODE, READONLY, ALIGN=2

                  NAND_ScanBlock PROC
;;;1523   */
;;;1524   uint8_t NAND_ScanBlock(uint32_t _ulBlockNo)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1525   {
000004  4681              MOV      r9,r0
;;;1526   	uint32_t i, k;
;;;1527   	uint32_t ulPageNo;
;;;1528   
;;;1529   	#if 0
;;;1530   	/* 如果NAND Flash出厂前已经标注为坏块了，则就认为是坏块 */
;;;1531   	if (NAND_IsBadBlock(_ulBlockNo))
;;;1532   	{
;;;1533   		return NAND_FAIL;
;;;1534   	}
;;;1535   	#endif
;;;1536   
;;;1537   	/* 下面的代码将通过反复擦除、编程的方式来测试NAND Flash每个块的可靠性 */
;;;1538   	memset(s_ucTempBuf, 0x00, NAND_PAGE_TOTAL_SIZE);
000006  f44f6504          MOV      r5,#0x840
00000a  4629              MOV      r1,r5
00000c  482e              LDR      r0,|L36.200|
00000e  f7fffffe          BL       __aeabi_memclr
;;;1539   	for (i = 0; i < BAD_BALOK_TEST_CYCLE; i++)
000012  f04f0800          MOV      r8,#0
;;;1540   	{
;;;1541   		/* 第1步：擦除这个块 */
;;;1542   		if (FSMC_NAND_EraseBlock(_ulBlockNo) != NAND_READY)
;;;1543   		{
;;;1544   			return NAND_FAIL;
;;;1545   		}
;;;1546   
;;;1547   		/* 第2步：读出块内每个page的数据，并判断是否全0xFF */
;;;1548   		ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
000016  ea4f1489          LSL      r4,r9,#6
                  |L36.26|
00001a  4648              MOV      r0,r9                 ;1542
00001c  f7fffffe          BL       FSMC_NAND_EraseBlock
000020  2840              CMP      r0,#0x40              ;1542
000022  d14e              BNE      |L36.194|
000024  4626              MOV      r6,r4
;;;1549   		for (k = 0; k < NAND_BLOCK_SIZE; k++)
000026  2700              MOVS     r7,#0
                  |L36.40|
;;;1550   		{
;;;1551   			/* 读出整页数据 */
;;;1552   			FSMC_NAND_ReadPage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE);
000028  462b              MOV      r3,r5
00002a  2200              MOVS     r2,#0
00002c  4631              MOV      r1,r6
00002e  4826              LDR      r0,|L36.200|
000030  f7fffffe          BL       FSMC_NAND_ReadPage
;;;1553   
;;;1554   			/* 判断存储单元是不是全0xFF */
;;;1555   			if (NAND_IsBufOk(s_ucTempBuf, NAND_PAGE_TOTAL_SIZE, 0xFF) == 0)
000034  22ff              MOVS     r2,#0xff
000036  4629              MOV      r1,r5
000038  4823              LDR      r0,|L36.200|
00003a  f7fffffe          BL       NAND_IsBufOk
00003e  b3e8              CBZ      r0,|L36.188|
000040  1c76              ADDS     r6,r6,#1
000042  1c7f              ADDS     r7,r7,#1
000044  2f40              CMP      r7,#0x40              ;1549
000046  d3ef              BCC      |L36.40|
;;;1556   			{
;;;1557   				return NAND_FAIL;
;;;1558   			}
;;;1559   
;;;1560   			ulPageNo++;		/* 继续写下一个页 */
;;;1561   		}
;;;1562   
;;;1563   		/* 第2步：写全0，并读回判断是否全0 */
;;;1564   		ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
000048  4626              MOV      r6,r4
;;;1565   		for (k = 0; k < NAND_BLOCK_SIZE; k++)
00004a  2700              MOVS     r7,#0
                  |L36.76|
;;;1566   		{
;;;1567   			/* 填充buf[]缓冲区为全0,并写入NAND Flash */
;;;1568   			memset(s_ucTempBuf, 0x00, NAND_PAGE_TOTAL_SIZE);
00004c  4629              MOV      r1,r5
00004e  481e              LDR      r0,|L36.200|
000050  f7fffffe          BL       __aeabi_memclr
;;;1569   			if (FSMC_NAND_WritePage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE) != NAND_OK)
000054  462b              MOV      r3,r5
000056  2200              MOVS     r2,#0
000058  4631              MOV      r1,r6
00005a  481b              LDR      r0,|L36.200|
00005c  f7fffffe          BL       FSMC_NAND_WritePage
000060  bb60              CBNZ     r0,|L36.188|
;;;1570   			{
;;;1571   				return NAND_FAIL;
;;;1572   			}
;;;1573   
;;;1574   			/* 读出整页数据, 判断存储单元是不是全0x00 */
;;;1575   			FSMC_NAND_ReadPage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE);
000062  462b              MOV      r3,r5
000064  2200              MOVS     r2,#0
000066  4631              MOV      r1,r6
000068  4817              LDR      r0,|L36.200|
00006a  f7fffffe          BL       FSMC_NAND_ReadPage
;;;1576   			if (NAND_IsBufOk(s_ucTempBuf, NAND_PAGE_TOTAL_SIZE, 0x00) == 0)
00006e  2200              MOVS     r2,#0
000070  4629              MOV      r1,r5
000072  4815              LDR      r0,|L36.200|
000074  f7fffffe          BL       NAND_IsBufOk
000078  b300              CBZ      r0,|L36.188|
00007a  1c76              ADDS     r6,r6,#1
00007c  1c7f              ADDS     r7,r7,#1
00007e  2f40              CMP      r7,#0x40              ;1565
000080  d3e4              BCC      |L36.76|
000082  f1080801          ADD      r8,r8,#1              ;1539
000086  f1b80f03          CMP      r8,#3                 ;1539
00008a  d3c6              BCC      |L36.26|
;;;1577   			{
;;;1578   				return NAND_FAIL;
;;;1579   			}
;;;1580   
;;;1581   			ulPageNo++;		/* 继续一个页 */
;;;1582   		}
;;;1583   	}
;;;1584   
;;;1585   	/* 最后一步：擦除整个块 */
;;;1586   	if (FSMC_NAND_EraseBlock(_ulBlockNo) != NAND_READY)
00008c  4648              MOV      r0,r9
00008e  f7fffffe          BL       FSMC_NAND_EraseBlock
000092  2840              CMP      r0,#0x40
000094  d115              BNE      |L36.194|
;;;1587   	{
;;;1588   		return NAND_FAIL;
;;;1589   	}
;;;1590   	ulPageNo = _ulBlockNo * NAND_BLOCK_SIZE;	/* 计算该块第1个页的页号 */
;;;1591   	for (k = 0; k < NAND_BLOCK_SIZE; k++)
000096  2600              MOVS     r6,#0
                  |L36.152|
;;;1592   	{
;;;1593   		/* 读出整页数据 */
;;;1594   		FSMC_NAND_ReadPage(s_ucTempBuf, ulPageNo, 0, NAND_PAGE_TOTAL_SIZE);
000098  462b              MOV      r3,r5
00009a  2200              MOVS     r2,#0
00009c  4621              MOV      r1,r4
00009e  480a              LDR      r0,|L36.200|
0000a0  f7fffffe          BL       FSMC_NAND_ReadPage
;;;1595   
;;;1596   		/* 判断存储单元是不是全0xFF */
;;;1597   		if (NAND_IsBufOk(s_ucTempBuf, NAND_PAGE_TOTAL_SIZE, 0xFF) == 0)
0000a4  22ff              MOVS     r2,#0xff
0000a6  4629              MOV      r1,r5
0000a8  4807              LDR      r0,|L36.200|
0000aa  f7fffffe          BL       NAND_IsBufOk
0000ae  b128              CBZ      r0,|L36.188|
0000b0  1c64              ADDS     r4,r4,#1
0000b2  1c76              ADDS     r6,r6,#1
0000b4  2e40              CMP      r6,#0x40              ;1591
0000b6  d3ef              BCC      |L36.152|
;;;1598   		{
;;;1599   			return NAND_FAIL;
;;;1600   		}
;;;1601   
;;;1602   		ulPageNo++;		/* 继续写下一个页 */
;;;1603   	}
;;;1604   
;;;1605   	return NAND_OK;
0000b8  2000              MOVS     r0,#0
                  |L36.186|
;;;1606   
;;;1607   }
0000ba  e000              B        |L36.190|
                  |L36.188|
0000bc  e001              B        |L36.194|
                  |L36.190|
0000be  e8bd87f0          POP      {r4-r10,pc}
                  |L36.194|
0000c2  2001              MOVS     r0,#1                 ;1599
0000c4  e7f9              B        |L36.186|
;;;1608   
                          ENDP

0000c6  0000              DCW      0x0000
                  |L36.200|
                          DCD      ||.bss||+0x800

                          AREA ||i.NAND_Write||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_Write PROC
;;;1008   */
;;;1009   uint8_t NAND_Write(uint32_t _ulMemAddr, uint32_t *_pWriteBuf, uint16_t _usSize)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1010   {
000004  4605              MOV      r5,r0
000006  460e              MOV      r6,r1
000008  4614              MOV      r4,r2
;;;1011   	uint16_t usPBN;			/* 物理块号 */
;;;1012   	uint32_t ulPhyPageNo;	/* 物理页号 */
;;;1013   	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;1014   	uint32_t ulTemp;
;;;1015   
;;;1016   	/* 数据长度必须是4字节整数倍 */
;;;1017   	if ((_usSize % 4) != 0)
00000a  0790              LSLS     r0,r2,#30
00000c  d006              BEQ      |L37.28|
;;;1018   	{
;;;1019   		printf_err("Error:1 NAND_Write()  %d\r\n",_usSize);
00000e  4611              MOV      r1,r2
000010  a01e              ADR      r0,|L37.140|
000012  f7fffffe          BL       __2printf
;;;1020   		return NAND_FAIL;
000016  2001              MOVS     r0,#1
                  |L37.24|
;;;1021   	}
;;;1022   	/* 数据长度不能超过512字节(遵循 Fat格式) */
;;;1023   	if (_usSize > 512)
;;;1024   	{
;;;1025   		printf_err("Error:2 NAND_Write() %d\r\n",_usSize);
;;;1026   		//return NAND_FAIL;
;;;1027   	}
;;;1028   
;;;1029   	usPBN = NAND_AddrToPhyBlockNo(_ulMemAddr);	/* 查询LUT表获得物理块号 */
;;;1030   
;;;1031   	ulTemp = _ulMemAddr % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;1032   	ulPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
;;;1033   	usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
;;;1034   
;;;1035   	/* 读出扇区的内容，判断是否全FF */
;;;1036   	if (FSMC_NAND_ReadData(s_ucTempBuf, ulPhyPageNo, usAddrInPage, _usSize) == NAND_FAIL)
;;;1037   	{
;;;1038   		return NAND_FAIL;	/* 读NAND Flash失败 */
;;;1039   	}
;;;1040   	/*　如果是全0xFF, 则可以直接写入，无需擦除 */
;;;1041   	if (NAND_IsBufOk(s_ucTempBuf, _usSize, 0xFF) == 1)
;;;1042   	{
;;;1043   		if (FSMC_NAND_WriteData((uint8_t *)_pWriteBuf, ulPhyPageNo, usAddrInPage, _usSize) == NAND_FAIL)
;;;1044   		{
;;;1045   			/* 将数据写入到另外一个块（空闲块） */
;;;1046   			return NAND_WriteToNewBlock(ulPhyPageNo, (uint8_t *)_pWriteBuf, usAddrInPage, _usSize);
;;;1047   		}
;;;1048   
;;;1049   		/* 标记该块已用 */
;;;1050   		if (NAND_MarkUsedBlock(ulPhyPageNo / NAND_BLOCK_SIZE) == NAND_FAIL)
;;;1051   		{
;;;1052   			/* 标记失败，将数据写入到另外一个块（空闲块） */
;;;1053   			return NAND_WriteToNewBlock(ulPhyPageNo, (uint8_t *)_pWriteBuf, usAddrInPage, _usSize);
;;;1054   		}
;;;1055   		return NAND_OK;	/* 写入成功 */
;;;1056   	}
;;;1057   
;;;1058   	/* 将数据写入到另外一个块（空闲块） */
;;;1059   	return NAND_WriteToNewBlock(ulPhyPageNo, (uint8_t *)_pWriteBuf, usAddrInPage, _usSize);
;;;1060   }
000018  e8bd81f0          POP      {r4-r8,pc}
                  |L37.28|
00001c  f5b47f00          CMP      r4,#0x200             ;1023
000020  d903              BLS      |L37.42|
000022  4611              MOV      r1,r2                 ;1025
000024  a020              ADR      r0,|L37.168|
000026  f7fffffe          BL       __2printf
                  |L37.42|
00002a  4628              MOV      r0,r5                 ;1029
00002c  f7fffffe          BL       NAND_AddrToPhyBlockNo
000030  4601              MOV      r1,r0                 ;1029
000032  f3c50010          UBFX     r0,r5,#0,#17          ;1031
000036  0189              LSLS     r1,r1,#6              ;1032
000038  eb0125d0          ADD      r5,r1,r0,LSR #11      ;1032
00003c  f3c0070a          UBFX     r7,r0,#0,#11          ;1033
000040  4623              MOV      r3,r4                 ;1036
000042  463a              MOV      r2,r7                 ;1036
000044  4629              MOV      r1,r5                 ;1036
000046  481f              LDR      r0,|L37.196|
000048  f7fffffe          BL       FSMC_NAND_ReadData
00004c  2801              CMP      r0,#1                 ;1036
00004e  d0e3              BEQ      |L37.24|
000050  22ff              MOVS     r2,#0xff              ;1041
000052  4621              MOV      r1,r4                 ;1041
000054  481b              LDR      r0,|L37.196|
000056  f7fffffe          BL       NAND_IsBufOk
00005a  2801              CMP      r0,#1                 ;1041
00005c  d10e              BNE      |L37.124|
00005e  4623              MOV      r3,r4                 ;1043
000060  463a              MOV      r2,r7                 ;1043
000062  4629              MOV      r1,r5                 ;1043
000064  4630              MOV      r0,r6                 ;1043
000066  f7fffffe          BL       FSMC_NAND_WriteData
00006a  2801              CMP      r0,#1                 ;1043
00006c  d006              BEQ      |L37.124|
00006e  09a8              LSRS     r0,r5,#6              ;1050
000070  f7fffffe          BL       NAND_MarkUsedBlock
000074  2801              CMP      r0,#1                 ;1050
000076  d001              BEQ      |L37.124|
000078  2000              MOVS     r0,#0                 ;1055
00007a  e7cd              B        |L37.24|
                  |L37.124|
00007c  4623              MOV      r3,r4                 ;1059
00007e  463a              MOV      r2,r7                 ;1059
000080  4631              MOV      r1,r6                 ;1059
000082  4628              MOV      r0,r5                 ;1059
000084  e8bd41f0          POP      {r4-r8,lr}            ;1059
000088  f7ffbffe          B.W      NAND_WriteToNewBlock
;;;1061   
                          ENDP

                  |L37.140|
00008c  4572726f          DCB      "Error:1 NAND_Write()  %d\r\n",0
000090  723a3120
000094  4e414e44
000098  5f577269
00009c  74652829
0000a0  20202564
0000a4  0d0a00  
0000a7  00                DCB      0
                  |L37.168|
0000a8  4572726f          DCB      "Error:2 NAND_Write() %d\r\n",0
0000ac  723a3220
0000b0  4e414e44
0000b4  5f577269
0000b8  74652829
0000bc  2025640d
0000c0  0a00    
0000c2  00                DCB      0
0000c3  00                DCB      0
                  |L37.196|
                          DCD      ||.bss||+0x800

                          AREA ||i.NAND_WriteMultiSectors||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_WriteMultiSectors PROC
;;;1121   */
;;;1122   uint8_t NAND_WriteMultiSectors(uint8_t *_pBuf, uint32_t _SectorNo, uint16_t _SectorSize, uint32_t _SectorCount)
000000  e92d5fff          PUSH     {r0-r12,lr}
;;;1123   {
;;;1124   	uint32_t i;
;;;1125   	uint32_t usLBN;			/* 逻辑块号 */
;;;1126   	uint32_t usPBN;			/* 物理块号 */
;;;1127   	uint32_t uiPhyPageNo;	/* 物理页号 */
;;;1128   	uint16_t usAddrInPage;	/* 页内偏移地址 */
;;;1129   	uint32_t ulTemp;
;;;1130   	uint8_t ucReturn;
;;;1131   
;;;1132   	/*
;;;1133   		HY27UF081G2A = 128M Flash.  有 1024个BLOCK, 每个BLOCK包含64个PAGE， 每个PAGE包含2048+64字节，
;;;1134   		擦除最小单位是BLOCK， 编程最小单位是字节。
;;;1135   
;;;1136   		每个PAGE在逻辑上可以分为4个512字节扇区。
;;;1137   	*/
;;;1138   
;;;1139   	for (i = 0; i < _SectorCount; i++)
000004  2500              MOVS     r5,#0
000006  461f              MOV      r7,r3                 ;1123
000008  4614              MOV      r4,r2                 ;1123
;;;1140   	{
;;;1141   		/* 根据逻辑扇区号和扇区大小计算逻辑块号 */
;;;1142   		//usLBN = (_SectorNo * _SectorSize) / (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;1143   		/* (_SectorNo * _SectorSize) 乘积可能大于32位，因此换下面这种写法 */
;;;1144   		usLBN = (_SectorNo + i) / (NAND_BLOCK_SIZE * (NAND_PAGE_SIZE / _SectorSize));
00000a  f44f6900          MOV      r9,#0x800
00000e  46aa              MOV      r10,r5
000010  e08d              B        |L38.302|
                  |L38.18|
000012  fbb9f0f4          UDIV     r0,r9,r4
000016  0181              LSLS     r1,r0,#6
000018  9801              LDR      r0,[sp,#4]
00001a  464e              MOV      r6,r9
00001c  eb000805          ADD      r8,r0,r5
000020  fbb8f0f1          UDIV     r0,r8,r1
000024  4683              MOV      r11,r0
;;;1145   		usPBN = NAND_LBNtoPBN(usLBN);	/* 查询LUT表获得物理块号 */
000026  f7fffffe          BL       NAND_LBNtoPBN
00002a  4602              MOV      r2,r0
;;;1146   		if (usPBN >= NAND_BLOCK_COUNT)
00002c  f5b06f80          CMP      r0,#0x400
000030  d304              BCC      |L38.60|
;;;1147   		{
;;;1148   			printf_err("Error1: NAND_WriteMultiSectors(), no format. usLBN=%d, usPBN=%d\r\n", usLBN, usPBN);
000032  4659              MOV      r1,r11
000034  4840              LDR      r0,|L38.312|
000036  f7fffffe          BL       __2printf
;;;1149   			/* 没有格式化，usPBN = 0xFFFF */
;;;1150   			return NAND_FAIL;
00003a  e073              B        |L38.292|
                  |L38.60|
;;;1151   		}
;;;1152   
;;;1153   		//ulTemp = ((uint64_t)(_SectorNo + i) * _SectorSize) % (NAND_BLOCK_SIZE * NAND_PAGE_SIZE);
;;;1154   		ulTemp = ((_SectorNo + i) % (NAND_BLOCK_SIZE * (NAND_PAGE_SIZE / _SectorSize))) *  _SectorSize;
00003c  fbb6f0f4          UDIV     r0,r6,r4
000040  0181              LSLS     r1,r0,#6
000042  fbb8f3f1          UDIV     r3,r8,r1
000046  fb018013          MLS      r0,r1,r3,r8
00004a  4360              MULS     r0,r4,r0
;;;1155   		uiPhyPageNo = usPBN * NAND_BLOCK_SIZE + ulTemp / NAND_PAGE_SIZE;	/* 计算物理页号 */
00004c  0191              LSLS     r1,r2,#6
00004e  eb0128d0          ADD      r8,r1,r0,LSR #11
;;;1156   		usAddrInPage = ulTemp % NAND_PAGE_SIZE;	/* 计算页内偏移地址 */
000052  f3c00b0a          UBFX     r11,r0,#0,#11
;;;1157   
;;;1158   		/* 如果 _SectorCount > 0, 并且是页面首地址，则可以进行优化 */
;;;1159   		if (usAddrInPage == 0)
;;;1160   		{
;;;1161   			/* 暂未处理 */
;;;1162   		}
;;;1163   		
;;;1164   		memset(s_ucTempBuf, 0xFF, _SectorSize);
000056  22ff              MOVS     r2,#0xff
000058  4621              MOV      r1,r4
00005a  4838              LDR      r0,|L38.316|
00005c  f7fffffe          BL       __aeabi_memset
000060  4b37              LDR      r3,|L38.320|
;;;1165   
;;;1166   		/*　如果是全0xFF, 则可以直接写入，无需擦除 */
;;;1167   		//if (NAND_IsBufOk(s_ucTempBuf, _SectorSize, 0xFF) == 1)
;;;1168   		if (FSMC_NAND_CompPage(s_ucTempBuf, uiPhyPageNo, usAddrInPage, _SectorSize) == NAND_OK)
000062  4e36              LDR      r6,|L38.316|
000064  f883a000          STRB     r10,[r3,#0]
000068  4a36              LDR      r2,|L38.324|
00006a  f882b000          STRB     r11,[r2,#0]
00006e  ea4f201b          LSR      r0,r11,#8
000072  7010              STRB     r0,[r2,#0]
000074  f8828000          STRB     r8,[r2,#0]
000078  ea4f2018          LSR      r0,r8,#8
00007c  7010              STRB     r0,[r2,#0]
00007e  2030              MOVS     r0,#0x30
000080  7018              STRB     r0,[r3,#0]
000082  2000              MOVS     r0,#0
                  |L38.132|
000084  1c40              ADDS     r0,r0,#1
000086  b280              UXTH     r0,r0
000088  2814              CMP      r0,#0x14
00008a  d3fb              BCC      |L38.132|
                  |L38.140|
00008c  2140              MOVS     r1,#0x40
00008e  482e              LDR      r0,|L38.328|
000090  f7fffffe          BL       GPIO_ReadInputDataBit
000094  2800              CMP      r0,#0
000096  d0f9              BEQ      |L38.140|
000098  2000              MOVS     r0,#0
00009a  f04f42e0          MOV      r2,#0x70000000
00009e  e014              B        |L38.202|
                  |L38.160|
0000a0  5c31              LDRB     r1,[r6,r0]
0000a2  7813              LDRB     r3,[r2,#0]
0000a4  4299              CMP      r1,r3
0000a6  d00e              BEQ      |L38.198|
;;;1169   		{
;;;1170   			if (FSMC_NAND_WriteData(&_pBuf[i * _SectorSize], uiPhyPageNo, usAddrInPage, _SectorSize) == NAND_FAIL)
;;;1171   			{
;;;1172   				printf_err("Error3: NAND_WriteMultiSectors(), Write Faile\r\n");
;;;1173   				/* 将数据写入到另外一个块（空闲块） */
;;;1174   				ucReturn = NAND_WriteToNewBlock(uiPhyPageNo, &_pBuf[i * _SectorSize], usAddrInPage, _SectorSize);
;;;1175   				if (ucReturn != NAND_OK)
;;;1176   				{
;;;1177   					printf_err("Error4: NAND_WriteMultiSectors(), Write Faile\r\n");
;;;1178   					return NAND_FAIL;	/* 失败 */
;;;1179   				}
;;;1180   				
;;;1181   				/* 标记源块为坏块 */
;;;1182   				NAND_MarkBadBlock(uiPhyPageNo / NAND_BLOCK_SIZE);	/* 将源块标记为坏块 */
;;;1183   				continue;
;;;1184   			}
;;;1185   
;;;1186   			/* 标记该块已用 */
;;;1187   			if (NAND_MarkUsedBlock(uiPhyPageNo / NAND_BLOCK_SIZE) == NAND_FAIL)
;;;1188   			{
;;;1189   				/* 标记失败，将数据写入到另外一个块（空闲块） */
;;;1190   				ucReturn = NAND_WriteToNewBlock(uiPhyPageNo, &_pBuf[i * _SectorSize], usAddrInPage, _SectorSize);
;;;1191   				if (ucReturn != NAND_OK)
;;;1192   				{
;;;1193   					return NAND_FAIL;	/* 失败 */
;;;1194   				}
;;;1195   				continue;
;;;1196   			}
;;;1197   		}
;;;1198   		else	/* 目标区域已经有数据，不是全FF, 则直接将数据写入另外一个空闲块 */
;;;1199   		{
;;;1200   			/* 将数据写入到另外一个块（空闲块） */
;;;1201   			ucReturn = NAND_WriteToNewBlock(uiPhyPageNo, &_pBuf[i * _SectorSize], usAddrInPage, _SectorSize);
0000a8  9800              LDR      r0,[sp,#0]
0000aa  4623              MOV      r3,r4
0000ac  fb050104          MLA      r1,r5,r4,r0
0000b0  465a              MOV      r2,r11
0000b2  4640              MOV      r0,r8
0000b4  f7fffffe          BL       NAND_WriteToNewBlock
;;;1202   			if (ucReturn != NAND_OK)
0000b8  2800              CMP      r0,#0
0000ba  d037              BEQ      |L38.300|
;;;1203   			{
;;;1204   				printf_err("Error5: NAND_WriteMultiSectors(), Write Faile\r\n");
0000bc  a023              ADR      r0,|L38.332|
0000be  bf00              NOP                            ;1177
                  |L38.192|
0000c0  f7fffffe          BL       __2printf
0000c4  e02e              B        |L38.292|
                  |L38.198|
0000c6  1c40              ADDS     r0,r0,#1              ;1177
0000c8  b280              UXTH     r0,r0                 ;1177
                  |L38.202|
0000ca  4621              MOV      r1,r4                 ;1177
0000cc  42a0              CMP      r0,r4                 ;1177
0000ce  d3e7              BCC      |L38.160|
0000d0  9800              LDR      r0,[sp,#0]            ;1170
0000d2  460b              MOV      r3,r1                 ;1170
0000d4  fb050004          MLA      r0,r5,r4,r0           ;1170
0000d8  4606              MOV      r6,r0                 ;1170
0000da  465a              MOV      r2,r11                ;1170
0000dc  4641              MOV      r1,r8                 ;1170
0000de  f7fffffe          BL       FSMC_NAND_WriteData
0000e2  2801              CMP      r0,#1                 ;1170
0000e4  d006              BEQ      |L38.244|
0000e6  ea4f1098          LSR      r0,r8,#6              ;1187
0000ea  f7fffffe          BL       NAND_MarkUsedBlock
0000ee  2801              CMP      r0,#1                 ;1187
0000f0  d011              BEQ      |L38.278|
0000f2  e01b              B        |L38.300|
                  |L38.244|
0000f4  a021              ADR      r0,|L38.380|
0000f6  f7fffffe          BL       __2printf
0000fa  4631              MOV      r1,r6                 ;1172
0000fc  4623              MOV      r3,r4                 ;1174
0000fe  465a              MOV      r2,r11                ;1174
000100  4640              MOV      r0,r8                 ;1174
000102  f7fffffe          BL       NAND_WriteToNewBlock
000106  b108              CBZ      r0,|L38.268|
000108  a028              ADR      r0,|L38.428|
00010a  e7d9              B        |L38.192|
                  |L38.268|
00010c  ea4f1098          LSR      r0,r8,#6              ;1182
000110  f7fffffe          BL       NAND_MarkBadBlock
000114  e00a              B        |L38.300|
                  |L38.278|
000116  4631              MOV      r1,r6                 ;1183
000118  4623              MOV      r3,r4                 ;1190
00011a  465a              MOV      r2,r11                ;1190
00011c  4640              MOV      r0,r8                 ;1190
00011e  f7fffffe          BL       NAND_WriteToNewBlock
000122  b118              CBZ      r0,|L38.300|
                  |L38.292|
000124  2001              MOVS     r0,#1                 ;1193
                  |L38.294|
;;;1205   				return NAND_FAIL;	/* 失败 */
;;;1206   			}
;;;1207   			continue;
;;;1208   		}
;;;1209   	}
;;;1210   	return NAND_OK;		/* 成功 */
;;;1211   }
000126  b004              ADD      sp,sp,#0x10
000128  e8bd9ff0          POP      {r4-r12,pc}
                  |L38.300|
00012c  1c6d              ADDS     r5,r5,#1
                  |L38.302|
00012e  42bd              CMP      r5,r7                 ;1139
000130  f4ffaf6f          BCC      |L38.18|
000134  2000              MOVS     r0,#0                 ;1210
000136  e7f6              B        |L38.294|
;;;1212   
                          ENDP

                  |L38.312|
                          DCD      ||.conststring||+0x8c
                  |L38.316|
                          DCD      ||.bss||+0x800
                  |L38.320|
                          DCD      0x70010000
                  |L38.324|
                          DCD      0x70020000
                  |L38.328|
                          DCD      0x40012000
                  |L38.332|
00014c  4572726f          DCB      "Error5: NAND_WriteMultiSectors(), Write Faile\r\n",0
000150  72353a20
000154  4e414e44
000158  5f577269
00015c  74654d75
000160  6c746953
000164  6563746f
000168  72732829
00016c  2c205772
000170  69746520
000174  4661696c
000178  650d0a00
                  |L38.380|
00017c  4572726f          DCB      "Error3: NAND_WriteMultiSectors(), Write Faile\r\n",0
000180  72333a20
000184  4e414e44
000188  5f577269
00018c  74654d75
000190  6c746953
000194  6563746f
000198  72732829
00019c  2c205772
0001a0  69746520
0001a4  4661696c
0001a8  650d0a00
                  |L38.428|
0001ac  4572726f          DCB      "Error4: NAND_WriteMultiSectors(), Write Faile\r\n",0
0001b0  72343a20
0001b4  4e414e44
0001b8  5f577269
0001bc  74654d75
0001c0  6c746953
0001c4  6563746f
0001c8  72732829
0001cc  2c205772
0001d0  69746520
0001d4  4661696c
0001d8  650d0a00

                          AREA ||i.NAND_WriteToNewBlock||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  NAND_WriteToNewBlock PROC
;;;912    */
;;;913    uint8_t NAND_WriteToNewBlock(uint32_t _ulPhyPageNo, uint8_t *_pWriteBuf, uint16_t _usOffset, uint16_t _usSize)
000000  e92d4fff          PUSH     {r0-r11,lr}
;;;914    {
000004  b081              SUB      sp,sp,#4
000006  469b              MOV      r11,r3
000008  4605              MOV      r5,r0
;;;915    	uint16_t n, i;
;;;916    	uint16_t usNewBlock;
;;;917    	uint16_t ulSrcBlock;
;;;918    	uint16_t usOffsetPageNo;
;;;919    
;;;920    	ulSrcBlock = _ulPhyPageNo / NAND_BLOCK_SIZE;		/* 根据物理页号反推块号 */
00000a  f3c0168f          UBFX     r6,r0,#6,#16
;;;921    	usOffsetPageNo = _ulPhyPageNo % NAND_BLOCK_SIZE;	/* 根据物理页号计算物理页号在块内偏移页号 */
00000e  f000083f          AND      r8,r0,#0x3f
;;;922    	/* 增加循环的目的是处理目标块为坏块的情况 */
;;;923    	for (n = 0; n < 10; n++)
000012  f04f0900          MOV      r9,#0
000016  f2403aff          MOV      r10,#0x3ff
                  |L39.26|
00001a  4654              MOV      r4,r10
00001c  0668              LSLS     r0,r5,#25
00001e  d401              BMI      |L39.36|
000020  f24034fe          MOV      r4,#0x3fe
                  |L39.36|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       NAND_IsFreeBlock
00002a  b120              CBZ      r0,|L39.54|
;;;924    	{
;;;925    		/* 如果不是全0xFF， 则需要寻找一个空闲可用块，并将页内的数据全部移到新块中，然后擦除这个块 */
;;;926    		usNewBlock = NAND_FindFreeBlock(_ulPhyPageNo);	/* 从最后一个Block开始，搜寻一个可用块.  */
00002c  4627              MOV      r7,r4
;;;927    		if (usNewBlock >= NAND_BLOCK_COUNT)
00002e  f5b46f80          CMP      r4,#0x400
000032  d204              BCS      |L39.62|
000034  e009              B        |L39.74|
                  |L39.54|
000036  2c02              CMP      r4,#2
000038  d204              BCS      |L39.68|
00003a  f64f74ff          MOV      r4,#0xffff
                  |L39.62|
;;;928    		{
;;;929    			printf_err("Error1: NAND_WriteToNewBlock() %d\r\n", usNewBlock);
00003e  4621              MOV      r1,r4
000040  a02e              ADR      r0,|L39.252|
;;;930    			return NAND_FAIL;	/* 查找空闲块失败 */
000042  e057              B        |L39.244|
                  |L39.68|
000044  1ea4              SUBS     r4,r4,#2
000046  b2a4              UXTH     r4,r4
000048  e7ec              B        |L39.36|
                  |L39.74|
;;;931    		}
;;;932    
;;;933    		printf_ok("NAND_WriteToNewBlock(%d -> %d)\r\n", ulSrcBlock, usNewBlock);
;;;934    		
;;;935    		/* 使用page-copy功能，将当前块（usPBN）的数据全部搬移到新块（usNewBlock） */
;;;936    		for (i = 0; i < NAND_BLOCK_SIZE; i++)
00004a  2400              MOVS     r4,#0
                  |L39.76|
;;;937    		{
;;;938    			if (i == usOffsetPageNo)
00004c  4544              CMP      r4,r8
00004e  d10e              BNE      |L39.110|
;;;939    			{
;;;940    				/* 如果写入的数据在当前页，则需要使用带随机数据的Copy-Back命令 */
;;;941    				if (FSMC_NAND_PageCopyBackEx(ulSrcBlock * NAND_BLOCK_SIZE + i, usNewBlock * NAND_BLOCK_SIZE + i,
000050  e9dd2302          LDRD     r2,r3,[sp,#8]
000054  eb041187          ADD      r1,r4,r7,LSL #6
000058  eb041086          ADD      r0,r4,r6,LSL #6
00005c  f8cdb000          STR      r11,[sp,#0]
000060  f7fffffe          BL       FSMC_NAND_PageCopyBackEx
000064  2801              CMP      r0,#1
000066  d10a              BNE      |L39.126|
;;;942    					_pWriteBuf, _usOffset, _usSize) == NAND_FAIL)
;;;943    				{
;;;944    					printf_err("Error2: NAND_WriteToNewBlock() %d\r\n", ulSrcBlock);
000068  4631              MOV      r1,r6
00006a  a02d              ADR      r0,|L39.288|
;;;945    					NAND_MarkBadBlock(usNewBlock);	/* 将新块标记为坏块 */
;;;946    					NAND_BuildLUT();				/* 重建LUT表 */
;;;947    					break;
00006c  e010              B        |L39.144|
                  |L39.110|
;;;948    				}
;;;949    
;;;950    			}
;;;951    			else
;;;952    			{
;;;953    				/* 使用NAND Flash 提供的整页Copy-Back功能，可以显著提高操作效率 */
;;;954    				if (FSMC_NAND_PageCopyBack(ulSrcBlock * NAND_BLOCK_SIZE + i,
00006e  eb041187          ADD      r1,r4,r7,LSL #6
000072  eb041086          ADD      r0,r4,r6,LSL #6
000076  f7fffffe          BL       FSMC_NAND_PageCopyBack
00007a  2801              CMP      r0,#1
00007c  d006              BEQ      |L39.140|
                  |L39.126|
00007e  1c64              ADDS     r4,r4,#1
000080  b2a4              UXTH     r4,r4                 ;936
000082  2c40              CMP      r4,#0x40              ;936
000084  d3e2              BCC      |L39.76|
                  |L39.134|
;;;955    					usNewBlock * NAND_BLOCK_SIZE + i) == NAND_FAIL)
;;;956    				{
;;;957    					printf_err("Error3: NAND_WriteToNewBlock() %d\r\n", ulSrcBlock);
;;;958    					
;;;959    					NAND_MarkBadBlock(usNewBlock);	/* 将新块标记为坏块 */
;;;960    					NAND_BuildLUT();				/* 重建LUT表 */
;;;961    					break;
;;;962    				}
;;;963    			}
;;;964    		}
;;;965    		/* 目标块更新成功 */
;;;966    		if (i == NAND_BLOCK_SIZE)
000086  2c40              CMP      r4,#0x40
000088  d00a              BEQ      |L39.160|
00008a  e01d              B        |L39.200|
                  |L39.140|
00008c  4631              MOV      r1,r6                 ;957
00008e  a02d              ADR      r0,|L39.324|
                  |L39.144|
000090  f7fffffe          BL       __2printf
000094  4638              MOV      r0,r7                 ;945
000096  f7fffffe          BL       NAND_MarkBadBlock
00009a  f7fffffe          BL       NAND_BuildLUT
00009e  e7f2              B        |L39.134|
                  |L39.160|
;;;967    		{
;;;968    			/* 标记新块为已用块 */
;;;969    			if (NAND_MarkUsedBlock(usNewBlock) == NAND_FAIL)
0000a0  4638              MOV      r0,r7
0000a2  f7fffffe          BL       NAND_MarkUsedBlock
0000a6  2801              CMP      r0,#1
0000a8  d01d              BEQ      |L39.230|
;;;970    			{
;;;971    				NAND_MarkBadBlock(usNewBlock);	/* 将新块标记为坏块 */
;;;972    				NAND_BuildLUT();				/* 重建LUT表 */
;;;973    				continue;
;;;974    			}
;;;975    
;;;976    			/* 擦除源BLOCK  (如果源块写失败，则会擦除坏块标记) */
;;;977    			if (FSMC_NAND_EraseBlock(ulSrcBlock) != NAND_READY)
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       FSMC_NAND_EraseBlock
0000b0  2840              CMP      r0,#0x40
0000b2  d01a              BEQ      |L39.234|
;;;978    			{
;;;979    				printf_err("Error4: FSMC_NAND_EraseBlock(), %d\r\n", ulSrcBlock);
0000b4  4631              MOV      r1,r6
0000b6  a02c              ADR      r0,|L39.360|
0000b8  f7fffffe          BL       __2printf
;;;980    				NAND_MarkBadBlock(ulSrcBlock);	/* 将源块标记为坏块 */
0000bc  ea4f0006          MOV.W    r0,r6
                  |L39.192|
0000c0  f7fffffe          BL       NAND_MarkBadBlock
;;;981    				NAND_BuildLUT();				/* 重建LUT表 */
0000c4  f7fffffe          BL       NAND_BuildLUT
                  |L39.200|
0000c8  f1090001          ADD      r0,r9,#1              ;923
0000cc  fa1ff980          UXTH     r9,r0                 ;923
0000d0  f1b90f0a          CMP      r9,#0xa               ;923
0000d4  d3a1              BCC      |L39.26|
                  |L39.214|
;;;982    				continue;
;;;983    			}
;;;984    			NAND_BuildLUT();				/* 重建LUT表 */
;;;985    			break;
;;;986    		}
;;;987    	}
;;;988    	if (n == 10)
0000d6  4648              MOV      r0,r9
0000d8  f1b90f0a          CMP      r9,#0xa
0000dc  d008              BEQ      |L39.240|
;;;989    	{
;;;990    		printf_err("Error5: FSMC_NAND_EraseBlock() n=%d\r\n", n);
;;;991    		return NAND_FAIL;
;;;992    	}
;;;993    
;;;994    	return NAND_OK;	/* 写入成功 */
0000de  2000              MOVS     r0,#0
                  |L39.224|
;;;995    }
0000e0  b005              ADD      sp,sp,#0x14
0000e2  e8bd8ff0          POP      {r4-r11,pc}
                  |L39.230|
0000e6  4638              MOV      r0,r7                 ;971
0000e8  e7ea              B        |L39.192|
                  |L39.234|
0000ea  f7fffffe          BL       NAND_BuildLUT
0000ee  e7f2              B        |L39.214|
                  |L39.240|
0000f0  4601              MOV      r1,r0                 ;990
0000f2  a027              ADR      r0,|L39.400|
                  |L39.244|
0000f4  f7fffffe          BL       __2printf
0000f8  2001              MOVS     r0,#1                 ;991
0000fa  e7f1              B        |L39.224|
;;;996    
                          ENDP

                  |L39.252|
0000fc  4572726f          DCB      "Error1: NAND_WriteToNewBlock() %d\r\n",0
000100  72313a20
000104  4e414e44
000108  5f577269
00010c  7465546f
000110  4e657742
000114  6c6f636b
000118  28292025
00011c  640d0a00
                  |L39.288|
000120  4572726f          DCB      "Error2: NAND_WriteToNewBlock() %d\r\n",0
000124  72323a20
000128  4e414e44
00012c  5f577269
000130  7465546f
000134  4e657742
000138  6c6f636b
00013c  28292025
000140  640d0a00
                  |L39.324|
000144  4572726f          DCB      "Error3: NAND_WriteToNewBlock() %d\r\n",0
000148  72333a20
00014c  4e414e44
000150  5f577269
000154  7465546f
000158  4e657742
00015c  6c6f636b
000160  28292025
000164  640d0a00
                  |L39.360|
000168  4572726f          DCB      "Error4: FSMC_NAND_EraseBlock(), %d\r\n",0
00016c  72343a20
000170  46534d43
000174  5f4e414e
000178  445f4572
00017c  61736542
000180  6c6f636b
000184  28292c20
000188  25640d0a
00018c  00      
00018d  00                DCB      0
00018e  00                DCB      0
00018f  00                DCB      0
                  |L39.400|
000190  4572726f          DCB      "Error5: FSMC_NAND_EraseBlock() n=%d\r\n",0
000194  72353a20
000198  46534d43
00019c  5f4e414e
0001a0  445f4572
0001a4  61736542
0001a8  6c6f636b
0001ac  2829206e
0001b0  3d25640d
0001b4  0a00    
0001b6  00                DCB      0
0001b7  00                DCB      0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_usLUT
                          %        2048
                  s_ucTempBuf
                          %        2112

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  4572726f          DCB      "Error A18 not same:  FSMC_NAND_PageCopyBackEx(src=%d, t"
000004  72204131
000008  38206e6f
00000c  74207361
000010  6d653a20
000014  2046534d
000018  435f4e41
00001c  4e445f50
000020  61676543
000024  6f707942
000028  61636b45
00002c  78287372
000030  633d2564
000034  2c2074  
000037  61723d25          DCB      "ar=%d) \r\n",0
00003b  6429200d
00003f  0a00    
000041  00                DCB      0
000042  00                DCB      0
000043  00                DCB      0
000044  4572726f          DCB      "Error: FSMC_NAND_PageCopyBackEx(src=%d, tar=%d, offset="
000048  723a2046
00004c  534d435f
000050  4e414e44
000054  5f506167
000058  65436f70
00005c  79426163
000060  6b457828
000064  7372633d
000068  25642c20
00006c  7461723d
000070  25642c20
000074  6f666673
000078  65743d  
00007b  25642c20          DCB      "%d, size=%d)\r\n",0
00007f  73697a65
000083  3d256429
000087  0d0a00  
00008a  00                DCB      0
00008b  00                DCB      0
00008c  4572726f          DCB      "Error1: NAND_WriteMultiSectors(), no format. usLBN=%d, "
000090  72313a20
000094  4e414e44
000098  5f577269
00009c  74654d75
0000a0  6c746953
0000a4  6563746f
0000a8  72732829
0000ac  2c206e6f
0000b0  20666f72
0000b4  6d61742e
0000b8  2075734c
0000bc  424e3d25
0000c0  642c20  
0000c3  75735042          DCB      "usPBN=%d\r\n",0
0000c7  4e3d2564
0000cb  0d0a00  
0000ce  00                DCB      0
0000cf  00                DCB      0
0000d0  4572726f          DCB      "Error: NAND_ReadMultiSectors(), ReadData(page = %d, add"
0000d4  723a204e
0000d8  414e445f
0000dc  52656164
0000e0  4d756c74
0000e4  69536563
0000e8  746f7273
0000ec  28292c20
0000f0  52656164
0000f4  44617461
0000f8  28706167
0000fc  65203d20
000100  25642c20
000104  616464  
000107  72203d20          DCB      "r = %d)\r\n",0
00010b  2564290d
00010f  0a00    
000111  00                DCB      0
000112  00                DCB      0
000113  00                DCB      0
000114  48593237          DCB      "HY27UF081G2A\r\n  1024 Blocks, 64 pages per block, 2048"
000118  55463038
00011c  31473241
000120  0d0a2020
000124  31303234
000128  20426c6f
00012c  636b732c
000130  20363420
000134  70616765
000138  73207065
00013c  7220626c
000140  6f636b2c
000144  20323034
000148  38      
000149  202b2036          DCB      " + 64 bytes per page\r\n",0
00014d  34206279
000151  74657320
000155  70657220
000159  70616765
00015d  0d0a00  
000160  4b394631          DCB      "K9F1G08U0A\r\n  1024 Blocks, 64 pages per block, 2048 +"
000164  47303855
000168  30410d0a
00016c  20203130
000170  32342042
000174  6c6f636b
000178  732c2036
00017c  34207061
000180  67657320
000184  70657220
000188  626c6f63
00018c  6b2c2032
000190  30343820
000194  2b      
000195  20363420          DCB      " 64 bytes per page\r\n",0
000199  62797465
00019d  73207065
0001a1  72207061
0001a5  67650d0a
0001a9  00      
0001aa  00                DCB      0
0001ab  00                DCB      0
0001ac  4b394631          DCB      "K9F1G08U0B\r\n  1024 Blocks, 64 pages per block, 2048 +"
0001b0  47303855
0001b4  30420d0a
0001b8  20203130
0001bc  32342042
0001c0  6c6f636b
0001c4  732c2036
0001c8  34207061
0001cc  67657320
0001d0  70657220
0001d4  626c6f63
0001d8  6b2c2032
0001dc  30343820
0001e0  2b      
0001e1  20363420          DCB      " 64 bytes per page\r\n",0
0001e5  62797465
0001e9  73207065
0001ed  72207061
0001f1  67650d0a
0001f5  00      
0001f6  00                DCB      0
0001f7  00                DCB      0
0001f8  48323755          DCB      "H27U4G8F2DTR\r\n  4096 Blocks, 64 pages per block, 2048"
0001fc  34473846
000200  32445452
000204  0d0a2020
000208  34303936
00020c  20426c6f
000210  636b732c
000214  20363420
000218  70616765
00021c  73207065
000220  7220626c
000224  6f636b2c
000228  20323034
00022c  38      
00022d  202b2036          DCB      " + 64 bytes per page\r\n",0
000231  34206279
000235  74657320
000239  70657220
00023d  70616765
000241  0d0a00  
000244  48323755          DCB      "H27U1G8F2BTR\r\n  1024 Blocks, 64 pages per block, 2048"
000248  31473846
00024c  32425452
000250  0d0a2020
000254  31303234
000258  20426c6f
00025c  636b732c
000260  20363420
000264  70616765
000268  73207065
00026c  7220626c
000270  6f636b2c
000274  20323034
000278  38      
000279  202b2036          DCB      " + 64 bytes per page\r\n",0
00027d  34206279
000281  74657320
000285  70657220
000289  70616765
00028d  0d0a00  

                          AREA ||.data||, DATA, ALIGN=1

                  s_usValidDataBlockCount
000000  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_nand_flash.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_nand_flash_c_7c01b1d9____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___16_bsp_nand_flash_c_7c01b1d9____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_bsp_nand_flash_c_7c01b1d9____REVSH|
#line 128
|__asm___16_bsp_nand_flash_c_7c01b1d9____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
