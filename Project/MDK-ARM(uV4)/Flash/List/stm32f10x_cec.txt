; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_cec.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_cec.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\stm32f10x_cec.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_cec.c]
                          THUMB

                          AREA ||i.CEC_ClearFlag||, CODE, READONLY, ALIGN=2

                  CEC_ClearFlag PROC
;;;354      */
;;;355    void CEC_ClearFlag(uint32_t CEC_FLAG)
000000  4906              LDR      r1,|L1.28|
;;;356    { 
000002  b510              PUSH     {r4,lr}
;;;357      uint32_t tmp = 0x0;
;;;358      
;;;359      /* Check the parameters */
;;;360      assert_param(IS_CEC_CLEAR_FLAG(CEC_FLAG));
;;;361    
;;;362      tmp = CEC->CSR & 0x2;
000004  680a              LDR      r2,[r1,#0]
;;;363           
;;;364      /* Clear the selected CEC flags */
;;;365      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_FLAG) & 0xFFFFFFFC) | tmp);
000006  680c              LDR      r4,[r1,#0]
000008  f0020302          AND      r3,r2,#2              ;362
00000c  f06f0203          MVN      r2,#3
000010  4382              BICS     r2,r2,r0
000012  431a              ORRS     r2,r2,r3
000014  4014              ANDS     r4,r4,r2
000016  600c              STR      r4,[r1,#0]
;;;366    }
000018  bd10              POP      {r4,pc}
;;;367    
                          ENDP

00001a  0000              DCW      0x0000
                  |L1.28|
                          DCD      0x40007810

                          AREA ||i.CEC_ClearITPendingBit||, CODE, READONLY, ALIGN=2

                  CEC_ClearITPendingBit PROC
;;;413      */
;;;414    void CEC_ClearITPendingBit(uint16_t CEC_IT)
000000  4906              LDR      r1,|L2.28|
;;;415    {
000002  b510              PUSH     {r4,lr}
;;;416      uint32_t tmp = 0x0;
;;;417      
;;;418      /* Check the parameters */
;;;419      assert_param(IS_CEC_GET_IT(CEC_IT));
;;;420      
;;;421      tmp = CEC->CSR & 0x2;
000004  680a              LDR      r2,[r1,#0]
;;;422      
;;;423      /* Clear the selected CEC interrupt pending bits */
;;;424      CEC->CSR &= (uint32_t)(((~(uint32_t)CEC_IT) & 0xFFFFFFFC) | tmp);
000006  680c              LDR      r4,[r1,#0]
000008  f0020302          AND      r3,r2,#2              ;421
00000c  f06f0203          MVN      r2,#3
000010  4382              BICS     r2,r2,r0
000012  431a              ORRS     r2,r2,r3
000014  4014              ANDS     r4,r4,r2
000016  600c              STR      r4,[r1,#0]
;;;425    }
000018  bd10              POP      {r4,pc}
;;;426    
                          ENDP

00001a  0000              DCW      0x0000
                  |L2.28|
                          DCD      0x40007810

                          AREA ||i.CEC_Cmd||, CODE, READONLY, ALIGN=2

                  CEC_Cmd PROC
;;;169      */
;;;170    void CEC_Cmd(FunctionalState NewState)
000000  4904              LDR      r1,|L3.20|
;;;171    {
;;;172      /* Check the parameters */
;;;173      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;174    
;;;175      *(__IO uint32_t *) CFGR_PE_BB = (uint32_t)NewState;
000002  6008              STR      r0,[r1,#0]
000004  2800              CMP      r0,#0                 ;171
000006  d103              BNE      |L3.16|
;;;176    
;;;177      if(NewState == DISABLE)
;;;178      {
;;;179        /* Wait until the PE bit is cleared by hardware (Idle Line detected) */
;;;180        while((CEC->CFGR & CEC_CFGR_PE) != (uint32_t)RESET)
000008  4803              LDR      r0,|L3.24|
                  |L3.10|
00000a  6801              LDR      r1,[r0,#0]
00000c  07c9              LSLS     r1,r1,#31
00000e  d1fc              BNE      |L3.10|
                  |L3.16|
;;;181        {
;;;182        }  
;;;183      }  
;;;184    }
000010  4770              BX       lr
;;;185    
                          ENDP

000012  0000              DCW      0x0000
                  |L3.20|
                          DCD      0x420f0000
                  |L3.24|
                          DCD      0x40007800

                          AREA ||i.CEC_DeInit||, CODE, READONLY, ALIGN=1

                  CEC_DeInit PROC
;;;123      */
;;;124    void CEC_DeInit(void)
000000  b510              PUSH     {r4,lr}
;;;125    {
;;;126      /* Enable CEC reset state */
;;;127      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, ENABLE);  
000002  2101              MOVS     r1,#1
000004  078c              LSLS     r4,r1,#30
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB1PeriphResetCmd
;;;128      /* Release CEC from reset state */
;;;129      RCC_APB1PeriphResetCmd(RCC_APB1Periph_CEC, DISABLE); 
00000c  4620              MOV      r0,r4
00000e  e8bd4010          POP      {r4,lr}
000012  2100              MOVS     r1,#0
000014  f7ffbffe          B.W      RCC_APB1PeriphResetCmd
;;;130    }
;;;131    
                          ENDP


                          AREA ||i.CEC_EndOfMessageCmd||, CODE, READONLY, ALIGN=2

                  CEC_EndOfMessageCmd PROC
;;;267      */
;;;268    void CEC_EndOfMessageCmd(FunctionalState NewState)
000000  4901              LDR      r1,|L5.8|
;;;269    {   
;;;270      /* Check the parameters */
;;;271      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;272      
;;;273      /* The data byte will be transmitted with or without an EOM bit*/
;;;274      *(__IO uint32_t *) CSR_TEOM_BB = (uint32_t)NewState;
000002  f8c10204          STR      r0,[r1,#0x204]
;;;275    }
000006  4770              BX       lr
;;;276    
                          ENDP

                  |L5.8|
                          DCD      0x420f0000

                          AREA ||i.CEC_GetFlagStatus||, CODE, READONLY, ALIGN=2

                  CEC_GetFlagStatus PROC
;;;296      */
;;;297    FlagStatus CEC_GetFlagStatus(uint32_t CEC_FLAG) 
000000  4601              MOV      r1,r0
;;;298    {
;;;299      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;300      uint32_t cecreg = 0, cecbase = 0;
;;;301      
;;;302      /* Check the parameters */
;;;303      assert_param(IS_CEC_GET_FLAG(CEC_FLAG));
;;;304     
;;;305      /* Get the CEC peripheral base address */
;;;306      cecbase = (uint32_t)(CEC_BASE);
;;;307      
;;;308      /* Read flag register index */
;;;309      cecreg = CEC_FLAG >> 28;
000004  0f0a              LSRS     r2,r1,#28
;;;310      
;;;311      /* Get bit[23:0] of the flag */
;;;312      CEC_FLAG &= FLAG_Mask;
000006  f021417f          BIC      r1,r1,#0xff000000
00000a  d002              BEQ      |L6.18|
;;;313      
;;;314      if(cecreg != 0)
;;;315      {
;;;316        /* Flag in CEC ESR Register */
;;;317        CEC_FLAG = (uint32_t)(CEC_FLAG >> 16);
00000c  0c09              LSRS     r1,r1,#16
;;;318        
;;;319        /* Get the CEC ESR register address */
;;;320        cecbase += 0xC;
00000e  4a04              LDR      r2,|L6.32|
000010  e001              B        |L6.22|
                  |L6.18|
;;;321      }
;;;322      else
;;;323      {
;;;324        /* Get the CEC CSR register address */
;;;325        cecbase += 0x10;
000012  4a03              LDR      r2,|L6.32|
000014  1d12              ADDS     r2,r2,#4
                  |L6.22|
;;;326      }
;;;327      
;;;328      if(((*(__IO uint32_t *)cecbase) & CEC_FLAG) != (uint32_t)RESET)
000016  6812              LDR      r2,[r2,#0]
000018  420a              TST      r2,r1
00001a  d000              BEQ      |L6.30|
;;;329      {
;;;330        /* CEC_FLAG is set */
;;;331        bitstatus = SET;
00001c  2001              MOVS     r0,#1
                  |L6.30|
;;;332      }
;;;333      else
;;;334      {
;;;335        /* CEC_FLAG is reset */
;;;336        bitstatus = RESET;
;;;337      }
;;;338      
;;;339      /* Return the CEC_FLAG status */
;;;340      return  bitstatus;
;;;341    }
00001e  4770              BX       lr
;;;342    
                          ENDP

                  |L6.32|
                          DCD      0x4000780c

                          AREA ||i.CEC_GetITStatus||, CODE, READONLY, ALIGN=2

                  CEC_GetITStatus PROC
;;;377      */
;;;378    ITStatus CEC_GetITStatus(uint8_t CEC_IT)
000000  4907              LDR      r1,|L7.32|
;;;379    {
000002  4602              MOV      r2,r0
;;;380      ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;381      uint32_t enablestatus = 0;
;;;382      
;;;383      /* Check the parameters */
;;;384       assert_param(IS_CEC_GET_IT(CEC_IT));
;;;385       
;;;386      /* Get the CEC IT enable bit status */
;;;387      enablestatus = (CEC->CFGR & (uint8_t)CEC_CFGR_IE) ;
000006  6809              LDR      r1,[r1,#0]
;;;388      
;;;389      /* Check the status of the specified CEC interrupt */
;;;390      if (((CEC->CSR & CEC_IT) != (uint32_t)RESET) && enablestatus)
000008  4b05              LDR      r3,|L7.32|
00000a  f0010102          AND      r1,r1,#2              ;387
00000e  3310              ADDS     r3,r3,#0x10
000010  681b              LDR      r3,[r3,#0]
000012  4213              TST      r3,r2
000014  d002              BEQ      |L7.28|
000016  2900              CMP      r1,#0
000018  d000              BEQ      |L7.28|
;;;391      {
;;;392        /* CEC_IT is set */
;;;393        bitstatus = SET;
00001a  2001              MOVS     r0,#1
                  |L7.28|
;;;394      }
;;;395      else
;;;396      {
;;;397        /* CEC_IT is reset */
;;;398        bitstatus = RESET;
;;;399      }
;;;400      /* Return the CEC_IT status */
;;;401      return  bitstatus;
;;;402    }
00001c  4770              BX       lr
;;;403    
                          ENDP

00001e  0000              DCW      0x0000
                  |L7.32|
                          DCD      0x40007800

                          AREA ||i.CEC_ITConfig||, CODE, READONLY, ALIGN=2

                  CEC_ITConfig PROC
;;;191      */
;;;192    void CEC_ITConfig(FunctionalState NewState)
000000  4901              LDR      r1,|L8.8|
;;;193    {
;;;194      /* Check the parameters */
;;;195      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;196    
;;;197      *(__IO uint32_t *) CFGR_IE_BB = (uint32_t)NewState;
000002  6048              STR      r0,[r1,#4]
;;;198    }
000004  4770              BX       lr
;;;199    
                          ENDP

000006  0000              DCW      0x0000
                  |L8.8|
                          DCD      0x420f0000

                          AREA ||i.CEC_Init||, CODE, READONLY, ALIGN=2

                  CEC_Init PROC
;;;140      */
;;;141    void CEC_Init(CEC_InitTypeDef* CEC_InitStruct)
000000  4a04              LDR      r2,|L9.20|
;;;142    {
;;;143      uint16_t tmpreg = 0;
;;;144     
;;;145      /* Check the parameters */
;;;146      assert_param(IS_CEC_BIT_TIMING_ERROR_MODE(CEC_InitStruct->CEC_BitTimingMode)); 
;;;147      assert_param(IS_CEC_BIT_PERIOD_ERROR_MODE(CEC_InitStruct->CEC_BitPeriodMode));
;;;148         
;;;149      /*---------------------------- CEC CFGR Configuration -----------------*/
;;;150      /* Get the CEC CFGR value */
;;;151      tmpreg = CEC->CFGR;
000002  6811              LDR      r1,[r2,#0]
;;;152      
;;;153      /* Clear BTEM and BPEM bits */
;;;154      tmpreg &= CFGR_CLEAR_Mask;
000004  f00103f3          AND      r3,r1,#0xf3
;;;155      
;;;156      /* Configure CEC: Bit Timing Error and Bit Period Error */
;;;157      tmpreg |= (uint16_t)(CEC_InitStruct->CEC_BitTimingMode | CEC_InitStruct->CEC_BitPeriodMode);
000008  8801              LDRH     r1,[r0,#0]
00000a  8840              LDRH     r0,[r0,#2]
00000c  4301              ORRS     r1,r1,r0
00000e  4319              ORRS     r1,r1,r3
;;;158    
;;;159      /* Write to CEC CFGR  register*/
;;;160      CEC->CFGR = tmpreg;
000010  6011              STR      r1,[r2,#0]
;;;161      
;;;162    }
000012  4770              BX       lr
;;;163    
                          ENDP

                  |L9.20|
                          DCD      0x40007800

                          AREA ||i.CEC_OwnAddressConfig||, CODE, READONLY, ALIGN=2

                  CEC_OwnAddressConfig PROC
;;;204      */
;;;205    void CEC_OwnAddressConfig(uint8_t CEC_OwnAddress)
000000  4901              LDR      r1,|L10.8|
;;;206    {
;;;207      /* Check the parameters */
;;;208      assert_param(IS_CEC_ADDRESS(CEC_OwnAddress));
;;;209    
;;;210      /* Set the CEC own address */
;;;211      CEC->OAR = CEC_OwnAddress;
000002  6008              STR      r0,[r1,#0]
;;;212    }
000004  4770              BX       lr
;;;213    
                          ENDP

000006  0000              DCW      0x0000
                  |L10.8|
                          DCD      0x40007804

                          AREA ||i.CEC_ReceiveDataByte||, CODE, READONLY, ALIGN=2

                  CEC_ReceiveDataByte PROC
;;;244      */
;;;245    uint8_t CEC_ReceiveDataByte(void)
000000  4801              LDR      r0,|L11.8|
;;;246    {
;;;247      /* Receive Data */
;;;248      return (uint8_t)(CEC->RXD);
000002  6800              LDR      r0,[r0,#0]
000004  b2c0              UXTB     r0,r0
;;;249    }
000006  4770              BX       lr
;;;250    
                          ENDP

                  |L11.8|
                          DCD      0x40007818

                          AREA ||i.CEC_SendDataByte||, CODE, READONLY, ALIGN=2

                  CEC_SendDataByte PROC
;;;232      */
;;;233    void CEC_SendDataByte(uint8_t Data)
000000  4901              LDR      r1,|L12.8|
;;;234    {  
;;;235      /* Transmit Data */
;;;236      CEC->TXD = Data ;
000002  6008              STR      r0,[r1,#0]
;;;237    }
000004  4770              BX       lr
;;;238    
                          ENDP

000006  0000              DCW      0x0000
                  |L12.8|
                          DCD      0x40007814

                          AREA ||i.CEC_SetPrescaler||, CODE, READONLY, ALIGN=2

                  CEC_SetPrescaler PROC
;;;218      */
;;;219    void CEC_SetPrescaler(uint16_t CEC_Prescaler)
000000  4901              LDR      r1,|L13.8|
;;;220    {
;;;221      /* Check the parameters */
;;;222      assert_param(IS_CEC_PRESCALER(CEC_Prescaler));
;;;223    
;;;224      /* Set the  Prescaler value*/
;;;225      CEC->PRES = CEC_Prescaler;
000002  6008              STR      r0,[r1,#0]
;;;226    }
000004  4770              BX       lr
;;;227    
                          ENDP

000006  0000              DCW      0x0000
                  |L13.8|
                          DCD      0x40007808

                          AREA ||i.CEC_StartOfMessage||, CODE, READONLY, ALIGN=2

                  CEC_StartOfMessage PROC
;;;255      */
;;;256    void CEC_StartOfMessage(void)
000000  4902              LDR      r1,|L14.12|
;;;257    {  
;;;258      /* Starts of new message */
;;;259      *(__IO uint32_t *) CSR_TSOM_BB = (uint32_t)0x1;
000002  2001              MOVS     r0,#1
000004  f8c10200          STR      r0,[r1,#0x200]
;;;260    }
000008  4770              BX       lr
;;;261    
                          ENDP

00000a  0000              DCW      0x0000
                  |L14.12|
                          DCD      0x420f0000

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_cec.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_cec_c_f294eadc____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_cec_c_f294eadc____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_cec_c_f294eadc____REVSH|
#line 128
|__asm___15_stm32f10x_cec_c_f294eadc____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
