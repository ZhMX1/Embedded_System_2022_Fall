; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_ds18b20.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_ds18b20.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_ds18b20.crf ..\..\User\bsp\src\bsp_ds18b20.c]
                          THUMB

                          AREA ||i.DS18B20_ReadByte||, CODE, READONLY, ALIGN=2

                  DS18B20_ReadByte PROC
;;;183    */
;;;184    static uint8_t DS18B20_ReadByte(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;185    {
;;;186    	/*
;;;187    		写数据时序, 见DS18B20 page 16
;;;188    	*/
;;;189    	uint8_t i;
;;;190    	uint8_t read = 0;
000004  2400              MOVS     r4,#0
;;;191    
;;;192    	for (i = 0; i < 8; i++)
;;;193    	{
;;;194    		read >>= 1;
;;;195    
;;;196    		DQ_0();
000006  4e0e              LDR      r6,|L1.64|
000008  4625              MOV      r5,r4                 ;192
00000a  f44f7780          MOV      r7,#0x100
                  |L1.14|
00000e  0864              LSRS     r4,r4,#1              ;194
000010  6177              STR      r7,[r6,#0x14]
;;;197    		bsp_DelayUS(3);
000012  2003              MOVS     r0,#3
000014  f7fffffe          BL       bsp_DelayUS
;;;198    		DQ_1();
000018  6137              STR      r7,[r6,#0x10]
;;;199    		bsp_DelayUS(3);
00001a  2003              MOVS     r0,#3
00001c  f7fffffe          BL       bsp_DelayUS
;;;200    
;;;201    		if (DQ_IS_LOW())
000020  68b0              LDR      r0,[r6,#8]
000022  05c0              LSLS     r0,r0,#23
000024  d501              BPL      |L1.42|
;;;202    		{
;;;203    			;
;;;204    		}
;;;205    		else
;;;206    		{
;;;207    			read |= 0x80;
000026  f0440480          ORR      r4,r4,#0x80
                  |L1.42|
;;;208    		}
;;;209    		bsp_DelayUS(60);
00002a  203c              MOVS     r0,#0x3c
00002c  f7fffffe          BL       bsp_DelayUS
000030  1c6d              ADDS     r5,r5,#1
000032  b2ed              UXTB     r5,r5                 ;192
000034  2d08              CMP      r5,#8                 ;192
000036  d3ea              BCC      |L1.14|
;;;210    	}
;;;211    
;;;212    	return read;
000038  4620              MOV      r0,r4
;;;213    }
00003a  e8bd81f0          POP      {r4-r8,pc}
;;;214    
                          ENDP

00003e  0000              DCW      0x0000
                  |L1.64|
                          DCD      0x40012000

                          AREA ||i.DS18B20_ReadID||, CODE, READONLY, ALIGN=1

                  DS18B20_ReadID PROC
;;;254    */
;;;255    uint8_t DS18B20_ReadID(uint8_t *_id)
000000  b570              PUSH     {r4-r6,lr}
;;;256    {
000002  4605              MOV      r5,r0
;;;257    	uint8_t i;
;;;258    
;;;259    	/* 总线复位 */
;;;260    	if (DS18B20_Reset() == 0)
000004  f7fffffe          BL       DS18B20_Reset
000008  2800              CMP      r0,#0
00000a  d00d              BEQ      |L2.40|
;;;261    	{
;;;262    		return 0;
;;;263    	}
;;;264    
;;;265    	DS18B20_WriteByte(0x33);	/* 发命令 */
00000c  2033              MOVS     r0,#0x33
00000e  f7fffffe          BL       DS18B20_WriteByte
;;;266    	for (i = 0; i < 8; i++)
000012  2400              MOVS     r4,#0
                  |L2.20|
;;;267    	{
;;;268    		_id[i] = DS18B20_ReadByte();
000014  f7fffffe          BL       DS18B20_ReadByte
000018  5528              STRB     r0,[r5,r4]
00001a  1c64              ADDS     r4,r4,#1
00001c  b2e4              UXTB     r4,r4                 ;266
00001e  2c08              CMP      r4,#8                 ;266
000020  d3f8              BCC      |L2.20|
;;;269    	}
;;;270    
;;;271    	DS18B20_Reset();		/* 总线复位 */
000022  f7fffffe          BL       DS18B20_Reset
;;;272    	
;;;273    	return 1;
000026  2001              MOVS     r0,#1
                  |L2.40|
;;;274    }
000028  bd70              POP      {r4-r6,pc}
;;;275    
                          ENDP


                          AREA ||i.DS18B20_ReadTempByID||, CODE, READONLY, ALIGN=1

                  DS18B20_ReadTempByID PROC
;;;283    */
;;;284    int16_t DS18B20_ReadTempByID(uint8_t *_id)
000000  b570              PUSH     {r4-r6,lr}
;;;285    {
000002  4605              MOV      r5,r0
;;;286    	uint8_t temp1, temp2;
;;;287    	uint8_t i;
;;;288    
;;;289    	DS18B20_Reset();		/* 总线复位 */
000004  f7fffffe          BL       DS18B20_Reset
;;;290    
;;;291    	DS18B20_WriteByte(0x55);	/* 发命令 */
000008  2055              MOVS     r0,#0x55
00000a  f7fffffe          BL       DS18B20_WriteByte
;;;292    	for (i = 0; i < 8; i++)
00000e  2400              MOVS     r4,#0
                  |L3.16|
;;;293    	{
;;;294    		DS18B20_WriteByte(_id[i]);
000010  5d28              LDRB     r0,[r5,r4]
000012  f7fffffe          BL       DS18B20_WriteByte
000016  1c64              ADDS     r4,r4,#1
000018  b2e4              UXTB     r4,r4                 ;292
00001a  2c08              CMP      r4,#8                 ;292
00001c  d3f8              BCC      |L3.16|
;;;295    	}
;;;296    	DS18B20_WriteByte(0x44);	/* 发转换命令 */
00001e  2044              MOVS     r0,#0x44
000020  f7fffffe          BL       DS18B20_WriteByte
;;;297    
;;;298    	DS18B20_Reset();		/* 总线复位 */
000024  f7fffffe          BL       DS18B20_Reset
;;;299    
;;;300    	DS18B20_WriteByte(0x55);	/* 发命令 */
000028  2055              MOVS     r0,#0x55
00002a  f7fffffe          BL       DS18B20_WriteByte
;;;301    	for (i = 0; i < 8; i++)
00002e  2400              MOVS     r4,#0
                  |L3.48|
;;;302    	{
;;;303    		DS18B20_WriteByte(_id[i]);
000030  5d28              LDRB     r0,[r5,r4]
000032  f7fffffe          BL       DS18B20_WriteByte
000036  1c64              ADDS     r4,r4,#1
000038  b2e4              UXTB     r4,r4                 ;301
00003a  2c08              CMP      r4,#8                 ;301
00003c  d3f8              BCC      |L3.48|
;;;304    	}	
;;;305    	DS18B20_WriteByte(0xbe);
00003e  20be              MOVS     r0,#0xbe
000040  f7fffffe          BL       DS18B20_WriteByte
;;;306    
;;;307    	temp1 = DS18B20_ReadByte();	/* 读温度值低字节 */
000044  f7fffffe          BL       DS18B20_ReadByte
000048  4604              MOV      r4,r0
;;;308    	temp2 = DS18B20_ReadByte();	/* 读温度值高字节 */
00004a  f7fffffe          BL       DS18B20_ReadByte
;;;309    
;;;310    	return ((temp2 << 8) | temp1);	/* 返回16位寄存器值 */
00004e  ea442000          ORR      r0,r4,r0,LSL #8
000052  b200              SXTH     r0,r0
;;;311    }
000054  bd70              POP      {r4-r6,pc}
;;;312    
                          ENDP


                          AREA ||i.DS18B20_ReadTempReg||, CODE, READONLY, ALIGN=1

                  DS18B20_ReadTempReg PROC
;;;222    */
;;;223    int16_t DS18B20_ReadTempReg(void)
000000  b510              PUSH     {r4,lr}
;;;224    {
;;;225    	uint8_t temp1, temp2;
;;;226    
;;;227    	/* 总线复位 */
;;;228    	if (DS18B20_Reset() == 0)
000002  f7fffffe          BL       DS18B20_Reset
000006  2800              CMP      r0,#0
000008  d015              BEQ      |L4.54|
;;;229    	{
;;;230    		return 0;
;;;231    	}		
;;;232    
;;;233    	DS18B20_WriteByte(0xcc);	/* 发命令 */
00000a  20cc              MOVS     r0,#0xcc
00000c  f7fffffe          BL       DS18B20_WriteByte
;;;234    	DS18B20_WriteByte(0x44);	/* 发转换命令 */
000010  2044              MOVS     r0,#0x44
000012  f7fffffe          BL       DS18B20_WriteByte
;;;235    
;;;236    	DS18B20_Reset();		/* 总线复位 */
000016  f7fffffe          BL       DS18B20_Reset
;;;237    
;;;238    	DS18B20_WriteByte(0xcc);	/* 发命令 */
00001a  20cc              MOVS     r0,#0xcc
00001c  f7fffffe          BL       DS18B20_WriteByte
;;;239    	DS18B20_WriteByte(0xbe);
000020  20be              MOVS     r0,#0xbe
000022  f7fffffe          BL       DS18B20_WriteByte
;;;240    
;;;241    	temp1 = DS18B20_ReadByte();	/* 读温度值低字节 */
000026  f7fffffe          BL       DS18B20_ReadByte
00002a  4604              MOV      r4,r0
;;;242    	temp2 = DS18B20_ReadByte();	/* 读温度值高字节 */
00002c  f7fffffe          BL       DS18B20_ReadByte
;;;243    
;;;244    	return ((temp2 << 8) | temp1);	/* 返回16位寄存器值 */
000030  ea442000          ORR      r0,r4,r0,LSL #8
000034  b200              SXTH     r0,r0
                  |L4.54|
;;;245    }
000036  bd10              POP      {r4,pc}
;;;246    
                          ENDP


                          AREA ||i.DS18B20_Reset||, CODE, READONLY, ALIGN=2

                  DS18B20_Reset PROC
;;;72     */
;;;73     uint8_t DS18B20_Reset(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;74     {
;;;75     	/*
;;;76     		复位时序, 见DS18B20 page 15
;;;77     
;;;78     		首先主机拉低DQ，持续最少 480us
;;;79     		然后释放DQ，等待DQ被上拉电阻拉高，约 15-60us
;;;80     		DS18B20 将驱动DQ为低 60-240us， 这个信号叫 presence pulse  (在位脉冲,表示DS18B20准备就绪 可以接受命令)
;;;81     		如果主机检测到这个低应答信号，表示DS18B20复位成功
;;;82     	*/
;;;83     
;;;84     	uint8_t i;
;;;85     	uint16_t k;
;;;86     
;;;87     	DISABLE_INT();/* 禁止全局中断 */
000004  2001              MOVS     r0,#1
000006  f3808810          MSR      PRIMASK,r0
;;;88     
;;;89     	/* 复位，如果失败则返回0 */
;;;90     	for (i = 0; i < 1; i++)
00000a  2400              MOVS     r4,#0
;;;91     	{
;;;92     		DQ_0();				/* 拉低DQ */
00000c  4d1b              LDR      r5,|L5.124|
00000e  0207              LSLS     r7,r0,#8
;;;93     		bsp_DelayUS(520);	/* 延迟 520uS， 要求这个延迟大于 480us */
000010  f44f7802          MOV      r8,#0x208
                  |L5.20|
000014  616f              STR      r7,[r5,#0x14]         ;92
000016  4640              MOV      r0,r8
000018  f7fffffe          BL       bsp_DelayUS
;;;94     		DQ_1();				/* 释放DQ */
00001c  612f              STR      r7,[r5,#0x10]
;;;95     
;;;96     		bsp_DelayUS(15);	/* 等待15us */
00001e  200f              MOVS     r0,#0xf
000020  f7fffffe          BL       bsp_DelayUS
;;;97     
;;;98     		/* 检测DQ电平是否为低 */
;;;99     		for (k = 0; k < 10; k++)
000024  2600              MOVS     r6,#0
                  |L5.38|
;;;100    		{
;;;101    			if (DQ_IS_LOW())
000026  68a8              LDR      r0,[r5,#8]
000028  05c0              LSLS     r0,r0,#23
00002a  d507              BPL      |L5.60|
;;;102    			{
;;;103    				break;
;;;104    			}
;;;105    			bsp_DelayUS(10);	/* 等待65us */
00002c  200a              MOVS     r0,#0xa
00002e  f7fffffe          BL       bsp_DelayUS
000032  1c76              ADDS     r6,r6,#1
000034  b2b6              UXTH     r6,r6                 ;99
000036  2e0a              CMP      r6,#0xa               ;99
000038  d3f5              BCC      |L5.38|
00003a  e00f              B        |L5.92|
                  |L5.60|
;;;106    		}
;;;107    		if (k >= 10)
00003c  2e0a              CMP      r6,#0xa
00003e  d20d              BCS      |L5.92|
;;;108    		{
;;;109    			continue;		/* 失败 */
;;;110    		}
;;;111    
;;;112    		/* 等待DS18B20释放DQ */
;;;113    		for (k = 0; k < 30; k++)
000040  2600              MOVS     r6,#0
                  |L5.66|
;;;114    		{
;;;115    			if (!DQ_IS_LOW())
000042  68a8              LDR      r0,[r5,#8]
000044  05c0              LSLS     r0,r0,#23
000046  d407              BMI      |L5.88|
;;;116    			{
;;;117    				break;
;;;118    			}
;;;119    			bsp_DelayUS(10);	/* 等待65us */
000048  200a              MOVS     r0,#0xa
00004a  f7fffffe          BL       bsp_DelayUS
00004e  1c76              ADDS     r6,r6,#1
000050  b2b6              UXTH     r6,r6                 ;113
000052  2e1e              CMP      r6,#0x1e              ;113
000054  d3f5              BCC      |L5.66|
000056  e001              B        |L5.92|
                  |L5.88|
;;;120    		}
;;;121    		if (k >= 30)
000058  2e1e              CMP      r6,#0x1e
00005a  d303              BCC      |L5.100|
                  |L5.92|
00005c  1c64              ADDS     r4,r4,#1
00005e  f01404ff          ANDS     r4,r4,#0xff           ;90
000062  d0d7              BEQ      |L5.20|
                  |L5.100|
;;;122    		{
;;;123    			continue;		/* 失败 */
;;;124    		}
;;;125    
;;;126    		break;
;;;127    	}
;;;128    
;;;129    	ENABLE_INT();	/* 使能全局中断 */
000064  2000              MOVS     r0,#0
000066  f3808810          MSR      PRIMASK,r0
;;;130    
;;;131    	bsp_DelayUS(5);
00006a  2005              MOVS     r0,#5
00006c  f7fffffe          BL       bsp_DelayUS
;;;132    
;;;133    	if (i >= 1)
000070  b114              CBZ      r4,|L5.120|
;;;134    	{
;;;135    		return 0;
000072  2000              MOVS     r0,#0
                  |L5.116|
;;;136    	}
;;;137    
;;;138    	return 1;
;;;139    }
000074  e8bd81f0          POP      {r4-r8,pc}
                  |L5.120|
000078  2001              MOVS     r0,#1                 ;138
00007a  e7fb              B        |L5.116|
;;;140    
                          ENDP

                  |L5.124|
                          DCD      0x40012000

                          AREA ||i.DS18B20_WriteByte||, CODE, READONLY, ALIGN=2

                  DS18B20_WriteByte PROC
;;;148    */
;;;149    static void DS18B20_WriteByte(uint8_t _val)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;150    {
;;;151    	/*
;;;152    		写数据时序, 见DS18B20 page 16
;;;153    	*/
;;;154    	uint8_t i;
;;;155    
;;;156    	for (i = 0; i < 8; i++)
;;;157    	{
;;;158    		DQ_0();
000004  4e0d              LDR      r6,|L6.60|
000006  4607              MOV      r7,r0                 ;150
000008  2400              MOVS     r4,#0                 ;156
00000a  f44f7580          MOV      r5,#0x100
                  |L6.14|
00000e  6175              STR      r5,[r6,#0x14]
;;;159    		bsp_DelayUS(2);
000010  2002              MOVS     r0,#2
000012  f7fffffe          BL       bsp_DelayUS
;;;160    
;;;161    		if (_val & 0x01)
000016  07f8              LSLS     r0,r7,#31
000018  d001              BEQ      |L6.30|
;;;162    		{
;;;163    			DQ_1();
00001a  6135              STR      r5,[r6,#0x10]
00001c  e000              B        |L6.32|
                  |L6.30|
;;;164    		}
;;;165    		else
;;;166    		{
;;;167    			DQ_0();
00001e  6175              STR      r5,[r6,#0x14]
                  |L6.32|
;;;168    		}
;;;169    		bsp_DelayUS(60);
000020  203c              MOVS     r0,#0x3c
000022  f7fffffe          BL       bsp_DelayUS
;;;170    		DQ_1();
000026  6135              STR      r5,[r6,#0x10]
;;;171    		bsp_DelayUS(2);
000028  2002              MOVS     r0,#2
00002a  f7fffffe          BL       bsp_DelayUS
;;;172    		_val >>= 1;
00002e  1c64              ADDS     r4,r4,#1
000030  087f              LSRS     r7,r7,#1
000032  b2e4              UXTB     r4,r4                 ;156
000034  2c08              CMP      r4,#8                 ;156
000036  d3ea              BCC      |L6.14|
;;;173    	}
;;;174    }
000038  e8bd81f0          POP      {r4-r8,pc}
;;;175    
                          ENDP

                  |L6.60|
                          DCD      0x40012000

                          AREA ||i.bsp_InitDS18B20||, CODE, READONLY, ALIGN=2

                  bsp_InitDS18B20 PROC
;;;47     */
;;;48     void bsp_InitDS18B20(void)
000000  b538              PUSH     {r3-r5,lr}
;;;49     {
;;;50     	GPIO_InitTypeDef GPIO_InitStructure;
;;;51     
;;;52     	/* 打开GPIO时钟 */
;;;53     	RCC_APB2PeriphClockCmd(RCC_DQ, ENABLE);
000002  2101              MOVS     r1,#1
000004  020c              LSLS     r4,r1,#8
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;54     
;;;55     	DQ_1();
00000c  4806              LDR      r0,|L7.40|
00000e  6104              STR      r4,[r0,#0x10]
;;;56     
;;;57     	/* 配置DQ为开漏输出 */
;;;58     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000010  2103              MOVS     r1,#3
000012  f88d1002          STRB     r1,[sp,#2]
;;;59     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_Out_OD;	/* 开漏输出模式 */
000016  2114              MOVS     r1,#0x14
000018  f88d1003          STRB     r1,[sp,#3]
;;;60     
;;;61     	GPIO_InitStructure.GPIO_Pin = PIN_DQ;
00001c  f8ad4000          STRH     r4,[sp,#0]
;;;62     	GPIO_Init(PORT_DQ, &GPIO_InitStructure);
000020  4669              MOV      r1,sp
000022  f7fffffe          BL       GPIO_Init
;;;63     }
000026  bd38              POP      {r3-r5,pc}
;;;64     
                          ENDP

                  |L7.40|
                          DCD      0x40012000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_ds18b20.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_ds18b20_c_ceb834f6____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___13_bsp_ds18b20_c_ceb834f6____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___13_bsp_ds18b20_c_ceb834f6____REVSH|
#line 128
|__asm___13_bsp_ds18b20_c_ceb834f6____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
