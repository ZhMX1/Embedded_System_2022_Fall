; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\uip-fw.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\uip-fw.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\uip-fw.crf ..\..\User\uIP\uip\uip-fw.c]
                          THUMB

                          AREA ||i.fwcache_register||, CODE, READONLY, ALIGN=2

                  fwcache_register PROC
;;;281    static void
;;;282    fwcache_register(void)
000000  b530              PUSH     {r4,r5,lr}
;;;283    {
;;;284      struct fwcache_entry *fw;
;;;285      int i, oldest;
;;;286    
;;;287      oldest = FW_TIME;
000002  2314              MOVS     r3,#0x14
;;;288      fw = NULL;
000004  2000              MOVS     r0,#0
;;;289    
;;;290      /* Find the oldest entry in the cache. */
;;;291      for(i = 0; i < FWCACHE_SIZE; ++i) {
;;;292        if(fwcache[i].timer == 0) {
000006  4a12              LDR      r2,|L1.80|
000008  4601              MOV      r1,r0                 ;291
00000a  bf00              NOP      
                  |L1.12|
00000c  ebc105c1          RSB      r5,r1,r1,LSL #3
000010  f8324015          LDRH     r4,[r2,r5,LSL #1]
000014  b1bc              CBZ      r4,|L1.70|
;;;293          fw = &fwcache[i];
;;;294          break;
;;;295        } else if(fwcache[i].timer <= oldest) {
000016  429c              CMP      r4,r3
000018  dc02              BGT      |L1.32|
;;;296          fw = &fwcache[i];
00001a  eb020045          ADD      r0,r2,r5,LSL #1
00001e  4623              MOV      r3,r4
                  |L1.32|
000020  1c49              ADDS     r1,r1,#1
000022  2902              CMP      r1,#2                 ;291
000024  dbf2              BLT      |L1.12|
                  |L1.38|
;;;297          oldest = fwcache[i].timer;
;;;298        }
;;;299      }
;;;300    
;;;301      fw->timer = FW_TIME;
000026  2114              MOVS     r1,#0x14
000028  8001              STRH     r1,[r0,#0]
;;;302      fw->ipid = BUF->ipid;
00002a  490a              LDR      r1,|L1.84|
00002c  8a4a              LDRH     r2,[r1,#0x12]  ; uip_buf
00002e  8142              STRH     r2,[r0,#0xa]
;;;303      fw->srcipaddr[0] = BUF->srcipaddr[0];
000030  8b4a              LDRH     r2,[r1,#0x1a]  ; uip_buf
000032  8042              STRH     r2,[r0,#2]
;;;304      fw->srcipaddr[1] = BUF->srcipaddr[1];
000034  8b8a              LDRH     r2,[r1,#0x1c]  ; uip_buf
000036  8082              STRH     r2,[r0,#4]
;;;305      fw->destipaddr[0] = BUF->destipaddr[0];
000038  8bca              LDRH     r2,[r1,#0x1e]  ; uip_buf
00003a  80c2              STRH     r2,[r0,#6]
;;;306      fw->destipaddr[1] = BUF->destipaddr[1];
00003c  8c0a              LDRH     r2,[r1,#0x20]  ; uip_buf
00003e  8102              STRH     r2,[r0,#8]
;;;307      fw->proto = BUF->proto;
000040  7dc9              LDRB     r1,[r1,#0x17]  ; uip_buf
000042  7301              STRB     r1,[r0,#0xc]
;;;308    #if notdef
;;;309      fw->payload[0] = BUF->srcport;
;;;310      fw->payload[1] = BUF->destport;
;;;311    #endif
;;;312    #if UIP_REASSEMBLY > 0
;;;313      fw->len = BUF->len;
;;;314      fw->offset = BUF->ipoffset;
;;;315    #endif
;;;316    }
000044  bd30              POP      {r4,r5,pc}
                  |L1.70|
000046  ebc100c1          RSB      r0,r1,r1,LSL #3       ;293
00004a  eb020040          ADD      r0,r2,r0,LSL #1       ;293
00004e  e7ea              B        |L1.38|
;;;317    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L1.80|
                          DCD      ||.bss||
                  |L1.84|
                          DCD      uip_buf

                          AREA ||i.time_exceeded||, CODE, READONLY, ALIGN=2

                  time_exceeded PROC
;;;221    static void
;;;222    time_exceeded(void)
000000  b570              PUSH     {r4-r6,lr}
;;;223    {
;;;224      u16_t tmp16;
;;;225    
;;;226      /* We don't send out ICMP errors for ICMP messages. */
;;;227      if(ICMPBUF->proto == UIP_PROTO_ICMP) {
000002  4c1c              LDR      r4,|L2.116|
000004  2500              MOVS     r5,#0
;;;228        uip_len = 0;
000006  4e1c              LDR      r6,|L2.120|
000008  7de0              LDRB     r0,[r4,#0x17]         ;227  ; uip_buf
00000a  2801              CMP      r0,#1                 ;227
00000c  d030              BEQ      |L2.112|
;;;229        return;
;;;230      }
;;;231      /* Copy fields from packet header into payload of this ICMP packet. */
;;;232      memcpy(&(ICMPBUF->payload[0]), ICMPBUF, 28);
00000e  f104010e          ADD      r1,r4,#0xe
000012  221c              MOVS     r2,#0x1c
000014  f101001c          ADD      r0,r1,#0x1c
000018  f7fffffe          BL       __aeabi_memcpy
;;;233    
;;;234      /* Set the ICMP type and code. */
;;;235      ICMPBUF->type = ICMP_TE;
00001c  200b              MOVS     r0,#0xb
00001e  f8840022          STRB     r0,[r4,#0x22]
;;;236      ICMPBUF->icode = 0;
000022  f8845023          STRB     r5,[r4,#0x23]
;;;237    
;;;238      /* Calculate the ICMP checksum. */
;;;239      ICMPBUF->icmpchksum = 0;
000026  84a5              STRH     r5,[r4,#0x24]
;;;240      ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
000028  f1040022          ADD      r0,r4,#0x22
00002c  2124              MOVS     r1,#0x24
00002e  340e              ADDS     r4,r4,#0xe
000030  f7fffffe          BL       uip_chksum
000034  43c0              MVNS     r0,r0
000036  82e0              STRH     r0,[r4,#0x16]
;;;241    
;;;242      /* Set the IP destination address to be the source address of the
;;;243         original packet. */
;;;244      tmp16= BUF->destipaddr[0];
;;;245      BUF->destipaddr[0] = BUF->srcipaddr[0];
000038  89a0              LDRH     r0,[r4,#0xc]  ; uip_buf
00003a  8220              STRH     r0,[r4,#0x10]
;;;246      BUF->srcipaddr[0] = tmp16;
;;;247      tmp16 = BUF->destipaddr[1];
;;;248      BUF->destipaddr[1] = BUF->srcipaddr[1];
00003c  89e0              LDRH     r0,[r4,#0xe]  ; uip_buf
00003e  8260              STRH     r0,[r4,#0x12]
;;;249      BUF->srcipaddr[1] = tmp16;
;;;250    
;;;251      /* Set our IP address as the source address. */
;;;252      BUF->srcipaddr[0] = uip_hostaddr[0];
000040  480e              LDR      r0,|L2.124|
000042  8801              LDRH     r1,[r0,#0]  ; uip_hostaddr
000044  81a1              STRH     r1,[r4,#0xc]
;;;253      BUF->srcipaddr[1] = uip_hostaddr[1];
000046  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
000048  81e0              STRH     r0,[r4,#0xe]
;;;254    
;;;255      /* The size of the ICMP time exceeded packet is 36 + the size of the
;;;256         IP header (20) = 56. */
;;;257      uip_len = 56;
00004a  2038              MOVS     r0,#0x38
00004c  8030              STRH     r0,[r6,#0]
;;;258      ICMPBUF->len[0] = 0;
00004e  70a5              STRB     r5,[r4,#2]
;;;259      ICMPBUF->len[1] = uip_len;
000050  70e0              STRB     r0,[r4,#3]
;;;260    
;;;261      /* Fill in the other fields in the IP header. */
;;;262      ICMPBUF->vhl = 0x45;
000052  2045              MOVS     r0,#0x45
000054  7020              STRB     r0,[r4,#0]
;;;263      ICMPBUF->tos = 0;
000056  7065              STRB     r5,[r4,#1]
;;;264      ICMPBUF->ipoffset[0] = ICMPBUF->ipoffset[1] = 0;
000058  71e5              STRB     r5,[r4,#7]
00005a  71a5              STRB     r5,[r4,#6]
;;;265      ICMPBUF->ttl  = UIP_TTL;
00005c  2040              MOVS     r0,#0x40
00005e  7220              STRB     r0,[r4,#8]
;;;266      ICMPBUF->proto = UIP_PROTO_ICMP;
000060  2001              MOVS     r0,#1
000062  7260              STRB     r0,[r4,#9]
;;;267    
;;;268      /* Calculate IP checksum. */
;;;269      ICMPBUF->ipchksum = 0;
000064  8165              STRH     r5,[r4,#0xa]
;;;270      ICMPBUF->ipchksum = ~(uip_ipchksum());
000066  f7fffffe          BL       uip_ipchksum
00006a  43c0              MVNS     r0,r0
00006c  8160              STRH     r0,[r4,#0xa]
;;;271    
;;;272    
;;;273    }
00006e  bd70              POP      {r4-r6,pc}
                  |L2.112|
000070  8035              STRH     r5,[r6,#0]            ;228
000072  bd70              POP      {r4-r6,pc}
;;;274    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L2.116|
                          DCD      uip_buf
                  |L2.120|
                          DCD      uip_len
                  |L2.124|
                          DCD      uip_hostaddr

                          AREA ||i.uip_fw_default||, CODE, READONLY, ALIGN=2

                  uip_fw_default PROC
;;;512    void
;;;513    uip_fw_default(struct uip_fw_netif *netif)
000000  4901              LDR      r1,|L3.8|
;;;514    {
;;;515      defaultnetif = netif;
000002  6048              STR      r0,[r1,#4]  ; defaultnetif
;;;516    }
000004  4770              BX       lr
;;;517    /*------------------------------------------------------------------------------*/
                          ENDP

000006  0000              DCW      0x0000
                  |L3.8|
                          DCD      ||.data||

                          AREA ||i.uip_fw_forward||, CODE, READONLY, ALIGN=2

                  uip_fw_forward PROC
;;;405    u8_t
;;;406    uip_fw_forward(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;407    {
;;;408      struct fwcache_entry *fw;
;;;409    
;;;410      /* First check if the packet is destined for ourselves and return 0
;;;411         to indicate that the packet should be processed locally. */
;;;412      if(BUF->destipaddr[0] == uip_hostaddr[0] &&
000004  4c2c              LDR      r4,|L4.184|
000006  482d              LDR      r0,|L4.188|
000008  4621              MOV      r1,r4
00000a  8be2              LDRH     r2,[r4,#0x1e]  ; uip_buf
00000c  8803              LDRH     r3,[r0,#0]  ; uip_hostaddr
;;;413         BUF->destipaddr[1] == uip_hostaddr[1]) {
00000e  8c09              LDRH     r1,[r1,#0x20]
000010  429a              CMP      r2,r3                 ;412
000012  d102              BNE      |L4.26|
000014  8840              LDRH     r0,[r0,#2]  ; uip_hostaddr
000016  4281              CMP      r1,r0
000018  d031              BEQ      |L4.126|
                  |L4.26|
;;;414        return UIP_FW_LOCAL;
;;;415      }
;;;416    
;;;417      /* If we use ping IP address configuration, and our IP address is
;;;418         not yet configured, we should intercept all ICMP echo packets. */
;;;419    #if UIP_PINGADDRCONF
;;;420      if((uip_hostaddr[0] | uip_hostaddr[1]) == 0 &&
;;;421         BUF->proto == UIP_PROTO_ICMP &&
;;;422         ICMPBUF->type == ICMP_ECHO) {
;;;423        return UIP_FW_LOCAL;
;;;424      }
;;;425    #endif /* UIP_PINGADDRCONF */
;;;426    
;;;427      /* Check if the packet is in the forwarding cache already, and if so
;;;428         we drop it. */
;;;429    
;;;430      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
00001a  4829              LDR      r0,|L4.192|
;;;431        if(fw->timer != 0 &&
;;;432    #if UIP_REASSEMBLY > 0
;;;433           fw->len == BUF->len &&
;;;434           fw->offset == BUF->ipoffset &&
;;;435    #endif
;;;436           fw->ipid == BUF->ipid &&
00001c  8a66              LDRH     r6,[r4,#0x12]
;;;437           fw->srcipaddr[0] == BUF->srcipaddr[0] &&
00001e  8b67              LDRH     r7,[r4,#0x1a]
;;;438           fw->srcipaddr[1] == BUF->srcipaddr[1] &&
000020  8ba3              LDRH     r3,[r4,#0x1c]
;;;439           fw->destipaddr[0] == BUF->destipaddr[0] &&
;;;440           fw->destipaddr[1] == BUF->destipaddr[1] &&
;;;441    #if notdef
;;;442           fw->payload[0] == BUF->srcport &&
;;;443           fw->payload[1] == BUF->destport &&
;;;444    #endif
;;;445           fw->proto == BUF->proto) {
000022  7de5              LDRB     r5,[r4,#0x17]
000024  f1000c1c          ADD      r12,r0,#0x1c          ;430
000028  e01e              B        |L4.104|
00002a  bf00              NOP                            ;431
                  |L4.44|
00002c  f8b0e000          LDRH     lr,[r0,#0]            ;431
000030  f1be0f00          CMP      lr,#0                 ;431
000034  d017              BEQ      |L4.102|
000036  f8b0e00a          LDRH     lr,[r0,#0xa]          ;436
00003a  45b6              CMP      lr,r6                 ;436
00003c  d113              BNE      |L4.102|
00003e  f8b0e002          LDRH     lr,[r0,#2]            ;437
000042  45be              CMP      lr,r7                 ;437
000044  d10f              BNE      |L4.102|
000046  f8b0e004          LDRH     lr,[r0,#4]            ;438
00004a  459e              CMP      lr,r3                 ;438
00004c  d10b              BNE      |L4.102|
00004e  f8b0e006          LDRH     lr,[r0,#6]            ;439
000052  4596              CMP      lr,r2                 ;439
000054  d107              BNE      |L4.102|
000056  f8b0e008          LDRH     lr,[r0,#8]            ;440
00005a  458e              CMP      lr,r1                 ;440
00005c  d103              BNE      |L4.102|
00005e  f890e00c          LDRB     lr,[r0,#0xc]
000062  45ae              CMP      lr,r5
000064  d025              BEQ      |L4.178|
                  |L4.102|
000066  300e              ADDS     r0,r0,#0xe
                  |L4.104|
000068  4560              CMP      r0,r12                ;430
00006a  d3df              BCC      |L4.44|
;;;446          /* Drop packet. */
;;;447          return UIP_FW_FORWARDED;
;;;448        }
;;;449      }
;;;450    
;;;451      /* If the TTL reaches zero we produce an ICMP time exceeded message
;;;452         in the uip_buf buffer and forward that packet back to the sender
;;;453         of the packet. */
;;;454      if(BUF->ttl <= 1) {
00006c  7da0              LDRB     r0,[r4,#0x16]  ; uip_buf
00006e  2801              CMP      r0,#1
000070  d80a              BHI      |L4.136|
;;;455        /* No time exceeded for broadcasts and multicasts! */
;;;456        if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
000072  f64f70ff          MOV      r0,#0xffff
000076  4282              CMP      r2,r0
000078  d104              BNE      |L4.132|
00007a  4281              CMP      r1,r0
00007c  d102              BNE      |L4.132|
                  |L4.126|
;;;457          return UIP_FW_LOCAL;
00007e  2000              MOVS     r0,#0
                  |L4.128|
;;;458        }
;;;459        time_exceeded();
;;;460      }
;;;461    
;;;462      /* Decrement the TTL (time-to-live) value in the IP header */
;;;463      BUF->ttl = BUF->ttl - 1;
;;;464    
;;;465      /* Update the IP checksum. */
;;;466      if(BUF->ipchksum >= HTONS(0xffff - 0x0100)) {
;;;467        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100) + 1;
;;;468      } else {
;;;469        BUF->ipchksum = BUF->ipchksum + HTONS(0x0100);
;;;470      }
;;;471    
;;;472      if(uip_len > 0) {
;;;473        uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN];
;;;474        uip_fw_output();
;;;475      }
;;;476    
;;;477    #if UIP_BROADCAST
;;;478      if(BUF->destipaddr[0] == 0xffff && BUF->destipaddr[1] == 0xffff) {
;;;479        return UIP_FW_LOCAL;
;;;480      }
;;;481    #endif /* UIP_BROADCAST */
;;;482    
;;;483      /* Return non-zero to indicate that the packet was forwarded and that no
;;;484         other processing should be made. */
;;;485      return UIP_FW_FORWARDED;
;;;486    }
000080  e8bd81f0          POP      {r4-r8,pc}
                  |L4.132|
000084  f7fffffe          BL       time_exceeded
                  |L4.136|
000088  7da0              LDRB     r0,[r4,#0x16]         ;463  ; uip_buf
00008a  f64f71fe          MOV      r1,#0xfffe            ;466
00008e  1e40              SUBS     r0,r0,#1              ;463
000090  75a0              STRB     r0,[r4,#0x16]         ;463
000092  8b20              LDRH     r0,[r4,#0x18]         ;466  ; uip_buf
000094  4288              CMP      r0,r1                 ;466
000096  d301              BCC      |L4.156|
000098  1c80              ADDS     r0,r0,#2              ;466
00009a  e000              B        |L4.158|
                  |L4.156|
00009c  1c40              ADDS     r0,r0,#1              ;467
                  |L4.158|
00009e  8320              STRH     r0,[r4,#0x18]         ;469
0000a0  4808              LDR      r0,|L4.196|
0000a2  8800              LDRH     r0,[r0,#0]            ;472  ; uip_len
0000a4  b128              CBZ      r0,|L4.178|
0000a6  4804              LDR      r0,|L4.184|
0000a8  4907              LDR      r1,|L4.200|
0000aa  3036              ADDS     r0,r0,#0x36           ;473
0000ac  6008              STR      r0,[r1,#0]            ;474  ; uip_appdata
0000ae  f7fffffe          BL       uip_fw_output
                  |L4.178|
0000b2  2001              MOVS     r0,#1                 ;485
0000b4  e7e4              B        |L4.128|
;;;487    /*------------------------------------------------------------------------------*/
                          ENDP

0000b6  0000              DCW      0x0000
                  |L4.184|
                          DCD      uip_buf
                  |L4.188|
                          DCD      uip_hostaddr
                  |L4.192|
                          DCD      ||.bss||
                  |L4.196|
                          DCD      uip_len
                  |L4.200|
                          DCD      uip_appdata

                          AREA ||i.uip_fw_init||, CODE, READONLY, ALIGN=2

                  uip_fw_init PROC
;;;182    void
;;;183    uip_fw_init(void)
000000  4905              LDR      r1,|L5.24|
;;;184    {
;;;185      struct uip_fw_netif *t;
;;;186      defaultnetif = NULL;
000002  2200              MOVS     r2,#0
;;;187      while(netifs != NULL) {
;;;188        t = netifs;
000004  604a              STR      r2,[r1,#4]  ; defaultnetif
000006  6808              LDR      r0,[r1,#0]            ;184  ; netifs
000008  e002              B        |L5.16|
                  |L5.10|
00000a  4603              MOV      r3,r0
;;;189        netifs = netifs->next;
00000c  6800              LDR      r0,[r0,#0]
;;;190        t->next = NULL;
00000e  601a              STR      r2,[r3,#0]
                  |L5.16|
000010  2800              CMP      r0,#0                 ;187
000012  d1fa              BNE      |L5.10|
000014  6008              STR      r0,[r1,#0]            ;189  ; netifs
;;;191      }
;;;192    }
000016  4770              BX       lr
;;;193    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L5.24|
                          DCD      ||.data||

                          AREA ||i.uip_fw_output||, CODE, READONLY, ALIGN=2

                  uip_fw_output PROC
;;;357    u8_t
;;;358    uip_fw_output(void)
000000  b570              PUSH     {r4-r6,lr}
;;;359    {
;;;360      struct uip_fw_netif *netif;
;;;361    
;;;362      if(uip_len == 0) {
000002  4813              LDR      r0,|L6.80|
000004  8800              LDRH     r0,[r0,#0]  ; uip_len
000006  b138              CBZ      r0,|L6.24|
;;;363        return UIP_FW_ZEROLEN;
;;;364      }
;;;365    
;;;366      fwcache_register();
000008  f7fffffe          BL       fwcache_register
00000c  4912              LDR      r1,|L6.88|
00000e  4b11              LDR      r3,|L6.84|
000010  8bca              LDRH     r2,[r1,#0x1e]
000012  8c09              LDRH     r1,[r1,#0x20]
;;;367    
;;;368    #if UIP_BROADCAST
;;;369      /* Link local broadcasts go out on all interfaces. */
;;;370      if(/*BUF->proto == UIP_PROTO_UDP &&*/
;;;371         BUF->destipaddr[0] == 0xffff &&
;;;372         BUF->destipaddr[1] == 0xffff) {
;;;373        if(defaultnetif != NULL) {
;;;374          defaultnetif->output();
;;;375        }
;;;376        for(netif = netifs; netif != NULL; netif = netif->next) {
;;;377          netif->output();
;;;378        }
;;;379        return UIP_FW_OK;
;;;380      }
;;;381    #endif /* UIP_BROADCAST */
;;;382    
;;;383      netif = find_netif();
000014  6818              LDR      r0,[r3,#0]  ; netifs
000016  e010              B        |L6.58|
                  |L6.24|
000018  2002              MOVS     r0,#2                 ;363
;;;384      /*  printf("uip_fw_output: netif %p ->output %p len %d\n", netif,
;;;385    	 netif->output,
;;;386    	 uip_len);*/
;;;387    
;;;388      if(netif == NULL) {
;;;389        return UIP_FW_NOROUTE;
;;;390      }
;;;391      /* If we now have found a suitable network interface, we call its
;;;392         output function to send out the packet. */
;;;393      return netif->output();
;;;394    }
00001a  bd70              POP      {r4-r6,pc}
                  |L6.28|
00001c  8904              LDRH     r4,[r0,#8]
00001e  8886              LDRH     r6,[r0,#4]
000020  ea020504          AND      r5,r2,r4
000024  4026              ANDS     r6,r6,r4
000026  42b5              CMP      r5,r6
000028  d106              BNE      |L6.56|
00002a  8944              LDRH     r4,[r0,#0xa]
00002c  88c6              LDRH     r6,[r0,#6]
00002e  ea010504          AND      r5,r1,r4
000032  4026              ANDS     r6,r6,r4
000034  42b5              CMP      r5,r6
000036  d003              BEQ      |L6.64|
                  |L6.56|
000038  6800              LDR      r0,[r0,#0]
                  |L6.58|
00003a  2800              CMP      r0,#0
00003c  d1ee              BNE      |L6.28|
00003e  6858              LDR      r0,[r3,#4]  ; defaultnetif
                  |L6.64|
000040  b118              CBZ      r0,|L6.74|
000042  68c0              LDR      r0,[r0,#0xc]          ;393
000044  e8bd4070          POP      {r4-r6,lr}            ;393
000048  4700              BX       r0                    ;393
                  |L6.74|
00004a  2004              MOVS     r0,#4                 ;389
00004c  bd70              POP      {r4-r6,pc}
;;;395    /*------------------------------------------------------------------------------*/
                          ENDP

00004e  0000              DCW      0x0000
                  |L6.80|
                          DCD      uip_len
                  |L6.84|
                          DCD      ||.data||
                  |L6.88|
                          DCD      uip_buf

                          AREA ||i.uip_fw_periodic||, CODE, READONLY, ALIGN=2

                  uip_fw_periodic PROC
;;;522    void
;;;523    uip_fw_periodic(void)
000000  4805              LDR      r0,|L7.24|
;;;524    {
;;;525      struct fwcache_entry *fw;
;;;526      for(fw = fwcache; fw < &fwcache[FWCACHE_SIZE]; ++fw) {
000002  f100011c          ADD      r1,r0,#0x1c
000006  e004              B        |L7.18|
                  |L7.8|
;;;527        if(fw->timer > 0) {
000008  8802              LDRH     r2,[r0,#0]
00000a  b10a              CBZ      r2,|L7.16|
00000c  1e52              SUBS     r2,r2,#1
;;;528          --fw->timer;
00000e  8002              STRH     r2,[r0,#0]
                  |L7.16|
000010  300e              ADDS     r0,r0,#0xe
                  |L7.18|
000012  4288              CMP      r0,r1                 ;526
000014  d3f8              BCC      |L7.8|
;;;529        }
;;;530      }
;;;531    }
000016  4770              BX       lr
;;;532    /*------------------------------------------------------------------------------*/
                          ENDP

                  |L7.24|
                          DCD      ||.bss||

                          AREA ||i.uip_fw_register||, CODE, READONLY, ALIGN=2

                  uip_fw_register PROC
;;;495    void
;;;496    uip_fw_register(struct uip_fw_netif *netif)
000000  4902              LDR      r1,|L8.12|
;;;497    {
;;;498      netif->next = netifs;
000002  680a              LDR      r2,[r1,#0]  ; netifs
;;;499      netifs = netif;
000004  6002              STR      r2,[r0,#0]
000006  6008              STR      r0,[r1,#0]  ; netifs
;;;500    }
000008  4770              BX       lr
;;;501    /*------------------------------------------------------------------------------*/
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      ||.data||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  fwcache
                          %        28

                          AREA ||.data||, DATA, ALIGN=2

                  netifs
                          DCD      0x00000000
                  defaultnetif
                          DCD      0x00000000
