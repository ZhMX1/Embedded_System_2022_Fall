; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\stm32f10x_adc.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\stm32f10x_adc.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\stm32f10x_adc.crf ..\..\Libraries\STM32F10x_StdPeriph_Driver\src\stm32f10x_adc.c]
                          THUMB

                          AREA ||i.ADC_AnalogWatchdogCmd||, CODE, READONLY, ALIGN=2

                  ADC_AnalogWatchdogCmd PROC
;;;1087     */
;;;1088   void ADC_AnalogWatchdogCmd(ADC_TypeDef* ADCx, uint32_t ADC_AnalogWatchdog)
000000  6842              LDR      r2,[r0,#4]
;;;1089   {
;;;1090     uint32_t tmpreg = 0;
;;;1091     /* Check the parameters */
;;;1092     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1093     assert_param(IS_ADC_ANALOG_WATCHDOG(ADC_AnalogWatchdog));
;;;1094     /* Get the old register value */
;;;1095     tmpreg = ADCx->CR1;
;;;1096     /* Clear AWDEN, AWDENJ and AWDSGL bits */
;;;1097     tmpreg &= CR1_AWDMode_Reset;
000002  4b02              LDR      r3,|L1.12|
000004  401a              ANDS     r2,r2,r3
;;;1098     /* Set the analog watchdog enable mode */
;;;1099     tmpreg |= ADC_AnalogWatchdog;
000006  430a              ORRS     r2,r2,r1
;;;1100     /* Store the new register value */
;;;1101     ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;1102   }
00000a  4770              BX       lr
;;;1103   
                          ENDP

                  |L1.12|
                          DCD      0xff3ffdff

                          AREA ||i.ADC_AnalogWatchdogSingleChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogSingleChannelConfig PROC
;;;1150     */
;;;1151   void ADC_AnalogWatchdogSingleChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel)
000000  6842              LDR      r2,[r0,#4]
;;;1152   {
;;;1153     uint32_t tmpreg = 0;
;;;1154     /* Check the parameters */
;;;1155     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1156     assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;1157     /* Get the old register value */
;;;1158     tmpreg = ADCx->CR1;
;;;1159     /* Clear the Analog watchdog channel select bits */
;;;1160     tmpreg &= CR1_AWDCH_Reset;
000002  f022021f          BIC      r2,r2,#0x1f
;;;1161     /* Set the Analog watchdog channel */
;;;1162     tmpreg |= ADC_Channel;
000006  430a              ORRS     r2,r2,r1
;;;1163     /* Store the new register value */
;;;1164     ADCx->CR1 = tmpreg;
000008  6042              STR      r2,[r0,#4]
;;;1165   }
00000a  4770              BX       lr
;;;1166   
                          ENDP


                          AREA ||i.ADC_AnalogWatchdogThresholdsConfig||, CODE, READONLY, ALIGN=1

                  ADC_AnalogWatchdogThresholdsConfig PROC
;;;1112     */
;;;1113   void ADC_AnalogWatchdogThresholdsConfig(ADC_TypeDef* ADCx, uint16_t HighThreshold,
000000  6241              STR      r1,[r0,#0x24]
;;;1114                                           uint16_t LowThreshold)
;;;1115   {
;;;1116     /* Check the parameters */
;;;1117     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1118     assert_param(IS_ADC_THRESHOLD(HighThreshold));
;;;1119     assert_param(IS_ADC_THRESHOLD(LowThreshold));
;;;1120     /* Set the ADCx high threshold */
;;;1121     ADCx->HTR = HighThreshold;
;;;1122     /* Set the ADCx low threshold */
;;;1123     ADCx->LTR = LowThreshold;
000002  6282              STR      r2,[r0,#0x28]
;;;1124   }
000004  4770              BX       lr
;;;1125   
                          ENDP


                          AREA ||i.ADC_AutoInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_AutoInjectedConvCmd PROC
;;;739      */
;;;740    void ADC_AutoInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;741    {
;;;742      /* Check the parameters */
;;;743      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;744      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;745      if (NewState != DISABLE)
;;;746      {
;;;747        /* Enable the selected ADC automatic injected group conversion */
;;;748        ADCx->CR1 |= CR1_JAUTO_Set;
;;;749      }
;;;750      else
;;;751      {
;;;752        /* Disable the selected ADC automatic injected group conversion */
;;;753        ADCx->CR1 &= CR1_JAUTO_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L4.12|
000006  f4416180          ORR      r1,r1,#0x400          ;748
00000a  e001              B        |L4.16|
                  |L4.12|
00000c  f4216180          BIC      r1,r1,#0x400
                  |L4.16|
000010  6041              STR      r1,[r0,#4]            ;748
;;;754      }
;;;755    }
000012  4770              BX       lr
;;;756    
                          ENDP


                          AREA ||i.ADC_ClearFlag||, CODE, READONLY, ALIGN=1

                  ADC_ClearFlag PROC
;;;1233     */
;;;1234   void ADC_ClearFlag(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  43c9              MVNS     r1,r1
;;;1235   {
;;;1236     /* Check the parameters */
;;;1237     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1238     assert_param(IS_ADC_CLEAR_FLAG(ADC_FLAG));
;;;1239     /* Clear the selected ADC flags */
;;;1240     ADCx->SR = ~(uint32_t)ADC_FLAG;
000002  6001              STR      r1,[r0,#0]
;;;1241   }
000004  4770              BX       lr
;;;1242   
                          ENDP


                          AREA ||i.ADC_ClearITPendingBit||, CODE, READONLY, ALIGN=1

                  ADC_ClearITPendingBit PROC
;;;1288     */
;;;1289   void ADC_ClearITPendingBit(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  ea6f2111          MVN      r1,r1,LSR #8
;;;1290   {
;;;1291     uint8_t itmask = 0;
;;;1292     /* Check the parameters */
;;;1293     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1294     assert_param(IS_ADC_IT(ADC_IT));
;;;1295     /* Get the ADC IT index */
;;;1296     itmask = (uint8_t)(ADC_IT >> 8);
;;;1297     /* Clear the selected ADC interrupt pending bits */
;;;1298     ADCx->SR = ~(uint32_t)itmask;
000004  6001              STR      r1,[r0,#0]
;;;1299   }
000006  4770              BX       lr
;;;1300   
                          ENDP


                          AREA ||i.ADC_Cmd||, CODE, READONLY, ALIGN=1

                  ADC_Cmd PROC
;;;304      */
;;;305    void ADC_Cmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;306    {
;;;307      /* Check the parameters */
;;;308      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;309      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;310      if (NewState != DISABLE)
;;;311      {
;;;312        /* Set the ADON bit to wake up the ADC from power down mode */
;;;313        ADCx->CR2 |= CR2_ADON_Set;
;;;314      }
;;;315      else
;;;316      {
;;;317        /* Disable the selected ADC peripheral */
;;;318        ADCx->CR2 &= CR2_ADON_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L7.12|
000006  f0410101          ORR      r1,r1,#1              ;313
00000a  e001              B        |L7.16|
                  |L7.12|
00000c  f0210101          BIC      r1,r1,#1
                  |L7.16|
000010  6081              STR      r1,[r0,#8]            ;313
;;;319      }
;;;320    }
000012  4770              BX       lr
;;;321    
                          ENDP


                          AREA ||i.ADC_DMACmd||, CODE, READONLY, ALIGN=1

                  ADC_DMACmd PROC
;;;329      */
;;;330    void ADC_DMACmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;331    {
;;;332      /* Check the parameters */
;;;333      assert_param(IS_ADC_DMA_PERIPH(ADCx));
;;;334      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;335      if (NewState != DISABLE)
;;;336      {
;;;337        /* Enable the selected ADC DMA request */
;;;338        ADCx->CR2 |= CR2_DMA_Set;
;;;339      }
;;;340      else
;;;341      {
;;;342        /* Disable the selected ADC DMA request */
;;;343        ADCx->CR2 &= CR2_DMA_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L8.12|
000006  f4417180          ORR      r1,r1,#0x100          ;338
00000a  e001              B        |L8.16|
                  |L8.12|
00000c  f4217180          BIC      r1,r1,#0x100
                  |L8.16|
000010  6081              STR      r1,[r0,#8]            ;338
;;;344      }
;;;345    }
000012  4770              BX       lr
;;;346    
                          ENDP


                          AREA ||i.ADC_DeInit||, CODE, READONLY, ALIGN=2

                  ADC_DeInit PROC
;;;184      */
;;;185    void ADC_DeInit(ADC_TypeDef* ADCx)
000000  490d              LDR      r1,|L9.56|
;;;186    {
000002  b510              PUSH     {r4,lr}
;;;187      /* Check the parameters */
;;;188      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;189      
;;;190      if (ADCx == ADC1)
000004  4288              CMP      r0,r1
000006  d102              BNE      |L9.14|
;;;191      {
;;;192        /* Enable ADC1 reset state */
;;;193        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, ENABLE);
000008  2101              MOVS     r1,#1
00000a  1544              ASRS     r4,r0,#21
;;;194        /* Release ADC1 from reset state */
;;;195        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC1, DISABLE);
00000c  e00a              B        |L9.36|
                  |L9.14|
;;;196      }
;;;197      else if (ADCx == ADC2)
00000e  490b              LDR      r1,|L9.60|
000010  4288              CMP      r0,r1
000012  d102              BNE      |L9.26|
;;;198      {
;;;199        /* Enable ADC2 reset state */
;;;200        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, ENABLE);
000014  2101              MOVS     r1,#1
000016  1504              ASRS     r4,r0,#20
;;;201        /* Release ADC2 from reset state */
;;;202        RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC2, DISABLE);
000018  e004              B        |L9.36|
                  |L9.26|
;;;203      }
;;;204      else
;;;205      {
;;;206        if (ADCx == ADC3)
00001a  4909              LDR      r1,|L9.64|
00001c  4288              CMP      r0,r1
00001e  d10a              BNE      |L9.54|
;;;207        {
;;;208          /* Enable ADC3 reset state */
;;;209          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, ENABLE);
000020  2101              MOVS     r1,#1
000022  03cc              LSLS     r4,r1,#15
                  |L9.36|
000024  4620              MOV      r0,r4
000026  f7fffffe          BL       RCC_APB2PeriphResetCmd
;;;210          /* Release ADC3 from reset state */
;;;211          RCC_APB2PeriphResetCmd(RCC_APB2Periph_ADC3, DISABLE);
00002a  4620              MOV      r0,r4
00002c  e8bd4010          POP      {r4,lr}
000030  2100              MOVS     r1,#0
000032  f7ffbffe          B.W      RCC_APB2PeriphResetCmd
                  |L9.54|
;;;212        }
;;;213      }
;;;214    }
000036  bd10              POP      {r4,pc}
;;;215    
                          ENDP

                  |L9.56|
                          DCD      0x40012400
                  |L9.60|
                          DCD      0x40012800
                  |L9.64|
                          DCD      0x40013c00

                          AREA ||i.ADC_DiscModeChannelCountConfig||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeChannelCountConfig PROC
;;;514      */
;;;515    void ADC_DiscModeChannelCountConfig(ADC_TypeDef* ADCx, uint8_t Number)
000000  6842              LDR      r2,[r0,#4]
;;;516    {
;;;517      uint32_t tmpreg1 = 0;
;;;518      uint32_t tmpreg2 = 0;
;;;519      /* Check the parameters */
;;;520      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;521      assert_param(IS_ADC_REGULAR_DISC_NUMBER(Number));
;;;522      /* Get the old register value */
;;;523      tmpreg1 = ADCx->CR1;
;;;524      /* Clear the old discontinuous mode channel count */
;;;525      tmpreg1 &= CR1_DISCNUM_Reset;
000002  1e49              SUBS     r1,r1,#1
000004  f4224260          BIC      r2,r2,#0xe000
;;;526      /* Set the discontinuous mode channel count */
;;;527      tmpreg2 = Number - 1;
;;;528      tmpreg1 |= tmpreg2 << 13;
000008  ea423141          ORR      r1,r2,r1,LSL #13
;;;529      /* Store the new register value */
;;;530      ADCx->CR1 = tmpreg1;
00000c  6041              STR      r1,[r0,#4]
;;;531    }
00000e  4770              BX       lr
;;;532    
                          ENDP


                          AREA ||i.ADC_DiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_DiscModeCmd PROC
;;;541      */
;;;542    void ADC_DiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;543    {
;;;544      /* Check the parameters */
;;;545      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;546      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;547      if (NewState != DISABLE)
;;;548      {
;;;549        /* Enable the selected ADC regular discontinuous mode */
;;;550        ADCx->CR1 |= CR1_DISCEN_Set;
;;;551      }
;;;552      else
;;;553      {
;;;554        /* Disable the selected ADC regular discontinuous mode */
;;;555        ADCx->CR1 &= CR1_DISCEN_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L11.12|
000006  f4416100          ORR      r1,r1,#0x800          ;550
00000a  e001              B        |L11.16|
                  |L11.12|
00000c  f4216100          BIC      r1,r1,#0x800
                  |L11.16|
000010  6041              STR      r1,[r0,#4]            ;550
;;;556      }
;;;557    }
000012  4770              BX       lr
;;;558    
                          ENDP


                          AREA ||i.ADC_ExternalTrigConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigConvCmd PROC
;;;691      */
;;;692    void ADC_ExternalTrigConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;693    {
;;;694      /* Check the parameters */
;;;695      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;696      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;697      if (NewState != DISABLE)
;;;698      {
;;;699        /* Enable the selected ADC conversion on external event */
;;;700        ADCx->CR2 |= CR2_EXTTRIG_Set;
;;;701      }
;;;702      else
;;;703      {
;;;704        /* Disable the selected ADC conversion on external event */
;;;705        ADCx->CR2 &= CR2_EXTTRIG_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L12.12|
000006  f4411180          ORR      r1,r1,#0x100000       ;700
00000a  e001              B        |L12.16|
                  |L12.12|
00000c  f4211180          BIC      r1,r1,#0x100000
                  |L12.16|
000010  6081              STR      r1,[r0,#8]            ;700
;;;706      }
;;;707    }
000012  4770              BX       lr
;;;708    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvCmd PROC
;;;829      */
;;;830    void ADC_ExternalTrigInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;831    {
;;;832      /* Check the parameters */
;;;833      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;834      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;835      if (NewState != DISABLE)
;;;836      {
;;;837        /* Enable the selected ADC external event selection for injected group */
;;;838        ADCx->CR2 |= CR2_JEXTTRIG_Set;
;;;839      }
;;;840      else
;;;841      {
;;;842        /* Disable the selected ADC external event selection for injected group */
;;;843        ADCx->CR2 &= CR2_JEXTTRIG_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L13.12|
000006  f4414100          ORR      r1,r1,#0x8000         ;838
00000a  e001              B        |L13.16|
                  |L13.12|
00000c  f4214100          BIC      r1,r1,#0x8000
                  |L13.16|
000010  6081              STR      r1,[r0,#8]            ;838
;;;844      }
;;;845    }
000012  4770              BX       lr
;;;846    
                          ENDP


                          AREA ||i.ADC_ExternalTrigInjectedConvConfig||, CODE, READONLY, ALIGN=1

                  ADC_ExternalTrigInjectedConvConfig PROC
;;;804      */
;;;805    void ADC_ExternalTrigInjectedConvConfig(ADC_TypeDef* ADCx, uint32_t ADC_ExternalTrigInjecConv)
000000  6882              LDR      r2,[r0,#8]
;;;806    {
;;;807      uint32_t tmpreg = 0;
;;;808      /* Check the parameters */
;;;809      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;810      assert_param(IS_ADC_EXT_INJEC_TRIG(ADC_ExternalTrigInjecConv));
;;;811      /* Get the old register value */
;;;812      tmpreg = ADCx->CR2;
;;;813      /* Clear the old external event selection for injected group */
;;;814      tmpreg &= CR2_JEXTSEL_Reset;
000002  f42242e0          BIC      r2,r2,#0x7000
;;;815      /* Set the external event selection for injected group */
;;;816      tmpreg |= ADC_ExternalTrigInjecConv;
000006  430a              ORRS     r2,r2,r1
;;;817      /* Store the new register value */
;;;818      ADCx->CR2 = tmpreg;
000008  6082              STR      r2,[r0,#8]
;;;819    }
00000a  4770              BX       lr
;;;820    
                          ENDP


                          AREA ||i.ADC_GetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetCalibrationStatus PROC
;;;435      */
;;;436    FlagStatus ADC_GetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;437    {
;;;438      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;439      /* Check the parameters */
;;;440      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;441      /* Check the status of CAL bit */
;;;442      if ((ADCx->CR2 & CR2_CAL_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0749              LSLS     r1,r1,#29
000008  d500              BPL      |L15.12|
;;;443      {
;;;444        /* CAL bit is set: calibration on going */
;;;445        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L15.12|
;;;446      }
;;;447      else
;;;448      {
;;;449        /* CAL bit is reset: end of calibration */
;;;450        bitstatus = RESET;
;;;451      }
;;;452      /* Return the CAL bit status */
;;;453      return  bitstatus;
;;;454    }
00000c  4770              BX       lr
;;;455    
                          ENDP


                          AREA ||i.ADC_GetConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetConversionValue PROC
;;;713      */
;;;714    uint16_t ADC_GetConversionValue(ADC_TypeDef* ADCx)
000000  6cc0              LDR      r0,[r0,#0x4c]
;;;715    {
;;;716      /* Check the parameters */
;;;717      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;718      /* Return the selected ADC conversion value */
;;;719      return (uint16_t) ADCx->DR;
000002  b280              UXTH     r0,r0
;;;720    }
000004  4770              BX       lr
;;;721    
                          ENDP


                          AREA ||i.ADC_GetDualModeConversionValue||, CODE, READONLY, ALIGN=2

                  ADC_GetDualModeConversionValue PROC
;;;725      */
;;;726    uint32_t ADC_GetDualModeConversionValue(void)
000000  4801              LDR      r0,|L17.8|
;;;727    {
;;;728      /* Return the dual mode conversion value */
;;;729      return (*(__IO uint32_t *) DR_ADDRESS);
000002  6800              LDR      r0,[r0,#0]
;;;730    }
000004  4770              BX       lr
;;;731    
                          ENDP

000006  0000              DCW      0x0000
                  |L17.8|
                          DCD      0x4001244c

                          AREA ||i.ADC_GetFlagStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetFlagStatus PROC
;;;1200     */
;;;1201   FlagStatus ADC_GetFlagStatus(ADC_TypeDef* ADCx, uint8_t ADC_FLAG)
000000  4602              MOV      r2,r0
;;;1202   {
;;;1203     FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;1204     /* Check the parameters */
;;;1205     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1206     assert_param(IS_ADC_GET_FLAG(ADC_FLAG));
;;;1207     /* Check the status of the specified ADC flag */
;;;1208     if ((ADCx->SR & ADC_FLAG) != (uint8_t)RESET)
000004  6812              LDR      r2,[r2,#0]
000006  420a              TST      r2,r1
000008  d000              BEQ      |L18.12|
;;;1209     {
;;;1210       /* ADC_FLAG is set */
;;;1211       bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L18.12|
;;;1212     }
;;;1213     else
;;;1214     {
;;;1215       /* ADC_FLAG is reset */
;;;1216       bitstatus = RESET;
;;;1217     }
;;;1218     /* Return the ADC_FLAG status */
;;;1219     return  bitstatus;
;;;1220   }
00000c  4770              BX       lr
;;;1221   
                          ENDP


                          AREA ||i.ADC_GetITStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetITStatus PROC
;;;1252     */
;;;1253   ITStatus ADC_GetITStatus(ADC_TypeDef* ADCx, uint16_t ADC_IT)
000000  b510              PUSH     {r4,lr}
;;;1254   {
000002  4602              MOV      r2,r0
;;;1255     ITStatus bitstatus = RESET;
000004  2000              MOVS     r0,#0
;;;1256     uint32_t itmask = 0, enablestatus = 0;
;;;1257     /* Check the parameters */
;;;1258     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1259     assert_param(IS_ADC_GET_IT(ADC_IT));
;;;1260     /* Get the ADC IT index */
;;;1261     itmask = ADC_IT >> 8;
;;;1262     /* Get the ADC_IT enable bit status */
;;;1263     enablestatus = (ADCx->CR1 & (uint8_t)ADC_IT) ;
000006  6854              LDR      r4,[r2,#4]
000008  0a0b              LSRS     r3,r1,#8              ;1261
00000a  b2c9              UXTB     r1,r1
00000c  400c              ANDS     r4,r4,r1
;;;1264     /* Check the status of the specified ADC interrupt */
;;;1265     if (((ADCx->SR & itmask) != (uint32_t)RESET) && enablestatus)
00000e  6811              LDR      r1,[r2,#0]
000010  4219              TST      r1,r3
000012  d002              BEQ      |L19.26|
000014  2c00              CMP      r4,#0
000016  d000              BEQ      |L19.26|
;;;1266     {
;;;1267       /* ADC_IT is set */
;;;1268       bitstatus = SET;
000018  2001              MOVS     r0,#1
                  |L19.26|
;;;1269     }
;;;1270     else
;;;1271     {
;;;1272       /* ADC_IT is reset */
;;;1273       bitstatus = RESET;
;;;1274     }
;;;1275     /* Return the ADC_IT status */
;;;1276     return  bitstatus;
;;;1277   }
00001a  bd10              POP      {r4,pc}
;;;1278   
                          ENDP


                          AREA ||i.ADC_GetInjectedConversionValue||, CODE, READONLY, ALIGN=1

                  ADC_GetInjectedConversionValue PROC
;;;1057     */
;;;1058   uint16_t ADC_GetInjectedConversionValue(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel)
000000  b508              PUSH     {r3,lr}
;;;1059   {
;;;1060     __IO uint32_t tmp = 0;
;;;1061     
;;;1062     /* Check the parameters */
;;;1063     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1064     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1065   
;;;1066     tmp = (uint32_t)ADCx;
;;;1067     tmp += ADC_InjectedChannel + JDR_Offset;
000002  4408              ADD      r0,r0,r1
000004  3028              ADDS     r0,r0,#0x28
;;;1068     
;;;1069     /* Returns the selected injected channel conversion data value */
;;;1070     return (uint16_t) (*(__IO uint32_t*)  tmp);   
000006  9000              STR      r0,[sp,#0]
000008  6800              LDR      r0,[r0,#0]
00000a  b280              UXTH     r0,r0
;;;1071   }
00000c  bd08              POP      {r3,pc}
;;;1072   
                          ENDP


                          AREA ||i.ADC_GetResetCalibrationStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetResetCalibrationStatus PROC
;;;397      */
;;;398    FlagStatus ADC_GetResetCalibrationStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;399    {
;;;400      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;401      /* Check the parameters */
;;;402      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;403      /* Check the status of RSTCAL bit */
;;;404      if ((ADCx->CR2 & CR2_RSTCAL_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0709              LSLS     r1,r1,#28
000008  d500              BPL      |L21.12|
;;;405      {
;;;406        /* RSTCAL bit is set */
;;;407        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L21.12|
;;;408      }
;;;409      else
;;;410      {
;;;411        /* RSTCAL bit is reset */
;;;412        bitstatus = RESET;
;;;413      }
;;;414      /* Return the RSTCAL bit status */
;;;415      return  bitstatus;
;;;416    }
00000c  4770              BX       lr
;;;417    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartConvStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartConvStatus PROC
;;;486      */
;;;487    FlagStatus ADC_GetSoftwareStartConvStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;488    {
;;;489      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;490      /* Check the parameters */
;;;491      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;492      /* Check the status of SWSTART bit */
;;;493      if ((ADCx->CR2 & CR2_SWSTART_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0249              LSLS     r1,r1,#9
000008  d500              BPL      |L22.12|
;;;494      {
;;;495        /* SWSTART bit is set */
;;;496        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L22.12|
;;;497      }
;;;498      else
;;;499      {
;;;500        /* SWSTART bit is reset */
;;;501        bitstatus = RESET;
;;;502      }
;;;503      /* Return the SWSTART bit status */
;;;504      return  bitstatus;
;;;505    }
00000c  4770              BX       lr
;;;506    
                          ENDP


                          AREA ||i.ADC_GetSoftwareStartInjectedConvCmdStatus||, CODE, READONLY, ALIGN=1

                  ADC_GetSoftwareStartInjectedConvCmdStatus PROC
;;;878      */
;;;879    FlagStatus ADC_GetSoftwareStartInjectedConvCmdStatus(ADC_TypeDef* ADCx)
000000  4601              MOV      r1,r0
;;;880    {
;;;881      FlagStatus bitstatus = RESET;
000002  2000              MOVS     r0,#0
;;;882      /* Check the parameters */
;;;883      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;884      /* Check the status of JSWSTART bit */
;;;885      if ((ADCx->CR2 & CR2_JSWSTART_Set) != (uint32_t)RESET)
000004  6889              LDR      r1,[r1,#8]
000006  0289              LSLS     r1,r1,#10
000008  d500              BPL      |L23.12|
;;;886      {
;;;887        /* JSWSTART bit is set */
;;;888        bitstatus = SET;
00000a  2001              MOVS     r0,#1
                  |L23.12|
;;;889      }
;;;890      else
;;;891      {
;;;892        /* JSWSTART bit is reset */
;;;893        bitstatus = RESET;
;;;894      }
;;;895      /* Return the JSWSTART bit status */
;;;896      return  bitstatus;
;;;897    }
00000c  4770              BX       lr
;;;898    
                          ENDP


                          AREA ||i.ADC_ITConfig||, CODE, READONLY, ALIGN=1

                  ADC_ITConfig PROC
;;;358      */
;;;359    void ADC_ITConfig(ADC_TypeDef* ADCx, uint16_t ADC_IT, FunctionalState NewState)
000000  2a00              CMP      r2,#0
;;;360    {
;;;361      uint8_t itmask = 0;
;;;362      /* Check the parameters */
;;;363      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;364      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;365      assert_param(IS_ADC_IT(ADC_IT));
;;;366      /* Get the ADC IT index */
;;;367      itmask = (uint8_t)ADC_IT;
;;;368      if (NewState != DISABLE)
;;;369      {
;;;370        /* Enable the selected ADC interrupts */
;;;371        ADCx->CR1 |= itmask;
;;;372      }
;;;373      else
;;;374      {
;;;375        /* Disable the selected ADC interrupts */
;;;376        ADCx->CR1 &= (~(uint32_t)itmask);
000002  6842              LDR      r2,[r0,#4]
000004  b2c9              UXTB     r1,r1                 ;367
000006  d001              BEQ      |L24.12|
000008  430a              ORRS     r2,r2,r1              ;371
00000a  e000              B        |L24.14|
                  |L24.12|
00000c  438a              BICS     r2,r2,r1
                  |L24.14|
00000e  6042              STR      r2,[r0,#4]            ;371
;;;377      }
;;;378    }
000010  4770              BX       lr
;;;379    
                          ENDP


                          AREA ||i.ADC_Init||, CODE, READONLY, ALIGN=2

                  ADC_Init PROC
;;;223      */
;;;224    void ADC_Init(ADC_TypeDef* ADCx, ADC_InitTypeDef* ADC_InitStruct)
000000  b510              PUSH     {r4,lr}
;;;225    {
;;;226      uint32_t tmpreg1 = 0;
;;;227      uint8_t tmpreg2 = 0;
;;;228      /* Check the parameters */
;;;229      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;230      assert_param(IS_ADC_MODE(ADC_InitStruct->ADC_Mode));
;;;231      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ScanConvMode));
;;;232      assert_param(IS_FUNCTIONAL_STATE(ADC_InitStruct->ADC_ContinuousConvMode));
;;;233      assert_param(IS_ADC_EXT_TRIG(ADC_InitStruct->ADC_ExternalTrigConv));   
;;;234      assert_param(IS_ADC_DATA_ALIGN(ADC_InitStruct->ADC_DataAlign)); 
;;;235      assert_param(IS_ADC_REGULAR_LENGTH(ADC_InitStruct->ADC_NbrOfChannel));
;;;236    
;;;237      /*---------------------------- ADCx CR1 Configuration -----------------*/
;;;238      /* Get the ADCx CR1 value */
;;;239      tmpreg1 = ADCx->CR1;
000002  6842              LDR      r2,[r0,#4]
;;;240      /* Clear DUALMOD and SCAN bits */
;;;241      tmpreg1 &= CR1_CLEAR_Mask;
000004  4b0e              LDR      r3,|L25.64|
;;;242      /* Configure ADCx: Dual mode and scan conversion mode */
;;;243      /* Set DUALMOD bits according to ADC_Mode value */
;;;244      /* Set SCAN bit according to ADC_ScanConvMode value */
;;;245      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_Mode | ((uint32_t)ADC_InitStruct->ADC_ScanConvMode << 8));
000006  790c              LDRB     r4,[r1,#4]
000008  401a              ANDS     r2,r2,r3              ;241
00000a  680b              LDR      r3,[r1,#0]
00000c  ea422204          ORR      r2,r2,r4,LSL #8
000010  4313              ORRS     r3,r3,r2
;;;246      /* Write to ADCx CR1 */
;;;247      ADCx->CR1 = tmpreg1;
000012  6043              STR      r3,[r0,#4]
;;;248    
;;;249      /*---------------------------- ADCx CR2 Configuration -----------------*/
;;;250      /* Get the ADCx CR2 value */
;;;251      tmpreg1 = ADCx->CR2;
000014  6883              LDR      r3,[r0,#8]
;;;252      /* Clear CONT, ALIGN and EXTSEL bits */
;;;253      tmpreg1 &= CR2_CLEAR_Mask;
000016  4a0b              LDR      r2,|L25.68|
000018  4013              ANDS     r3,r3,r2
00001a  e9d14202          LDRD     r4,r2,[r1,#8]
;;;254      /* Configure ADCx: external trigger event and continuous conversion mode */
;;;255      /* Set ALIGN bit according to ADC_DataAlign value */
;;;256      /* Set EXTSEL bits according to ADC_ExternalTrigConv value */
;;;257      /* Set CONT bit according to ADC_ContinuousConvMode value */
;;;258      tmpreg1 |= (uint32_t)(ADC_InitStruct->ADC_DataAlign | ADC_InitStruct->ADC_ExternalTrigConv |
00001e  4322              ORRS     r2,r2,r4
000020  794c              LDRB     r4,[r1,#5]
000022  ea430344          ORR      r3,r3,r4,LSL #1
000026  431a              ORRS     r2,r2,r3
;;;259                ((uint32_t)ADC_InitStruct->ADC_ContinuousConvMode << 1));
;;;260      /* Write to ADCx CR2 */
;;;261      ADCx->CR2 = tmpreg1;
000028  6082              STR      r2,[r0,#8]
;;;262    
;;;263      /*---------------------------- ADCx SQR1 Configuration -----------------*/
;;;264      /* Get the ADCx SQR1 value */
;;;265      tmpreg1 = ADCx->SQR1;
00002a  6ac2              LDR      r2,[r0,#0x2c]
;;;266      /* Clear L bits */
;;;267      tmpreg1 &= SQR1_CLEAR_Mask;
;;;268      /* Configure ADCx: regular channel sequence length */
;;;269      /* Set L bits according to ADC_NbrOfChannel value */
;;;270      tmpreg2 |= (uint8_t) (ADC_InitStruct->ADC_NbrOfChannel - (uint8_t)1);
00002c  7c09              LDRB     r1,[r1,#0x10]
00002e  f4220270          BIC      r2,r2,#0xf00000       ;267
000032  1e49              SUBS     r1,r1,#1
000034  b2c9              UXTB     r1,r1
;;;271      tmpreg1 |= (uint32_t)tmpreg2 << 20;
000036  ea425101          ORR      r1,r2,r1,LSL #20
;;;272      /* Write to ADCx SQR1 */
;;;273      ADCx->SQR1 = tmpreg1;
00003a  62c1              STR      r1,[r0,#0x2c]
;;;274    }
00003c  bd10              POP      {r4,pc}
;;;275    
                          ENDP

00003e  0000              DCW      0x0000
                  |L25.64|
                          DCD      0xfff0feff
                  |L25.68|
                          DCD      0xfff1f7fd

                          AREA ||i.ADC_InjectedChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedChannelConfig PROC
;;;935      */
;;;936    void ADC_InjectedChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;937    {
;;;938      uint32_t tmpreg1 = 0, tmpreg2 = 0, tmpreg3 = 0;
;;;939      /* Check the parameters */
;;;940      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;941      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;942      assert_param(IS_ADC_INJECTED_RANK(Rank));
;;;943      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;944      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;945      if (ADC_Channel > ADC_Channel_9)
;;;946      {
;;;947        /* Get the old register value */
;;;948        tmpreg1 = ADCx->SMPR1;
;;;949        /* Calculate the mask to clear */
;;;950        tmpreg2 = SMPR1_SMP_Set << (3*(ADC_Channel - 10));
000002  2407              MOVS     r4,#7
000004  2909              CMP      r1,#9                 ;945
000006  d90a              BLS      |L26.30|
000008  68c5              LDR      r5,[r0,#0xc]          ;948
00000a  f1a1060a          SUB      r6,r1,#0xa
00000e  eb060646          ADD      r6,r6,r6,LSL #1
000012  40b4              LSLS     r4,r4,r6
;;;951        /* Clear the old channel sample time */
;;;952        tmpreg1 &= ~tmpreg2;
000014  43a5              BICS     r5,r5,r4
;;;953        /* Calculate the mask to set */
;;;954        tmpreg2 = (uint32_t)ADC_SampleTime << (3*(ADC_Channel - 10));
000016  40b3              LSLS     r3,r3,r6
;;;955        /* Set the new channel sample time */
;;;956        tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;957        /* Store the new register value */
;;;958        ADCx->SMPR1 = tmpreg1;
00001a  60c5              STR      r5,[r0,#0xc]
00001c  e007              B        |L26.46|
                  |L26.30|
;;;959      }
;;;960      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;961      {
;;;962        /* Get the old register value */
;;;963        tmpreg1 = ADCx->SMPR2;
00001e  6905              LDR      r5,[r0,#0x10]
;;;964        /* Calculate the mask to clear */
;;;965        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000020  eb010641          ADD      r6,r1,r1,LSL #1
000024  40b4              LSLS     r4,r4,r6
;;;966        /* Clear the old channel sample time */
;;;967        tmpreg1 &= ~tmpreg2;
000026  43a5              BICS     r5,r5,r4
;;;968        /* Calculate the mask to set */
;;;969        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000028  40b3              LSLS     r3,r3,r6
;;;970        /* Set the new channel sample time */
;;;971        tmpreg1 |= tmpreg2;
00002a  431d              ORRS     r5,r5,r3
;;;972        /* Store the new register value */
;;;973        ADCx->SMPR2 = tmpreg1;
00002c  6105              STR      r5,[r0,#0x10]
                  |L26.46|
;;;974      }
;;;975      /* Rank configuration */
;;;976      /* Get the old register value */
;;;977      tmpreg1 = ADCx->JSQR;
00002e  6b83              LDR      r3,[r0,#0x38]
;;;978      /* Get JL value: Number = JL+1 */
;;;979      tmpreg3 =  (tmpreg1 & JSQR_JL_Set)>> 20;
000030  f3c35401          UBFX     r4,r3,#20,#2
;;;980      /* Calculate the mask to clear: ((Rank-1)+(4-JL-1)) */
;;;981      tmpreg2 = JSQR_JSQ_Set << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000034  1b12              SUBS     r2,r2,r4
000036  1c92              ADDS     r2,r2,#2
000038  eb020482          ADD      r4,r2,r2,LSL #2
00003c  221f              MOVS     r2,#0x1f
00003e  40a2              LSLS     r2,r2,r4
;;;982      /* Clear the old JSQx bits for the selected rank */
;;;983      tmpreg1 &= ~tmpreg2;
000040  4393              BICS     r3,r3,r2
;;;984      /* Calculate the mask to set: ((Rank-1)+(4-JL-1)) */
;;;985      tmpreg2 = (uint32_t)ADC_Channel << (5 * (uint8_t)((Rank + 3) - (tmpreg3 + 1)));
000042  40a1              LSLS     r1,r1,r4
;;;986      /* Set the JSQx bits for the selected rank */
;;;987      tmpreg1 |= tmpreg2;
000044  430b              ORRS     r3,r3,r1
;;;988      /* Store the new register value */
;;;989      ADCx->JSQR = tmpreg1;
000046  6383              STR      r3,[r0,#0x38]
;;;990    }
000048  bd70              POP      {r4-r6,pc}
;;;991    
                          ENDP


                          AREA ||i.ADC_InjectedDiscModeCmd||, CODE, READONLY, ALIGN=1

                  ADC_InjectedDiscModeCmd PROC
;;;765      */
;;;766    void ADC_InjectedDiscModeCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;767    {
;;;768      /* Check the parameters */
;;;769      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;770      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;771      if (NewState != DISABLE)
;;;772      {
;;;773        /* Enable the selected ADC injected discontinuous mode */
;;;774        ADCx->CR1 |= CR1_JDISCEN_Set;
;;;775      }
;;;776      else
;;;777      {
;;;778        /* Disable the selected ADC injected discontinuous mode */
;;;779        ADCx->CR1 &= CR1_JDISCEN_Reset;
000002  6841              LDR      r1,[r0,#4]
000004  d002              BEQ      |L27.12|
000006  f4415180          ORR      r1,r1,#0x1000         ;774
00000a  e001              B        |L27.16|
                  |L27.12|
00000c  f4215180          BIC      r1,r1,#0x1000
                  |L27.16|
000010  6041              STR      r1,[r0,#4]            ;774
;;;780      }
;;;781    }
000012  4770              BX       lr
;;;782    
                          ENDP


                          AREA ||i.ADC_InjectedSequencerLengthConfig||, CODE, READONLY, ALIGN=1

                  ADC_InjectedSequencerLengthConfig PROC
;;;998      */
;;;999    void ADC_InjectedSequencerLengthConfig(ADC_TypeDef* ADCx, uint8_t Length)
000000  6b82              LDR      r2,[r0,#0x38]
;;;1000   {
;;;1001     uint32_t tmpreg1 = 0;
;;;1002     uint32_t tmpreg2 = 0;
;;;1003     /* Check the parameters */
;;;1004     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1005     assert_param(IS_ADC_INJECTED_LENGTH(Length));
;;;1006     
;;;1007     /* Get the old register value */
;;;1008     tmpreg1 = ADCx->JSQR;
;;;1009     /* Clear the old injected sequnence lenght JL bits */
;;;1010     tmpreg1 &= JSQR_JL_Reset;
000002  1e49              SUBS     r1,r1,#1
000004  f4221240          BIC      r2,r2,#0x300000
;;;1011     /* Set the injected sequnence lenght JL bits */
;;;1012     tmpreg2 = Length - 1; 
;;;1013     tmpreg1 |= tmpreg2 << 20;
000008  ea425101          ORR      r1,r2,r1,LSL #20
;;;1014     /* Store the new register value */
;;;1015     ADCx->JSQR = tmpreg1;
00000c  6381              STR      r1,[r0,#0x38]
;;;1016   }
00000e  4770              BX       lr
;;;1017   
                          ENDP


                          AREA ||i.ADC_RegularChannelConfig||, CODE, READONLY, ALIGN=1

                  ADC_RegularChannelConfig PROC
;;;595      */
;;;596    void ADC_RegularChannelConfig(ADC_TypeDef* ADCx, uint8_t ADC_Channel, uint8_t Rank, uint8_t ADC_SampleTime)
000000  b570              PUSH     {r4-r6,lr}
;;;597    {
;;;598      uint32_t tmpreg1 = 0, tmpreg2 = 0;
;;;599      /* Check the parameters */
;;;600      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;601      assert_param(IS_ADC_CHANNEL(ADC_Channel));
;;;602      assert_param(IS_ADC_REGULAR_RANK(Rank));
;;;603      assert_param(IS_ADC_SAMPLE_TIME(ADC_SampleTime));
;;;604      /* if ADC_Channel_10 ... ADC_Channel_17 is selected */
;;;605      if (ADC_Channel > ADC_Channel_9)
;;;606      {
;;;607        /* Get the old register value */
;;;608        tmpreg1 = ADCx->SMPR1;
;;;609        /* Calculate the mask to clear */
;;;610        tmpreg2 = SMPR1_SMP_Set << (3 * (ADC_Channel - 10));
000002  2407              MOVS     r4,#7
000004  2909              CMP      r1,#9                 ;605
000006  d90a              BLS      |L29.30|
000008  68c5              LDR      r5,[r0,#0xc]          ;608
00000a  f1a1060a          SUB      r6,r1,#0xa
00000e  eb060646          ADD      r6,r6,r6,LSL #1
000012  40b4              LSLS     r4,r4,r6
;;;611        /* Clear the old channel sample time */
;;;612        tmpreg1 &= ~tmpreg2;
000014  43a5              BICS     r5,r5,r4
;;;613        /* Calculate the mask to set */
;;;614        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * (ADC_Channel - 10));
000016  40b3              LSLS     r3,r3,r6
;;;615        /* Set the new channel sample time */
;;;616        tmpreg1 |= tmpreg2;
000018  431d              ORRS     r5,r5,r3
;;;617        /* Store the new register value */
;;;618        ADCx->SMPR1 = tmpreg1;
00001a  60c5              STR      r5,[r0,#0xc]
00001c  e007              B        |L29.46|
                  |L29.30|
;;;619      }
;;;620      else /* ADC_Channel include in ADC_Channel_[0..9] */
;;;621      {
;;;622        /* Get the old register value */
;;;623        tmpreg1 = ADCx->SMPR2;
00001e  6905              LDR      r5,[r0,#0x10]
;;;624        /* Calculate the mask to clear */
;;;625        tmpreg2 = SMPR2_SMP_Set << (3 * ADC_Channel);
000020  eb010641          ADD      r6,r1,r1,LSL #1
000024  40b4              LSLS     r4,r4,r6
;;;626        /* Clear the old channel sample time */
;;;627        tmpreg1 &= ~tmpreg2;
000026  43a5              BICS     r5,r5,r4
;;;628        /* Calculate the mask to set */
;;;629        tmpreg2 = (uint32_t)ADC_SampleTime << (3 * ADC_Channel);
000028  40b3              LSLS     r3,r3,r6
;;;630        /* Set the new channel sample time */
;;;631        tmpreg1 |= tmpreg2;
00002a  431d              ORRS     r5,r5,r3
;;;632        /* Store the new register value */
;;;633        ADCx->SMPR2 = tmpreg1;
00002c  6105              STR      r5,[r0,#0x10]
                  |L29.46|
;;;634      }
;;;635      /* For Rank 1 to 6 */
;;;636      if (Rank < 7)
;;;637      {
;;;638        /* Get the old register value */
;;;639        tmpreg1 = ADCx->SQR3;
;;;640        /* Calculate the mask to clear */
;;;641        tmpreg2 = SQR3_SQ_Set << (5 * (Rank - 1));
00002e  231f              MOVS     r3,#0x1f
000030  2a07              CMP      r2,#7                 ;636
000032  d209              BCS      |L29.72|
000034  6b44              LDR      r4,[r0,#0x34]         ;639
000036  1e52              SUBS     r2,r2,#1              ;639
000038  eb020282          ADD      r2,r2,r2,LSL #2
00003c  4093              LSLS     r3,r3,r2
;;;642        /* Clear the old SQx bits for the selected rank */
;;;643        tmpreg1 &= ~tmpreg2;
00003e  439c              BICS     r4,r4,r3
;;;644        /* Calculate the mask to set */
;;;645        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 1));
000040  4091              LSLS     r1,r1,r2
;;;646        /* Set the SQx bits for the selected rank */
;;;647        tmpreg1 |= tmpreg2;
000042  430c              ORRS     r4,r4,r1
;;;648        /* Store the new register value */
;;;649        ADCx->SQR3 = tmpreg1;
000044  6344              STR      r4,[r0,#0x34]
;;;650      }
;;;651      /* For Rank 7 to 12 */
;;;652      else if (Rank < 13)
;;;653      {
;;;654        /* Get the old register value */
;;;655        tmpreg1 = ADCx->SQR2;
;;;656        /* Calculate the mask to clear */
;;;657        tmpreg2 = SQR2_SQ_Set << (5 * (Rank - 7));
;;;658        /* Clear the old SQx bits for the selected rank */
;;;659        tmpreg1 &= ~tmpreg2;
;;;660        /* Calculate the mask to set */
;;;661        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 7));
;;;662        /* Set the SQx bits for the selected rank */
;;;663        tmpreg1 |= tmpreg2;
;;;664        /* Store the new register value */
;;;665        ADCx->SQR2 = tmpreg1;
;;;666      }
;;;667      /* For Rank 13 to 16 */
;;;668      else
;;;669      {
;;;670        /* Get the old register value */
;;;671        tmpreg1 = ADCx->SQR1;
;;;672        /* Calculate the mask to clear */
;;;673        tmpreg2 = SQR1_SQ_Set << (5 * (Rank - 13));
;;;674        /* Clear the old SQx bits for the selected rank */
;;;675        tmpreg1 &= ~tmpreg2;
;;;676        /* Calculate the mask to set */
;;;677        tmpreg2 = (uint32_t)ADC_Channel << (5 * (Rank - 13));
;;;678        /* Set the SQx bits for the selected rank */
;;;679        tmpreg1 |= tmpreg2;
;;;680        /* Store the new register value */
;;;681        ADCx->SQR1 = tmpreg1;
;;;682      }
;;;683    }
000046  bd70              POP      {r4-r6,pc}
                  |L29.72|
000048  2a0d              CMP      r2,#0xd               ;652
00004a  d209              BCS      |L29.96|
00004c  6b04              LDR      r4,[r0,#0x30]         ;655
00004e  1fd2              SUBS     r2,r2,#7              ;655
000050  eb020282          ADD      r2,r2,r2,LSL #2       ;657
000054  4093              LSLS     r3,r3,r2              ;657
000056  439c              BICS     r4,r4,r3              ;659
000058  4091              LSLS     r1,r1,r2              ;661
00005a  430c              ORRS     r4,r4,r1              ;663
00005c  6304              STR      r4,[r0,#0x30]         ;665
00005e  bd70              POP      {r4-r6,pc}
                  |L29.96|
000060  6ac4              LDR      r4,[r0,#0x2c]         ;671
000062  3a0d              SUBS     r2,r2,#0xd            ;671
000064  eb020282          ADD      r2,r2,r2,LSL #2       ;673
000068  4093              LSLS     r3,r3,r2              ;673
00006a  439c              BICS     r4,r4,r3              ;675
00006c  4091              LSLS     r1,r1,r2              ;677
00006e  430c              ORRS     r4,r4,r1              ;679
000070  62c4              STR      r4,[r0,#0x2c]         ;681
000072  bd70              POP      {r4-r6,pc}
;;;684    
                          ENDP


                          AREA ||i.ADC_ResetCalibration||, CODE, READONLY, ALIGN=1

                  ADC_ResetCalibration PROC
;;;384      */
;;;385    void ADC_ResetCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;386    {
;;;387      /* Check the parameters */
;;;388      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;389      /* Resets the selected ADC calibration registers */  
;;;390      ADCx->CR2 |= CR2_RSTCAL_Set;
000002  f0410108          ORR      r1,r1,#8
000006  6081              STR      r1,[r0,#8]
;;;391    }
000008  4770              BX       lr
;;;392    
                          ENDP


                          AREA ||i.ADC_SetInjectedOffset||, CODE, READONLY, ALIGN=1

                  ADC_SetInjectedOffset PROC
;;;1030     */
;;;1031   void ADC_SetInjectedOffset(ADC_TypeDef* ADCx, uint8_t ADC_InjectedChannel, uint16_t Offset)
000000  b508              PUSH     {r3,lr}
;;;1032   {
;;;1033     __IO uint32_t tmp = 0;
;;;1034     
;;;1035     /* Check the parameters */
;;;1036     assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;1037     assert_param(IS_ADC_INJECTED_CHANNEL(ADC_InjectedChannel));
;;;1038     assert_param(IS_ADC_OFFSET(Offset));  
;;;1039     
;;;1040     tmp = (uint32_t)ADCx;
;;;1041     tmp += ADC_InjectedChannel;
000002  4408              ADD      r0,r0,r1
;;;1042     
;;;1043     /* Set the selected injected channel data offset */
;;;1044     *(__IO uint32_t *) tmp = (uint32_t)Offset;
000004  9000              STR      r0,[sp,#0]
000006  6002              STR      r2,[r0,#0]
;;;1045   }
000008  bd08              POP      {r3,pc}
;;;1046   
                          ENDP


                          AREA ||i.ADC_SoftwareStartConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartConvCmd PROC
;;;462      */
;;;463    void ADC_SoftwareStartConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;464    {
;;;465      /* Check the parameters */
;;;466      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;467      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;468      if (NewState != DISABLE)
;;;469      {
;;;470        /* Enable the selected ADC conversion on external event and start the selected
;;;471           ADC conversion */
;;;472        ADCx->CR2 |= CR2_EXTTRIG_SWSTART_Set;
;;;473      }
;;;474      else
;;;475      {
;;;476        /* Disable the selected ADC conversion on external event and stop the selected
;;;477           ADC conversion */
;;;478        ADCx->CR2 &= CR2_EXTTRIG_SWSTART_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L32.12|
000006  f44101a0          ORR      r1,r1,#0x500000       ;472
00000a  e001              B        |L32.16|
                  |L32.12|
00000c  f42101a0          BIC      r1,r1,#0x500000
                  |L32.16|
000010  6081              STR      r1,[r0,#8]            ;472
;;;479      }
;;;480    }
000012  4770              BX       lr
;;;481    
                          ENDP


                          AREA ||i.ADC_SoftwareStartInjectedConvCmd||, CODE, READONLY, ALIGN=1

                  ADC_SoftwareStartInjectedConvCmd PROC
;;;854      */
;;;855    void ADC_SoftwareStartInjectedConvCmd(ADC_TypeDef* ADCx, FunctionalState NewState)
000000  2900              CMP      r1,#0
;;;856    {
;;;857      /* Check the parameters */
;;;858      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;859      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;860      if (NewState != DISABLE)
;;;861      {
;;;862        /* Enable the selected ADC conversion for injected group on external event and start the selected
;;;863           ADC injected conversion */
;;;864        ADCx->CR2 |= CR2_JEXTTRIG_JSWSTART_Set;
;;;865      }
;;;866      else
;;;867      {
;;;868        /* Disable the selected ADC conversion on external event for injected group and stop the selected
;;;869           ADC injected conversion */
;;;870        ADCx->CR2 &= CR2_JEXTTRIG_JSWSTART_Reset;
000002  6881              LDR      r1,[r0,#8]
000004  d002              BEQ      |L33.12|
000006  f4411102          ORR      r1,r1,#0x208000       ;864
00000a  e001              B        |L33.16|
                  |L33.12|
00000c  f4211102          BIC      r1,r1,#0x208000
                  |L33.16|
000010  6081              STR      r1,[r0,#8]            ;864
;;;871      }
;;;872    }
000012  4770              BX       lr
;;;873    
                          ENDP


                          AREA ||i.ADC_StartCalibration||, CODE, READONLY, ALIGN=1

                  ADC_StartCalibration PROC
;;;422      */
;;;423    void ADC_StartCalibration(ADC_TypeDef* ADCx)
000000  6881              LDR      r1,[r0,#8]
;;;424    {
;;;425      /* Check the parameters */
;;;426      assert_param(IS_ADC_ALL_PERIPH(ADCx));
;;;427      /* Enable the selected ADC calibration process */  
;;;428      ADCx->CR2 |= CR2_CAL_Set;
000002  f0410104          ORR      r1,r1,#4
000006  6081              STR      r1,[r0,#8]
;;;429    }
000008  4770              BX       lr
;;;430    
                          ENDP


                          AREA ||i.ADC_StructInit||, CODE, READONLY, ALIGN=1

                  ADC_StructInit PROC
;;;280      */
;;;281    void ADC_StructInit(ADC_InitTypeDef* ADC_InitStruct)
000000  2100              MOVS     r1,#0
;;;282    {
;;;283      /* Reset ADC init structure parameters values */
;;;284      /* Initialize the ADC_Mode member */
;;;285      ADC_InitStruct->ADC_Mode = ADC_Mode_Independent;
;;;286      /* initialize the ADC_ScanConvMode member */
;;;287      ADC_InitStruct->ADC_ScanConvMode = DISABLE;
000002  6001              STR      r1,[r0,#0]
000004  7101              STRB     r1,[r0,#4]
;;;288      /* Initialize the ADC_ContinuousConvMode member */
;;;289      ADC_InitStruct->ADC_ContinuousConvMode = DISABLE;
000006  7141              STRB     r1,[r0,#5]
;;;290      /* Initialize the ADC_ExternalTrigConv member */
;;;291      ADC_InitStruct->ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;
;;;292      /* Initialize the ADC_DataAlign member */
;;;293      ADC_InitStruct->ADC_DataAlign = ADC_DataAlign_Right;
000008  6081              STR      r1,[r0,#8]
;;;294      /* Initialize the ADC_NbrOfChannel member */
;;;295      ADC_InitStruct->ADC_NbrOfChannel = 1;
00000a  60c1              STR      r1,[r0,#0xc]
00000c  2101              MOVS     r1,#1
00000e  7401              STRB     r1,[r0,#0x10]
;;;296    }
000010  4770              BX       lr
;;;297    
                          ENDP


                          AREA ||i.ADC_TempSensorVrefintCmd||, CODE, READONLY, ALIGN=2

                  ADC_TempSensorVrefintCmd PROC
;;;1172     */
;;;1173   void ADC_TempSensorVrefintCmd(FunctionalState NewState)
000000  4905              LDR      r1,|L36.24|
;;;1174   {
;;;1175     /* Check the parameters */
;;;1176     assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;1177     if (NewState != DISABLE)
000002  2800              CMP      r0,#0
;;;1178     {
;;;1179       /* Enable the temperature sensor and Vrefint channel*/
;;;1180       ADC1->CR2 |= CR2_TSVREFE_Set;
;;;1181     }
;;;1182     else
;;;1183     {
;;;1184       /* Disable the temperature sensor and Vrefint channel*/
;;;1185       ADC1->CR2 &= CR2_TSVREFE_Reset;
000004  6808              LDR      r0,[r1,#0]
000006  d002              BEQ      |L36.14|
000008  f4400000          ORR      r0,r0,#0x800000       ;1180
00000c  e001              B        |L36.18|
                  |L36.14|
00000e  f4200000          BIC      r0,r0,#0x800000
                  |L36.18|
000012  6008              STR      r0,[r1,#0]            ;1180
;;;1186     }
;;;1187   }
000014  4770              BX       lr
;;;1188   
                          ENDP

000016  0000              DCW      0x0000
                  |L36.24|
                          DCD      0x40012408

;*** Start embedded assembler ***

#line 1 "..\\..\\Libraries\\STM32F10x_StdPeriph_Driver\\src\\stm32f10x_adc.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_adc_c_e11a2ea2____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___15_stm32f10x_adc_c_e11a2ea2____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_stm32f10x_adc_c_e11a2ea2____REVSH|
#line 128
|__asm___15_stm32f10x_adc_c_e11a2ea2____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
