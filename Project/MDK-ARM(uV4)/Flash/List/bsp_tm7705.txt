; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_tm7705.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_tm7705.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_tm7705.crf ..\..\User\bsp\src\bsp_tm7705.c]
                          THUMB

                          AREA ||i.TM7705_CalibSelf||, CODE, READONLY, ALIGN=1

                  TM7705_CalibSelf PROC
;;;587    */
;;;588    void TM7705_CalibSelf(uint8_t _ch)
000000  b510              PUSH     {r4,lr}
;;;589    {
;;;590    	if (_ch == 1)
000002  2801              CMP      r0,#1
000004  d00b              BEQ      |L1.30|
;;;591    	{
;;;592    		/* 自校准CH1 */
;;;593    		TM7705_WriteByte(REG_SETUP | WRITE | CH_1);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
;;;594    		TM7705_WriteByte(MD_CAL_SELF | __CH1_GAIN_BIPOLAR_BUF | FSYNC_0);/* 启动自校准 */
;;;595    		TM7705_WaitDRDY();	/* 等待内部操作完成 --- 时间较长，约180ms */
;;;596    	}
;;;597    	else if (_ch == 2)
000006  2802              CMP      r0,#2
000008  d10b              BNE      |L1.34|
;;;598    	{
;;;599    		/* 自校准CH2 */
;;;600    		TM7705_WriteByte(REG_SETUP | WRITE | CH_2);	/* 写通信寄存器，下一步是写设置寄存器，通道2 */
00000a  2011              MOVS     r0,#0x11
                  |L1.12|
00000c  f7fffffe          BL       TM7705_WriteByte
;;;601    		TM7705_WriteByte(MD_CAL_SELF | __CH2_GAIN_BIPOLAR_BUF | FSYNC_0);	/* 启动自校准 */
000010  2046              MOVS     r0,#0x46
000012  f7fffffe          BL       TM7705_WriteByte
;;;602    		TM7705_WaitDRDY();	/* 等待内部操作完成  --- 时间较长，约180ms */
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      TM7705_WaitDRDY
                  |L1.30|
00001e  2010              MOVS     r0,#0x10              ;593
000020  e7f4              B        |L1.12|
                  |L1.34|
;;;603    	}
;;;604    }
000022  bd10              POP      {r4,pc}
;;;605    
                          ENDP


                          AREA ||i.TM7705_CfgSpiHard||, CODE, READONLY, ALIGN=2

                  TM7705_CfgSpiHard PROC
;;;208    */
;;;209    void TM7705_CfgSpiHard(void)
000000  b510              PUSH     {r4,lr}
;;;210    {
000002  b086              SUB      sp,sp,#0x18
;;;211    	SPI_InitTypeDef  SPI_InitStructure;
;;;212    
;;;213    	/* 配置SPI硬件参数 */
;;;214    	SPI_InitStructure.SPI_Direction = SPI_Direction_2Lines_FullDuplex;	/* 数据方向：2线全双工 */
000004  2000              MOVS     r0,#0
000006  f8ad0000          STRH     r0,[sp,#0]
;;;215    	SPI_InitStructure.SPI_Mode = SPI_Mode_Master;		/* STM32的SPI工作模式 ：主机模式 */
00000a  f44f7182          MOV      r1,#0x104
00000e  f8ad1002          STRH     r1,[sp,#2]
;;;216    	SPI_InitStructure.SPI_DataSize = SPI_DataSize_8b;	/* 数据位长度 ： 8位 */
000012  f8ad0004          STRH     r0,[sp,#4]
;;;217    	/* SPI_CPOL和SPI_CPHA结合使用决定时钟和数据采样点的相位关系、
;;;218    	   本例配置: 总线空闲是高电平,第2个边沿（上升沿采样数据)
;;;219    	*/
;;;220    	SPI_InitStructure.SPI_CPOL = SPI_CPOL_High;			/* 时钟上升沿采样数据 */
000016  2102              MOVS     r1,#2
000018  f8ad1006          STRH     r1,[sp,#6]
;;;221    	SPI_InitStructure.SPI_CPHA = SPI_CPHA_2Edge;		/* 时钟的第2个边沿采样数据 */
00001c  2101              MOVS     r1,#1
00001e  f8ad1008          STRH     r1,[sp,#8]
;;;222    	SPI_InitStructure.SPI_NSS = SPI_NSS_Soft;			/* 片选控制方式：软件控制 */
000022  0249              LSLS     r1,r1,#9
000024  f8ad100a          STRH     r1,[sp,#0xa]
;;;223    
;;;224    	/* 设置波特率预分频系数 SPI_BaudRatePrescaler_64 实测SCK周期 800ns ，12.5MHz */
;;;225    	SPI_InitStructure.SPI_BaudRatePrescaler = SPI_BaudRatePrescaler_64;
000028  2128              MOVS     r1,#0x28
00002a  f8ad100c          STRH     r1,[sp,#0xc]
;;;226    
;;;227    	SPI_InitStructure.SPI_FirstBit = SPI_FirstBit_MSB;	/* 数据位传输次序：高位先传 */
00002e  f8ad000e          STRH     r0,[sp,#0xe]
;;;228    	SPI_InitStructure.SPI_CRCPolynomial = 7;			/* CRC多项式寄存器，复位后为7。本例程不用 */
000032  2007              MOVS     r0,#7
;;;229    	SPI_Init(SPI1, &SPI_InitStructure);
000034  4c06              LDR      r4,|L2.80|
000036  f8ad0010          STRH     r0,[sp,#0x10]         ;228
00003a  4669              MOV      r1,sp
00003c  4620              MOV      r0,r4
00003e  f7fffffe          BL       SPI_Init
;;;230    
;;;231    	SPI_Cmd(SPI1, ENABLE);				/* 使能SPI  */
000042  2101              MOVS     r1,#1
000044  4620              MOV      r0,r4
000046  f7fffffe          BL       SPI_Cmd
;;;232    }
00004a  b006              ADD      sp,sp,#0x18
00004c  bd10              POP      {r4,pc}
;;;233    
                          ENDP

00004e  0000              DCW      0x0000
                  |L2.80|
                          DCD      0x40013000

                          AREA ||i.TM7705_GetAdc1||, CODE, READONLY, ALIGN=2

                  TM7705_GetAdc1 PROC
;;;761    */
;;;762    uint16_t TM7705_GetAdc1(void)
000000  4803              LDR      r0,|L3.16|
;;;763    {
;;;764    	/* 如果初始化时未检测到芯片则快速返回，避免影响主程序响应速度 */
;;;765    	if (g_TM7705_OK == 0)
000002  7801              LDRB     r1,[r0,#0]  ; g_TM7705_OK
000004  b109              CBZ      r1,|L3.10|
;;;766    	{
;;;767    		return 0;
;;;768    	}
;;;769    
;;;770    	return g_TM7705_Adc1;
000006  8840              LDRH     r0,[r0,#2]  ; g_TM7705_Adc1
;;;771    }
000008  4770              BX       lr
                  |L3.10|
00000a  2000              MOVS     r0,#0                 ;767
00000c  4770              BX       lr
;;;772    
                          ENDP

00000e  0000              DCW      0x0000
                  |L3.16|
                          DCD      ||.data||

                          AREA ||i.TM7705_GetAdc2||, CODE, READONLY, ALIGN=2

                  TM7705_GetAdc2 PROC
;;;780    */
;;;781    uint16_t TM7705_GetAdc2(void)
000000  4803              LDR      r0,|L4.16|
;;;782    {
;;;783    	/* 如果初始化时未检测到芯片则快速返回，避免影响主程序响应速度 */
;;;784    	if (g_TM7705_OK == 0)
000002  7801              LDRB     r1,[r0,#0]  ; g_TM7705_OK
000004  b109              CBZ      r1,|L4.10|
;;;785    	{
;;;786    		return 0;
;;;787    	}
;;;788    
;;;789    	return g_TM7705_Adc2;
000006  8880              LDRH     r0,[r0,#4]  ; g_TM7705_Adc2
;;;790    }
000008  4770              BX       lr
                  |L4.10|
00000a  2000              MOVS     r0,#0                 ;786
00000c  4770              BX       lr
;;;791    
                          ENDP

00000e  0000              DCW      0x0000
                  |L4.16|
                          DCD      ||.data||

                          AREA ||i.TM7705_Read2Byte||, CODE, READONLY, ALIGN=1

                  TM7705_Read2Byte PROC
;;;416    */
;;;417    static uint16_t TM7705_Read2Byte(void)
000000  b510              PUSH     {r4,lr}
;;;418    {
;;;419    	uint16_t read;
;;;420    
;;;421    	TM7705_SetCS(0);
000002  2000              MOVS     r0,#0
000004  f7fffffe          BL       TM7705_SetCS
;;;422    	read = bsp_spiRead1();
000008  f7fffffe          BL       bsp_spiRead1
;;;423    	read <<= 8;
00000c  f64f71ff          MOV      r1,#0xffff
000010  ea012400          AND      r4,r1,r0,LSL #8
;;;424    	read += bsp_spiRead1();
000014  f7fffffe          BL       bsp_spiRead1
000018  4420              ADD      r0,r0,r4
00001a  b284              UXTH     r4,r0
;;;425    	TM7705_SetCS(1);
00001c  2001              MOVS     r0,#1
00001e  f7fffffe          BL       TM7705_SetCS
;;;426    
;;;427    	return read;
000022  4620              MOV      r0,r4
;;;428    }
000024  bd10              POP      {r4,pc}
;;;429    
                          ENDP


                          AREA ||i.TM7705_ReadAdc||, CODE, READONLY, ALIGN=2

                  TM7705_ReadAdc PROC
;;;667    */
;;;668    uint16_t TM7705_ReadAdc(uint8_t _ch)
000000  b570              PUSH     {r4-r6,lr}
;;;669    {
000002  4605              MOV      r5,r0
;;;670    	uint8_t i;
;;;671    	uint16_t read = 0;
;;;672    
;;;673    	/* 为了避免通道切换造成读数失效，读2次 */
;;;674    	for (i = 0; i < 2; i++)
000004  f05f0400          MOVS.W   r4,#0
                  |L6.8|
;;;675    	{
;;;676    		TM7705_WaitDRDY();		/* 等待DRDY口线为0 */
000008  f7fffffe          BL       TM7705_WaitDRDY
;;;677    
;;;678    		if (_ch == 1)
00000c  2d01              CMP      r5,#1
00000e  d002              BEQ      |L6.22|
;;;679    		{
;;;680    			TM7705_WriteByte(0x38);
;;;681    		}
;;;682    		else if (_ch == 2)
000010  2d02              CMP      r5,#2
000012  d002              BEQ      |L6.26|
000014  e004              B        |L6.32|
                  |L6.22|
000016  2038              MOVS     r0,#0x38              ;680
000018  e000              B        |L6.28|
                  |L6.26|
;;;683    		{
;;;684    			TM7705_WriteByte(0x39);
00001a  2039              MOVS     r0,#0x39
                  |L6.28|
00001c  f7fffffe          BL       TM7705_WriteByte
                  |L6.32|
;;;685    		}
;;;686    
;;;687    		read = TM7705_Read2Byte();
000020  f7fffffe          BL       TM7705_Read2Byte
000024  1c64              ADDS     r4,r4,#1
000026  b2e4              UXTB     r4,r4                 ;674
000028  2c02              CMP      r4,#2                 ;674
00002a  d3ed              BCC      |L6.8|
;;;688    	}
;;;689    	return read;
;;;690    }
00002c  bd70              POP      {r4-r6,pc}
;;;691    
                          ENDP


                          AREA ||i.TM7705_ReadReg||, CODE, READONLY, ALIGN=1

                  TM7705_ReadReg PROC
;;;536    */
;;;537    uint32_t TM7705_ReadReg(uint8_t _RegID)
000000  b510              PUSH     {r4,lr}
;;;538    {
;;;539    	uint8_t bits;
;;;540    	uint32_t read;
;;;541    
;;;542    	switch (_RegID)
000002  2860              CMP      r0,#0x60
000004  d011              BEQ      |L7.42|
000006  dc05              BGT      |L7.20|
000008  b168              CBZ      r0,|L7.38|
00000a  2810              CMP      r0,#0x10
00000c  d00b              BEQ      |L7.38|
00000e  2820              CMP      r0,#0x20
000010  d106              BNE      |L7.32|
000012  e008              B        |L7.38|
                  |L7.20|
000014  2861              CMP      r0,#0x61
000016  d008              BEQ      |L7.42|
000018  2870              CMP      r0,#0x70
00001a  d006              BEQ      |L7.42|
00001c  2871              CMP      r0,#0x71
00001e  d004              BEQ      |L7.42|
                  |L7.32|
;;;543    	{
;;;544    		case REG_COMM:		/* 通信寄存器 */
;;;545    		case REG_SETUP:		/* 设置寄存器 8bit */
;;;546    		case REG_CLOCK:		/* 时钟寄存器 8bit */
;;;547    			bits = 8;
;;;548    			break;
;;;549    
;;;550    		case REG_ZERO_CH1:	/* CH1 偏移寄存器 24bit */
;;;551    		case REG_FULL_CH1:	/* CH1 满量程寄存器 24bit */
;;;552    		case REG_ZERO_CH2:	/* CH2 偏移寄存器 24bit */
;;;553    		case REG_FULL_CH2:	/* CH2 满量程寄存器 24bit*/
;;;554    			bits = 24;
;;;555    			break;
;;;556    
;;;557    		case REG_DATA:		/* 数据寄存器 16bit */
;;;558    		default:
;;;559    			return 0xFFFFFFFF;
000020  f04f30ff          MOV      r0,#0xffffffff
;;;560    	}
;;;561    
;;;562    	TM7705_WriteByte(_RegID | READ);	/* 写通信寄存器, 指定下一步是写操作，并指定写哪个寄存器 */
;;;563    
;;;564    	if (bits == 16)
;;;565    	{
;;;566    		read = TM7705_Read2Byte();
;;;567    	}
;;;568    	else if (bits == 8)
;;;569    	{
;;;570    		read = TM7705_ReadByte();
;;;571    	}
;;;572    	else	/* 24bit */
;;;573    	{
;;;574    		read = TM7705_Read3Byte();
;;;575    	}
;;;576    	return read;
;;;577    }
000024  bd10              POP      {r4,pc}
                  |L7.38|
000026  2408              MOVS     r4,#8                 ;547
000028  e000              B        |L7.44|
                  |L7.42|
00002a  2418              MOVS     r4,#0x18              ;554
                  |L7.44|
00002c  f0400008          ORR      r0,r0,#8              ;562
000030  f7fffffe          BL       TM7705_WriteByte
000034  2c10              CMP      r4,#0x10              ;564
000036  d014              BEQ      |L7.98|
000038  2c08              CMP      r4,#8                 ;568
00003a  f04f0000          MOV      r0,#0                 ;568
00003e  d014              BEQ      |L7.106|
000040  f7fffffe          BL       TM7705_SetCS
000044  f7fffffe          BL       bsp_spiRead1
000048  0204              LSLS     r4,r0,#8              ;568
00004a  f7fffffe          BL       bsp_spiRead1
00004e  4420              ADD      r0,r0,r4              ;568
000050  0204              LSLS     r4,r0,#8              ;568
000052  f7fffffe          BL       bsp_spiRead1
000056  4404              ADD      r4,r4,r0              ;568
                  |L7.88|
000058  2001              MOVS     r0,#1                 ;568
00005a  f7fffffe          BL       TM7705_SetCS
00005e  4620              MOV      r0,r4                 ;568
000060  bd10              POP      {r4,pc}
                  |L7.98|
000062  e8bd4010          POP      {r4,lr}               ;566
000066  f7ffbffe          B.W      TM7705_Read2Byte
                  |L7.106|
00006a  f7fffffe          BL       TM7705_SetCS
00006e  f7fffffe          BL       bsp_spiRead1
000072  4604              MOV      r4,r0                 ;566
000074  e7f0              B        |L7.88|
;;;578    
                          ENDP


                          AREA ||i.TM7705_Scan1||, CODE, READONLY, ALIGN=2

                  TM7705_Scan1 PROC
;;;738    */
;;;739    void TM7705_Scan1(void)
000000  b510              PUSH     {r4,lr}
;;;740    {
;;;741    	/* 如果初始化时未检测到芯片则快速返回，避免影响主程序响应速度 */
;;;742    	if (g_TM7705_OK == 0)
000002  4c08              LDR      r4,|L8.36|
000004  7820              LDRB     r0,[r4,#0]  ; g_TM7705_OK
000006  2800              CMP      r0,#0                 ;740
000008  d00b              BEQ      |L8.34|
;;;743    	{
;;;744    		return;
;;;745    	}
;;;746    
;;;747    	if (DRDY_IS_LOW())
00000a  2140              MOVS     r1,#0x40
00000c  4806              LDR      r0,|L8.40|
00000e  f7fffffe          BL       GPIO_ReadInputDataBit
000012  2800              CMP      r0,#0
000014  d105              BNE      |L8.34|
;;;748    	{
;;;749    		TM7705_WriteByte(0x38);
000016  2038              MOVS     r0,#0x38
000018  f7fffffe          BL       TM7705_WriteByte
;;;750    		g_TM7705_Adc1 = TM7705_Read2Byte();
00001c  f7fffffe          BL       TM7705_Read2Byte
000020  8060              STRH     r0,[r4,#2]
                  |L8.34|
;;;751    	}
;;;752    }
000022  bd10              POP      {r4,pc}
;;;753    
                          ENDP

                  |L8.36|
                          DCD      ||.data||
                  |L8.40|
                          DCD      0x40011c00

                          AREA ||i.TM7705_Scan2||, CODE, READONLY, ALIGN=2

                  TM7705_Scan2 PROC
;;;700    */
;;;701    void TM7705_Scan2(void)
000000  b510              PUSH     {r4,lr}
;;;702    {
;;;703    	static uint8_t s_ch = 1;
;;;704    
;;;705    	/* 如果初始化时未检测到芯片则快速返回，避免影响主程序响应速度 */
;;;706    	if (g_TM7705_OK == 0)
000002  4c0f              LDR      r4,|L9.64|
000004  7820              LDRB     r0,[r4,#0]  ; g_TM7705_OK
000006  2800              CMP      r0,#0                 ;702
000008  d010              BEQ      |L9.44|
;;;707    	{
;;;708    		return;
;;;709    	}
;;;710    
;;;711    	if (DRDY_IS_LOW())
00000a  2140              MOVS     r1,#0x40
00000c  480d              LDR      r0,|L9.68|
00000e  f7fffffe          BL       GPIO_ReadInputDataBit
000012  2800              CMP      r0,#0
000014  d10a              BNE      |L9.44|
;;;712    	{
;;;713    		/* 双通道交替读 */
;;;714    		if (s_ch == 1)
000016  7860              LDRB     r0,[r4,#1]  ; s_ch
000018  2801              CMP      r0,#1
00001a  d008              BEQ      |L9.46|
;;;715    		{
;;;716    			TM7705_WriteByte(0x38);
;;;717    			g_TM7705_Adc2 = TM7705_Read2Byte();
;;;718    
;;;719    			s_ch = 2;
;;;720    		}
;;;721    		else
;;;722    		{
;;;723    			TM7705_WriteByte(0x39);
00001c  2039              MOVS     r0,#0x39
00001e  f7fffffe          BL       TM7705_WriteByte
;;;724    			g_TM7705_Adc1 = TM7705_Read2Byte();
000022  f7fffffe          BL       TM7705_Read2Byte
000026  8060              STRH     r0,[r4,#2]
;;;725    
;;;726    			s_ch = 1;
000028  2001              MOVS     r0,#1
                  |L9.42|
00002a  7060              STRB     r0,[r4,#1]
                  |L9.44|
;;;727    		}
;;;728    	}
;;;729    }
00002c  bd10              POP      {r4,pc}
                  |L9.46|
00002e  2038              MOVS     r0,#0x38              ;716
000030  f7fffffe          BL       TM7705_WriteByte
000034  f7fffffe          BL       TM7705_Read2Byte
000038  80a0              STRH     r0,[r4,#4]            ;717
00003a  2002              MOVS     r0,#2                 ;719
00003c  e7f5              B        |L9.42|
;;;730    
                          ENDP

00003e  0000              DCW      0x0000
                  |L9.64|
                          DCD      ||.data||
                  |L9.68|
                          DCD      0x40011c00

                          AREA ||i.TM7705_SetCS||, CODE, READONLY, ALIGN=2

                  TM7705_SetCS PROC
;;;241    */
;;;242    void TM7705_SetCS(uint8_t _level)
000000  b570              PUSH     {r4-r6,lr}
;;;243    {
;;;244    	if (_level == 0)
;;;245    	{
;;;246    		bsp_SpiBusEnter();	/* 占用SPI总线， 用于总线共享 */
;;;247    
;;;248    		#ifdef SOFT_SPI		/* 软件SPI */
;;;249    			bsp_SetSpiSck(1);
;;;250    			TM7705_CS_0();
;;;251    		#endif
;;;252    
;;;253    		#ifdef HARD_SPI		/* 硬件SPI */
;;;254    			bsp_SPI_Init(SPI_Direction_2Lines_FullDuplex | SPI_Mode_Master | SPI_DataSize_8b
;;;255    				| SPI_CPOL_High | SPI_CPHA_2Edge | SPI_NSS_Soft | SPI_BaudRatePrescaler_64 | SPI_FirstBit_MSB);
;;;256    
;;;257    			TM7705_CS_0();
000002  4d08              LDR      r5,|L10.36|
000004  2408              MOVS     r4,#8
000006  b120              CBZ      r0,|L10.18|
;;;258    		#endif
;;;259    	}
;;;260    	else
;;;261    	{
;;;262    		TM7705_CS_1();
000008  612c              STR      r4,[r5,#0x10]
;;;263    
;;;264    		bsp_SpiBusExit();	/* 释放SPI总线， 用于总线共享 */
00000a  e8bd4070          POP      {r4-r6,lr}
00000e  f7ffbffe          B.W      bsp_SpiBusExit
                  |L10.18|
000012  f7fffffe          BL       bsp_SpiBusEnter
000016  f240302f          MOV      r0,#0x32f             ;254
00001a  f7fffffe          BL       bsp_SPI_Init
00001e  616c              STR      r4,[r5,#0x14]         ;257
;;;265    	}
;;;266    }
000020  bd70              POP      {r4-r6,pc}
;;;267    
                          ENDP

000022  0000              DCW      0x0000
                  |L10.36|
                          DCD      0x40011000

                          AREA ||i.TM7705_SytemCalibFull||, CODE, READONLY, ALIGN=1

                  TM7705_SytemCalibFull PROC
;;;641    */
;;;642    void TM7705_SytemCalibFull(uint8_t _ch)
000000  b510              PUSH     {r4,lr}
;;;643    {
;;;644    	if (_ch == 1)
000002  2801              CMP      r0,#1
000004  d00b              BEQ      |L11.30|
;;;645    	{
;;;646    		/* 校准CH1 */
;;;647    		TM7705_WriteByte(REG_SETUP | WRITE | CH_1);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
;;;648    		TM7705_WriteByte(MD_CAL_FULL | __CH1_GAIN_BIPOLAR_BUF | FSYNC_0);/* 启动自校准 */
;;;649    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
;;;650    	}
;;;651    	else if (_ch == 2)
000006  2802              CMP      r0,#2
000008  d10b              BNE      |L11.34|
;;;652    	{
;;;653    		/* 校准CH2 */
;;;654    		TM7705_WriteByte(REG_SETUP | WRITE | CH_2);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
00000a  2011              MOVS     r0,#0x11
                  |L11.12|
00000c  f7fffffe          BL       TM7705_WriteByte
;;;655    		TM7705_WriteByte(MD_CAL_FULL | __CH2_GAIN_BIPOLAR_BUF | FSYNC_0);	/* 启动自校准 */
000010  20c6              MOVS     r0,#0xc6
000012  f7fffffe          BL       TM7705_WriteByte
;;;656    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      TM7705_WaitDRDY
                  |L11.30|
00001e  2010              MOVS     r0,#0x10              ;647
000020  e7f4              B        |L11.12|
                  |L11.34|
;;;657    	}
;;;658    }
000022  bd10              POP      {r4,pc}
;;;659    
                          ENDP


                          AREA ||i.TM7705_SytemCalibZero||, CODE, READONLY, ALIGN=1

                  TM7705_SytemCalibZero PROC
;;;614    */
;;;615    void TM7705_SytemCalibZero(uint8_t _ch)
000000  b510              PUSH     {r4,lr}
;;;616    {
;;;617    	if (_ch == 1)
000002  2801              CMP      r0,#1
000004  d00b              BEQ      |L12.30|
;;;618    	{
;;;619    		/* 校准CH1 */
;;;620    		TM7705_WriteByte(REG_SETUP | WRITE | CH_1);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
;;;621    		TM7705_WriteByte(MD_CAL_ZERO | __CH1_GAIN_BIPOLAR_BUF | FSYNC_0);/* 启动自校准 */
;;;622    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
;;;623    	}
;;;624    	else if (_ch == 2)
000006  2802              CMP      r0,#2
000008  d10b              BNE      |L12.34|
;;;625    	{
;;;626    		/* 校准CH2 */
;;;627    		TM7705_WriteByte(REG_SETUP | WRITE | CH_2);	/* 写通信寄存器，下一步是写设置寄存器，通道1 */
00000a  2011              MOVS     r0,#0x11
                  |L12.12|
00000c  f7fffffe          BL       TM7705_WriteByte
;;;628    		TM7705_WriteByte(MD_CAL_ZERO | __CH2_GAIN_BIPOLAR_BUF | FSYNC_0);	/* 启动自校准 */
000010  2086              MOVS     r0,#0x86
000012  f7fffffe          BL       TM7705_WriteByte
;;;629    		TM7705_WaitDRDY();	/* 等待内部操作完成 */
000016  e8bd4010          POP      {r4,lr}
00001a  f7ffbffe          B.W      TM7705_WaitDRDY
                  |L12.30|
00001e  2010              MOVS     r0,#0x10              ;620
000020  e7f4              B        |L12.12|
                  |L12.34|
;;;630    	}
;;;631    }
000022  bd10              POP      {r4,pc}
;;;632    
                          ENDP


                          AREA ||i.TM7705_WaitDRDY||, CODE, READONLY, ALIGN=2

                  TM7705_WaitDRDY PROC
;;;459    */
;;;460    static void TM7705_WaitDRDY(void)
000000  b570              PUSH     {r4-r6,lr}
;;;461    {
;;;462    	uint32_t i;
;;;463    
;;;464    	/* 如果初始化时未检测到芯片则快速返回，避免影响主程序响应速度 */
;;;465    	if (g_TM7705_OK == 0)
000002  480b              LDR      r0,|L13.48|
000004  7800              LDRB     r0,[r0,#0]  ; g_TM7705_OK
000006  2800              CMP      r0,#0                 ;461
000008  d011              BEQ      |L13.46|
;;;466    	{
;;;467    		return;
;;;468    	}
;;;469    
;;;470    	for (i = 0; i < 4000000; i++)
;;;471    	{
;;;472    		if (DRDY_IS_LOW())
00000a  4e0a              LDR      r6,|L13.52|
00000c  4d0a              LDR      r5,|L13.56|
00000e  2400              MOVS     r4,#0                 ;470
                  |L13.16|
000010  2140              MOVS     r1,#0x40
000012  4630              MOV      r0,r6
000014  f7fffffe          BL       GPIO_ReadInputDataBit
000018  b110              CBZ      r0,|L13.32|
00001a  1c64              ADDS     r4,r4,#1
00001c  42ac              CMP      r4,r5                 ;470
00001e  d3f7              BCC      |L13.16|
                  |L13.32|
;;;473    		{
;;;474    			break;
;;;475    		}
;;;476    	}
;;;477    	if (i >= 4000000)
000020  42ac              CMP      r4,r5
000022  d304              BCC      |L13.46|
;;;478    	{
;;;479    		printf("TM7705_WaitDRDY() Time Out ...\r\n");		/* 调试语句. 用语排错 */
000024  e8bd4070          POP      {r4-r6,lr}
000028  a004              ADR      r0,|L13.60|
00002a  f7ffbffe          B.W      __2printf
                  |L13.46|
;;;480    	}
;;;481    }
00002e  bd70              POP      {r4-r6,pc}
;;;482    
                          ENDP

                  |L13.48|
                          DCD      ||.data||
                  |L13.52|
                          DCD      0x40011c00
                  |L13.56|
                          DCD      0x003d0900
                  |L13.60|
00003c  544d3737          DCB      "TM7705_WaitDRDY() Time Out ...\r\n",0
000040  30355f57
000044  61697444
000048  52445928
00004c  29205469
000050  6d65204f
000054  7574202e
000058  2e2e0d0a
00005c  00      
00005d  00                DCB      0
00005e  00                DCB      0
00005f  00                DCB      0

                          AREA ||i.TM7705_WriteByte||, CODE, READONLY, ALIGN=1

                  TM7705_WriteByte PROC
;;;365    */
;;;366    static void TM7705_WriteByte(uint8_t _data)
000000  b510              PUSH     {r4,lr}
;;;367    {
000002  4604              MOV      r4,r0
;;;368    	TM7705_SetCS(0);
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       TM7705_SetCS
;;;369    	bsp_spiWrite1(_data);
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       bsp_spiWrite1
;;;370    	TM7705_SetCS(1);
000010  e8bd4010          POP      {r4,lr}
000014  2001              MOVS     r0,#1
000016  f7ffbffe          B.W      TM7705_SetCS
;;;371    }
;;;372    
                          ENDP


                          AREA ||i.TM7705_WriteReg||, CODE, READONLY, ALIGN=1

                  TM7705_WriteReg PROC
;;;491    */
;;;492    void TM7705_WriteReg(uint8_t _RegID, uint32_t _RegValue)
000000  b510              PUSH     {r4,lr}
;;;493    {
000002  460c              MOV      r4,r1
;;;494    	uint8_t bits;
;;;495    
;;;496    	switch (_RegID)
000004  2860              CMP      r0,#0x60
000006  d012              BEQ      |L15.46|
000008  dc0b              BGT      |L15.34|
00000a  b118              CBZ      r0,|L15.20|
00000c  2810              CMP      r0,#0x10
00000e  d001              BEQ      |L15.20|
000010  2820              CMP      r0,#0x20
000012  d121              BNE      |L15.88|
                  |L15.20|
;;;497    	{
;;;498    		case REG_COMM:		/* 通信寄存器 */
;;;499    		case REG_SETUP:		/* 设置寄存器 8bit */
;;;500    		case REG_CLOCK:		/* 时钟寄存器 8bit */
;;;501    			bits = 8;
;;;502    			break;
;;;503    
;;;504    		case REG_ZERO_CH1:	/* CH1 偏移寄存器 24bit */
;;;505    		case REG_FULL_CH1:	/* CH1 满量程寄存器 24bit */
;;;506    		case REG_ZERO_CH2:	/* CH2 偏移寄存器 24bit */
;;;507    		case REG_FULL_CH2:	/* CH2 满量程寄存器 24bit*/
;;;508    			bits = 24;
;;;509    			break;
;;;510    
;;;511    		case REG_DATA:		/* 数据寄存器 16bit */
;;;512    		default:
;;;513    			return;
;;;514    	}
;;;515    
;;;516    	TM7705_WriteByte(_RegID | WRITE);	/* 写通信寄存器, 指定下一步是写操作，并指定写哪个寄存器 */
000014  f7fffffe          BL       TM7705_WriteByte
;;;517    
;;;518    	if (bits == 8)
;;;519    	{
;;;520    		TM7705_WriteByte((uint8_t)_RegValue);
000018  b2e0              UXTB     r0,r4
00001a  e8bd4010          POP      {r4,lr}
00001e  f7ffbffe          B.W      TM7705_WriteByte
                  |L15.34|
000022  2861              CMP      r0,#0x61              ;496
000024  d003              BEQ      |L15.46|
000026  2870              CMP      r0,#0x70              ;496
000028  d001              BEQ      |L15.46|
00002a  2871              CMP      r0,#0x71              ;496
00002c  d114              BNE      |L15.88|
                  |L15.46|
00002e  f7fffffe          BL       TM7705_WriteByte
000032  2000              MOVS     r0,#0                 ;516
000034  f7fffffe          BL       TM7705_SetCS
000038  f3c44007          UBFX     r0,r4,#16,#8          ;516
00003c  f7fffffe          BL       bsp_spiWrite1
000040  f3c42007          UBFX     r0,r4,#8,#8           ;516
000044  f7fffffe          BL       bsp_spiWrite1
000048  b2e0              UXTB     r0,r4                 ;516
00004a  f7fffffe          BL       bsp_spiWrite1
00004e  e8bd4010          POP      {r4,lr}               ;516
000052  2001              MOVS     r0,#1                 ;516
000054  f7ffbffe          B.W      TM7705_SetCS
                  |L15.88|
;;;521    	}
;;;522    	else	/* 24bit */
;;;523    	{
;;;524    		TM7705_Write3Byte(_RegValue);
;;;525    	}
;;;526    }
000058  bd10              POP      {r4,pc}
;;;527    
                          ENDP


                          AREA ||i.bsp_InitTM7705||, CODE, READONLY, ALIGN=2

                  bsp_InitTM7705 PROC
;;;275    */
;;;276    void bsp_InitTM7705(void)
000000  b5f8              PUSH     {r3-r7,lr}
000002  2101              MOVS     r1,#1
000004  2098              MOVS     r0,#0x98
000006  f7fffffe          BL       RCC_APB2PeriphClockCmd
00000a  2403              MOVS     r4,#3
00000c  f88d4002          STRB     r4,[sp,#2]
000010  2010              MOVS     r0,#0x10
000012  f88d0003          STRB     r0,[sp,#3]
000016  2101              MOVS     r1,#1
000018  4833              LDR      r0,|L16.232|
00001a  f7fffffe          BL       GPIO_PinRemapConfig
00001e  4e33              LDR      r6,|L16.236|
000020  2508              MOVS     r5,#8
000022  f8ad5000          STRH     r5,[sp,#0]
000026  4669              MOV      r1,sp
000028  4630              MOV      r0,r6
00002a  f7fffffe          BL       GPIO_Init
00002e  f8ad5000          STRH     r5,[sp,#0]
000032  4669              MOV      r1,sp
000034  482e              LDR      r0,|L16.240|
000036  f7fffffe          BL       GPIO_Init
00003a  2004              MOVS     r0,#4
00003c  f88d0003          STRB     r0,[sp,#3]
000040  f88d4002          STRB     r4,[sp,#2]
000044  2040              MOVS     r0,#0x40
000046  f8ad0000          STRH     r0,[sp,#0]
00004a  4669              MOV      r1,sp
00004c  4829              LDR      r0,|L16.244|
00004e  f7fffffe          BL       GPIO_Init
;;;277    {
;;;278    	TM7705_ConfigGPIO();
;;;279    	//TM7705_CfgSpiHard();
;;;280    
;;;281    	bsp_DelayMS(10);
000052  200a              MOVS     r0,#0xa
000054  f7fffffe          BL       bsp_DelayMS
000058  2108              MOVS     r1,#8
00005a  4630              MOV      r0,r6
00005c  f7fffffe          BL       GPIO_SetBits
000060  2001              MOVS     r0,#1
000062  f7fffffe          BL       bsp_DelayMS
000066  2108              MOVS     r1,#8
000068  4630              MOV      r0,r6
00006a  f7fffffe          BL       GPIO_ResetBits
00006e  2002              MOVS     r0,#2
000070  f7fffffe          BL       bsp_DelayMS
000074  2108              MOVS     r1,#8
000076  4630              MOV      r0,r6
000078  f7fffffe          BL       GPIO_SetBits
00007c  2001              MOVS     r0,#1
00007e  f7fffffe          BL       bsp_DelayMS
;;;282    
;;;283    	TM7705_ResetHard();		/* 硬件复位 */
;;;284    
;;;285    	/*
;;;286    		在接口序列丢失的情况下，如果在DIN 高电平的写操作持续了足够长的时间（至少 32个串行时钟周期），
;;;287    		TM7705 将会回到默认状态。
;;;288    	*/
;;;289    	bsp_DelayMS(5);
000082  2005              MOVS     r0,#5
000084  f7fffffe          BL       bsp_DelayMS
000088  2000              MOVS     r0,#0
00008a  f7fffffe          BL       TM7705_SetCS
00008e  20ff              MOVS     r0,#0xff
000090  f7fffffe          BL       bsp_spiWrite1
000094  20ff              MOVS     r0,#0xff
000096  f7fffffe          BL       bsp_spiWrite1
00009a  20ff              MOVS     r0,#0xff
00009c  f7fffffe          BL       bsp_spiWrite1
0000a0  20ff              MOVS     r0,#0xff
0000a2  f7fffffe          BL       bsp_spiWrite1
0000a6  2001              MOVS     r0,#1
0000a8  f7fffffe          BL       TM7705_SetCS
;;;290    
;;;291    	TM7705_SyncSPI();		/* 同步SPI接口时序 */
;;;292    
;;;293    	bsp_DelayMS(5);
0000ac  2005              MOVS     r0,#5
0000ae  f7fffffe          BL       bsp_DelayMS
;;;294    
;;;295    	/* 复位之后, 时钟寄存器应该是 0x05 再进入时 08*/
;;;296    	{
;;;297    		uint8_t reg;
;;;298    		
;;;299    		reg = TM7705_ReadReg(REG_CLOCK);
0000b2  2020              MOVS     r0,#0x20
0000b4  f7fffffe          BL       TM7705_ReadReg
0000b8  b2c0              UXTB     r0,r0
;;;300    		if ((reg == 0x05) || (reg == 0x08))
;;;301    		{
;;;302    			g_TM7705_OK = 1;
0000ba  490f              LDR      r1,|L16.248|
0000bc  2805              CMP      r0,#5                 ;300
0000be  d011              BEQ      |L16.228|
0000c0  2808              CMP      r0,#8                 ;300
0000c2  d00f              BEQ      |L16.228|
;;;303    		}
;;;304    		else
;;;305    		{
;;;306    			g_TM7705_OK = 0;
0000c4  2000              MOVS     r0,#0
                  |L16.198|
0000c6  7008              STRB     r0,[r1,#0]
;;;307    		}
;;;308    	}
;;;309    
;;;310    	/* 配置时钟寄存器 */
;;;311    	TM7705_WriteByte(REG_CLOCK | WRITE | CH_1);			/* 先写通信寄存器，下一步是写时钟寄存器 */
0000c8  2020              MOVS     r0,#0x20
0000ca  f7fffffe          BL       TM7705_WriteByte
;;;312    
;;;313    	TM7705_WriteByte(CLKDIS_0 | CLK_4_9152M | FS_50HZ);	/* 刷新速率50Hz */
0000ce  2008              MOVS     r0,#8
0000d0  f7fffffe          BL       TM7705_WriteByte
;;;314    	//TM7705_WriteByte(CLKDIS_0 | CLK_4_9152M | FS_500HZ);	/* 刷新速率500Hz */
;;;315    
;;;316    	/* 每次上电进行一次自校准 */
;;;317    	TM7705_CalibSelf(1);	/* 内部自校准 CH1 */
0000d4  2001              MOVS     r0,#1
0000d6  f7fffffe          BL       TM7705_CalibSelf
;;;318    	bsp_DelayMS(5);
0000da  e8bd40f8          POP      {r3-r7,lr}
0000de  2005              MOVS     r0,#5
0000e0  f7ffbffe          B.W      bsp_DelayMS
                  |L16.228|
0000e4  2001              MOVS     r0,#1                 ;302
0000e6  e7ee              B        |L16.198|
;;;319    }
;;;320    
                          ENDP

                  |L16.232|
                          DCD      0x00300200
                  |L16.236|
                          DCD      0x40010c00
                  |L16.240|
                          DCD      0x40011000
                  |L16.244|
                          DCD      0x40011c00
                  |L16.248|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=1

                  g_TM7705_OK
000000  00                DCB      0x00
                  s_ch
000001  01                DCB      0x01
                  g_TM7705_Adc1
000002  0000              DCB      0x00,0x00
                  g_TM7705_Adc2
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_tm7705.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_tm7705_c_24319657____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___12_bsp_tm7705_c_24319657____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___12_bsp_tm7705_c_24319657____REVSH|
#line 128
|__asm___12_bsp_tm7705_c_24319657____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
