; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_touch.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_touch.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_touch.crf ..\..\User\bsp\src\bsp_touch.c]
                          THUMB

                          AREA ||i.CalTwoPoint||, CODE, READONLY, ALIGN=1

                  CalTwoPoint PROC
;;;636    */
;;;637    static int32_t CalTwoPoint(uint16_t x1, uint16_t y1, uint16_t x2, uint16_t y2, uint16_t x)
000000  b510              PUSH     {r4,lr}
;;;638    {
;;;639    	return y1 + ((int32_t)(y2 - y1) * (x - x1)) / (x2 - x1);
000002  1a5b              SUBS     r3,r3,r1
000004  9c02              LDR      r4,[sp,#8]
000006  1a24              SUBS     r4,r4,r0
000008  4363              MULS     r3,r4,r3
00000a  1a10              SUBS     r0,r2,r0
00000c  fb93f0f0          SDIV     r0,r3,r0
000010  4408              ADD      r0,r0,r1
;;;640    }
000012  bd10              POP      {r4,pc}
;;;641    
                          ENDP


                          AREA ||i.TOUCH_Abs||, CODE, READONLY, ALIGN=1

                  TOUCH_Abs PROC
;;;1010   */
;;;1011   int32_t TOUCH_Abs(int32_t x)
000000  2800              CMP      r0,#0
;;;1012   {
000002  da00              BGE      |L2.6|
;;;1013   	if (x >= 0)
;;;1014   	{
;;;1015   		return x;
;;;1016   	}
;;;1017   	else
;;;1018   	{
;;;1019   		return -x;
000004  4240              RSBS     r0,r0,#0
                  |L2.6|
;;;1020   	}
;;;1021   }
000006  4770              BX       lr
;;;1022   
                          ENDP


                          AREA ||i.TOUCH_Calibration||, CODE, READONLY, ALIGN=2

                  TOUCH_Calibration PROC
;;;1030   */
;;;1031   void TOUCH_Calibration(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1032   {
;;;1033   	uint16_t usAdcX;
;;;1034   	uint16_t usAdcY;
;;;1035   	uint8_t usCount;
;;;1036   	uint8_t i;
;;;1037   	uint32_t n;
;;;1038   
;;;1039   	TOUCH_CelarFIFO();		/* 清除无效的触摸事件 */
000004  f7fffffe          BL       TOUCH_CelarFIFO
;;;1040   
;;;1041   	for (i = 0; i < CALIB_POINT_COUNT; i++)
;;;1042   	{
;;;1043   		TOUCH_DispPoint(i);		/* 显示校准点 */
;;;1044   
;;;1045   		TOUCH_WaitRelease(); 	/* 等待触笔释放 */
;;;1046   
;;;1047   		usCount = 0;
;;;1048   		for (n = 0; n < 500; n++)
;;;1049   		{
;;;1050   			usAdcX = TOUCH_ReadAdcX();
;;;1051   			usAdcY = TOUCH_ReadAdcY();
;;;1052   
;;;1053   			if (TOUCH_PressValid(usAdcX, usAdcY))
;;;1054   			{
;;;1055   				if (++usCount > 5)
;;;1056   				{
;;;1057   					/* 按压有效, 保存校准点ADC采样值 */
;;;1058   					if (i == 0)
;;;1059   					{
;;;1060   						g_tTP.usAdcX1 = usAdcX;
000008  f8df8104          LDR      r8,|L3.272|
00000c  2400              MOVS     r4,#0                 ;1041
00000e  f44f77fa          MOV      r7,#0x1f4             ;1048
                  |L3.18|
000012  4620              MOV      r0,r4                 ;1043
000014  f7fffffe          BL       TOUCH_DispPoint
000018  f7fffffe          BL       TOUCH_WaitRelease
00001c  2600              MOVS     r6,#0                 ;1047
00001e  4635              MOV      r5,r6                 ;1048
                  |L3.32|
000020  f7fffffe          BL       TOUCH_ReadAdcX
000024  4681              MOV      r9,r0                 ;1050
000026  f7fffffe          BL       TOUCH_ReadAdcY
00002a  4682              MOV      r10,r0                ;1051
00002c  4601              MOV      r1,r0                 ;1053
00002e  4648              MOV      r0,r9                 ;1053
000030  f7fffffe          BL       TOUCH_PressValid
000034  b1e0              CBZ      r0,|L3.112|
000036  1c76              ADDS     r6,r6,#1              ;1053
000038  b2f6              UXTB     r6,r6                 ;1055
00003a  2e05              CMP      r6,#5                 ;1055
00003c  d919              BLS      |L3.114|
00003e  b144              CBZ      r4,|L3.82|
;;;1061   						g_tTP.usAdcY1 = usAdcY;
;;;1062   					}
;;;1063   					else if (i == 1)
000040  2c01              CMP      r4,#1
000042  d00b              BEQ      |L3.92|
;;;1064   					{
;;;1065   						g_tTP.usAdcX2 = usAdcX;
;;;1066   						g_tTP.usAdcY2 = usAdcY;
;;;1067   					}
;;;1068   					else if (i == 2)
000044  2c02              CMP      r4,#2
000046  d00e              BEQ      |L3.102|
;;;1069   					{
;;;1070   						g_tTP.usAdcX3 = usAdcX;
;;;1071   						g_tTP.usAdcY3 = usAdcY;
;;;1072   					}
;;;1073   					else
;;;1074   					{
;;;1075   						g_tTP.usAdcX4 = usAdcX;
000048  f8a8900c          STRH     r9,[r8,#0xc]
;;;1076   						g_tTP.usAdcY4 = usAdcY;
00004c  f8a8a00e          STRH     r10,[r8,#0xe]
000050  e015              B        |L3.126|
                  |L3.82|
000052  f8a89000          STRH     r9,[r8,#0]            ;1060
000056  f8a8a002          STRH     r10,[r8,#2]           ;1061
00005a  e010              B        |L3.126|
                  |L3.92|
00005c  f8a89004          STRH     r9,[r8,#4]            ;1065
000060  f8a8a006          STRH     r10,[r8,#6]           ;1066
000064  e00b              B        |L3.126|
                  |L3.102|
000066  f8a89008          STRH     r9,[r8,#8]            ;1070
00006a  f8a8a00a          STRH     r10,[r8,#0xa]         ;1071
00006e  e006              B        |L3.126|
                  |L3.112|
;;;1077   					}
;;;1078   					break;
;;;1079   				}
;;;1080   			}
;;;1081   			else
;;;1082   			{
;;;1083   				usCount = 0;
000070  2600              MOVS     r6,#0
                  |L3.114|
;;;1084   			}
;;;1085   			bsp_DelayMS(10);
000072  200a              MOVS     r0,#0xa
000074  f7fffffe          BL       bsp_DelayMS
000078  1c6d              ADDS     r5,r5,#1
00007a  42bd              CMP      r5,r7                 ;1048
00007c  d3d0              BCC      |L3.32|
                  |L3.126|
;;;1086   		}
;;;1087   		if (n == 500)
00007e  42bd              CMP      r5,r7
000080  d044              BEQ      |L3.268|
000082  1c64              ADDS     r4,r4,#1
000084  b2e4              UXTB     r4,r4                 ;1041
000086  2c02              CMP      r4,#2                 ;1041
000088  d3c3              BCC      |L3.18|
;;;1088   		{
;;;1089   			return;
;;;1090   		}
;;;1091   	}
;;;1092   
;;;1093   	TOUCH_WaitRelease(); 	/* 等待触笔释放 */
00008a  f7fffffe          BL       TOUCH_WaitRelease
;;;1094   
;;;1095   	/* 识别触摸的 X, Y 和 显示面板的 X，Y 是否需要交换 */
;;;1096   	g_tTP.XYChange = 0;		/* 1表示X Y需要交换 */
00008e  2000              MOVS     r0,#0
000090  4644              MOV      r4,r8
000092  f8a80020          STRH     r0,[r8,#0x20]
;;;1097   	if (LCD_GetHeight() < LCD_GetWidth())
000096  f7fffffe          BL       LCD_GetHeight
00009a  4605              MOV      r5,r0
00009c  f7fffffe          BL       LCD_GetWidth
0000a0  2101              MOVS     r1,#1                 ;1036
0000a2  4285              CMP      r5,r0
;;;1098   	{
;;;1099   		if (TOUCH_Abs(g_tTP.usAdcX1 - g_tTP.usAdcX2) < TOUCH_Abs(g_tTP.usAdcY1 - g_tTP.usAdcY2))
;;;1100   		{
;;;1101   			g_tTP.XYChange = 1;
;;;1102   		}
;;;1103   	}
;;;1104   	else
;;;1105   	{
;;;1106   		if (TOUCH_Abs(g_tTP.usAdcX1 - g_tTP.usAdcX2) > TOUCH_Abs(g_tTP.usAdcY1 - g_tTP.usAdcY2))
0000a4  8820              LDRH     r0,[r4,#0]  ; g_tTP
0000a6  88a2              LDRH     r2,[r4,#4]  ; g_tTP
0000a8  eba00002          SUB      r0,r0,r2
0000ac  d20a              BCS      |L3.196|
0000ae  f7fffffe          BL       TOUCH_Abs
0000b2  4602              MOV      r2,r0                 ;1099
0000b4  8860              LDRH     r0,[r4,#2]            ;1099  ; g_tTP
0000b6  88e3              LDRH     r3,[r4,#6]            ;1099  ; g_tTP
0000b8  1ac0              SUBS     r0,r0,r3              ;1099
0000ba  f7fffffe          BL       TOUCH_Abs
0000be  4282              CMP      r2,r0                 ;1099
0000c0  db0a              BLT      |L3.216|
0000c2  e00a              B        |L3.218|
                  |L3.196|
0000c4  f7fffffe          BL       TOUCH_Abs
0000c8  4602              MOV      r2,r0
0000ca  8860              LDRH     r0,[r4,#2]  ; g_tTP
0000cc  88e3              LDRH     r3,[r4,#6]  ; g_tTP
0000ce  1ac0              SUBS     r0,r0,r3
0000d0  f7fffffe          BL       TOUCH_Abs
0000d4  4282              CMP      r2,r0
0000d6  dd00              BLE      |L3.218|
                  |L3.216|
;;;1107   		{
;;;1108   			g_tTP.XYChange = 1;
0000d8  8421              STRH     r1,[r4,#0x20]
                  |L3.218|
;;;1109   		}
;;;1110   	}
;;;1111   
;;;1112   	g_tTP.usLcdX1 = TP_X1;
0000da  2514              MOVS     r5,#0x14
0000dc  8225              STRH     r5,[r4,#0x10]
;;;1113   	g_tTP.usLcdY1 = TP_Y1;
0000de  8265              STRH     r5,[r4,#0x12]
;;;1114   	g_tTP.usLcdX2 = TP_X2;
0000e0  f7fffffe          BL       LCD_GetWidth
0000e4  3814              SUBS     r0,r0,#0x14
0000e6  82a0              STRH     r0,[r4,#0x14]
;;;1115   	g_tTP.usLcdY2 = TP_Y2;
0000e8  f7fffffe          BL       LCD_GetHeight
0000ec  3814              SUBS     r0,r0,#0x14
0000ee  82e0              STRH     r0,[r4,#0x16]
;;;1116   	g_tTP.usLcdX3 = TP_X3;
0000f0  8325              STRH     r5,[r4,#0x18]
;;;1117   	g_tTP.usLcdY3 = TP_Y3;
0000f2  f7fffffe          BL       LCD_GetHeight
0000f6  3814              SUBS     r0,r0,#0x14
0000f8  8360              STRH     r0,[r4,#0x1a]
;;;1118   	g_tTP.usLcdX4 = TP_X3;
0000fa  83a5              STRH     r5,[r4,#0x1c]
;;;1119   	g_tTP.usLcdY4 = TP_Y3;
0000fc  f7fffffe          BL       LCD_GetHeight
000100  3814              SUBS     r0,r0,#0x14
000102  83e0              STRH     r0,[r4,#0x1e]
;;;1120   
;;;1121   	/* 在最后一步，可以将校准参数保存入Flash 或者EEPROM */
;;;1122   	TOUCH_SaveParam();
000104  e8bd47f0          POP      {r4-r10,lr}
000108  f7ffbffe          B.W      TOUCH_SaveParam
                  |L3.268|
;;;1123   }
00010c  e8bd87f0          POP      {r4-r10,pc}
;;;1124   
                          ENDP

                  |L3.272|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_CapScan||, CODE, READONLY, ALIGN=2

                  TOUCH_CapScan PROC
;;;467    */
;;;468    void TOUCH_CapScan(void)
000000  4806              LDR      r0,|L4.28|
;;;469    {
;;;470    	if (g_GT811.Enable == 1)
000002  7800              LDRB     r0,[r0,#0]  ; g_GT811
000004  2801              CMP      r0,#1
000006  d005              BEQ      |L4.20|
;;;471    	{
;;;472    		GT811_Scan();
;;;473    		return;
;;;474    	}
;;;475    	
;;;476    	if (g_tFT5X06.Enable == 1)
000008  4805              LDR      r0,|L4.32|
00000a  7840              LDRB     r0,[r0,#1]  ; g_tFT5X06
00000c  2801              CMP      r0,#1
00000e  d103              BNE      |L4.24|
;;;477    	{
;;;478    		FT5X06_Scan();
000010  f7ffbffe          B.W      FT5X06_Scan
                  |L4.20|
000014  f7ffbffe          B.W      GT811_Scan
                  |L4.24|
;;;479    		return;
;;;480    	}
;;;481    }
000018  4770              BX       lr
;;;482    
                          ENDP

00001a  0000              DCW      0x0000
                  |L4.28|
                          DCD      g_GT811
                  |L4.32|
                          DCD      g_tFT5X06

                          AREA ||i.TOUCH_CelarFIFO||, CODE, READONLY, ALIGN=2

                  TOUCH_CelarFIFO PROC
;;;394    */
;;;395    void TOUCH_CelarFIFO(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
;;;396    {
;;;397    	__set_PRIMASK(1);  		/* 关中断 */
;;;398    	g_tTP.Write = g_tTP.Read;
000006  4804              LDR      r0,|L5.24|
000008  f8101f8e          LDRB     r1,[r0,#0x8e]!  ; g_tTP
00000c  7041              STRB     r1,[r0,#1]
;;;399    	__set_PRIMASK(0);  		/* 开中断 */
00000e  2000              MOVS     r0,#0
000010  f3808810          MSR      PRIMASK,r0
;;;400    }
000014  4770              BX       lr
;;;401    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_DataFilter||, CODE, READONLY, ALIGN=2

                  TOUCH_DataFilter PROC
;;;851    */
;;;852    static uint16_t TOUCH_DataFilter(uint16_t *_pBuf, uint8_t _ucCount)
000000  b5f0              PUSH     {r4-r7,lr}
;;;853    {
;;;854    #if 0
;;;855    	uint8_t i;
;;;856    	uint32_t uiSum;
;;;857    
;;;858    	uiSum = 0;
;;;859    	for (i = 0; i < _ucCount; i++)
;;;860    	{
;;;861    		uiSum += _pBuf[i];
;;;862    	}
;;;863    	return uiSum / _ucCount;
;;;864    #else
;;;865    	uint8_t flag;
;;;866    	uint8_t i;
;;;867    	uint16_t usTemp;
;;;868    	uint32_t uiSum;
;;;869    
;;;870    	/* 升序排列 */
;;;871        do
;;;872    	{
;;;873    		flag = 0;
;;;874    		for (i = 0; i < _ucCount - 1; i++)
000002  1e4c              SUBS     r4,r1,#1
                  |L6.4|
000004  2500              MOVS     r5,#0                 ;873
000006  462a              MOV      r2,r5
000008  e00d              B        |L6.38|
;;;875    		{
;;;876    			if (_pBuf[i] > _pBuf[i+1])
00000a  bf00              NOP      
                  |L6.12|
00000c  eb000642          ADD      r6,r0,r2,LSL #1
000010  f8307012          LDRH     r7,[r0,r2,LSL #1]
000014  8873              LDRH     r3,[r6,#2]
000016  429f              CMP      r7,r3
000018  d903              BLS      |L6.34|
;;;877    			{
;;;878    				usTemp = _pBuf[i + 1];
;;;879    				_pBuf[i+1] = _pBuf[i];
00001a  8077              STRH     r7,[r6,#2]
;;;880    				_pBuf[i] = usTemp;
00001c  f8203012          STRH     r3,[r0,r2,LSL #1]
;;;881    				flag = 1;
000020  2501              MOVS     r5,#1
                  |L6.34|
000022  1c52              ADDS     r2,r2,#1
000024  b2d2              UXTB     r2,r2                 ;874
                  |L6.38|
000026  42a2              CMP      r2,r4                 ;874
000028  dbf0              BLT      |L6.12|
;;;882    			}
;;;883    		}
;;;884    	}while(flag);
00002a  2d00              CMP      r5,#0
00002c  d1ea              BNE      |L6.4|
;;;885    
;;;886    	uiSum = 0;
00002e  2400              MOVS     r4,#0
;;;887    	for (i = 0; i < _ucCount / 3; i++)
000030  4622              MOV      r2,r4
;;;888    	{
;;;889    		uiSum += _pBuf[_ucCount / 3 + i];
000032  2303              MOVS     r3,#3
000034  e008              B        |L6.72|
000036  bf00              NOP      
                  |L6.56|
000038  fbb1f5f3          UDIV     r5,r1,r3
00003c  4415              ADD      r5,r5,r2
00003e  1c52              ADDS     r2,r2,#1
000040  f8305015          LDRH     r5,[r0,r5,LSL #1]
000044  b2d2              UXTB     r2,r2                 ;887
000046  442c              ADD      r4,r4,r5
                  |L6.72|
000048  fbb1f5f3          UDIV     r5,r1,r3              ;887
00004c  4295              CMP      r5,r2                 ;887
00004e  d8f3              BHI      |L6.56|
;;;890    	}
;;;891    	usTemp = uiSum / (_ucCount / 3);
000050  fbb1f0f3          UDIV     r0,r1,r3
000054  fbb4f0f0          UDIV     r0,r4,r0
000058  b280              UXTH     r0,r0
;;;892    	return usTemp;
;;;893    #endif
;;;894    }
00005a  bdf0              POP      {r4-r7,pc}
;;;895    
                          ENDP


                          AREA ||i.TOUCH_DispPoint||, CODE, READONLY, ALIGN=2

                  TOUCH_DispPoint PROC
;;;903    */
;;;904    static void TOUCH_DispPoint(uint8_t _ucIndex)
000000  b53e              PUSH     {r1-r5,lr}
;;;905    {
;;;906    	FONT_T tFont16;			/* 定义一个字体结构体变量，用于设置字体参数 */
;;;907    
;;;908    	/* 设置字体参数 */
;;;909    	{
;;;910    		tFont16.FontCode = FC_ST_16;	/* 字体代码 16点阵 */
000002  2101              MOVS     r1,#1
000004  f88d1004          STRB     r1,[sp,#4]
;;;911    		tFont16.FrontColor = CL_WHITE;		/* 字体颜色 0 或 1 */
;;;912    		tFont16.BackColor = CL_BLUE;	/* 文字背景颜色 */
000008  211f              MOVS     r1,#0x1f
00000a  f8ad1008          STRH     r1,[sp,#8]
00000e  f64f74ff          MOV      r4,#0xffff            ;911
;;;913    		tFont16.Space = 0;			/* 文字间距，单位 = 像素 */
000012  2100              MOVS     r1,#0
000014  f8ad4006          STRH     r4,[sp,#6]            ;911
000018  f8ad100a          STRH     r1,[sp,#0xa]
00001c  b1a0              CBZ      r0,|L7.72|
;;;914    	}
;;;915    
;;;916    /*
;;;917    	第1个点 ： x1 = CALIB_OFFSET, y1 = CALIB_OFFSET
;;;918    	第2个点 ： x2 = LCD_GetHeight() - CALIB_OFFSET, y2 = LCD_GetWidth - CALIB_OFFSET
;;;919    */
;;;920    	if (_ucIndex == 0)
;;;921    	{
;;;922    		LCD_ClrScr(CL_BLUE);  		/* 清屏，背景蓝色 */
;;;923    
;;;924    		/* 在屏幕边沿绘制2个矩形框(用于检测面板边缘像素是否正常) */
;;;925    		LCD_DrawRect(0, 0, LCD_GetHeight(), LCD_GetWidth(), CL_WHITE);
;;;926    		LCD_DrawRect(2, 2, LCD_GetHeight() - 4, LCD_GetWidth() - 4, CL_YELLOW);
;;;927    
;;;928    		LCD_DispStr(50, 10, "校准触摸屏", &tFont16);		/* 在(8,3)坐标处显示一串汉字 */
;;;929    
;;;930    		LCD_DrawCircle(TP_X1, TP_Y1, 6, CL_WHITE);
;;;931    	}
;;;932    	else if (_ucIndex == 1)
00001e  2801              CMP      r0,#1
000020  d03b              BEQ      |L7.154|
;;;933    	{
;;;934    		LCD_DrawCircle(TP_X1, TP_Y1, 6, CL_BLUE);			/* 擦除第1个点 */
;;;935    
;;;936    		LCD_DrawCircle(TP_X2, TP_Y2, 6, CL_WHITE);
;;;937    	}
;;;938    	else if (_ucIndex == 2)
000022  2802              CMP      r0,#2
000024  d04d              BEQ      |L7.194|
;;;939    	{
;;;940    		LCD_DrawCircle(TP_X2, TP_Y2, 6, CL_BLUE);			/* 擦除第2个点 */
;;;941    
;;;942    		LCD_DrawCircle(TP_X3, TP_Y3, 6, CL_WHITE);
;;;943    	}
;;;944    	else
;;;945    	{
;;;946    		LCD_DrawCircle(TP_X3, TP_Y3, 6, CL_BLUE);			/* 擦除第3个点 */
000026  f7fffffe          BL       LCD_GetHeight
00002a  3814              SUBS     r0,r0,#0x14
00002c  b281              UXTH     r1,r0
00002e  231f              MOVS     r3,#0x1f
000030  2206              MOVS     r2,#6
000032  2014              MOVS     r0,#0x14
000034  f7fffffe          BL       LCD_DrawCircle
;;;947    
;;;948    		LCD_DrawCircle(TP_X4, TP_Y4, 6, CL_WHITE);
000038  f7fffffe          BL       LCD_GetWidth
00003c  3814              SUBS     r0,r0,#0x14
00003e  2206              MOVS     r2,#6
000040  b280              UXTH     r0,r0
000042  4623              MOV      r3,r4
000044  2114              MOVS     r1,#0x14
000046  e039              B        |L7.188|
                  |L7.72|
000048  201f              MOVS     r0,#0x1f              ;922
00004a  f7fffffe          BL       LCD_ClrScr
00004e  f7fffffe          BL       LCD_GetWidth
000052  4605              MOV      r5,r0                 ;925
000054  f7fffffe          BL       LCD_GetHeight
000058  4602              MOV      r2,r0                 ;925
00005a  2100              MOVS     r1,#0                 ;925
00005c  462b              MOV      r3,r5                 ;925
00005e  4608              MOV      r0,r1                 ;925
000060  9400              STR      r4,[sp,#0]            ;925
000062  f7fffffe          BL       LCD_DrawRect
000066  f7fffffe          BL       LCD_GetWidth
00006a  1f00              SUBS     r0,r0,#4              ;926
00006c  b285              UXTH     r5,r0                 ;926
00006e  f7fffffe          BL       LCD_GetHeight
000072  1f00              SUBS     r0,r0,#4              ;926
000074  b282              UXTH     r2,r0                 ;926
000076  f64f70e0          MOV      r0,#0xffe0            ;926
00007a  2102              MOVS     r1,#2                 ;926
00007c  9000              STR      r0,[sp,#0]            ;926
00007e  462b              MOV      r3,r5                 ;926
000080  4608              MOV      r0,r1                 ;926
000082  f7fffffe          BL       LCD_DrawRect
000086  ab01              ADD      r3,sp,#4              ;928
000088  a218              ADR      r2,|L7.236|
00008a  210a              MOVS     r1,#0xa               ;928
00008c  2032              MOVS     r0,#0x32              ;928
00008e  f7fffffe          BL       LCD_DispStr
000092  2206              MOVS     r2,#6                 ;930
000094  4623              MOV      r3,r4                 ;930
000096  2114              MOVS     r1,#0x14              ;930
000098  e026              B        |L7.232|
                  |L7.154|
00009a  2114              MOVS     r1,#0x14              ;934
00009c  231f              MOVS     r3,#0x1f              ;934
00009e  2206              MOVS     r2,#6                 ;934
0000a0  4608              MOV      r0,r1                 ;934
0000a2  f7fffffe          BL       LCD_DrawCircle
0000a6  f7fffffe          BL       LCD_GetHeight
0000aa  3814              SUBS     r0,r0,#0x14           ;936
0000ac  b285              UXTH     r5,r0                 ;936
0000ae  f7fffffe          BL       LCD_GetWidth
0000b2  3814              SUBS     r0,r0,#0x14           ;936
0000b4  b280              UXTH     r0,r0                 ;936
0000b6  4623              MOV      r3,r4                 ;936
0000b8  2206              MOVS     r2,#6                 ;936
0000ba  4629              MOV      r1,r5                 ;936
                  |L7.188|
0000bc  f7fffffe          BL       LCD_DrawCircle
;;;949    	}
;;;950    }
0000c0  bd3e              POP      {r1-r5,pc}
                  |L7.194|
0000c2  f7fffffe          BL       LCD_GetHeight
0000c6  3814              SUBS     r0,r0,#0x14           ;940
0000c8  b285              UXTH     r5,r0                 ;940
0000ca  f7fffffe          BL       LCD_GetWidth
0000ce  3814              SUBS     r0,r0,#0x14           ;940
0000d0  b280              UXTH     r0,r0                 ;940
0000d2  231f              MOVS     r3,#0x1f              ;940
0000d4  2206              MOVS     r2,#6                 ;940
0000d6  4629              MOV      r1,r5                 ;940
0000d8  f7fffffe          BL       LCD_DrawCircle
0000dc  f7fffffe          BL       LCD_GetHeight
0000e0  3814              SUBS     r0,r0,#0x14           ;942
0000e2  b281              UXTH     r1,r0                 ;942
0000e4  4623              MOV      r3,r4                 ;942
0000e6  2206              MOVS     r2,#6                 ;942
                  |L7.232|
0000e8  2014              MOVS     r0,#0x14              ;942
0000ea  e7e7              B        |L7.188|
;;;951    
                          ENDP

                  |L7.236|
0000ec  d0a3d7bc          DCB      208,163,215,188,180,165,195,254,198,193,0
0000f0  b4a5c3fe
0000f4  c6c100  
0000f7  00                DCB      0

                          AREA ||i.TOUCH_GetKey||, CODE, READONLY, ALIGN=2

                  TOUCH_GetKey PROC
;;;364    */
;;;365    uint8_t TOUCH_GetKey(int16_t *_pX, int16_t *_pY)
000000  4a12              LDR      r2,|L8.76|
;;;366    {
000002  b510              PUSH     {r4,lr}
;;;367    	uint8_t ret;
;;;368    
;;;369    	if (g_tTP.Read == g_tTP.Write)
000004  f892308e          LDRB     r3,[r2,#0x8e]  ; g_tTP
000008  f892408f          LDRB     r4,[r2,#0x8f]  ; g_tTP
00000c  42a3              CMP      r3,r4
00000e  d101              BNE      |L8.20|
;;;370    	{
;;;371    		return TOUCH_NONE;
000010  2000              MOVS     r0,#0
;;;372    	}
;;;373    	else
;;;374    	{
;;;375    		ret = g_tTP.Event[g_tTP.Read];
;;;376    		*_pX = g_tTP.XBuf[g_tTP.Read];
;;;377    		*_pY = g_tTP.YBuf[g_tTP.Read];
;;;378    
;;;379    		if (++g_tTP.Read >= TOUCH_FIFO_SIZE)
;;;380    		{
;;;381    			g_tTP.Read = 0;
;;;382    		}
;;;383    		return ret;
;;;384    	}
;;;385    }
000012  bd10              POP      {r4,pc}
                  |L8.20|
000014  4c0d              LDR      r4,|L8.76|
000016  3429              ADDS     r4,r4,#0x29           ;375
000018  5d1c              LDRB     r4,[r3,r4]            ;375
00001a  eb020343          ADD      r3,r2,r3,LSL #1       ;376
00001e  8fdb              LDRH     r3,[r3,#0x3e]         ;376
000020  8003              STRH     r3,[r0,#0]            ;376
000022  f892008e          LDRB     r0,[r2,#0x8e]         ;377  ; g_tTP
000026  eb020040          ADD      r0,r2,r0,LSL #1       ;377
00002a  f8b00066          LDRH     r0,[r0,#0x66]         ;377
00002e  8008              STRH     r0,[r1,#0]            ;377
000030  f892008e          LDRB     r0,[r2,#0x8e]         ;379  ; g_tTP
000034  1c40              ADDS     r0,r0,#1              ;379
000036  b2c0              UXTB     r0,r0                 ;379
000038  f882008e          STRB     r0,[r2,#0x8e]         ;379
00003c  2814              CMP      r0,#0x14              ;379
00003e  d302              BCC      |L8.70|
000040  2000              MOVS     r0,#0                 ;381
000042  f882008e          STRB     r0,[r2,#0x8e]         ;381
                  |L8.70|
000046  4620              MOV      r0,r4                 ;383
000048  bd10              POP      {r4,pc}
;;;386    
                          ENDP

00004a  0000              DCW      0x0000
                  |L8.76|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_GetX||, CODE, READONLY, ALIGN=1

                  TOUCH_GetX PROC
;;;825    */
;;;826    int16_t TOUCH_GetX(void)
000000  b510              PUSH     {r4,lr}
;;;827    {
;;;828    	return TOUCH_TransX(TOUCH_ReadAdcX(), TOUCH_ReadAdcY());
000002  f7fffffe          BL       TOUCH_ReadAdcY
000006  4602              MOV      r2,r0
000008  f7fffffe          BL       TOUCH_ReadAdcX
00000c  e8bd4010          POP      {r4,lr}
000010  4611              MOV      r1,r2
000012  f7ffbffe          B.W      TOUCH_TransX
;;;829    }
;;;830    
                          ENDP


                          AREA ||i.TOUCH_GetY||, CODE, READONLY, ALIGN=1

                  TOUCH_GetY PROC
;;;838    */
;;;839    int16_t TOUCH_GetY(void)
000000  b510              PUSH     {r4,lr}
;;;840    {
;;;841    	return TOUCH_TransY(TOUCH_ReadAdcX(), TOUCH_ReadAdcY());
000002  f7fffffe          BL       TOUCH_ReadAdcY
000006  4602              MOV      r2,r0
000008  f7fffffe          BL       TOUCH_ReadAdcX
00000c  e8bd4010          POP      {r4,lr}
000010  4611              MOV      r1,r2
000012  f7ffbffe          B.W      TOUCH_TransY
;;;842    }
;;;843    
                          ENDP


                          AREA ||i.TOUCH_InRect||, CODE, READONLY, ALIGN=1

                  TOUCH_InRect PROC
;;;411    */
;;;412    uint8_t TOUCH_InRect(uint16_t _usX, uint16_t _usY,
000000  b530              PUSH     {r4,r5,lr}
;;;413    	uint16_t _usRectX, uint16_t _usRectY, uint16_t _usRectH, uint16_t _usRectW)
;;;414    {
;;;415    	if ((_usX > _usRectX) && (_usX < _usRectX + _usRectW)
000002  4290              CMP      r0,r2
000004  e9dd5403          LDRD     r5,r4,[sp,#0xc]       ;414
000008  d909              BLS      |L11.30|
00000a  4422              ADD      r2,r2,r4
00000c  4282              CMP      r2,r0
00000e  d906              BLS      |L11.30|
;;;416    		&& (_usY > _usRectY) && (_usY < _usRectY + _usRectH))
000010  4299              CMP      r1,r3
000012  d904              BLS      |L11.30|
000014  1958              ADDS     r0,r3,r5
000016  4288              CMP      r0,r1
000018  d901              BLS      |L11.30|
;;;417    	{
;;;418    		return 1;
00001a  2001              MOVS     r0,#1
;;;419    	}
;;;420    	else
;;;421    	{
;;;422    		return 0;
;;;423    	}
;;;424    }
00001c  bd30              POP      {r4,r5,pc}
                  |L11.30|
00001e  2000              MOVS     r0,#0                 ;422
000020  bd30              POP      {r4,r5,pc}
;;;425    
                          ENDP


                          AREA ||i.TOUCH_InitHard||, CODE, READONLY, ALIGN=2

                  TOUCH_InitHard PROC
;;;101    */
;;;102    void TOUCH_InitHard(void)
000000  b570              PUSH     {r4-r6,lr}
;;;103    {
;;;104    	uint16_t i;
;;;105    	
;;;106        g_tTP.Enable = 0;
000002  4c1e              LDR      r4,|L12.124|
000004  2600              MOVS     r6,#0
;;;107        g_tTP.Write = g_tTP.Read = 0;	
;;;108    
;;;109    	/* 50ms，等待GT811复位就绪，才能探测GT811芯片 ID */
;;;110    	for (i = 0; i < 5; i++)
000006  4635              MOV      r5,r6
000008  f8846028          STRB     r6,[r4,#0x28]         ;106
00000c  f884608e          STRB     r6,[r4,#0x8e]         ;107
000010  f884608f          STRB     r6,[r4,#0x8f]         ;107
                  |L12.20|
;;;111    	{
;;;112    		if (i2c_CheckDevice(GT811_I2C_ADDR) == 0)
000014  20ba              MOVS     r0,#0xba
000016  f7fffffe          BL       i2c_CheckDevice
00001a  b1e0              CBZ      r0,|L12.86|
;;;113    		{
;;;114    			GT811_InitHard();
;;;115    			return;		/* 2015-04-21 break 修改为 return */
;;;116    		}
;;;117    
;;;118    		/* FT系列电容触摸触摸 : 4.3寸id = 0x55    5.0寸id = 0x0A  7.0寸id = 0x06 */
;;;119    		if (i2c_CheckDevice(FT5X06_I2C_ADDR) == 0)
00001c  2070              MOVS     r0,#0x70
00001e  f7fffffe          BL       i2c_CheckDevice
000022  b1e0              CBZ      r0,|L12.94|
;;;120    		{
;;;121    			uint8_t id;
;;;122    			
;;;123    			bsp_DelayMS(50);
;;;124    			id = FT5X06_ReadID();			
;;;125    			if (id == 0x55)
;;;126    			{
;;;127    				//g_TouchType = CT_FT5X06;
;;;128    				//g_LcdType = LCD_43_480X272;		
;;;129    				//touch_printf("检测到4.3寸电容触摸屏\r\n");
;;;130    			}
;;;131    			else if (id == 0x0A)
;;;132    			{
;;;133    				//g_TouchType = CT_FT5X06;
;;;134    				//g_LcdType = LCD_50_800X480;		
;;;135    				//touch_printf("检测到5.0寸电容触摸屏\r\n");				
;;;136    			}
;;;137    			else	/* id == 0x06 表示7寸电容屏（FT芯片） */
;;;138    			{
;;;139    				//g_TouchType = CT_FT5X06;
;;;140    				//g_LcdType = LCD_70_800X480;		
;;;141    				//touch_printf("检测到7.0寸电容触摸屏\r\n");					
;;;142    			}
;;;143    			
;;;144    			FT5X06_InitHard();
;;;145    			return;
;;;146    		}
;;;147    		
;;;148    		bsp_DelayMS(10);
000024  200a              MOVS     r0,#0xa
000026  f7fffffe          BL       bsp_DelayMS
00002a  1c6d              ADDS     r5,r5,#1
00002c  b2ad              UXTH     r5,r5                 ;110
00002e  2d05              CMP      r5,#5                 ;110
000030  d3f0              BCC      |L12.20|
;;;149    	}
;;;150    		
;;;151    	if (g_ChipID == IC_8875)
000032  4813              LDR      r0,|L12.128|
000034  8800              LDRH     r0,[r0,#0]  ; g_ChipID
000036  2875              CMP      r0,#0x75
000038  d01a              BEQ      |L12.112|
;;;152    	{
;;;153    		RA8875_TouchInit();
;;;154    
;;;155    		g_tTP.usMaxAdc = 1023;	/* 10位ADC */
;;;156    	}
;;;157    	else
;;;158    	{	
;;;159    		TSC2046_InitHard();
00003a  f7fffffe          BL       TSC2046_InitHard
;;;160    
;;;161    		g_tTP.usMaxAdc = 4095;	/* 12位ADC */
00003e  f64070ff          MOV      r0,#0xfff
                  |L12.66|
000042  8460              STRH     r0,[r4,#0x22]
;;;162    	}
;;;163    
;;;164    	TOUCH_LoadParam();	/* 读取校准参数 */
000044  f7fffffe          BL       TOUCH_LoadParam
;;;165    
;;;166        g_tTP.Write = g_tTP.Read = 0;
000048  f8046f8e          STRB     r6,[r4,#0x8e]!
;;;167    
;;;168    	g_tTP.Enable = 1;
00004c  2001              MOVS     r0,#1
00004e  7066              STRB     r6,[r4,#1]            ;166
000050  f8040c66          STRB     r0,[r4,#-0x66]
;;;169    }
000054  bd70              POP      {r4-r6,pc}
                  |L12.86|
000056  e8bd4070          POP      {r4-r6,lr}            ;114
00005a  f7ffbffe          B.W      GT811_InitHard
                  |L12.94|
00005e  2032              MOVS     r0,#0x32              ;123
000060  f7fffffe          BL       bsp_DelayMS
000064  f7fffffe          BL       FT5X06_ReadID
000068  e8bd4070          POP      {r4-r6,lr}            ;144
00006c  f7ffbffe          B.W      FT5X06_InitHard
                  |L12.112|
000070  f7fffffe          BL       RA8875_TouchInit
000074  f24030ff          MOV      r0,#0x3ff             ;155
000078  e7e3              B        |L12.66|
;;;170    
                          ENDP

00007a  0000              DCW      0x0000
                  |L12.124|
                          DCD      ||.bss||+0x28
                  |L12.128|
                          DCD      g_ChipID

                          AREA ||i.TOUCH_LoadParam||, CODE, READONLY, ALIGN=2

                  TOUCH_LoadParam PROC
;;;1171   extern void LoadParam(void);
;;;1172   static void TOUCH_LoadParam(void)
000000  b510              PUSH     {r4,lr}
;;;1173   {
;;;1174   #if 1
;;;1175   	LoadParam();	/* 从Flash中读取参数 */
000002  f7fffffe          BL       LoadParam
;;;1176   
;;;1177   	g_tTP.usAdcX1 = g_tParam.usAdcX1;
000006  4812              LDR      r0,|L13.80|
000008  4912              LDR      r1,|L13.84|
00000a  8902              LDRH     r2,[r0,#8]  ; g_tParam
00000c  800a              STRH     r2,[r1,#0]
;;;1178   	g_tTP.usAdcY1 = g_tParam.usAdcY1;
00000e  8942              LDRH     r2,[r0,#0xa]  ; g_tParam
000010  804a              STRH     r2,[r1,#2]
;;;1179   	g_tTP.usAdcX2 = g_tParam.usAdcX2;
000012  8982              LDRH     r2,[r0,#0xc]  ; g_tParam
000014  808a              STRH     r2,[r1,#4]
;;;1180   	g_tTP.usAdcY2 = g_tParam.usAdcY2;
000016  89c2              LDRH     r2,[r0,#0xe]  ; g_tParam
000018  80ca              STRH     r2,[r1,#6]
;;;1181   	g_tTP.usAdcX3 = g_tParam.usAdcX3;
00001a  8a02              LDRH     r2,[r0,#0x10]  ; g_tParam
00001c  810a              STRH     r2,[r1,#8]
;;;1182   	g_tTP.usAdcY3 = g_tParam.usAdcY3;
00001e  8a42              LDRH     r2,[r0,#0x12]  ; g_tParam
000020  814a              STRH     r2,[r1,#0xa]
;;;1183   	g_tTP.usAdcX4 = g_tParam.usAdcX4;
000022  8a82              LDRH     r2,[r0,#0x14]  ; g_tParam
000024  818a              STRH     r2,[r1,#0xc]
;;;1184   	g_tTP.usAdcY4 = g_tParam.usAdcY4;
000026  8ac2              LDRH     r2,[r0,#0x16]  ; g_tParam
000028  81ca              STRH     r2,[r1,#0xe]
;;;1185   
;;;1186   	g_tTP.usLcdX1 = g_tParam.usLcdX1;
00002a  8b02              LDRH     r2,[r0,#0x18]  ; g_tParam
00002c  820a              STRH     r2,[r1,#0x10]
;;;1187   	g_tTP.usLcdY1 = g_tParam.usLcdY1;
00002e  8b42              LDRH     r2,[r0,#0x1a]  ; g_tParam
000030  824a              STRH     r2,[r1,#0x12]
;;;1188   	g_tTP.usLcdX2 = g_tParam.usLcdX2;
000032  8b82              LDRH     r2,[r0,#0x1c]  ; g_tParam
000034  828a              STRH     r2,[r1,#0x14]
;;;1189   	g_tTP.usLcdY2 = g_tParam.usLcdY2;
000036  8bc2              LDRH     r2,[r0,#0x1e]  ; g_tParam
000038  82ca              STRH     r2,[r1,#0x16]
;;;1190   	g_tTP.usLcdX3 = g_tParam.usLcdX3;
00003a  8c02              LDRH     r2,[r0,#0x20]  ; g_tParam
00003c  830a              STRH     r2,[r1,#0x18]
;;;1191   	g_tTP.usLcdY3 = g_tParam.usLcdY3;
00003e  8c42              LDRH     r2,[r0,#0x22]  ; g_tParam
000040  834a              STRH     r2,[r1,#0x1a]
;;;1192   	g_tTP.usLcdX4 = g_tParam.usLcdX4;
000042  8c82              LDRH     r2,[r0,#0x24]  ; g_tParam
000044  838a              STRH     r2,[r1,#0x1c]
;;;1193   	g_tTP.usLcdY4 = g_tParam.usLcdY4;
000046  8cc2              LDRH     r2,[r0,#0x26]  ; g_tParam
000048  83ca              STRH     r2,[r1,#0x1e]
;;;1194   
;;;1195   	g_tTP.XYChange = g_tParam.XYChange;
00004a  7980              LDRB     r0,[r0,#6]  ; g_tParam
00004c  8408              STRH     r0,[r1,#0x20]
;;;1196   #endif
;;;1197   }
00004e  bd10              POP      {r4,pc}
;;;1198   
                          ENDP

                  |L13.80|
                          DCD      g_tParam
                  |L13.84|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_MoveValid||, CODE, READONLY, ALIGN=2

                  TOUCH_MoveValid PROC
;;;434    */
;;;435    uint8_t TOUCH_MoveValid(uint16_t _usX1, uint16_t _usY1, uint16_t _usX2, uint16_t _usY2)
000000  b500              PUSH     {lr}
;;;436    {
;;;437    	int16_t iX, iY;
;;;438    	static uint8_t s_invalid_count = 0;
;;;439    
;;;440    	iX = TOUCH_Abs(_usX1 - _usX2);
000002  1a80              SUBS     r0,r0,r2
000004  f7fffffe          BL       TOUCH_Abs
000008  b202              SXTH     r2,r0
;;;441    	iY = TOUCH_Abs(_usY1 - _usY2);
00000a  1ac8              SUBS     r0,r1,r3
00000c  f7fffffe          BL       TOUCH_Abs
000010  b203              SXTH     r3,r0
000012  2100              MOVS     r1,#0
;;;442    
;;;443    	if ((iX < 25) && (iY < 25))
;;;444    	{
;;;445    		s_invalid_count = 0;
000014  4807              LDR      r0,|L14.52|
000016  2a19              CMP      r2,#0x19              ;443
000018  da01              BGE      |L14.30|
00001a  2b19              CMP      r3,#0x19              ;443
00001c  db05              BLT      |L14.42|
                  |L14.30|
;;;446    		return 1;
;;;447    	}
;;;448    	else
;;;449    	{
;;;450    		if (++s_invalid_count >= 3)
00001e  7802              LDRB     r2,[r0,#0]  ; s_invalid_count
000020  1c52              ADDS     r2,r2,#1
000022  b2d2              UXTB     r2,r2
000024  7002              STRB     r2,[r0,#0]
000026  2a03              CMP      r2,#3
000028  d302              BCC      |L14.48|
                  |L14.42|
;;;451    		{
;;;452    			s_invalid_count = 0;
00002a  7001              STRB     r1,[r0,#0]
;;;453    			return 1;
00002c  2001              MOVS     r0,#1
;;;454    		}
;;;455    		return 0;
;;;456    	}
;;;457    }
00002e  bd00              POP      {pc}
                  |L14.48|
000030  2000              MOVS     r0,#0                 ;455
000032  bd00              POP      {pc}
;;;458    
                          ENDP

                  |L14.52|
                          DCD      ||.data||

                          AREA ||i.TOUCH_PressValid||, CODE, READONLY, ALIGN=2

                  TOUCH_PressValid PROC
;;;959    */
;;;960    static uint8_t	TOUCH_PressValid(uint16_t _usX, uint16_t _usY)
000000  2802              CMP      r0,#2
;;;961    {
000002  d908              BLS      |L15.22|
;;;962    	if ((_usX <= ADC_VALID_OFFSET) || (_usY <= ADC_VALID_OFFSET)
000004  2902              CMP      r1,#2
000006  d906              BLS      |L15.22|
;;;963    		|| (_usX >= g_tTP.usMaxAdc - ADC_VALID_OFFSET)
000008  4a05              LDR      r2,|L15.32|
00000a  8c52              LDRH     r2,[r2,#0x22]  ; g_tTP
00000c  1e92              SUBS     r2,r2,#2
00000e  4282              CMP      r2,r0
000010  dd01              BLE      |L15.22|
;;;964    		|| (_usY >= g_tTP.usMaxAdc - ADC_VALID_OFFSET))
000012  428a              CMP      r2,r1
000014  dc01              BGT      |L15.26|
                  |L15.22|
;;;965    	{
;;;966    		return 0;
000016  2000              MOVS     r0,#0
;;;967    	}
;;;968    	else
;;;969    	{
;;;970    		return 1;
;;;971    	}
;;;972    }
000018  4770              BX       lr
                  |L15.26|
00001a  2001              MOVS     r0,#1                 ;970
00001c  4770              BX       lr
;;;973    
                          ENDP

00001e  0000              DCW      0x0000
                  |L15.32|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_PutKey||, CODE, READONLY, ALIGN=2

                  TOUCH_PutKey PROC
;;;216    */
;;;217    void TOUCH_PutKey(uint8_t _ucEvent, uint16_t _usX, uint16_t _usY)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;218    {
;;;219    	uint16_t xx, yy;
;;;220    	uint16_t x = 0, y = 0;
;;;221    
;;;222    	g_tTP.Event[g_tTP.Write] = _ucEvent;
000004  f8df9118          LDR      r9,|L16.288|
000008  4617              MOV      r7,r2                 ;218
00000a  4688              MOV      r8,r1                 ;218
00000c  f899208f          LDRB     r2,[r9,#0x8f]  ; g_tTP
000010  f1090129          ADD      r1,r9,#0x29
000014  2600              MOVS     r6,#0                 ;220
000016  5450              STRB     r0,[r2,r1]
;;;223    
;;;224    	if (g_GT811.Enable == 1)	/* 电容屏 (无需校准) */
000018  4842              LDR      r0,|L16.292|
00001a  4635              MOV      r5,r6                 ;220
00001c  7800              LDRB     r0,[r0,#0]  ; g_GT811
00001e  2801              CMP      r0,#1
000020  d040              BEQ      |L16.164|
;;;225    	{
;;;226    		xx = _usX;
;;;227    		yy = _usY;
;;;228    	}
;;;229    	else if (g_tFT5X06.Enable == 1)
000022  4841              LDR      r0,|L16.296|
000024  7840              LDRB     r0,[r0,#1]  ; g_tFT5X06
000026  2801              CMP      r0,#1
000028  d03c              BEQ      |L16.164|
;;;230    	{
;;;231    		xx = _usX;
;;;232    		yy = _usY;
;;;233    	}	
;;;234    	else	/* 电阻屏 */
;;;235    	{
;;;236    		xx = TOUCH_TransX(_usX, _usY);
00002a  4639              MOV      r1,r7
00002c  4640              MOV      r0,r8
00002e  f7fffffe          BL       TOUCH_TransX
000032  b284              UXTH     r4,r0
;;;237    		yy = TOUCH_TransY(_usX, _usY);
000034  4639              MOV      r1,r7
000036  4640              MOV      r0,r8
000038  f7fffffe          BL       TOUCH_TransY
00003c  b281              UXTH     r1,r0
                  |L16.62|
;;;238    	}
;;;239    	
;;;240    	/* 横屏和竖屏方向识别 */
;;;241    	if (g_tParam.TouchDirection > 3)
00003e  f8dfc0ec          LDR      r12,|L16.300|
000042  2700              MOVS     r7,#0
000044  f89c0005          LDRB     r0,[r12,#5]  ; g_tParam
000048  2803              CMP      r0,#3
00004a  d901              BLS      |L16.80|
;;;242    	{
;;;243    		g_tParam.TouchDirection  = 0;
00004c  f88c7005          STRB     r7,[r12,#5]
                  |L16.80|
;;;244    	}
;;;245    	switch (g_tParam.TouchDirection)
000050  f89c8005          LDRB     r8,[r12,#5]  ; g_tParam
;;;246    	{
;;;247    		case 0:	/* 校准触摸时，屏幕方向为0 */
;;;248    			if (g_LcdDirection == 0)		/* 横屏 */
;;;249    			{
;;;250    				x = xx;
;;;251    				y = yy;
;;;252    			}
;;;253    			else if (g_LcdDirection == 1)	/* 横屏180°*/
;;;254    			{
;;;255    				x = g_LcdWidth - xx - 1;
000054  4836              LDR      r0,|L16.304|
;;;256    				y = g_LcdHeight - yy - 1;
000056  4a37              LDR      r2,|L16.308|
000058  4b37              LDR      r3,|L16.312|
00005a  f1b80f00          CMP      r8,#0                 ;245
00005e  d024              BEQ      |L16.170|
000060  f1b80f01          CMP      r8,#1                 ;245
000064  d02a              BEQ      |L16.188|
000066  f1b80f02          CMP      r8,#2                 ;245
00006a  d030              BEQ      |L16.206|
00006c  f1b80f03          CMP      r8,#3                 ;245
000070  d036              BEQ      |L16.224|
;;;257    			}
;;;258    			else if (g_LcdDirection == 2)	/* 竖屏 */
;;;259    			{
;;;260    				y = xx;
;;;261    				x = g_LcdWidth - yy - 1;
;;;262    			}
;;;263    			else if (g_LcdDirection == 3)	/* 竖屏180° */
;;;264    			{
;;;265    				y = g_LcdHeight - xx - 1;
;;;266    				x = yy;
;;;267    			}
;;;268    			break;
;;;269    
;;;270    		case 1:	/* 校准触摸时，屏幕方向为1 */
;;;271    			if (g_LcdDirection == 0)		/* 横屏 */
;;;272    			{
;;;273    				x = g_LcdWidth - xx - 1;
;;;274    				y = g_LcdHeight - yy - 1;
;;;275    			}
;;;276    			else if (g_LcdDirection == 1)	/* 横屏180°*/
;;;277    			{
;;;278    				x = xx;
;;;279    				y = yy;
;;;280    			}
;;;281    			else if (g_LcdDirection == 2)	/* 竖屏 */
;;;282    			{
;;;283    				y = g_LcdHeight - xx - 1;
;;;284    				x = yy;
;;;285    			}
;;;286    			else if (g_LcdDirection == 3)	/* 竖屏180° */
;;;287    			{
;;;288    				y = xx;
;;;289    				x = g_LcdWidth - yy - 1;
;;;290    			}
;;;291    			break;
;;;292    
;;;293    		case 2:	/* 校准触摸时，屏幕方向为2 */
;;;294    			if (g_LcdDirection == 0)		/* 横屏 */
;;;295    			{
;;;296    				y = xx;
;;;297    				x = g_LcdWidth - yy - 1;
;;;298    			}
;;;299    			else if (g_LcdDirection == 1)	/* 横屏180°*/
;;;300    			{
;;;301    				y = g_LcdHeight - xx - 1;
;;;302    				x = yy;
;;;303    			}
;;;304    			else if (g_LcdDirection == 2)	/* 竖屏 */
;;;305    			{
;;;306    				x = xx;
;;;307    				y = yy;
;;;308    			}
;;;309    			else if (g_LcdDirection == 3)	/* 竖屏180° */
;;;310    			{
;;;311    				x = g_LcdWidth - xx - 1;
;;;312    				y = g_LcdHeight - yy - 1;
;;;313    			}
;;;314    			break;
;;;315    
;;;316    		case 3:	/* 校准触摸时，屏幕方向为3 */
;;;317    			if (g_LcdDirection == 0)		/* 横屏 */
;;;318    			{
;;;319    				y = xx;
;;;320    				x = g_LcdWidth - yy - 1;
;;;321    			}
;;;322    			else if (g_LcdDirection == 1)	/* 横屏180°*/
;;;323    			{
;;;324    				y = g_LcdHeight - xx - 1;
;;;325    				x = yy;
;;;326    			}
;;;327    			else if (g_LcdDirection == 2)	/* 竖屏 */
;;;328    			{
;;;329    				x = g_LcdWidth - xx - 1;
;;;330    				y = g_LcdHeight - yy - 1;
;;;331    			}
;;;332    			else if (g_LcdDirection == 3)	/* 竖屏180° */
;;;333    			{
;;;334    				x = xx;
;;;335    				y = yy;
;;;336    			}
;;;337    			break;
;;;338    
;;;339    		default:
;;;340    			g_tParam.TouchDirection = 0;	/* 方向参数无效时，纠正为缺省的横屏 */
000072  f88c7005          STRB     r7,[r12,#5]
                  |L16.118|
;;;341    			break;
;;;342    	}
;;;343    
;;;344    	g_tTP.XBuf[g_tTP.Write] = x;
000076  f899108f          LDRB     r1,[r9,#0x8f]  ; g_tTP
00007a  4648              MOV      r0,r9
00007c  eb090141          ADD      r1,r9,r1,LSL #1
000080  87ce              STRH     r6,[r1,#0x3e]
;;;345    	g_tTP.YBuf[g_tTP.Write] = y;
000082  f899108f          LDRB     r1,[r9,#0x8f]  ; g_tTP
000086  eb090141          ADD      r1,r9,r1,LSL #1
00008a  f8a15066          STRH     r5,[r1,#0x66]
;;;346    
;;;347    	if (++g_tTP.Write  >= TOUCH_FIFO_SIZE)
00008e  f8101f8f          LDRB     r1,[r0,#0x8f]!  ; g_tTP
000092  1c49              ADDS     r1,r1,#1
000094  b2c9              UXTB     r1,r1
000096  7001              STRB     r1,[r0,#0]
000098  2914              CMP      r1,#0x14
00009a  d301              BCC      |L16.160|
;;;348    	{
;;;349    		g_tTP.Write = 0;
00009c  f889708f          STRB     r7,[r9,#0x8f]
                  |L16.160|
;;;350    	}
;;;351    }
0000a0  e8bd87f0          POP      {r4-r10,pc}
                  |L16.164|
0000a4  4644              MOV      r4,r8                 ;231
0000a6  4639              MOV      r1,r7                 ;232
0000a8  e7c9              B        |L16.62|
                  |L16.170|
0000aa  781b              LDRB     r3,[r3,#0]            ;248  ; g_LcdDirection
0000ac  b303              CBZ      r3,|L16.240|
0000ae  2b01              CMP      r3,#1                 ;253
0000b0  d02d              BEQ      |L16.270|
0000b2  2b02              CMP      r3,#2                 ;258
0000b4  d01f              BEQ      |L16.246|
0000b6  2b03              CMP      r3,#3                 ;263
0000b8  d023              BEQ      |L16.258|
0000ba  e7dc              B        |L16.118|
                  |L16.188|
0000bc  781b              LDRB     r3,[r3,#0]            ;271  ; g_LcdDirection
0000be  b333              CBZ      r3,|L16.270|
0000c0  2b01              CMP      r3,#1                 ;276
0000c2  d015              BEQ      |L16.240|
0000c4  2b02              CMP      r3,#2                 ;281
0000c6  d01c              BEQ      |L16.258|
0000c8  2b03              CMP      r3,#3                 ;286
0000ca  d014              BEQ      |L16.246|
0000cc  e7d3              B        |L16.118|
                  |L16.206|
0000ce  781b              LDRB     r3,[r3,#0]            ;294  ; g_LcdDirection
0000d0  b18b              CBZ      r3,|L16.246|
0000d2  2b01              CMP      r3,#1                 ;299
0000d4  d015              BEQ      |L16.258|
0000d6  2b02              CMP      r3,#2                 ;304
0000d8  d00a              BEQ      |L16.240|
0000da  2b03              CMP      r3,#3                 ;309
0000dc  d017              BEQ      |L16.270|
0000de  e7ca              B        |L16.118|
                  |L16.224|
0000e0  781b              LDRB     r3,[r3,#0]            ;317  ; g_LcdDirection
0000e2  b143              CBZ      r3,|L16.246|
0000e4  2b01              CMP      r3,#1                 ;322
0000e6  d00c              BEQ      |L16.258|
0000e8  2b02              CMP      r3,#2                 ;327
0000ea  d010              BEQ      |L16.270|
0000ec  2b03              CMP      r3,#3                 ;332
0000ee  d1c2              BNE      |L16.118|
                  |L16.240|
0000f0  4626              MOV      r6,r4                 ;334
0000f2  460d              MOV      r5,r1                 ;335
0000f4  e7bf              B        |L16.118|
                  |L16.246|
0000f6  8800              LDRH     r0,[r0,#0]            ;320  ; g_LcdWidth
0000f8  4625              MOV      r5,r4                 ;319
0000fa  1a40              SUBS     r0,r0,r1              ;320
0000fc  1e40              SUBS     r0,r0,#1              ;320
0000fe  b286              UXTH     r6,r0                 ;320
000100  e7b9              B        |L16.118|
                  |L16.258|
000102  8810              LDRH     r0,[r2,#0]            ;324  ; g_LcdHeight
000104  460e              MOV      r6,r1                 ;325
000106  1b00              SUBS     r0,r0,r4              ;324
000108  1e40              SUBS     r0,r0,#1              ;324
00010a  b285              UXTH     r5,r0                 ;324
00010c  e7b3              B        |L16.118|
                  |L16.270|
00010e  8800              LDRH     r0,[r0,#0]            ;329  ; g_LcdWidth
000110  1b00              SUBS     r0,r0,r4              ;329
000112  1e40              SUBS     r0,r0,#1              ;329
000114  b286              UXTH     r6,r0                 ;329
000116  8810              LDRH     r0,[r2,#0]            ;330  ; g_LcdHeight
000118  1a40              SUBS     r0,r0,r1              ;330
00011a  1e40              SUBS     r0,r0,#1              ;330
00011c  b285              UXTH     r5,r0                 ;330
00011e  e7aa              B        |L16.118|
;;;352    
                          ENDP

                  |L16.288|
                          DCD      ||.bss||+0x28
                  |L16.292|
                          DCD      g_GT811
                  |L16.296|
                          DCD      g_tFT5X06
                  |L16.300|
                          DCD      g_tParam
                  |L16.304|
                          DCD      g_LcdWidth
                  |L16.308|
                          DCD      g_LcdHeight
                  |L16.312|
                          DCD      g_LcdDirection

                          AREA ||i.TOUCH_ReadAdcX||, CODE, READONLY, ALIGN=2

                  TOUCH_ReadAdcX PROC
;;;178    */
;;;179    uint16_t TOUCH_ReadAdcX(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
;;;180    {
;;;181    	uint16_t usAdc;
;;;182    
;;;183    	__set_PRIMASK(1);  		/* 关中断 */
;;;184    	usAdc = g_tTP.usAdcNowX;
000006  4803              LDR      r0,|L17.20|
;;;185    	__set_PRIMASK(0);  		/* 开中断 */
000008  2100              MOVS     r1,#0
00000a  8c80              LDRH     r0,[r0,#0x24]         ;184  ; g_tTP
00000c  f3818810          MSR      PRIMASK,r1            ;184
;;;186    
;;;187    	return usAdc;
;;;188    }
000010  4770              BX       lr
;;;189    
                          ENDP

000012  0000              DCW      0x0000
                  |L17.20|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_ReadAdcY||, CODE, READONLY, ALIGN=2

                  TOUCH_ReadAdcY PROC
;;;197    */
;;;198    uint16_t TOUCH_ReadAdcY(void)
000000  2001              MOVS     r0,#1
000002  f3808810          MSR      PRIMASK,r0
;;;199    {
;;;200    	uint16_t usAdc;
;;;201    
;;;202    	__set_PRIMASK(1);  		/* 关中断 */
;;;203    	usAdc = g_tTP.usAdcNowY;
000006  4803              LDR      r0,|L18.20|
;;;204    	__set_PRIMASK(0);  		/* 开中断 */
000008  2100              MOVS     r1,#0
00000a  8cc0              LDRH     r0,[r0,#0x26]         ;203  ; g_tTP
00000c  f3818810          MSR      PRIMASK,r1            ;203
;;;205    
;;;206    	return usAdc;
;;;207    }
000010  4770              BX       lr
;;;208    
                          ENDP

000012  0000              DCW      0x0000
                  |L18.20|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_SaveParam||, CODE, READONLY, ALIGN=2

                  TOUCH_SaveParam PROC
;;;1133   extern void SaveParam(void);
;;;1134   static void TOUCH_SaveParam(void)
000000  4914              LDR      r1,|L19.84|
;;;1135   {
;;;1136   #if 1
;;;1137   	g_tParam.usAdcX1 = g_tTP.usAdcX1;
000002  4815              LDR      r0,|L19.88|
000004  880a              LDRH     r2,[r1,#0]  ; g_tTP
000006  8102              STRH     r2,[r0,#8]
;;;1138   	g_tParam.usAdcY1 = g_tTP.usAdcY1;
000008  884a              LDRH     r2,[r1,#2]  ; g_tTP
00000a  8142              STRH     r2,[r0,#0xa]
;;;1139   	g_tParam.usAdcX2 = g_tTP.usAdcX2;
00000c  888a              LDRH     r2,[r1,#4]  ; g_tTP
00000e  8182              STRH     r2,[r0,#0xc]
;;;1140   	g_tParam.usAdcY2 = g_tTP.usAdcY2;
000010  88ca              LDRH     r2,[r1,#6]  ; g_tTP
000012  81c2              STRH     r2,[r0,#0xe]
;;;1141   	g_tParam.usAdcX3 = g_tTP.usAdcX3;
000014  890a              LDRH     r2,[r1,#8]  ; g_tTP
000016  8202              STRH     r2,[r0,#0x10]
;;;1142   	g_tParam.usAdcY3 = g_tTP.usAdcY3;
000018  894a              LDRH     r2,[r1,#0xa]  ; g_tTP
00001a  8242              STRH     r2,[r0,#0x12]
;;;1143   	g_tParam.usAdcX4 = g_tTP.usAdcX4;
00001c  898a              LDRH     r2,[r1,#0xc]  ; g_tTP
00001e  8282              STRH     r2,[r0,#0x14]
;;;1144   	g_tParam.usAdcY4 = g_tTP.usAdcY4;
000020  89ca              LDRH     r2,[r1,#0xe]  ; g_tTP
000022  82c2              STRH     r2,[r0,#0x16]
;;;1145   
;;;1146   	g_tParam.usLcdX1 = g_tTP.usLcdX1;
000024  8a0a              LDRH     r2,[r1,#0x10]  ; g_tTP
000026  8302              STRH     r2,[r0,#0x18]
;;;1147   	g_tParam.usLcdY1 = g_tTP.usLcdY1;
000028  8a4a              LDRH     r2,[r1,#0x12]  ; g_tTP
00002a  8342              STRH     r2,[r0,#0x1a]
;;;1148   	g_tParam.usLcdX2 = g_tTP.usLcdX2;
00002c  8a8a              LDRH     r2,[r1,#0x14]  ; g_tTP
00002e  8382              STRH     r2,[r0,#0x1c]
;;;1149   	g_tParam.usLcdY2 = g_tTP.usLcdY2;
000030  8aca              LDRH     r2,[r1,#0x16]  ; g_tTP
000032  83c2              STRH     r2,[r0,#0x1e]
;;;1150   	g_tParam.usLcdX3 = g_tTP.usLcdX3;
000034  8b0a              LDRH     r2,[r1,#0x18]  ; g_tTP
000036  8402              STRH     r2,[r0,#0x20]
;;;1151   	g_tParam.usLcdY3 = g_tTP.usLcdY3;
000038  8b4a              LDRH     r2,[r1,#0x1a]  ; g_tTP
00003a  8442              STRH     r2,[r0,#0x22]
;;;1152   	g_tParam.usLcdX4 = g_tTP.usLcdX4;
00003c  8b8a              LDRH     r2,[r1,#0x1c]  ; g_tTP
00003e  8482              STRH     r2,[r0,#0x24]
;;;1153   	g_tParam.usLcdY4 = g_tTP.usLcdY4;
000040  8bca              LDRH     r2,[r1,#0x1e]  ; g_tTP
000042  84c2              STRH     r2,[r0,#0x26]
;;;1154   
;;;1155   	g_tParam.XYChange = g_tTP.XYChange;
000044  f8911020          LDRB     r1,[r1,#0x20]  ; g_tTP
000048  7181              STRB     r1,[r0,#6]
;;;1156   
;;;1157   	g_tParam.TouchDirection = g_LcdDirection;	/* 2014-09-11 添加屏幕方向, 用于屏幕旋转时无需再次校准 */
00004a  4904              LDR      r1,|L19.92|
00004c  7809              LDRB     r1,[r1,#0]  ; g_LcdDirection
00004e  7141              STRB     r1,[r0,#5]
;;;1158   
;;;1159   	SaveParam();	/* 将参数写入Flash */
000050  f7ffbffe          B.W      SaveParam
;;;1160   #endif
;;;1161   }
;;;1162   
                          ENDP

                  |L19.84|
                          DCD      ||.bss||+0x28
                  |L19.88|
                          DCD      g_tParam
                  |L19.92|
                          DCD      g_LcdDirection

                          AREA ||i.TOUCH_Scan||, CODE, READONLY, ALIGN=2

                  TOUCH_Scan PROC
;;;490    */
;;;491    void TOUCH_Scan(void)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;492    {
;;;493    	uint16_t usAdcX;
;;;494    	uint16_t usAdcY;
;;;495    	uint8_t fPressed = 0;	
;;;496    	static uint16_t s_usXBuf[SAMPLE_COUNT];
;;;497    	static uint16_t s_usYBuf[SAMPLE_COUNT];
;;;498    	static uint8_t s_ucPos = 0;
;;;499    	static uint8_t s_count = 0;
;;;500    	static uint8_t s_down = 0;
;;;501    	static uint16_t s_usSaveAdcX, s_usSaveAdcY; /* 用于触笔抬起事件，保存按下和移动的最后采样值 */
;;;502    
;;;503    	if (g_GT811.Enable == 1)
000004  4845              LDR      r0,|L20.284|
000006  7800              LDRB     r0,[r0,#0]  ; g_GT811
000008  2801              CMP      r0,#1
00000a  d051              BEQ      |L20.176|
;;;504    	{
;;;505    		GT811_Timer1ms();	/* 电容触摸屏程序计数器 */
;;;506    		return;
;;;507    	}
;;;508    	
;;;509    	if (g_tFT5X06.Enable == 1)
00000c  4844              LDR      r0,|L20.288|
00000e  7840              LDRB     r0,[r0,#1]  ; g_tFT5X06
000010  2801              CMP      r0,#1
000012  d051              BEQ      |L20.184|
;;;510    	{
;;;511    		FT5X06_Timer1ms();	/* 电容触摸屏程序计数器 */
;;;512    		return;
;;;513    	}
;;;514    	
;;;515    	if (g_tTP.Enable == 0)
000014  4d43              LDR      r5,|L20.292|
000016  f8950028          LDRB     r0,[r5,#0x28]  ; g_tTP
00001a  2800              CMP      r0,#0
00001c  d046              BEQ      |L20.172|
;;;516    	{
;;;517    		return;
;;;518    	}
;;;519    
;;;520    	/* 获得原始的ADC值，未滤波 */
;;;521    	if (g_ChipID == IC_8875)
00001e  4842              LDR      r0,|L20.296|
000020  2600              MOVS     r6,#0
;;;522    	{
;;;523    		/* 如果主程序正在访问RA8875,则丢弃本次触摸采集，避免影响显示 */
;;;524    		if (RA8875_IsBusy())
;;;525    		{
;;;526    			return;
;;;527    		}
;;;528    
;;;529    		usAdcX = RA8875_TouchReadX();
;;;530    		usAdcY = RA8875_TouchReadY();
;;;531    		
;;;532    		if (TOUCH_PressValid(usAdcX, usAdcY))
;;;533    		{
;;;534    			fPressed = 1;
;;;535    		}
;;;536    	}
;;;537    	else
;;;538    	{
;;;539    		if (TSC2046_PenInt())
;;;540    		{
;;;541    			/* 如果主程序正在访问其他SPI外设，则丢弃本次触摸采集 */
;;;542    			if (bsp_SpiBusBusy())
;;;543    			{
;;;544    				return;
;;;545    			}
;;;546    
;;;547    			usAdcX = TSC2046_ReadAdc(ADC_CH_X);
;;;548    			usAdcY = TSC2046_ReadAdc(ADC_CH_Y);
;;;549    			
;;;550    			fPressed = 1;
;;;551    		}
;;;552    		else
;;;553    		{
;;;554    			usAdcX = 0;
;;;555    			usAdcY = 0;
;;;556    		}
;;;557    	}
;;;558    
;;;559    	if (fPressed == 1)
;;;560    	{
;;;561    		/* 按压30ms之后才开始采集数据 */
;;;562    		if (s_count >= DOWN_VALID)
000022  4c42              LDR      r4,|L20.300|
000024  8800              LDRH     r0,[r0,#0]            ;521  ; g_ChipID
000026  2875              CMP      r0,#0x75              ;521
000028  d04a              BEQ      |L20.192|
00002a  f7fffffe          BL       TSC2046_PenInt
00002e  2800              CMP      r0,#0                 ;539
000030  d056              BEQ      |L20.224|
000032  f7fffffe          BL       bsp_SpiBusBusy
000036  2800              CMP      r0,#0                 ;542
000038  d138              BNE      |L20.172|
00003a  2001              MOVS     r0,#1                 ;547
00003c  f7fffffe          BL       TSC2046_ReadAdc
000040  4680              MOV      r8,r0                 ;547
000042  2005              MOVS     r0,#5                 ;548
000044  f7fffffe          BL       TSC2046_ReadAdc
000048  4607              MOV      r7,r0                 ;548
                  |L20.74|
00004a  78a0              LDRB     r0,[r4,#2]  ; s_count
00004c  281e              CMP      r0,#0x1e
00004e  d357              BCC      |L20.256|
;;;563    		{
;;;564    			s_usXBuf[s_ucPos] = usAdcX;
000050  4a34              LDR      r2,|L20.292|
000052  7860              LDRB     r0,[r4,#1]  ; s_ucPos
000054  3a28              SUBS     r2,r2,#0x28
;;;565    			s_usYBuf[s_ucPos] = usAdcY;
000056  f1020114          ADD      r1,r2,#0x14
00005a  f8228010          STRH     r8,[r2,r0,LSL #1]     ;564
00005e  f8217010          STRH     r7,[r1,r0,LSL #1]
000062  1c40              ADDS     r0,r0,#1
;;;566    			
;;;567    			/* 采集10ms数据进行滤波 */
;;;568    			if (++s_ucPos >= SAMPLE_COUNT)
000064  b2c0              UXTB     r0,r0
000066  7060              STRB     r0,[r4,#1]
000068  280a              CMP      r0,#0xa
00006a  d31f              BCC      |L20.172|
;;;569    			{
;;;570    				s_ucPos = 0;
00006c  7066              STRB     r6,[r4,#1]
;;;571    
;;;572    			   	/* 对ADC采样值进行软件滤波 */
;;;573    				g_tTP.usAdcNowX = TOUCH_DataFilter(s_usXBuf, SAMPLE_COUNT);
00006e  210a              MOVS     r1,#0xa
000070  4610              MOV      r0,r2
000072  f7fffffe          BL       TOUCH_DataFilter
000076  84a8              STRH     r0,[r5,#0x24]
;;;574    				g_tTP.usAdcNowY = TOUCH_DataFilter(s_usYBuf, SAMPLE_COUNT);
000078  482a              LDR      r0,|L20.292|
00007a  210a              MOVS     r1,#0xa
00007c  3814              SUBS     r0,r0,#0x14
00007e  f7fffffe          BL       TOUCH_DataFilter
000082  84e8              STRH     r0,[r5,#0x26]
000084  4602              MOV      r2,r0
;;;575    
;;;576    				if (s_down == 0)
000086  78e0              LDRB     r0,[r4,#3]  ; s_down
000088  b390              CBZ      r0,|L20.240|
;;;577    				{
;;;578    					s_down = 1;
;;;579    					/* 触摸按下事件 */
;;;580    					TOUCH_PutKey(TOUCH_DOWN, g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;581    
;;;582    					s_usSaveAdcX = g_tTP.usAdcNowX;
;;;583    					s_usSaveAdcY = g_tTP.usAdcNowY;
;;;584    				}
;;;585    				else
;;;586    				{
;;;587    					/* 每隔10ms 发送一次触摸移动事件 */
;;;588    					if (TOUCH_MoveValid(s_usSaveAdcX, s_usSaveAdcY, g_tTP.usAdcNowX, g_tTP.usAdcNowY))
00008a  8ca8              LDRH     r0,[r5,#0x24]  ; g_tTP
00008c  4613              MOV      r3,r2
00008e  4602              MOV      r2,r0
000090  88e1              LDRH     r1,[r4,#6]  ; s_usSaveAdcY
000092  88a0              LDRH     r0,[r4,#4]  ; s_usSaveAdcX
000094  f7fffffe          BL       TOUCH_MoveValid
000098  b358              CBZ      r0,|L20.242|
;;;589    					{
;;;590    						/* 触摸移动事件 */
;;;591    						TOUCH_PutKey(TOUCH_MOVE, g_tTP.usAdcNowX, g_tTP.usAdcNowY);
00009a  8cea              LDRH     r2,[r5,#0x26]  ; g_tTP
00009c  8ca9              LDRH     r1,[r5,#0x24]  ; g_tTP
00009e  2002              MOVS     r0,#2
                  |L20.160|
0000a0  f7fffffe          BL       TOUCH_PutKey
;;;592    
;;;593    						s_usSaveAdcX = g_tTP.usAdcNowX;
0000a4  8ca8              LDRH     r0,[r5,#0x24]  ; g_tTP
0000a6  80a0              STRH     r0,[r4,#4]
;;;594    						s_usSaveAdcY = g_tTP.usAdcNowY;
0000a8  8ce8              LDRH     r0,[r5,#0x26]  ; g_tTP
0000aa  80e0              STRH     r0,[r4,#6]
                  |L20.172|
;;;595    					}
;;;596    					else
;;;597    					{
;;;598    						g_tTP.usAdcNowX = 0; /* for debug stop */
;;;599    					}
;;;600    				}
;;;601    			}
;;;602    		}
;;;603    		else
;;;604    		{
;;;605    			s_count++;
;;;606    		}
;;;607    	}
;;;608    	else
;;;609    	{
;;;610    		if (s_count > 0)
;;;611    		{
;;;612    			if (--s_count == 0)
;;;613    			{
;;;614    				/* 触摸释放事件 */
;;;615    				//TOUCH_PutKey(TOUCH_RELEASE, g_tTP.usAdcNowX, g_tTP.usAdcNowY);
;;;616    				TOUCH_PutKey(TOUCH_RELEASE, s_usSaveAdcX, s_usSaveAdcY);
;;;617    
;;;618    				g_tTP.usAdcNowX = 0;
;;;619    				g_tTP.usAdcNowY = 0;
;;;620    
;;;621    				s_count = 0;
;;;622    				s_down = 0;
;;;623    			}
;;;624    		}
;;;625    		s_ucPos = 0;
;;;626    	}
;;;627    }
0000ac  e8bd81f0          POP      {r4-r8,pc}
                  |L20.176|
0000b0  e8bd41f0          POP      {r4-r8,lr}            ;505
0000b4  f7ffbffe          B.W      GT811_Timer1ms
                  |L20.184|
0000b8  e8bd41f0          POP      {r4-r8,lr}            ;511
0000bc  f7ffbffe          B.W      FT5X06_Timer1ms
                  |L20.192|
0000c0  f7fffffe          BL       RA8875_IsBusy
0000c4  2800              CMP      r0,#0                 ;524
0000c6  d1f1              BNE      |L20.172|
0000c8  f7fffffe          BL       RA8875_TouchReadX
0000cc  4680              MOV      r8,r0                 ;529
0000ce  f7fffffe          BL       RA8875_TouchReadY
0000d2  4607              MOV      r7,r0                 ;530
0000d4  4601              MOV      r1,r0                 ;532
0000d6  4640              MOV      r0,r8                 ;532
0000d8  f7fffffe          BL       TOUCH_PressValid
0000dc  2800              CMP      r0,#0                 ;532
0000de  d1b4              BNE      |L20.74|
                  |L20.224|
0000e0  78a0              LDRB     r0,[r4,#2]            ;610  ; s_count
0000e2  b1c8              CBZ      r0,|L20.280|
0000e4  1e40              SUBS     r0,r0,#1              ;610
0000e6  f01000ff          ANDS     r0,r0,#0xff           ;612
0000ea  70a0              STRB     r0,[r4,#2]            ;612
0000ec  d00b              BEQ      |L20.262|
0000ee  e013              B        |L20.280|
                  |L20.240|
0000f0  e000              B        |L20.244|
                  |L20.242|
0000f2  e003              B        |L20.252|
                  |L20.244|
0000f4  2001              MOVS     r0,#1                 ;578
0000f6  70e0              STRB     r0,[r4,#3]            ;578
0000f8  8ca9              LDRH     r1,[r5,#0x24]         ;580  ; g_tTP
0000fa  e7d1              B        |L20.160|
                  |L20.252|
0000fc  84ae              STRH     r6,[r5,#0x24]         ;598
0000fe  e7d5              B        |L20.172|
                  |L20.256|
000100  1c40              ADDS     r0,r0,#1
000102  70a0              STRB     r0,[r4,#2]            ;605
000104  e7d2              B        |L20.172|
                  |L20.262|
000106  88e2              LDRH     r2,[r4,#6]            ;616  ; s_usSaveAdcY
000108  88a1              LDRH     r1,[r4,#4]            ;616  ; s_usSaveAdcX
00010a  2003              MOVS     r0,#3                 ;616
00010c  f7fffffe          BL       TOUCH_PutKey
000110  84ae              STRH     r6,[r5,#0x24]         ;618
000112  84ee              STRH     r6,[r5,#0x26]         ;619
000114  70a6              STRB     r6,[r4,#2]            ;621
000116  70e6              STRB     r6,[r4,#3]            ;622
                  |L20.280|
000118  7066              STRB     r6,[r4,#1]            ;625
00011a  e7c7              B        |L20.172|
;;;628    
                          ENDP

                  |L20.284|
                          DCD      g_GT811
                  |L20.288|
                          DCD      g_tFT5X06
                  |L20.292|
                          DCD      ||.bss||+0x28
                  |L20.296|
                          DCD      g_ChipID
                  |L20.300|
                          DCD      ||.data||

                          AREA ||i.TOUCH_TransX||, CODE, READONLY, ALIGN=2

                  TOUCH_TransX PROC
;;;649    */
;;;650    static int16_t TOUCH_TransX(uint16_t _usAdcX, uint16_t _usAdcY)
000000  b5f8              PUSH     {r3-r7,lr}
;;;651    {
;;;652    #if CALIB_POINT_COUNT == 2	/* 2点校准 */
;;;653    	uint16_t x;
;;;654    	int32_t y;
;;;655    
;;;656    	if (g_tTP.XYChange == 0)
000002  4c0b              LDR      r4,|L21.48|
000004  4622              MOV      r2,r4
000006  8c26              LDRH     r6,[r4,#0x20]  ; g_tTP
;;;657    	{
;;;658    		x = _usAdcX;
;;;659    		if (x == 0)
;;;660    		{
;;;661    			y = 0;
;;;662    		}
;;;663    		else
;;;664    		{
;;;665    			//y = CalTwoPoint(g_tTP.usAdcX1, TP_X1, g_tTP.usAdcX2, TP_X2, x);
;;;666    			y = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usLcdX1, g_tTP.usAdcX2, g_tTP.usLcdX2, x);
000008  8a15              LDRH     r5,[r2,#0x10]
00000a  8a93              LDRH     r3,[r2,#0x14]
00000c  b146              CBZ      r6,|L21.32|
;;;667    		}
;;;668    	}
;;;669    	else
;;;670    	{
;;;671    		x = _usAdcY;
;;;672    		if (x == 0)
00000e  b169              CBZ      r1,|L21.44|
;;;673    		{
;;;674    			y = 0;
;;;675    		}
;;;676    		else
;;;677    		{
;;;678    			//y = CalTwoPoint(g_tTP.usAdcY1, TP_X1, g_tTP.usAdcY2, TP_X2, x);
;;;679    			y = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usLcdX1, g_tTP.usAdcY2, g_tTP.usLcdX2, x);
000010  9100              STR      r1,[sp,#0]
000012  88e2              LDRH     r2,[r4,#6]  ; g_tTP
000014  8860              LDRH     r0,[r4,#2]  ; g_tTP
                  |L21.22|
000016  4629              MOV      r1,r5
000018  f7fffffe          BL       CalTwoPoint
                  |L21.28|
;;;680    		}
;;;681    	}
;;;682    	return y;
00001c  b200              SXTH     r0,r0
;;;683    #else		/* 4点校准 */
;;;684    	uint16_t x, x1, x2;
;;;685    	int32_t y;
;;;686    
;;;687    	if (g_tTP.XYChange == 0)	/* X Y 坐标不交换 */
;;;688    	{
;;;689    		x = _usAdcX;
;;;690    
;;;691    		/* 根据 Y ADC 实时计算直线方程的参考点x1, x2
;;;692    			if  _usAdcY = usAdcY1 then  取点 = (AdcX1, TP_X1, AdcX4, TP_X4, _usAdcY)
;;;693    			if  _usAdcY = usAdcY2 then  取点 = (AdcX3, TP_X3, AdcX2, TP_X2, _usAdcY)
;;;694    
;;;695    			其中 TP_X1 = TP_X3;  TP_X4 = TP_X1 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;696    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;697    		*/
;;;698    		x1 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX1, g_tTP.usAdcY2,  g_tTP.usAdcX3, _usAdcY);
;;;699    		x2 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX4, g_tTP.usAdcY2,  g_tTP.usAdcX2, _usAdcY);
;;;700    	}
;;;701    	else						/* X Y 坐标交换 */
;;;702    	{
;;;703    		x = _usAdcY;
;;;704    
;;;705    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;706    			if  _usAdcX = usAdcX1 then  取点 = (AdcY1, TP_X1, AdcY4, TP_X4, _usAdcX)
;;;707    			if  _usAdcX = usAdcX2 then  取点 = (AdcY3, TP_X3, AdcY2, TP_X2, _usAdcX)
;;;708    
;;;709    			其中 TP_X1 = TP_X3;  TP_X4 = TP_X1 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;710    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;711    		*/
;;;712    		x1 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY1, g_tTP.usAdcX2,  g_tTP.usAdcY3, _usAdcX);
;;;713    		x2 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY4, g_tTP.usAdcX2,  g_tTP.usAdcY2, _usAdcX);
;;;714    	}
;;;715    
;;;716    	if (x == 0)
;;;717    	{
;;;718    		y = 0;
;;;719    	}
;;;720    	else
;;;721    	{
;;;722    		/* 根据2点直线方程，计算坐标 */
;;;723    		//y = CalTwoPoint(x1, TP_X1, x2, TP_X2, x);
;;;724    		CalTwoPoint(x1, g_tTP.usLcdX1, x2, g_tTP.usLcd2, x);
;;;725    	}
;;;726    	return y;
;;;727    #endif
;;;728    }
00001e  bdf8              POP      {r3-r7,pc}
                  |L21.32|
000020  2800              CMP      r0,#0                 ;659
000022  d0fb              BEQ      |L21.28|
000024  9000              STR      r0,[sp,#0]            ;666
000026  88a2              LDRH     r2,[r4,#4]            ;666  ; g_tTP
000028  8820              LDRH     r0,[r4,#0]            ;666  ; g_tTP
00002a  e7f4              B        |L21.22|
                  |L21.44|
00002c  2000              MOVS     r0,#0                 ;674
00002e  e7f5              B        |L21.28|
;;;729    
                          ENDP

                  |L21.48|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_TransY||, CODE, READONLY, ALIGN=2

                  TOUCH_TransY PROC
;;;737    */
;;;738    static int16_t TOUCH_TransY(uint16_t _usAdcX, uint16_t _usAdcY)
000000  b5f8              PUSH     {r3-r7,lr}
;;;739    {
;;;740    #if CALIB_POINT_COUNT == 2	/* 2点校准 */
;;;741    	int32_t x;
;;;742    	int32_t y;
;;;743    
;;;744    	if (g_tTP.XYChange == 0)
000002  4c0b              LDR      r4,|L22.48|
000004  4622              MOV      r2,r4
000006  8c26              LDRH     r6,[r4,#0x20]  ; g_tTP
;;;745    	{
;;;746    		x = _usAdcY;
;;;747    		if (x == 0)
;;;748    		{
;;;749    			y = 0;
;;;750    		}
;;;751    		else
;;;752    		{
;;;753    			//y = CalTwoPoint(g_tTP.usAdcY1, TP_Y1, g_tTP.usAdcY2, TP_Y2, x);
;;;754    			y = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usLcdY1, g_tTP.usAdcY2, g_tTP.usLcdY2, x);
000008  8a55              LDRH     r5,[r2,#0x12]
00000a  8ad3              LDRH     r3,[r2,#0x16]
00000c  b146              CBZ      r6,|L22.32|
;;;755    		}
;;;756    	}
;;;757    	else
;;;758    	{
;;;759    		x = _usAdcX;
;;;760    		if (x == 0)
00000e  b128              CBZ      r0,|L22.28|
;;;761    		{
;;;762    			y = 0;
;;;763    		}
;;;764    		else
;;;765    		{
;;;766    			//y = CalTwoPoint(g_tTP.usAdcX1, TP_Y1, g_tTP.usAdcX2, TP_Y2, x);
;;;767    			y = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usLcdY1, g_tTP.usAdcX2, g_tTP.usLcdY2, x);
000010  9000              STR      r0,[sp,#0]
000012  88a2              LDRH     r2,[r4,#4]  ; g_tTP
000014  8820              LDRH     r0,[r4,#0]  ; g_tTP
                  |L22.22|
000016  4629              MOV      r1,r5
000018  f7fffffe          BL       CalTwoPoint
                  |L22.28|
;;;768    		}
;;;769    	}
;;;770    	return y;
00001c  b200              SXTH     r0,r0
;;;771    #else		/* 4点校准 */
;;;772    	int32_t x, x1, x2;
;;;773    	int32_t y;
;;;774    
;;;775    	if (g_tTP.XYChange == 0)	/* X Y 坐标不交换 */
;;;776    	{
;;;777    		x = _usAdcY;
;;;778    
;;;779    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;780    			if  _usAdcX = usAdcX1 then  取点 = (AdcY1, TP_Y1, AdcY3, TP_Y3, _usAdcX)
;;;781    			if  _usAdcX = usAdcX2 then  取点 = (AdcY4, TP_Y4, AdcY2, TP_Y2, _usAdcX)
;;;782    
;;;783    			其中 TP_Y1 = TP_Y4;  TP_Y3 = TP_Y2 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;784    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;785    		*/
;;;786    		x1 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY1, g_tTP.usAdcX2,  g_tTP.usAdcY4, _usAdcX);
;;;787    		x2 = CalTwoPoint(g_tTP.usAdcX1, g_tTP.usAdcY3, g_tTP.usAdcX2,  g_tTP.usAdcY2, _usAdcX);
;;;788    	}
;;;789    	else						/* X Y 坐标交换 */
;;;790    	{
;;;791    		x = _usAdcX;
;;;792    
;;;793    		/* 根据 X ADC 实时计算直线方程的参考点x1, x2
;;;794    			if  _usAdcY = usAdcY1 then  取点 = (AdcX1, TP_Y1, AdcX3, TP_Y3, _usAdcY)
;;;795    			if  _usAdcY = usAdcY2 then  取点 = (AdcX4, TP_Y4, AdcX2, TP_Y2, _usAdcY)
;;;796    
;;;797    			其中 TP_Y1 = TP_Y3;  TP_Y4 = TP_Y2 , 这是程序设定的校准位置的像素坐标, 是固定的。
;;;798    			我们仅需要动态计算对第1个和第3个参数。同样采用2点直线方程计算。
;;;799    		*/
;;;800    		x1 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX1, g_tTP.usAdcY2,  g_tTP.usAdcX4, _usAdcY);
;;;801    		x2 = CalTwoPoint(g_tTP.usAdcY1, g_tTP.usAdcX3, g_tTP.usAdcY2,  g_tTP.usAdcX2, _usAdcY);
;;;802    	}
;;;803    
;;;804    	if (x == 0)
;;;805    	{
;;;806    		y = 0;
;;;807    	}
;;;808    	else
;;;809    	{
;;;810    		/* 根据2点直线方程，计算坐标 */
;;;811    		//y = CalTwoPoint(x1, TP_Y1, x2, TP_Y2, x);
;;;812    		y = CalTwoPoint(x1, g_tTP.usLcdY1, x2, g_tTP.usLcdY2, x);
;;;813    	}
;;;814    	return y;
;;;815    #endif
;;;816    }
00001e  bdf8              POP      {r3-r7,pc}
                  |L22.32|
000020  b119              CBZ      r1,|L22.42|
000022  9100              STR      r1,[sp,#0]            ;754
000024  88e2              LDRH     r2,[r4,#6]            ;754  ; g_tTP
000026  8860              LDRH     r0,[r4,#2]            ;754  ; g_tTP
000028  e7f5              B        |L22.22|
                  |L22.42|
00002a  2000              MOVS     r0,#0                 ;749
00002c  e7f6              B        |L22.28|
;;;817    
                          ENDP

00002e  0000              DCW      0x0000
                  |L22.48|
                          DCD      ||.bss||+0x28

                          AREA ||i.TOUCH_WaitRelease||, CODE, READONLY, ALIGN=1

                  TOUCH_WaitRelease PROC
;;;981    */
;;;982    static void TOUCH_WaitRelease(void)
000000  b510              PUSH     {r4,lr}
;;;983    {
;;;984    	uint8_t usCount = 0;
000002  2400              MOVS     r4,#0
                  |L23.4|
;;;985    
;;;986    	for (;;)
;;;987    	{
;;;988    		if (TOUCH_PressValid(TOUCH_ReadAdcX(), TOUCH_ReadAdcY()) == 0)
000004  f7fffffe          BL       TOUCH_ReadAdcY
000008  4602              MOV      r2,r0
00000a  f7fffffe          BL       TOUCH_ReadAdcX
00000e  4611              MOV      r1,r2
000010  f7fffffe          BL       TOUCH_PressValid
000014  b120              CBZ      r0,|L23.32|
;;;989    		{
;;;990    			if (++usCount > 5)
;;;991    			{
;;;992    				break;
;;;993    			}
;;;994    		}
;;;995    		else
;;;996    		{
;;;997    			usCount = 0;
000016  2400              MOVS     r4,#0
                  |L23.24|
;;;998    		}
;;;999    		bsp_DelayMS(10);
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       bsp_DelayMS
00001e  e7f1              B        |L23.4|
                  |L23.32|
000020  1c64              ADDS     r4,r4,#1
000022  b2e4              UXTB     r4,r4                 ;990
000024  2c05              CMP      r4,#5                 ;990
000026  d9f7              BLS      |L23.24|
;;;1000   	}
;;;1001   }
000028  bd10              POP      {r4,pc}
;;;1002   
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=1

                  s_usXBuf
                          %        20
                  s_usYBuf
                          %        20
                  g_tTP
                          %        144

                          AREA ||.data||, DATA, ALIGN=1

                  s_invalid_count
000000  00                DCB      0x00
                  s_ucPos
000001  00                DCB      0x00
                  s_count
000002  00                DCB      0x00
                  s_down
000003  00                DCB      0x00
                  s_usSaveAdcX
000004  0000              DCB      0x00,0x00
                  s_usSaveAdcY
000006  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_touch.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_touch_c_30847bcd____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___11_bsp_touch_c_30847bcd____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___11_bsp_touch_c_30847bcd____REVSH|
#line 128
|__asm___11_bsp_touch_c_30847bcd____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
