; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\form_dso.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\form_dso.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\form_dso.crf ..\..\User\app\src\form_dso.c]
                          THUMB

                          AREA ||i.AdjustAtt||, CODE, READONLY, ALIGN=2

                  AdjustAtt PROC
;;;1007   */
;;;1008   static void AdjustAtt(uint8_t ch, uint8_t mode)
000000  4a18              LDR      r2,|L1.100|
;;;1009   {
;;;1010   
;;;1011   	if (ch == 1)
;;;1012   	{
;;;1013   		if (mode == 0) 	/* 降低 */
;;;1014   		{
;;;1015   			if (g_DSO->Ch1AttId > 0)
;;;1016   			{
;;;1017   				g_DSO->Ch1AttId--;
;;;1018   			}
;;;1019   		}
;;;1020   		else		/* 增加 */
;;;1021   		{
;;;1022   			if (g_DSO->Ch1AttId < ATT_COUNT - 1)
;;;1023   			{
;;;1024   				g_DSO->Ch1AttId++;
;;;1025   			}
;;;1026   		}
;;;1027   
;;;1028   		g_DSO->Ch1Attenuation = g_AttTable[g_DSO->Ch1AttId][0];
000002  4b17              LDR      r3,|L1.96|
000004  2801              CMP      r0,#1                 ;1011
000006  6852              LDR      r2,[r2,#4]            ;1015
000008  f5025280          ADD      r2,r2,#0x1000         ;1015
00000c  d010              BEQ      |L1.48|
;;;1029   		g_DSO->Ch1VScale =  g_AttTable[g_DSO->Ch1AttId][1];
;;;1030   	}
;;;1031   	else if (ch == 2)
00000e  2802              CMP      r0,#2
000010  d10d              BNE      |L1.46|
;;;1032   	{
;;;1033   		if (mode == 0) 	/* 降低 */
;;;1034   		{
;;;1035   			if (g_DSO->Ch2AttId > 0)
;;;1036   			{
;;;1037   				g_DSO->Ch2AttId--;
;;;1038   			}
;;;1039   		}
;;;1040   		else		/* 增加 */
;;;1041   		{
;;;1042   			if (g_DSO->Ch2AttId < ATT_COUNT - 1)
000012  7c50              LDRB     r0,[r2,#0x11]
000014  b1f9              CBZ      r1,|L1.86|
000016  2805              CMP      r0,#5
000018  d201              BCS      |L1.30|
00001a  1c40              ADDS     r0,r0,#1
                  |L1.28|
;;;1043   			{
;;;1044   				g_DSO->Ch2AttId++;
00001c  7450              STRB     r0,[r2,#0x11]
                  |L1.30|
;;;1045   			}
;;;1046   		}
;;;1047   		g_DSO->Ch2Attenuation = g_AttTable[g_DSO->Ch2AttId][0];
00001e  b2c0              UXTB     r0,r0
000020  f8531030          LDR      r1,[r3,r0,LSL #3]
;;;1048   		g_DSO->Ch2VScale =  g_AttTable[g_DSO->Ch2AttId][1];
000024  eb0300c0          ADD      r0,r3,r0,LSL #3
000028  6191              STR      r1,[r2,#0x18]
00002a  8880              LDRH     r0,[r0,#4]
00002c  83d0              STRH     r0,[r2,#0x1e]
                  |L1.46|
;;;1049   	}
;;;1050   }
00002e  4770              BX       lr
                  |L1.48|
000030  7c10              LDRB     r0,[r2,#0x10]         ;1022
000032  b161              CBZ      r1,|L1.78|
000034  2805              CMP      r0,#5                 ;1022
000036  d201              BCS      |L1.60|
000038  1c40              ADDS     r0,r0,#1              ;1022
                  |L1.58|
00003a  7410              STRB     r0,[r2,#0x10]         ;1024
                  |L1.60|
00003c  b2c0              UXTB     r0,r0                 ;1028
00003e  f8531030          LDR      r1,[r3,r0,LSL #3]     ;1028
000042  eb0300c0          ADD      r0,r3,r0,LSL #3       ;1029
000046  6151              STR      r1,[r2,#0x14]         ;1029
000048  8880              LDRH     r0,[r0,#4]            ;1029
00004a  8390              STRH     r0,[r2,#0x1c]         ;1029
00004c  4770              BX       lr
                  |L1.78|
00004e  2800              CMP      r0,#0                 ;1015
000050  d0f4              BEQ      |L1.60|
000052  1e40              SUBS     r0,r0,#1              ;1015
000054  e7f1              B        |L1.58|
                  |L1.86|
000056  2800              CMP      r0,#0                 ;1035
000058  d0e1              BEQ      |L1.30|
00005a  1e40              SUBS     r0,r0,#1              ;1035
00005c  e7de              B        |L1.28|
;;;1051   
                          ENDP

00005e  0000              DCW      0x0000
                  |L1.96|
                          DCD      ||.constdata||+0x3c
                  |L1.100|
                          DCD      ||.data||

                          AREA ||i.DispCh1Wave||, CODE, READONLY, ALIGN=2

                  DispCh1Wave PROC
;;;548    */
;;;549    static void DispCh1Wave(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;550    {
;;;551    	int16_t i;		/* 有符号数 */
;;;552    	//uint16_t pos;
;;;553    	uint16_t *px;
;;;554    	uint16_t *py;
;;;555    	int16_t iTemp;
;;;556    
;;;557    	/* 显示通道1电平标记 */
;;;558    	{
;;;559    		static uint16_t y = 70;
;;;560    	
;;;561    		LCD_DrawLine(1, y, 7, y, CL_BLUE);	 /* 选择蓝色 */
000004  4c3e              LDR      r4,|L2.256|
000006  201f              MOVS     r0,#0x1f
000008  9000              STR      r0,[sp,#0]
00000a  8823              LDRH     r3,[r4,#0]  ; y
00000c  2207              MOVS     r2,#7
00000e  4619              MOV      r1,r3
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       LCD_DrawLine
;;;562    
;;;563    		y = g_DSO->Ch1VOffset;
000016  6860              LDR      r0,[r4,#4]  ; g_DSO
000018  f5005080          ADD      r0,r0,#0x1000
00001c  8d40              LDRH     r0,[r0,#0x2a]
00001e  8020              STRH     r0,[r4,#0]
;;;564    
;;;565    		if (y < 20)
000020  2814              CMP      r0,#0x14
000022  d201              BCS      |L2.40|
;;;566    		{
;;;567    			y = 20;
000024  2014              MOVS     r0,#0x14
000026  e002              B        |L2.46|
                  |L2.40|
;;;568    		}
;;;569    		else if (y > 220)
000028  28dc              CMP      r0,#0xdc
00002a  d901              BLS      |L2.48|
;;;570    		{
;;;571    			y = 220;
00002c  20dc              MOVS     r0,#0xdc
                  |L2.46|
00002e  8020              STRH     r0,[r4,#0]
                  |L2.48|
;;;572    		}
;;;573    		LCD_DrawLine(1, y, 5, y, CL_YELLOW);
000030  f64f70e0          MOV      r0,#0xffe0
000034  9000              STR      r0,[sp,#0]
000036  8823              LDRH     r3,[r4,#0]  ; y
000038  2205              MOVS     r2,#5
00003a  4619              MOV      r1,r3
00003c  2001              MOVS     r0,#1
00003e  f7fffffe          BL       LCD_DrawLine
;;;574    	}
;;;575    
;;;576    //	if (s_DispFirst == 0)
;;;577    //	{
;;;578    //		s_DispFirst = 1;
;;;579    //		LCD_ClrScr(CL_BLUE);  			/* 清屏，背景蓝色 */
;;;580    //	}
;;;581    
;;;582    	if (g_DSO->BufUsed == 0)
000042  6860              LDR      r0,[r4,#4]  ; g_DSO
;;;583    	{
;;;584    		g_DSO->BufUsed = 1;
;;;585    	}
;;;586    	else
;;;587    	{
;;;588    		g_DSO->BufUsed = 0;
;;;589    	}
;;;590    
;;;591    	if (g_DSO->BufUsed == 0)
;;;592    	{
;;;593    		px = g_DSO->xCh1Buf1;
000044  f2410730          MOV      r7,#0x1030
000048  4601              MOV      r1,r0                 ;582
00004a  f5005000          ADD      r0,r0,#0x2000         ;582
;;;594    		py = g_DSO->yCh1Buf1;
00004e  f2412c9c          MOV      r12,#0x129c
000052  f8902390          LDRB     r2,[r0,#0x390]        ;582
;;;595    	}
;;;596    	else
;;;597    	{
;;;598    		px = g_DSO->xCh1Buf2;
000056  f2415908          MOV      r9,#0x1508
;;;599    		py = g_DSO->yCh1Buf2;
00005a  f2417874          MOV      r8,#0x1774
00005e  b312              CBZ      r2,|L2.166|
000060  2200              MOVS     r2,#0                 ;588
000062  f8802390          STRB     r2,[r0,#0x390]        ;588
000066  19ce              ADDS     r6,r1,r7              ;593
000068  eb01050c          ADD      r5,r1,r12             ;594
                  |L2.108|
;;;600    	}
;;;601    
;;;602    	/* 计算当前最新的数据位置，向前递减400个样本 */
;;;603    	//pos = SAMPLE_COUNT - DMA_GetCurrDataCounter(DMA1_Channel1);
;;;604    	//pos = 0;
;;;605    
;;;606    	for (i = 0; i < 300; i++)
00006c  2000              MOVS     r0,#0
;;;607    	{
;;;608    		px[i] = 10 + i;
;;;609    		/* ADC = 2024 是BNC悬空输入时的ADC数值，统计多块板子获得的  */
;;;610    		iTemp = g_DSO->Ch1VOffset + (int16_t)((2024 - g_DSO->Ch1Buf[i + 1]) * 10) / g_DSO->Ch1Attenuation;
00006e  46a3              MOV      r11,r4
000070  f44f7a96          MOV      r10,#0x12c            ;606
000074  f5015380          ADD      r3,r1,#0x1000
                  |L2.120|
000078  f100020a          ADD      r2,r0,#0xa            ;608
00007c  f8262010          STRH     r2,[r6,r0,LSL #1]     ;608
000080  eb010240          ADD      r2,r1,r0,LSL #1
000084  695c              LDR      r4,[r3,#0x14]
000086  8852              LDRH     r2,[r2,#2]
000088  f5c262fd          RSB      r2,r2,#0x7e8
00008c  eb020282          ADD      r2,r2,r2,LSL #2
000090  0052              LSLS     r2,r2,#1
000092  b212              SXTH     r2,r2
000094  fb92f2f4          SDIV     r2,r2,r4
000098  8d5c              LDRH     r4,[r3,#0x2a]
00009a  4422              ADD      r2,r2,r4
00009c  b212              SXTH     r2,r2
;;;611    
;;;612    		if (iTemp > 220)
00009e  2adc              CMP      r2,#0xdc
0000a0  dd09              BLE      |L2.182|
;;;613    		{
;;;614    			iTemp = 220;
0000a2  22dc              MOVS     r2,#0xdc
0000a4  e00a              B        |L2.188|
                  |L2.166|
0000a6  2201              MOVS     r2,#1                 ;584
0000a8  f8802390          STRB     r2,[r0,#0x390]        ;584
0000ac  eb010609          ADD      r6,r1,r9              ;598
0000b0  eb010508          ADD      r5,r1,r8              ;599
0000b4  e7da              B        |L2.108|
                  |L2.182|
;;;615    		}
;;;616    		else if (iTemp < 20)
0000b6  2a14              CMP      r2,#0x14
0000b8  da00              BGE      |L2.188|
;;;617    		{
;;;618    			iTemp = 20;
0000ba  2214              MOVS     r2,#0x14
                  |L2.188|
;;;619    		}
;;;620    		py[i] = iTemp;
0000bc  f8252010          STRH     r2,[r5,r0,LSL #1]
0000c0  1c40              ADDS     r0,r0,#1
0000c2  b200              SXTH     r0,r0                 ;606
0000c4  4550              CMP      r0,r10                ;606
0000c6  dbd7              BLT      |L2.120|
;;;621    	}
;;;622    
;;;623    	/* 清除上帧波形 */
;;;624    	if (g_DSO->BufUsed == 0)
0000c8  f8db0004          LDR      r0,[r11,#4]  ; g_DSO
0000cc  f2423190          MOV      r1,#0x2390
;;;625    	{
;;;626    		LCD_DrawPoints(g_DSO->xCh1Buf2, g_DSO->yCh1Buf2, 300, CL_BLUE);
;;;627    	}
;;;628    	else
;;;629    	{
;;;630    		LCD_DrawPoints(g_DSO->xCh1Buf1, g_DSO->yCh1Buf1, 300, CL_BLUE);
0000d0  f04f031f          MOV      r3,#0x1f
0000d4  5c09              LDRB     r1,[r1,r0]            ;624
0000d6  4652              MOV      r2,r10
0000d8  b171              CBZ      r1,|L2.248|
0000da  eb00010c          ADD      r1,r0,r12
0000de  4438              ADD      r0,r0,r7
                  |L2.224|
0000e0  f7fffffe          BL       LCD_DrawPoints
;;;631    	}
;;;632    
;;;633    	/* 显示更新的波形 */
;;;634    	LCD_DrawPoints((uint16_t *)px, (uint16_t *)py, 300, CL_YELLOW);
0000e4  b001              ADD      sp,sp,#4
0000e6  4652              MOV      r2,r10
0000e8  4629              MOV      r1,r5
0000ea  4630              MOV      r0,r6
0000ec  e8bd4ff0          POP      {r4-r11,lr}
0000f0  f64f73e0          MOV      r3,#0xffe0
0000f4  f7ffbffe          B.W      LCD_DrawPoints
                  |L2.248|
0000f8  eb000108          ADD      r1,r0,r8              ;626
0000fc  4448              ADD      r0,r0,r9              ;626
0000fe  e7ef              B        |L2.224|
;;;635    }
;;;636    
                          ENDP

                  |L2.256|
                          DCD      ||.data||

                          AREA ||i.DispCh2Wave||, CODE, READONLY, ALIGN=2

                  DispCh2Wave PROC
;;;644    */
;;;645    static void DispCh2Wave(void)
000000  e92d4ff8          PUSH     {r3-r11,lr}
;;;646    {
;;;647    	int16_t i;		/* 有符号数 */
;;;648    	//uint16_t pos;
;;;649    	uint16_t *px;
;;;650    	uint16_t *py;
;;;651    	int16_t iTemp;
;;;652    
;;;653    	/* 显示通道2电平标记 */
;;;654    	{
;;;655    		static uint16_t y = 170;
;;;656    
;;;657    		LCD_DrawLine(1, y, 5, y, CL_BLUE);
000004  4d3b              LDR      r5,|L3.244|
000006  201f              MOVS     r0,#0x1f
000008  9000              STR      r0,[sp,#0]
00000a  886b              LDRH     r3,[r5,#2]  ; y
00000c  2205              MOVS     r2,#5
00000e  4619              MOV      r1,r3
000010  2001              MOVS     r0,#1
000012  f7fffffe          BL       LCD_DrawLine
;;;658    
;;;659    		y = g_DSO->Ch2VOffset;
000016  6868              LDR      r0,[r5,#4]  ; g_DSO
000018  f5005080          ADD      r0,r0,#0x1000
00001c  8d80              LDRH     r0,[r0,#0x2c]
00001e  8068              STRH     r0,[r5,#2]
;;;660    
;;;661    		if (y < 20)
000020  2814              CMP      r0,#0x14
000022  d201              BCS      |L3.40|
;;;662    		{
;;;663    			y = 20;
000024  2014              MOVS     r0,#0x14
000026  e002              B        |L3.46|
                  |L3.40|
;;;664    		}
;;;665    		else if (y > 220)
000028  28dc              CMP      r0,#0xdc
00002a  d901              BLS      |L3.48|
;;;666    		{
;;;667    			y = 220;
00002c  20dc              MOVS     r0,#0xdc
                  |L3.46|
00002e  8068              STRH     r0,[r5,#2]
                  |L3.48|
;;;668    		}
;;;669    		LCD_DrawLine(1, y, 5, y, CL_GREEN);
000030  f44f6bfc          MOV      r11,#0x7e0
000034  f8cdb000          STR      r11,[sp,#0]
000038  886b              LDRH     r3,[r5,#2]  ; y
00003a  2205              MOVS     r2,#5
00003c  4619              MOV      r1,r3
00003e  2001              MOVS     r0,#1
000040  f7fffffe          BL       LCD_DrawLine
;;;670    	}
;;;671    		
;;;672    	if (g_DSO->BufUsed == 0)
000044  686c              LDR      r4,[r5,#4]  ; g_DSO
000046  f2423090          MOV      r0,#0x2390
;;;673    	{
;;;674    		px = g_DSO->xCh2Buf1;
;;;675    		py = g_DSO->yCh2Buf1;
00004a  f641414c          MOV      r1,#0x1c4c
00004e  5d00              LDRB     r0,[r0,r4]            ;672
;;;676    	}
;;;677    	else
;;;678    	{
;;;679    		px = g_DSO->xCh2Buf2;
000050  f6416cb8          MOV      r12,#0x1eb8
;;;680    		py = g_DSO->yCh2Buf2;
000054  f2421824          MOV      r8,#0x2124
000058  b310              CBZ      r0,|L3.160|
00005a  eb04060c          ADD      r6,r4,r12             ;679
00005e  eb040708          ADD      r7,r4,r8
                  |L3.98|
;;;681    	}
;;;682    
;;;683    	/* 计算当前最新的数据位置，向前递减400个样本 */
;;;684    	//pos = SAMPLE_COUNT - DMA_GetCurrDataCounter(DMA2_Channel5);
;;;685    	//pos = 0;
;;;686    
;;;687    	for (i = 0; i < 300; i++)
;;;688    	{
;;;689    		px[i] = 10 + i;
;;;690    		
;;;691    		/* ADC = 2024 是BNC悬空输入时的ADC数值，统计多块板子获得的  */
;;;692    		iTemp = g_DSO->Ch2VOffset + (int16_t)((2024 - g_DSO->Ch2Buf[i + 1]) * 10) / g_DSO->Ch2Attenuation;
000062  4623              MOV      r3,r4
000064  2000              MOVS     r0,#0                 ;687
000066  46aa              MOV      r10,r5
000068  f44f7996          MOV      r9,#0x12c             ;687
00006c  f5045480          ADD      r4,r4,#0x1000         ;687
                  |L3.112|
000070  f100020a          ADD      r2,r0,#0xa            ;689
000074  f8262010          STRH     r2,[r6,r0,LSL #1]     ;689
000078  eb030240          ADD      r2,r3,r0,LSL #1
00007c  69a5              LDR      r5,[r4,#0x18]
00007e  f8b22802          LDRH     r2,[r2,#0x802]
000082  f5c262fd          RSB      r2,r2,#0x7e8
000086  eb020282          ADD      r2,r2,r2,LSL #2
00008a  0052              LSLS     r2,r2,#1
00008c  b212              SXTH     r2,r2
00008e  fb92f2f5          SDIV     r2,r2,r5
000092  8da5              LDRH     r5,[r4,#0x2c]
000094  442a              ADD      r2,r2,r5
000096  b212              SXTH     r2,r2
;;;693    
;;;694    		if (iTemp > 220)
000098  2adc              CMP      r2,#0xdc
00009a  dd05              BLE      |L3.168|
;;;695    		{
;;;696    			iTemp = 220;
00009c  22dc              MOVS     r2,#0xdc
00009e  e006              B        |L3.174|
                  |L3.160|
0000a0  f50456cf          ADD      r6,r4,#0x19e0         ;674
0000a4  1867              ADDS     r7,r4,r1              ;675
0000a6  e7dc              B        |L3.98|
                  |L3.168|
;;;697    		}
;;;698    		else if (iTemp < 20)
0000a8  2a14              CMP      r2,#0x14
0000aa  da00              BGE      |L3.174|
;;;699    		{
;;;700    			iTemp = 20;
0000ac  2214              MOVS     r2,#0x14
                  |L3.174|
;;;701    		}
;;;702    		py[i] = iTemp;
0000ae  f8272010          STRH     r2,[r7,r0,LSL #1]
0000b2  1c40              ADDS     r0,r0,#1
0000b4  b200              SXTH     r0,r0                 ;687
0000b6  4548              CMP      r0,r9                 ;687
0000b8  dbda              BLT      |L3.112|
;;;703    	}
;;;704    
;;;705    	/* 清除上帧波形 */
;;;706    	if (g_DSO->BufUsed == 0)
0000ba  f8da0004          LDR      r0,[r10,#4]  ; g_DSO
0000be  f2423290          MOV      r2,#0x2390
;;;707    	{
;;;708    		LCD_DrawPoints(g_DSO->xCh2Buf2, g_DSO->yCh2Buf2, 300, CL_BLUE);
;;;709    	}
;;;710    	else
;;;711    	{
;;;712    		LCD_DrawPoints(g_DSO->xCh2Buf1, g_DSO->yCh2Buf1, 300, CL_BLUE);
0000c2  f04f031f          MOV      r3,#0x1f
0000c6  5c12              LDRB     r2,[r2,r0]            ;706
0000c8  2a00              CMP      r2,#0                 ;706
0000ca  464a              MOV      r2,r9
0000cc  d00d              BEQ      |L3.234|
0000ce  4401              ADD      r1,r1,r0
0000d0  f50050cf          ADD      r0,r0,#0x19e0
                  |L3.212|
0000d4  f7fffffe          BL       LCD_DrawPoints
;;;713    	}
;;;714    	/* 显示更新的波形 */
;;;715    	LCD_DrawPoints((uint16_t *)px, (uint16_t *)py, 300, CL_GREEN);
0000d8  b001              ADD      sp,sp,#4
0000da  465b              MOV      r3,r11
0000dc  464a              MOV      r2,r9
0000de  4639              MOV      r1,r7
0000e0  4630              MOV      r0,r6
0000e2  e8bd4ff0          POP      {r4-r11,lr}
0000e6  f7ffbffe          B.W      LCD_DrawPoints
                  |L3.234|
0000ea  eb000108          ADD      r1,r0,r8              ;708
0000ee  4460              ADD      r0,r0,r12             ;708
0000f0  e7f0              B        |L3.212|
;;;716    }
;;;717    
                          ENDP

0000f2  0000              DCW      0x0000
                  |L3.244|
                          DCD      ||.data||

                          AREA ||i.DispChInfo||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_widthprec
                  DispChInfo PROC
;;;725    */
;;;726    static void DispChInfo(void)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;727    {
000004  b08b              SUB      sp,sp,#0x2c
;;;728    	char buf[32];   /* 字符显示缓冲区 */
;;;729    	FONT_T font;
;;;730    
;;;731    	/* 分组框标题字体 */
;;;732    	font.FontCode = FC_ST_16;
000006  2001              MOVS     r0,#1
000008  f88d0020          STRB     r0,[sp,#0x20]
;;;733    	font.BackColor = CL_BLUE;		/* 和背景色相同 */
00000c  251f              MOVS     r5,#0x1f
00000e  f8ad5024          STRH     r5,[sp,#0x24]
;;;734    	font.FrontColor = CL_WHITE;		/* 白色文字 */
;;;735    	font.Space = 0;	
000012  2000              MOVS     r0,#0
000014  f64f79ff          MOV      r9,#0xffff            ;734
000018  f8ad0026          STRH     r0,[sp,#0x26]
00001c  f8ad9022          STRH     r9,[sp,#0x22]         ;734
;;;736    
;;;737    	/* 显示示波器程序版本 */
;;;738    	LCD_DispStr(10, 2, DSO_VER, &font);
000020  ab08              ADD      r3,sp,#0x20
000022  a25a              ADR      r2,|L4.396|
000024  2102              MOVS     r1,#2
000026  200a              MOVS     r0,#0xa
000028  f7fffffe          BL       LCD_DispStr
;;;739    
;;;740    	/* 显示通道1信息 */
;;;741    	if (g_DSO->Ch1DC == 1)
00002c  4c59              LDR      r4,|L4.404|
00002e  6860              LDR      r0,[r4,#4]  ; g_DSO
000030  f5005080          ADD      r0,r0,#0x1000
000034  f8900028          LDRB     r0,[r0,#0x28]
000038  2801              CMP      r0,#1
00003a  d010              BEQ      |L4.94|
;;;742    	{
;;;743    		strcpy(buf, "CH1 DC ");
;;;744    	}
;;;745    	else
;;;746    	{
;;;747    		strcpy(buf, "CH1 AC ");
00003c  a156              ADR      r1,|L4.408|
                  |L4.62|
00003e  4668              MOV      r0,sp
000040  f7fffffe          BL       strcpy
;;;748    	}
;;;749    
;;;750    	if (g_DSO->Ch1VScale >= 1000)
000044  6860              LDR      r0,[r4,#4]  ; g_DSO
000046  f44f767a          MOV      r6,#0x3e8
00004a  f5005080          ADD      r0,r0,#0x1000
00004e  466f              MOV      r7,sp                 ;728
000050  8b82              LDRH     r2,[r0,#0x1c]
000052  42b2              CMP      r2,r6
000054  d305              BCC      |L4.98|
;;;751    	{
;;;752    		sprintf(&buf[7], "%d.00V", g_DSO->Ch1VScale / 1000);
000056  fbb2f2f6          UDIV     r2,r2,r6
00005a  a151              ADR      r1,|L4.416|
00005c  e002              B        |L4.100|
                  |L4.94|
00005e  a152              ADR      r1,|L4.424|
000060  e7ed              B        |L4.62|
                  |L4.98|
;;;753    	}
;;;754    	else
;;;755    	{
;;;756    		sprintf(&buf[7], "%dmV", g_DSO->Ch1VScale);
000062  a153              ADR      r1,|L4.432|
                  |L4.100|
000064  1df8              ADDS     r0,r7,#7
000066  f7fffffe          BL       __2sprintf
;;;757    	}
;;;758    
;;;759    	if (g_DSO->ActiveCH == 1)
00006a  6860              LDR      r0,[r4,#4]  ; g_DSO
;;;760    	{
;;;761    		font.BackColor = CL_YELLOW;		/* 黄色 */
;;;762    		font.FrontColor = CL_MAGENTA;	/* 紫色 */	
00006c  f64f081f          MOV      r8,#0xf81f
000070  f5005080          ADD      r0,r0,#0x1000         ;759
000074  f890102e          LDRB     r1,[r0,#0x2e]         ;759
000078  f64f70e0          MOV      r0,#0xffe0            ;761
00007c  2901              CMP      r1,#1                 ;759
;;;763    	}
;;;764    	else
;;;765    	{
;;;766    		font.BackColor = CL_YELLOW;		/* 黄色 */
00007e  f8ad0024          STRH     r0,[sp,#0x24]
000082  d020              BEQ      |L4.198|
;;;767    		font.FrontColor = CL_BLUE;		/* 蓝色 */	
000084  f8ad5022          STRH     r5,[sp,#0x22]
                  |L4.136|
;;;768    	}
;;;769    
;;;770    	LCD_DispStr(10, 224, buf, &font);
000088  ab08              ADD      r3,sp,#0x20
00008a  466a              MOV      r2,sp
00008c  21e0              MOVS     r1,#0xe0
00008e  200a              MOVS     r0,#0xa
000090  f7fffffe          BL       LCD_DispStr
;;;771    
;;;772    	/* 显示通道2信息 */
;;;773    	font.FrontColor = CL_RED; /* CH2 红色 */
000094  f44f4078          MOV      r0,#0xf800
000098  f8ad0022          STRH     r0,[sp,#0x22]
;;;774    	if (g_DSO->Ch2DC == 1)
00009c  6860              LDR      r0,[r4,#4]  ; g_DSO
00009e  f5005080          ADD      r0,r0,#0x1000
0000a2  f8900029          LDRB     r0,[r0,#0x29]
0000a6  2801              CMP      r0,#1
0000a8  d010              BEQ      |L4.204|
;;;775    	{
;;;776    		strcpy(buf, "CH2 DC ");
;;;777    	}
;;;778    	else
;;;779    	{
;;;780    		strcpy(buf, "CH2 AC ");
0000aa  a143              ADR      r1,|L4.440|
                  |L4.172|
0000ac  4668              MOV      r0,sp
0000ae  f7fffffe          BL       strcpy
;;;781    	}
;;;782    
;;;783    	if (g_DSO->Ch2VScale >= 1000)
0000b2  6860              LDR      r0,[r4,#4]  ; g_DSO
0000b4  f5005080          ADD      r0,r0,#0x1000
0000b8  8bc2              LDRH     r2,[r0,#0x1e]
0000ba  42b2              CMP      r2,r6
0000bc  d308              BCC      |L4.208|
;;;784    	{
;;;785    		sprintf(&buf[7], "%d.00V", g_DSO->Ch2VScale / 1000);
0000be  fbb2f2f6          UDIV     r2,r2,r6
0000c2  a137              ADR      r1,|L4.416|
0000c4  e005              B        |L4.210|
                  |L4.198|
0000c6  f8ad8022          STRH     r8,[sp,#0x22]         ;762
0000ca  e7dd              B        |L4.136|
                  |L4.204|
0000cc  a13c              ADR      r1,|L4.448|
0000ce  e7ed              B        |L4.172|
                  |L4.208|
;;;786    	}
;;;787    	else
;;;788    	{
;;;789    		sprintf(&buf[7], "%dmV", g_DSO->Ch2VScale);
0000d0  a137              ADR      r1,|L4.432|
                  |L4.210|
0000d2  1df8              ADDS     r0,r7,#7
0000d4  f7fffffe          BL       __2sprintf
;;;790    	}
;;;791    	if (g_DSO->ActiveCH == 2)
0000d8  6860              LDR      r0,[r4,#4]  ; g_DSO
0000da  f5005080          ADD      r0,r0,#0x1000
0000de  f890102e          LDRB     r1,[r0,#0x2e]
;;;792    	{
;;;793    		font.BackColor = CL_GREEN;		/* 绿色 */
0000e2  f44f60fc          MOV      r0,#0x7e0
0000e6  2902              CMP      r1,#2                 ;791
;;;794    		font.FrontColor = CL_MAGENTA;	/* 紫色 */			
;;;795    	}
;;;796    	else
;;;797    	{
;;;798    		font.BackColor = CL_GREEN;		/* 绿色 */
0000e8  f8ad0024          STRH     r0,[sp,#0x24]
0000ec  d014              BEQ      |L4.280|
;;;799    		font.FrontColor = CL_BLUE;		/* 紫色 */			
0000ee  f8ad5022          STRH     r5,[sp,#0x22]
                  |L4.242|
;;;800    	}
;;;801    	LCD_DispStr(120, 224, buf, &font);
0000f2  ab08              ADD      r3,sp,#0x20
0000f4  466a              MOV      r2,sp
0000f6  21e0              MOVS     r1,#0xe0
0000f8  2078              MOVS     r0,#0x78
0000fa  f7fffffe          BL       LCD_DispStr
;;;802    
;;;803    	/* 显示时基 */
;;;804    	font.FrontColor = CL_WHITE;		/* 白色 */		
0000fe  f8ad9022          STRH     r9,[sp,#0x22]
;;;805    	font.BackColor = CL_BLUE;		/* 蓝色 */
000102  f8ad5024          STRH     r5,[sp,#0x24]
;;;806    		
;;;807    	if (g_DSO->TimeBase < 1000)
000106  6860              LDR      r0,[r4,#4]  ; g_DSO
000108  464f              MOV      r7,r9                 ;804
00010a  f5005080          ADD      r0,r0,#0x1000
00010e  68c2              LDR      r2,[r0,#0xc]
000110  42b2              CMP      r2,r6
000112  d204              BCS      |L4.286|
;;;808    	{
;;;809    		sprintf(buf, "Time %3dus", g_DSO->TimeBase);
000114  a12c              ADR      r1,|L4.456|
000116  e00c              B        |L4.306|
                  |L4.280|
000118  f8ad8022          STRH     r8,[sp,#0x22]         ;794
00011c  e7e9              B        |L4.242|
                  |L4.286|
;;;810    	}
;;;811    	else if (g_DSO->TimeBase < 1000000)
00011e  482d              LDR      r0,|L4.468|
000120  4282              CMP      r2,r0
000122  d203              BCS      |L4.300|
;;;812    	{
;;;813    		sprintf(buf, "Time %3dms", g_DSO->TimeBase / 1000);
000124  fbb2f2f6          UDIV     r2,r2,r6
000128  a12b              ADR      r1,|L4.472|
00012a  e002              B        |L4.306|
                  |L4.300|
;;;814    	}
;;;815    	else
;;;816    	{
;;;817    		sprintf(buf, "Time %3ds ", g_DSO->TimeBase / 1000000);	
00012c  fbb2f2f0          UDIV     r2,r2,r0
000130  a12c              ADR      r1,|L4.484|
                  |L4.306|
000132  4668              MOV      r0,sp                 ;813
000134  f7fffffe          BL       __2sprintf
;;;818    	}
;;;819    	LCD_DispStr(230, 224,  buf, &font);
000138  ab08              ADD      r3,sp,#0x20
00013a  466a              MOV      r2,sp
00013c  21e0              MOVS     r1,#0xe0
00013e  20e6              MOVS     r0,#0xe6
000140  f7fffffe          BL       LCD_DispStr
;;;820    
;;;821    
;;;822    	/* 显示调节模式 */
;;;823    	font.FrontColor = CL_WHITE;		/* 白字 */		
000144  f8ad7022          STRH     r7,[sp,#0x22]
;;;824    	font.BackColor = CL_BLUE;		/* 蓝底 */
000148  f8ad5024          STRH     r5,[sp,#0x24]
;;;825    	
;;;826    	if (g_DSO->AdjustMode == 1)
00014c  6860              LDR      r0,[r4,#4]  ; g_DSO
;;;827    	{
;;;828    		LCD_DispStr(245, 2, "调节位置", &font);
;;;829    	}
;;;830    	else
;;;831    	{
;;;832    		LCD_DispStr(245, 2, "调节幅度", &font);
00014e  ab08              ADD      r3,sp,#0x20
000150  f5005080          ADD      r0,r0,#0x1000         ;826
000154  f890002f          LDRB     r0,[r0,#0x2f]         ;826
000158  2801              CMP      r0,#1                 ;826
00015a  d015              BEQ      |L4.392|
00015c  a224              ADR      r2,|L4.496|
                  |L4.350|
00015e  2102              MOVS     r1,#2
000160  20f5              MOVS     r0,#0xf5
000162  f7fffffe          BL       LCD_DispStr
;;;833    	}
;;;834    
;;;835    	sprintf(buf, "采样频率:%7dHz",	g_DSO->SampleFreq);
000166  6860              LDR      r0,[r4,#4]  ; g_DSO
000168  a124              ADR      r1,|L4.508|
00016a  f5005080          ADD      r0,r0,#0x1000
00016e  6882              LDR      r2,[r0,#8]
000170  4668              MOV      r0,sp
000172  f7fffffe          BL       __2sprintf
;;;836    	LCD_DispStr(75, 2, buf, &font);
000176  ab08              ADD      r3,sp,#0x20
000178  466a              MOV      r2,sp
00017a  2102              MOVS     r1,#2
00017c  204b              MOVS     r0,#0x4b
00017e  f7fffffe          BL       LCD_DispStr
;;;837    }
000182  b00b              ADD      sp,sp,#0x2c
000184  e8bd83f0          POP      {r4-r9,pc}
                  |L4.392|
000188  a220              ADR      r2,|L4.524|
00018a  e7e8              B        |L4.350|
;;;838    
                          ENDP

                  |L4.396|
00018c  56302e36          DCB      "V0.6",0
000190  00      
000191  00                DCB      0
000192  00                DCB      0
000193  00                DCB      0
                  |L4.404|
                          DCD      ||.data||
                  |L4.408|
000198  43483120          DCB      "CH1 AC ",0
00019c  41432000
                  |L4.416|
0001a0  25642e30          DCB      "%d.00V",0
0001a4  305600  
0001a7  00                DCB      0
                  |L4.424|
0001a8  43483120          DCB      "CH1 DC ",0
0001ac  44432000
                  |L4.432|
0001b0  25646d56          DCB      "%dmV",0
0001b4  00      
0001b5  00                DCB      0
0001b6  00                DCB      0
0001b7  00                DCB      0
                  |L4.440|
0001b8  43483220          DCB      "CH2 AC ",0
0001bc  41432000
                  |L4.448|
0001c0  43483220          DCB      "CH2 DC ",0
0001c4  44432000
                  |L4.456|
0001c8  54696d65          DCB      "Time %3dus",0
0001cc  20253364
0001d0  757300  
0001d3  00                DCB      0
                  |L4.468|
                          DCD      0x000f4240
                  |L4.472|
0001d8  54696d65          DCB      "Time %3dms",0
0001dc  20253364
0001e0  6d7300  
0001e3  00                DCB      0
                  |L4.484|
0001e4  54696d65          DCB      "Time %3ds ",0
0001e8  20253364
0001ec  732000  
0001ef  00                DCB      0
                  |L4.496|
0001f0  b5f7bdda          DCB      181,247,189,218,183,249,182,200,0
0001f4  b7f9b6c8
0001f8  00      
0001f9  00                DCB      0
0001fa  00                DCB      0
0001fb  00                DCB      0
                  |L4.508|
0001fc  b2c9d1f9          DCB      178,201,209,249,198,181,194,202,":%7dHz",0
000200  c6b5c2ca
000204  3a253764
000208  487a00  
00020b  00                DCB      0
                  |L4.524|
00020c  b5f7bdda          DCB      181,247,189,218,206,187,214,195,0
000210  cebbd6c3
000214  00      
000215  00                DCB      0
000216  00                DCB      0
000217  00                DCB      0

                          AREA ||i.DispDSO||, CODE, READONLY, ALIGN=1

                  DispDSO PROC
;;;846    */
;;;847    static void DispDSO(void)
000000  b510              PUSH     {r4,lr}
;;;848    {
;;;849    	DispButton();
;;;850    
;;;851    	DispFrame();	/* 绘制刻度框 */
000002  f7fffffe          BL       DispFrame
;;;852    	DispChInfo();	/* 显示通道信息(幅度，时间档位) */
000006  f7fffffe          BL       DispChInfo
;;;853    
;;;854    	DispCh1Wave();	/* 显示波形1 */	
00000a  f7fffffe          BL       DispCh1Wave
;;;855    	DispCh2Wave();	/* 显示波形2 */	
00000e  e8bd4010          POP      {r4,lr}
000012  f7ffbffe          B.W      DispCh2Wave
;;;856    }
;;;857    
                          ENDP


                          AREA ||i.DispFrame||, CODE, READONLY, ALIGN=1

                  DispFrame PROC
;;;487    */
;;;488    static void DispFrame(void)
000000  b5f8              PUSH     {r3-r7,lr}
;;;489    {
;;;490    	uint16_t x, y;
;;;491    
;;;492    	/* 绘制一个实线矩形框 x, y, h, w */
;;;493    	LCD_DrawRect(9, 19, 202, 302, CL_WHITE);
000002  f64f76ff          MOV      r6,#0xffff
000006  f44f7397          MOV      r3,#0x12e
00000a  22ca              MOVS     r2,#0xca
00000c  2113              MOVS     r1,#0x13
00000e  2009              MOVS     r0,#9
000010  9600              STR      r6,[sp,#0]
000012  f7fffffe          BL       LCD_DrawRect
;;;494    
;;;495    	/* 绘制垂直刻度点 */
;;;496    	for (x = 0; x < 13; x++)
000016  2500              MOVS     r5,#0
                  |L6.24|
;;;497    	{
;;;498    		for (y = 0; y < 41; y++)
;;;499    		{
;;;500    			LCD_PutPixel(10 + (x * 25), 20 + (y * 5), CL_WHITE);
000018  eb0500c5          ADD      r0,r5,r5,LSL #3
00001c  2400              MOVS     r4,#0                 ;498
00001e  eb001705          ADD      r7,r0,r5,LSL #4
000022  370a              ADDS     r7,r7,#0xa
                  |L6.36|
000024  eb040084          ADD      r0,r4,r4,LSL #2
000028  3014              ADDS     r0,r0,#0x14
00002a  b281              UXTH     r1,r0
00002c  b2b8              UXTH     r0,r7
00002e  4632              MOV      r2,r6
000030  f7fffffe          BL       LCD_PutPixel
000034  1c64              ADDS     r4,r4,#1
000036  b2a4              UXTH     r4,r4                 ;498
000038  2c29              CMP      r4,#0x29              ;498
00003a  d3f3              BCC      |L6.36|
00003c  1c6d              ADDS     r5,r5,#1              ;498
00003e  b2ad              UXTH     r5,r5                 ;496
000040  2d0d              CMP      r5,#0xd               ;496
000042  d3e9              BCC      |L6.24|
;;;501    		}
;;;502    	}
;;;503    
;;;504    	/* 绘制水平刻度点 */
;;;505    	for (y = 0; y < 9; y++)
000044  2500              MOVS     r5,#0
                  |L6.70|
;;;506    	{
;;;507    		for (x = 0; x < 61; x++)
;;;508    		{
;;;509    			LCD_PutPixel(10 + (x * 5), 20 + (y * 25), CL_WHITE);
000046  eb0500c5          ADD      r0,r5,r5,LSL #3
00004a  2400              MOVS     r4,#0                 ;507
00004c  eb001705          ADD      r7,r0,r5,LSL #4
000050  3714              ADDS     r7,r7,#0x14
                  |L6.82|
000052  eb040084          ADD      r0,r4,r4,LSL #2
000056  300a              ADDS     r0,r0,#0xa
000058  b2b9              UXTH     r1,r7
00005a  b280              UXTH     r0,r0
00005c  4632              MOV      r2,r6
00005e  f7fffffe          BL       LCD_PutPixel
000062  1c64              ADDS     r4,r4,#1
000064  b2a4              UXTH     r4,r4                 ;507
000066  2c3d              CMP      r4,#0x3d              ;507
000068  d3f3              BCC      |L6.82|
00006a  1c6d              ADDS     r5,r5,#1              ;507
00006c  b2ad              UXTH     r5,r5                 ;505
00006e  2d09              CMP      r5,#9                 ;505
000070  d3e9              BCC      |L6.70|
;;;510    		}
;;;511    	}
;;;512    
;;;513    	/* 绘制垂直中心刻度点 */
;;;514    	for (y = 0; y < 41; y++)
000072  2400              MOVS     r4,#0
                  |L6.116|
;;;515    	{	 
;;;516    		LCD_PutPixel(9 + (6 * 25), 20 + (y * 5), CL_WHITE);
000074  eb040584          ADD      r5,r4,r4,LSL #2
000078  3514              ADDS     r5,r5,#0x14
00007a  b2a9              UXTH     r1,r5
00007c  4632              MOV      r2,r6
00007e  209f              MOVS     r0,#0x9f
000080  f7fffffe          BL       LCD_PutPixel
;;;517    		LCD_PutPixel(11 + (6 * 25), 20 + (y * 5), CL_WHITE);
000084  b2a9              UXTH     r1,r5
000086  4632              MOV      r2,r6
000088  20a1              MOVS     r0,#0xa1
00008a  f7fffffe          BL       LCD_PutPixel
00008e  1c64              ADDS     r4,r4,#1
000090  b2a4              UXTH     r4,r4                 ;514
000092  2c29              CMP      r4,#0x29              ;514
000094  d3ee              BCC      |L6.116|
;;;518    	}
;;;519    
;;;520    	/* 绘制水平中心刻度点 */
;;;521    	for (x = 0; x < 61; x++)
000096  2400              MOVS     r4,#0
                  |L6.152|
;;;522    	{	 
;;;523    		LCD_PutPixel(10 + (x * 5), 19 + (4 * 25), CL_WHITE);
000098  eb040584          ADD      r5,r4,r4,LSL #2
00009c  350a              ADDS     r5,r5,#0xa
00009e  b2a8              UXTH     r0,r5
0000a0  4632              MOV      r2,r6
0000a2  2177              MOVS     r1,#0x77
0000a4  f7fffffe          BL       LCD_PutPixel
;;;524    		LCD_PutPixel(10 + (x * 5), 21 + (4 * 25), CL_WHITE);
0000a8  b2a8              UXTH     r0,r5
0000aa  4632              MOV      r2,r6
0000ac  2179              MOVS     r1,#0x79
0000ae  f7fffffe          BL       LCD_PutPixel
0000b2  1c64              ADDS     r4,r4,#1
0000b4  b2a4              UXTH     r4,r4                 ;521
0000b6  2c3d              CMP      r4,#0x3d              ;521
0000b8  d3ee              BCC      |L6.152|
;;;525    	}
;;;526    }
0000ba  bdf8              POP      {r3-r7,pc}
;;;527    
                          ENDP


                          AREA ||i.DispHelp1||, CODE, READONLY, ALIGN=2

                  DispHelp1 PROC
;;;372    */
;;;373    static void DispHelp1(void)
000000  b51c              PUSH     {r2-r4,lr}
;;;374    {
;;;375    	uint16_t y;
;;;376    	uint16_t LineCap;
;;;377    	FONT_T font;
;;;378    
;;;379    	/* 分组框标题字体 */
;;;380    	font.FontCode = FC_ST_16;
000002  2001              MOVS     r0,#1
000004  f88d0000          STRB     r0,[sp,#0]
;;;381    	font.BackColor = CL_BLUE;		/* 和背景色相同 */
000008  201f              MOVS     r0,#0x1f
00000a  f8ad0004          STRH     r0,[sp,#4]
;;;382    	font.FrontColor = CL_WHITE;		/* 白色文字 */
00000e  f64f70ff          MOV      r0,#0xffff
000012  f8ad0002          STRH     r0,[sp,#2]
;;;383    	font.Space = 0;
000016  2400              MOVS     r4,#0
000018  f8ad4006          STRH     r4,[sp,#6]
;;;384    
;;;385    	LCD_ClrScr(CL_BLUE);  		/* 清屏，背景蓝色 */
00001c  201f              MOVS     r0,#0x1f
00001e  f7fffffe          BL       LCD_ClrScr
;;;386    
;;;387    	y = 0;
;;;388    	LineCap = 18; /* 行间距 */
;;;389    	LCD_DispStr(20, y, "安富莱STM32F103ZE-EK开发板  www.armfly.com", &font);
000022  466b              MOV      r3,sp
000024  a222              ADR      r2,|L7.176|
000026  4621              MOV      r1,r4
000028  2014              MOVS     r0,#0x14
00002a  f7fffffe          BL       LCD_DispStr
;;;390    	
;;;391    	font.FrontColor = CL_YELLOW;		/* 黄色文字 */
00002e  f64f70e0          MOV      r0,#0xffe0
000032  f8ad0002          STRH     r0,[sp,#2]
;;;392    	
;;;393    	y += LineCap;	
000036  2112              MOVS     r1,#0x12
;;;394    	LCD_DispStr(30, y, "QQ:1295744630     Email:armfly@qq.com", &font);
000038  466b              MOV      r3,sp
00003a  a228              ADR      r2,|L7.220|
00003c  201e              MOVS     r0,#0x1e
00003e  f7fffffe          BL       LCD_DispStr
;;;395    	y += LineCap;
;;;396    
;;;397    	y += LineCap;
000042  2136              MOVS     r1,#0x36
;;;398    
;;;399    	LCD_DispStr(30, y, "操作提示:", &font);
000044  466b              MOV      r3,sp
000046  a22f              ADR      r2,|L7.260|
000048  201e              MOVS     r0,#0x1e
00004a  f7fffffe          BL       LCD_DispStr
;;;400    	y += LineCap;
00004e  2148              MOVS     r1,#0x48
;;;401    	LCD_DispStr(50, y, "TAMPER键 = 切换通道焦点。CH1或CH2", &font);
000050  466b              MOV      r3,sp
000052  a22f              ADR      r2,|L7.272|
000054  2032              MOVS     r0,#0x32
000056  f7fffffe          BL       LCD_DispStr
;;;402    	y += LineCap;
00005a  215a              MOVS     r1,#0x5a
;;;403    	LCD_DispStr(50, y, "WAKEUP键 = 显示帮助或退出帮助", &font);
00005c  466b              MOV      r3,sp
00005e  a235              ADR      r2,|L7.308|
000060  2032              MOVS     r0,#0x32
000062  f7fffffe          BL       LCD_DispStr
;;;404    	y += LineCap;
000066  216c              MOVS     r1,#0x6c
;;;405    	LCD_DispStr(50, y, "USER  键 = 暂停或实时运行", &font);
000068  466b              MOV      r3,sp
00006a  a23a              ADR      r2,|L7.340|
00006c  2032              MOVS     r0,#0x32
00006e  f7fffffe          BL       LCD_DispStr
;;;406    	y += LineCap;
000072  217e              MOVS     r1,#0x7e
;;;407    	LCD_DispStr(50, y, "摇杆上键 = 放大波形垂直幅度或向上移动", &font);
000074  466b              MOV      r3,sp
000076  a23e              ADR      r2,|L7.368|
000078  2032              MOVS     r0,#0x32
00007a  f7fffffe          BL       LCD_DispStr
;;;408    	y += LineCap;
00007e  2190              MOVS     r1,#0x90
;;;409    	LCD_DispStr(50, y, "摇杆下键 = 缩小波形垂直幅度或向下移动", &font);
000080  466b              MOV      r3,sp
000082  a245              ADR      r2,|L7.408|
000084  2032              MOVS     r0,#0x32
000086  f7fffffe          BL       LCD_DispStr
;;;410    	y += LineCap;
00008a  21a2              MOVS     r1,#0xa2
;;;411    	LCD_DispStr(50, y, "摇杆左键 = 水平展宽波形", &font);
00008c  466b              MOV      r3,sp
00008e  a24c              ADR      r2,|L7.448|
000090  2032              MOVS     r0,#0x32
000092  f7fffffe          BL       LCD_DispStr
;;;412    	y += LineCap;
000096  21b4              MOVS     r1,#0xb4
;;;413    	LCD_DispStr(50, y, "摇杆右键 = 水平缩小波形", &font);
000098  466b              MOV      r3,sp
00009a  a24f              ADR      r2,|L7.472|
00009c  2032              MOVS     r0,#0x32
00009e  f7fffffe          BL       LCD_DispStr
;;;414    	y += LineCap;
0000a2  21c6              MOVS     r1,#0xc6
;;;415    	LCD_DispStr(50, y, "摇杆OK键 = 切换摇杆调节模式。幅度或位置", &font);
0000a4  466b              MOV      r3,sp
0000a6  a252              ADR      r2,|L7.496|
0000a8  2032              MOVS     r0,#0x32
0000aa  f7fffffe          BL       LCD_DispStr
;;;416    }
0000ae  bd1c              POP      {r2-r4,pc}
;;;417    
                          ENDP

                  |L7.176|
0000b0  b0b2b8bb          DCB      176,178,184,187,192,179,"STM32F103ZE-EK",191,170,183,162
0000b4  c0b35354
0000b8  4d333246
0000bc  3130335a
0000c0  452d454b
0000c4  bfaab7a2
0000c8  b0e52020          DCB      176,229,"  www.armfly.com",0
0000cc  7777772e
0000d0  61726d66
0000d4  6c792e63
0000d8  6f6d00  
0000db  00                DCB      0
                  |L7.220|
0000dc  51513a31          DCB      "QQ:1295744630     Email:armfly@qq.com",0
0000e0  32393537
0000e4  34343633
0000e8  30202020
0000ec  2020456d
0000f0  61696c3a
0000f4  61726d66
0000f8  6c794071
0000fc  712e636f
000100  6d00    
000102  00                DCB      0
000103  00                DCB      0
                  |L7.260|
000104  b2d9d7f7          DCB      178,217,215,247,204,225,202,190,":",0
000108  cce1cabe
00010c  3a00    
00010e  00                DCB      0
00010f  00                DCB      0
                  |L7.272|
000110  54414d50          DCB      "TAMPER",188,252," = ",199,208,187,187,205,168,181,192,189
000114  4552bcfc
000118  203d20c7
00011c  d0bbbbcd
000120  a8b5c0bd
000124  b9b5e3a1          DCB      185,181,227,161,163,"CH1",187,242,"CH2",0
000128  a3434831
00012c  bbf24348
000130  3200    
000132  00                DCB      0
000133  00                DCB      0
                  |L7.308|
000134  57414b45          DCB      "WAKEUP",188,252," = ",207,212,202,190,176,239,214,250,187
000138  5550bcfc
00013c  203d20cf
000140  d4cabeb0
000144  efd6fabb
000148  f2cdcbb3          DCB      242,205,203,179,246,176,239,214,250,0
00014c  f6b0efd6
000150  fa00    
000152  00                DCB      0
000153  00                DCB      0
                  |L7.340|
000154  55534552          DCB      "USER  ",188,252," = ",212,221,205,163,187,242,202,181,202
000158  2020bcfc
00015c  203d20d4
000160  ddcda3bb
000164  f2cab5ca
000168  b1d4cbd0          DCB      177,212,203,208,208,0
00016c  d000    
00016e  00                DCB      0
00016f  00                DCB      0
                  |L7.368|
000170  d2a1b8cb          DCB      210,161,184,203,201,207,188,252," = ",183,197,180,243,178
000174  c9cfbcfc
000178  203d20b7
00017c  c5b4f3b2
000180  a8d0ceb4          DCB      168,208,206,180,185,214,177,183,249,182,200,187,242,207,242
000184  b9d6b1b7
000188  f9b6c8bb
00018c  f2cff2  
00018f  c9cfd2c6          DCB      201,207,210,198,182,175,0
000193  b6af00  
000196  00                DCB      0
000197  00                DCB      0
                  |L7.408|
000198  d2a1b8cb          DCB      210,161,184,203,207,194,188,252," = ",203,245,208,161,178
00019c  cfc2bcfc
0001a0  203d20cb
0001a4  f5d0a1b2
0001a8  a8d0ceb4          DCB      168,208,206,180,185,214,177,183,249,182,200,187,242,207,242
0001ac  b9d6b1b7
0001b0  f9b6c8bb
0001b4  f2cff2  
0001b7  cfc2d2c6          DCB      207,194,210,198,182,175,0
0001bb  b6af00  
0001be  00                DCB      0
0001bf  00                DCB      0
                  |L7.448|
0001c0  d2a1b8cb          DCB      210,161,184,203,215,243,188,252," = ",203,174,198,189,213
0001c4  d7f3bcfc
0001c8  203d20cb
0001cc  aec6bdd5
0001d0  b9bfedb2          DCB      185,191,237,178,168,208,206,0
0001d4  a8d0ce00
                  |L7.472|
0001d8  d2a1b8cb          DCB      210,161,184,203,211,210,188,252," = ",203,174,198,189,203
0001dc  d3d2bcfc
0001e0  203d20cb
0001e4  aec6bdcb
0001e8  f5d0a1b2          DCB      245,208,161,178,168,208,206,0
0001ec  a8d0ce00
                  |L7.496|
0001f0  d2a1b8cb          DCB      210,161,184,203,"OK",188,252," = ",199,208,187,187,210,161
0001f4  4f4bbcfc
0001f8  203d20c7
0001fc  d0bbbbd2
000200  a1      
000201  b8cbb5f7          DCB      184,203,181,247,189,218,196,163,202,189,161,163,183,249,182
000205  bddac4a3
000209  cabda1a3
00020d  b7f9b6  
000210  c8bbf2ce          DCB      200,187,242,206,187,214,195,0
000214  bbd6c300

                          AREA ||i.DsoMain||, CODE, READONLY, ALIGN=2

                  DsoMain PROC
;;;109    */
;;;110    void DsoMain(void)
000000  b570              PUSH     {r4-r6,lr}
;;;111    {
000002  f5ad5d0f          SUB      sp,sp,#0x23c0
;;;112    	uint8_t MainStatus = S_RUN;		/* 程序执行状态 */
000006  2501              MOVS     r5,#1
;;;113    	DSO_T tDSO;			/* 很大的一个变量，存放在堆栈。节约全局变量空间 */
;;;114    	
;;;115    	memset(&tDSO, 0, sizeof(tDSO));
000008  ac01              ADD      r4,sp,#4
00000a  f88d5000          STRB     r5,[sp,#0]            ;112
00000e  f2423194          MOV      r1,#0x2394
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       __aeabi_memclr4
;;;116    	g_DSO = &tDSO;
000018  481d              LDR      r0,|L8.144|
;;;117    
;;;118    	InitWaveMaker();	/* 使用STM32内部DAC输出正弦波 */
00001a  6044              STR      r4,[r0,#4]  ; g_DSO
00001c  f7fffffe          BL       InitWaveMaker
;;;119    	
;;;120    	bsp_InitAD9833();				/* 使用外部AD9833模块输出三角波 */
000020  f7fffffe          BL       bsp_InitAD9833
000024  f05f0603          MOVS.W   r6,#3                 ;112
                  |L8.40|
;;;121    
;;;122    	
;;;123    	/* 进入主程序循环体 */
;;;124    	while (1)
;;;125    	{
;;;126    		switch (MainStatus)
000028  f89d0000          LDRB     r0,[sp,#0]
00002c  b148              CBZ      r0,|L8.66|
00002e  2801              CMP      r0,#1
000030  d02a              BEQ      |L8.136|
000032  2803              CMP      r0,#3
000034  d1f8              BNE      |L8.40|
;;;127    		{
;;;128    			case S_HELP:
;;;129    				DsoHelp(&MainStatus);		/* 显示帮助 */
;;;130    				break;
;;;131    
;;;132    			case S_RUN:
;;;133    				DsoRun(&MainStatus);		/* 全速采集，实时显示 */
;;;134    				break;
;;;135    
;;;136    			case S_EXIT:
;;;137    				AD9833_SelectWave(NONE_WAVE);	/* 关闭输出 */
000036  2000              MOVS     r0,#0
000038  f7fffffe          BL       AD9833_SelectWave
;;;138    				return;
;;;139    			
;;;140    			default:
;;;141    				break;
;;;142    		}
;;;143    	}
;;;144    }
00003c  f50d5d0f          ADD      sp,sp,#0x23c0
000040  bd70              POP      {r4-r6,pc}
                  |L8.66|
000042  2401              MOVS     r4,#1
                  |L8.68|
000044  f7fffffe          BL       bsp_Idle
000048  b114              CBZ      r4,|L8.80|
00004a  2400              MOVS     r4,#0
00004c  f7fffffe          BL       DispHelp1
                  |L8.80|
000050  f7fffffe          BL       bsp_GetKey
000054  b168              CBZ      r0,|L8.114|
000056  280d              CMP      r0,#0xd
000058  d00b              BEQ      |L8.114|
00005a  dc04              BGT      |L8.102|
00005c  2804              CMP      r0,#4
00005e  d00d              BEQ      |L8.124|
000060  2807              CMP      r0,#7
000062  d106              BNE      |L8.114|
000064  e00d              B        |L8.130|
                  |L8.102|
000066  2810              CMP      r0,#0x10
000068  d00b              BEQ      |L8.130|
00006a  2813              CMP      r0,#0x13
00006c  d009              BEQ      |L8.130|
00006e  2816              CMP      r0,#0x16
000070  d007              BEQ      |L8.130|
                  |L8.114|
000072  f89d0000          LDRB     r0,[sp,#0]
000076  2800              CMP      r0,#0
000078  d0e4              BEQ      |L8.68|
00007a  e7d5              B        |L8.40|
                  |L8.124|
00007c  f88d5000          STRB     r5,[sp,#0]
000080  e7d2              B        |L8.40|
                  |L8.130|
000082  f88d6000          STRB     r6,[sp,#0]
000086  e7cf              B        |L8.40|
                  |L8.136|
000088  4668              MOV      r0,sp                 ;133
00008a  f7fffffe          BL       DsoRun
00008e  e7cb              B        |L8.40|
;;;145    
                          ENDP

                  |L8.144|
                          DCD      ||.data||

                          AREA ||i.DsoRun||, CODE, READONLY, ALIGN=2

                  DsoRun PROC
;;;1129   */
;;;1130   static void DsoRun(uint8_t *pMainStatus)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1131   {
000004  b08a              SUB      sp,sp,#0x28
000006  4606              MOV      r6,r0
;;;1132   	uint8_t KeyCode;
;;;1133   	uint8_t fRefresh = 1;	/* LCD刷新标志 */
000008  2501              MOVS     r5,#1
;;;1134   	FormDSO_T form;	
;;;1135   	uint8_t ucTouch;
;;;1136   	int16_t tpX, tpY;	
;;;1137   
;;;1138   	InitDsoParam();	/* 初始化示波器参数 */
00000a  f7fffffe          BL       InitDsoParam
;;;1139   
;;;1140   	InitDSO();		/* 配置示波器用到的外设：ADC,TIM,DMA等 */
00000e  f7fffffe          BL       InitDSO
;;;1141   
;;;1142   	LCD_ClrScr(CL_BLUE);  			/* 清屏，背景蓝色 */
000012  201f              MOVS     r0,#0x1f
000014  f7fffffe          BL       LCD_ClrScr
;;;1143   	
;;;1144   	FormDSO = &form;
000018  4c95              LDR      r4,|L9.624|
;;;1145   	
;;;1146   	/* 绘制一个按钮 */
;;;1147   	{
;;;1148   		/* 按钮字体 */
;;;1149   		FormDSO->FontBtn.FontCode = FC_ST_16;
;;;1150   		FormDSO->FontBtn.BackColor = CL_MASK;		/* 透明背景 */
00001a  f6491099          MOV      r0,#0x9999
;;;1151   		FormDSO->FontBtn.FrontColor = CL_BLACK;
00001e  f04f0800          MOV      r8,#0
000022  f8c4d008          STR      sp,[r4,#8]            ;1144  ; FormDSO
000026  2701              MOVS     r7,#1                 ;1149
000028  f8ad0004          STRH     r0,[sp,#4]            ;1150
;;;1152   		FormDSO->FontBtn.Space = 0;
;;;1153   		
;;;1154   		/* 按钮 */
;;;1155   		FormDSO->BtnRet.Left = BTN_RET_X;
00002c  4a91              LDR      r2,|L9.628|
00002e  f88d7000          STRB     r7,[sp,#0]            ;1149
000032  f8ad8002          STRH     r8,[sp,#2]            ;1151
000036  f8ad8006          STRH     r8,[sp,#6]            ;1152
00003a  8812              LDRH     r2,[r2,#0]  ; g_LcdWidth
00003c  4669              MOV      r1,sp                 ;1144
00003e  3a58              SUBS     r2,r2,#0x58
000040  f8ad200a          STRH     r2,[sp,#0xa]
;;;1156   		FormDSO->BtnRet.Top = BTN_RET_Y;
000044  4a8c              LDR      r2,|L9.632|
000046  4640              MOV      r0,r8                 ;1151
000048  8812              LDRH     r2,[r2,#0]  ; g_LcdHeight
00004a  3a24              SUBS     r2,r2,#0x24
00004c  f8ad200c          STRH     r2,[sp,#0xc]
;;;1157   		FormDSO->BtnRet.Height = BTN_RET_H;
000050  2220              MOVS     r2,#0x20
000052  f8ad200e          STRH     r2,[sp,#0xe]
;;;1158   		FormDSO->BtnRet.Width = BTN_RET_W;
000056  2250              MOVS     r2,#0x50
000058  f8ad2010          STRH     r2,[sp,#0x10]
;;;1159   		FormDSO->BtnRet.pCaption = BTN_RET_T;
00005c  a287              ADR      r2,|L9.636|
00005e  e9cd1205          STRD     r1,r2,[sp,#0x14]
;;;1160   		FormDSO->BtnRet.Font = &FormDSO->FontBtn;
;;;1161   		FormDSO->BtnRet.Focus = 0;
000062  f88d001c          STRB     r0,[sp,#0x1c]
;;;1162   		
;;;1163   		LCD_DrawButton(&FormDSO->BtnRet);
000066  f1010008          ADD      r0,r1,#8
00006a  f7fffffe          BL       LCD_DrawButton
;;;1164   	}
;;;1165   
;;;1166   	AD9833_SetWaveFreq(100000);		/* 频率 = 10KHz, 单位是0.1Hz */
00006e  f8df9214          LDR      r9,|L9.644|
000072  4648              MOV      r0,r9
000074  f7fffffe          BL       AD9833_SetWaveFreq
;;;1167   	
;;;1168   	AD9833_SetWaveFreq(100000);		/* 频率 = 10KHz, 单位是0.1Hz */
000078  4648              MOV      r0,r9
00007a  f7fffffe          BL       AD9833_SetWaveFreq
;;;1169   	AD9833_SelectWave(SINE_WAVE);	/* 正弦波 */	
00007e  2002              MOVS     r0,#2
000080  f7fffffe          BL       AD9833_SelectWave
;;;1170   	
;;;1171   	bsp_StartTimer(1, 150);		/* 启动定时器1，100ms刷新1次 */
000084  2196              MOVS     r1,#0x96
000086  2001              MOVS     r0,#1
000088  f7fffffe          BL       bsp_StartTimer
00008c  f8df91f8          LDR      r9,|L9.648|
000090  f8dfa1f8          LDR      r10,|L9.652|
;;;1172   	while (*pMainStatus == S_RUN)
000094  e0af              B        |L9.502|
;;;1173   	{
;;;1174   		bsp_Idle();
000096  bf00              NOP      
                  |L9.152|
000098  f7fffffe          BL       bsp_Idle
;;;1175   
;;;1176   		if (fRefresh)
00009c  b915              CBNZ     r5,|L9.164|
00009e  e00b              B        |L9.184|
                  |L9.160|
0000a0  f7fffffe          BL       bsp_Idle
                  |L9.164|
;;;1177   		{
;;;1178   			fRefresh = 0;
;;;1179   
;;;1180   			//StopADC();	/* 暂停采样 */
;;;1181   			if (g_DSO->HoldEn == 1)
0000a4  6860              LDR      r0,[r4,#4]  ; g_DSO
0000a6  2500              MOVS     r5,#0                 ;1178
0000a8  f5005000          ADD      r0,r0,#0x2000
0000ac  f8900391          LDRB     r0,[r0,#0x391]
0000b0  2801              CMP      r0,#1
0000b2  d101              BNE      |L9.184|
;;;1182   			{
;;;1183   				DispDSO();
0000b4  f7fffffe          BL       DispDSO
                  |L9.184|
;;;1184   			}
;;;1185   			//StartADC();	/* 开始采样 */
;;;1186   		}
;;;1187   
;;;1188   		if (bsp_CheckTimer(1))
0000b8  2001              MOVS     r0,#1
0000ba  f7fffffe          BL       bsp_CheckTimer
0000be  b178              CBZ      r0,|L9.224|
;;;1189   		{
;;;1190   			bsp_StartTimer(1, 150);		/* 启动定时器1，100ms刷新1次 */
0000c0  2196              MOVS     r1,#0x96
0000c2  2001              MOVS     r0,#1
0000c4  f7fffffe          BL       bsp_StartTimer
;;;1191   
;;;1192   			/* 运行状态。每隔100ms刷新1次波形 */
;;;1193   			if (g_DSO->HoldEn == 0)
0000c8  6860              LDR      r0,[r4,#4]  ; g_DSO
0000ca  f5005000          ADD      r0,r0,#0x2000
0000ce  f8900391          LDRB     r0,[r0,#0x391]
0000d2  b928              CBNZ     r0,|L9.224|
;;;1194   			{
;;;1195   				StopADC();	/* 暂停采样 */
0000d4  f7fffffe          BL       StopADC
;;;1196   				DispDSO();
0000d8  f7fffffe          BL       DispDSO
;;;1197   				StartADC();	/* 开始采样 */
0000dc  f7fffffe          BL       StartADC
                  |L9.224|
;;;1198   			}
;;;1199   		}
;;;1200   
;;;1201   		ucTouch = TOUCH_GetKey(&tpX, &tpY);	/* 读取触摸事件 */
0000e0  a909              ADD      r1,sp,#0x24
0000e2  a808              ADD      r0,sp,#0x20
0000e4  f7fffffe          BL       TOUCH_GetKey
;;;1202   		if (ucTouch != TOUCH_NONE)
0000e8  b1e0              CBZ      r0,|L9.292|
;;;1203   		{
;;;1204   			switch (ucTouch)
0000ea  2801              CMP      r0,#1
0000ec  d002              BEQ      |L9.244|
0000ee  2803              CMP      r0,#3
0000f0  d118              BNE      |L9.292|
0000f2  e00a              B        |L9.266|
                  |L9.244|
;;;1205   			{
;;;1206   				case TOUCH_DOWN:		/* 触笔按下事件 */
;;;1207   					if (LCD_ButtonTouchDown(&FormDSO->BtnRet, tpX, tpY))
0000f4  f8bd0024          LDRH     r0,[sp,#0x24]
0000f8  b282              UXTH     r2,r0
0000fa  f8bd0020          LDRH     r0,[sp,#0x20]
0000fe  b281              UXTH     r1,r0
000100  68a0              LDR      r0,[r4,#8]  ; FormDSO
000102  3008              ADDS     r0,r0,#8
000104  f7fffffe          BL       LCD_ButtonTouchDown
;;;1208   					{
;;;1209   						// *pMainStatus = S_EXIT;
;;;1210   					}
;;;1211   					break;
000108  e00c              B        |L9.292|
                  |L9.266|
;;;1212   
;;;1213   				case TOUCH_RELEASE:		/* 触笔释放事件 */
;;;1214   					if (LCD_ButtonTouchRelease(&FormDSO->BtnRet, tpX, tpY))
00010a  f8bd0024          LDRH     r0,[sp,#0x24]
00010e  b282              UXTH     r2,r0
000110  f8bd0020          LDRH     r0,[sp,#0x20]
000114  b281              UXTH     r1,r0
000116  68a0              LDR      r0,[r4,#8]  ; FormDSO
000118  3008              ADDS     r0,r0,#8
00011a  f7fffffe          BL       LCD_ButtonTouchRelease
00011e  b108              CBZ      r0,|L9.292|
;;;1215   					{
;;;1216   						*pMainStatus = S_EXIT;
000120  2003              MOVS     r0,#3
000122  7030              STRB     r0,[r6,#0]
                  |L9.292|
;;;1217   					}
;;;1218   					break;
;;;1219   			}
;;;1220   		}
;;;1221   		
;;;1222   		/* 读取按键，大于0表示有键按下 */
;;;1223   		KeyCode = bsp_GetKey();
000124  f7fffffe          BL       bsp_GetKey
;;;1224   		if (KeyCode > 0)
000128  b380              CBZ      r0,|L9.396|
;;;1225   		{
;;;1226   			/* 有键按下 */
;;;1227   			switch (KeyCode)
00012a  280d              CMP      r0,#0xd
00012c  d078              BEQ      |L9.544|
00012e  dc08              BGT      |L9.322|
000130  2801              CMP      r0,#1
000132  d00d              BEQ      |L9.336|
000134  2804              CMP      r0,#4
000136  d019              BEQ      |L9.364|
000138  2807              CMP      r0,#7
00013a  d01c              BEQ      |L9.374|
00013c  280a              CMP      r0,#0xa
00013e  d15a              BNE      |L9.502|
000140  e061              B        |L9.518|
                  |L9.322|
000142  2810              CMP      r0,#0x10
000144  d02c              BEQ      |L9.416|
000146  2813              CMP      r0,#0x13
000148  d03f              BEQ      |L9.458|
00014a  2816              CMP      r0,#0x16
00014c  d153              BNE      |L9.502|
00014e  e049              B        |L9.484|
                  |L9.336|
;;;1228   			{
;;;1229   				case  KEY_DOWN_K1:	/* TAMPER 键，通道选择(CH1或CH2) */
;;;1230   					if (g_DSO->ActiveCH == 1)
000150  6860              LDR      r0,[r4,#4]  ; g_DSO
000152  f5005080          ADD      r0,r0,#0x1000
000156  f890102e          LDRB     r1,[r0,#0x2e]
00015a  2901              CMP      r1,#1
00015c  d002              BEQ      |L9.356|
;;;1231   					{
;;;1232   						g_DSO->ActiveCH = 2;
;;;1233   					}
;;;1234   					else
;;;1235   					{
;;;1236   						g_DSO->ActiveCH = 1;
00015e  f880702e          STRB     r7,[r0,#0x2e]
000162  e047              B        |L9.500|
                  |L9.356|
000164  2102              MOVS     r1,#2                 ;1232
000166  f880102e          STRB     r1,[r0,#0x2e]         ;1232
00016a  e043              B        |L9.500|
                  |L9.364|
;;;1237   					}
;;;1238   					fRefresh = 1;		/* 请求刷新LCD */
;;;1239   					break;
;;;1240   
;;;1241   				case  KEY_DOWN_K2:	/* WAKEUP 键, 调节模式选择(幅度或者垂直偏移) */
;;;1242   					/* 退出,进入全速运行状态 */
;;;1243   					*pMainStatus = S_HELP;
00016c  f8868000          STRB     r8,[r6,#0]
                  |L9.368|
;;;1244   					break;
;;;1245   
;;;1246   				case  KEY_DOWN_K3:	/* USER 键 */
;;;1247   					if (g_DSO->HoldEn == 0)
;;;1248   					{
;;;1249   						g_DSO->HoldEn = 1;
;;;1250   
;;;1251   						/* 保存暂停时的时基,为了水平扩展用 */
;;;1252   						g_DSO->TimeBaseIdHold = g_DSO->TimeBaseId;	
;;;1253   
;;;1254   						StopADC();
;;;1255   					}
;;;1256   					else
;;;1257   					{
;;;1258   						g_DSO->HoldEn = 0;
;;;1259   						StartADC();				
;;;1260   					}
;;;1261   					fRefresh = 1;		/* 请求刷新LCD */
;;;1262   					break;
;;;1263   
;;;1264   				case JOY_DOWN_L:	/* 摇杆LEFT键按下 */
;;;1265   					if (g_DSO->HoldEn == 0)
;;;1266   					{
;;;1267   						DecSampleFreq();	/* 递减采样频率 */
;;;1268   						fRefresh = 1;		/* 请求刷新LCD */
;;;1269   					}
;;;1270   					else
;;;1271   					{
;;;1272   						; /* 波形水平移动，待完善 */
;;;1273   					}
;;;1274   					break;
;;;1275   
;;;1276   				case JOY_DOWN_R:	/* 摇杆RIGHT键按下 */
;;;1277   					if (g_DSO->HoldEn == 0)
;;;1278   					{
;;;1279   						IncSampleFreq();  	/* 递增采样频率 */					
;;;1280   						fRefresh = 1;		/* 请求刷新LCD */
;;;1281   					}
;;;1282   					else
;;;1283   					{
;;;1284   						; /* 波形水平移动，待完善 */
;;;1285   					}
;;;1286   					break;
;;;1287   
;;;1288   				case  JOY_DOWN_OK:	/* 摇杆OK键 */
;;;1289   					if (g_DSO->AdjustMode == 0)
;;;1290   					{
;;;1291   						g_DSO->AdjustMode = 1;
;;;1292   					}
;;;1293   					else
;;;1294   					{
;;;1295   						g_DSO->AdjustMode = 0;
;;;1296   					}
;;;1297   					fRefresh = 1;		/* 请求刷新LCD */
;;;1298   					break;
;;;1299   
;;;1300   				case JOY_DOWN_U:	/* 摇杆UP键按下 */
;;;1301   					if (g_DSO->ActiveCH == 1) 	/* 当前激活的是CH1 */
;;;1302   					{
;;;1303   						if (g_DSO->AdjustMode == 0)	/* 调节幅度放大倍数 */
;;;1304   						{
;;;1305   							AdjustAtt(1, 1);
;;;1306   						}
;;;1307   						else 	/* 调节上下偏移 */
;;;1308   						{
;;;1309   							g_DSO->Ch1VOffset -= 5;
;;;1310   						}
;;;1311   					}
;;;1312   					else	/* 当前激活的是CH2 */
;;;1313   					{
;;;1314   						if (g_DSO->AdjustMode == 0)	/* 调节幅度放大倍数 */
;;;1315   						{
;;;1316   							AdjustAtt(2, 1);
;;;1317   						}
;;;1318   						else 	/* 调节上下偏移 */
;;;1319   						{
;;;1320   							g_DSO->Ch2VOffset -= 5;
;;;1321   						}
;;;1322   					}
;;;1323   					fRefresh = 1;		/* 请求刷新LCD */
;;;1324   					break;
;;;1325   
;;;1326   				case JOY_DOWN_D:		/* 摇杆DOWN键按下 */
;;;1327   					if (g_DSO->ActiveCH == 1) 	/* 当前激活的是CH1 */
;;;1328   					{
;;;1329   						if (g_DSO->AdjustMode == 0)	/* 调节幅度放大倍数 */
;;;1330   						{
;;;1331   							AdjustAtt(1, 0);
;;;1332   						}
;;;1333   						else 	/* 调节上下偏移 */
;;;1334   						{
;;;1335   							g_DSO->Ch1VOffset += 5;
;;;1336   						}
;;;1337   					}
;;;1338   					else	/* 当前激活的是CH2 */
;;;1339   					{
;;;1340   						if (g_DSO->AdjustMode == 0)	/* 调节幅度放大倍数 */
;;;1341   						{
;;;1342   							AdjustAtt(2, 0);
;;;1343   						}
;;;1344   						else 	/* 调节上下偏移 */
;;;1345   						{
;;;1346   							g_DSO->Ch2VOffset += 5;
;;;1347   						}
;;;1348   					}
;;;1349   					fRefresh = 1;		/* 请求刷新LCD */
;;;1350   					break;
;;;1351   
;;;1352   				default:
;;;1353   					break;
;;;1354   			}
;;;1355   		}
;;;1356   	}
;;;1357   }
000170  b00a              ADD      sp,sp,#0x28
000172  e8bd87f0          POP      {r4-r10,pc}
                  |L9.374|
000176  6860              LDR      r0,[r4,#4]            ;1247  ; g_DSO
000178  f5005100          ADD      r1,r0,#0x2000         ;1247
00017c  f8912391          LDRB     r2,[r1,#0x391]        ;1247
000180  b12a              CBZ      r2,|L9.398|
000182  f8818391          STRB     r8,[r1,#0x391]        ;1258
000186  f7fffffe          BL       StartADC
00018a  e033              B        |L9.500|
                  |L9.396|
00018c  e033              B        |L9.502|
                  |L9.398|
00018e  f5005080          ADD      r0,r0,#0x1000         ;1249
000192  f8817391          STRB     r7,[r1,#0x391]        ;1249
000196  6841              LDR      r1,[r0,#4]            ;1252
000198  6001              STR      r1,[r0,#0]            ;1254
00019a  f7fffffe          BL       StopADC
00019e  e029              B        |L9.500|
                  |L9.416|
0001a0  6860              LDR      r0,[r4,#4]            ;1265  ; g_DSO
0001a2  f2423191          MOV      r1,#0x2391            ;1265
0001a6  5c09              LDRB     r1,[r1,r0]            ;1265
0001a8  bb29              CBNZ     r1,|L9.502|
0001aa  f5005080          ADD      r0,r0,#0x1000         ;1265
0001ae  6841              LDR      r1,[r0,#4]            ;1265
0001b0  b109              CBZ      r1,|L9.438|
0001b2  1e49              SUBS     r1,r1,#1              ;1265
0001b4  e014              B        |L9.480|
                  |L9.438|
0001b6  f8591021          LDR      r1,[r9,r1,LSL #2]     ;1265
0001ba  60c1              STR      r1,[r0,#0xc]          ;1265
0001bc  fbbaf1f1          UDIV     r1,r10,r1             ;1265
0001c0  6081              STR      r1,[r0,#8]            ;1265
0001c2  4608              MOV      r0,r1                 ;1265
0001c4  f7fffffe          BL       SetSampRate
0001c8  e033              B        |L9.562|
                  |L9.458|
0001ca  6860              LDR      r0,[r4,#4]            ;1277  ; g_DSO
0001cc  f2423191          MOV      r1,#0x2391            ;1277
0001d0  5c09              LDRB     r1,[r1,r0]            ;1277
0001d2  b981              CBNZ     r1,|L9.502|
0001d4  f5005080          ADD      r0,r0,#0x1000         ;1277
0001d8  6841              LDR      r1,[r0,#4]            ;1277
0001da  290e              CMP      r1,#0xe               ;1277
0001dc  d2eb              BCS      |L9.438|
0001de  1c49              ADDS     r1,r1,#1              ;1277
                  |L9.480|
0001e0  6041              STR      r1,[r0,#4]            ;1277
0001e2  e7e8              B        |L9.438|
                  |L9.484|
0001e4  6860              LDR      r0,[r4,#4]            ;1289  ; g_DSO
0001e6  f5005080          ADD      r0,r0,#0x1000         ;1289
0001ea  f890102f          LDRB     r1,[r0,#0x2f]         ;1289
0001ee  b139              CBZ      r1,|L9.512|
0001f0  f880802f          STRB     r8,[r0,#0x2f]         ;1295
                  |L9.500|
0001f4  2501              MOVS     r5,#1                 ;1297
                  |L9.502|
0001f6  7830              LDRB     r0,[r6,#0]            ;1172
0001f8  2801              CMP      r0,#1                 ;1172
0001fa  f43faf4d          BEQ      |L9.152|
0001fe  e7b7              B        |L9.368|
                  |L9.512|
000200  f880702f          STRB     r7,[r0,#0x2f]         ;1291
000204  e7f6              B        |L9.500|
                  |L9.518|
000206  6860              LDR      r0,[r4,#4]            ;1301  ; g_DSO
000208  f5005080          ADD      r0,r0,#0x1000         ;1301
00020c  f890102e          LDRB     r1,[r0,#0x2e]         ;1301
000210  2901              CMP      r1,#1                 ;1301
000212  f890102f          LDRB     r1,[r0,#0x2f]         ;1314
000216  d004              BEQ      |L9.546|
000218  b149              CBZ      r1,|L9.558|
00021a  8d81              LDRH     r1,[r0,#0x2c]         ;1320
00021c  1f49              SUBS     r1,r1,#5              ;1320
00021e  e019              B        |L9.596|
                  |L9.544|
000220  e00c              B        |L9.572|
                  |L9.546|
000222  b111              CBZ      r1,|L9.554|
000224  8d41              LDRH     r1,[r0,#0x2a]         ;1309
000226  1f49              SUBS     r1,r1,#5              ;1309
000228  e019              B        |L9.606|
                  |L9.554|
00022a  2101              MOVS     r1,#1                 ;1305
00022c  e019              B        |L9.610|
                  |L9.558|
00022e  2101              MOVS     r1,#1                 ;1316
000230  e019              B        |L9.614|
                  |L9.562|
000232  7830              LDRB     r0,[r6,#0]            ;1172
000234  2801              CMP      r0,#1                 ;1172
000236  f43faf33          BEQ      |L9.160|
00023a  e799              B        |L9.368|
                  |L9.572|
00023c  6860              LDR      r0,[r4,#4]            ;1327  ; g_DSO
00023e  f5005080          ADD      r0,r0,#0x1000         ;1327
000242  f890102e          LDRB     r1,[r0,#0x2e]         ;1327
000246  2901              CMP      r1,#1                 ;1327
000248  f890102f          LDRB     r1,[r0,#0x2f]         ;1340
00024c  d004              BEQ      |L9.600|
00024e  b151              CBZ      r1,|L9.614|
000250  8d81              LDRH     r1,[r0,#0x2c]         ;1346
000252  1d49              ADDS     r1,r1,#5              ;1346
                  |L9.596|
000254  8581              STRH     r1,[r0,#0x2c]         ;1346
000256  e7ec              B        |L9.562|
                  |L9.600|
000258  b119              CBZ      r1,|L9.610|
00025a  8d41              LDRH     r1,[r0,#0x2a]         ;1335
00025c  1d49              ADDS     r1,r1,#5              ;1335
                  |L9.606|
00025e  8541              STRH     r1,[r0,#0x2a]         ;1335
000260  e7e7              B        |L9.562|
                  |L9.610|
000262  2001              MOVS     r0,#1                 ;1305
000264  e000              B        |L9.616|
                  |L9.614|
000266  2002              MOVS     r0,#2                 ;1316
                  |L9.616|
000268  f7fffffe          BL       AdjustAtt
00026c  e7e1              B        |L9.562|
;;;1358   
                          ENDP

00026e  0000              DCW      0x0000
                  |L9.624|
                          DCD      ||.data||
                  |L9.628|
                          DCD      g_LcdWidth
                  |L9.632|
                          DCD      g_LcdHeight
                  |L9.636|
00027c  b7b5bbd8          DCB      183,181,187,216,0
000280  00      
000281  00                DCB      0
000282  00                DCB      0
000283  00                DCB      0
                  |L9.644|
                          DCD      0x000186a0
                  |L9.648|
                          DCD      ||.constdata||
                  |L9.652|
                          DCD      0x017d7840

                          AREA ||i.InitDSO||, CODE, READONLY, ALIGN=2

                  InitDSO PROC
;;;153    */
;;;154    static void InitDSO(void)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;155    {
000004  b08c              SUB      sp,sp,#0x30
;;;156    	/* 配置GPIO.  */
;;;157    	{
;;;158    		GPIO_InitTypeDef GPIO_InitStructure;
;;;159    
;;;160    		/* 打开GPIO_C 和 AFIO 的时钟 */
;;;161    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC	| RCC_APB2Periph_AFIO, ENABLE);
000006  2101              MOVS     r1,#1
000008  2011              MOVS     r0,#0x11
00000a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;162    
;;;163    		/* 配置PC0为模拟输入模式 */
;;;164    		GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1;
00000e  2003              MOVS     r0,#3
000010  f8ad0000          STRH     r0,[sp,#0]
;;;165    		GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN;
000014  2400              MOVS     r4,#0
000016  f88d4003          STRB     r4,[sp,#3]
;;;166    		GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001a  f88d0002          STRB     r0,[sp,#2]
;;;167    		GPIO_Init(GPIOC, &GPIO_InitStructure);
00001e  4669              MOV      r1,sp
000020  4862              LDR      r0,|L10.428|
000022  f7fffffe          BL       GPIO_Init
;;;168    	}
;;;169    
;;;170    
;;;171    	/* 配置DMA1_1 用于CH1 */
;;;172    	#if 1
;;;173    	{
;;;174    		DMA_InitTypeDef DMA_InitStructure;
;;;175    
;;;176    		/* Enable DMA1 clock */
;;;177    		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA1, ENABLE);
000026  2101              MOVS     r1,#1
000028  4608              MOV      r0,r1
00002a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;178    
;;;179    		DMA_DeInit(DMA1_Channel1);		/* 复位DMA1寄存器到缺省状态 */
00002e  f8dfa180          LDR      r10,|L10.432|
000032  4650              MOV      r0,r10
000034  f7fffffe          BL       DMA_DeInit
;;;180    		DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;	/* 选择ADC1的数据寄存器作为源 */
;;;181    		DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)&g_DSO->Ch1Buf;	/* 目标地址 */
000038  f8df917c          LDR      r9,|L10.440|
00003c  485d              LDR      r0,|L10.436|
00003e  9000              STR      r0,[sp,#0]
;;;182    		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;	/* 设置DMA传输方向，外设(ADC)作为源 */
;;;183    		DMA_InitStructure.DMA_BufferSize = SAMPLE_COUNT;	/* 设置缓冲区大小 */
000040  f44f6580          MOV      r5,#0x400
000044  a901              ADD      r1,sp,#4
000046  f8d90004          LDR      r0,[r9,#4]  ; g_DSO
;;;184    		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	/* 外设地址不自增 */
;;;185    		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;	/* 存储器地址需要自增 */
00004a  f04f0880          MOV      r8,#0x80
00004e  e8810031          STM      r1,{r0,r4,r5}         ;183
;;;186    		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	/* 选择外设传输单位：16bit */
000052  e9cd4804          STRD     r4,r8,[sp,#0x10]
;;;187    		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;	/* 选择内存传输单位：16bit */
;;;188    		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;	/* 无需循环模式   */
;;;189    		DMA_InitStructure.DMA_Priority = DMA_Priority_High;	/* 选择DMA优先级 */
000056  00e8              LSLS     r0,r5,#3
000058  10af              ASRS     r7,r5,#2              ;186
00005a  e9cd4008          STRD     r4,r0,[sp,#0x20]
;;;190    		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;	/* DMA传输类型，不是内存到内存 */
;;;191    		DMA_Init(DMA1_Channel1, &DMA_InitStructure);
00005e  e9cd7506          STRD     r7,r5,[sp,#0x18]
000062  464e              MOV      r6,r9                 ;181
000064  4669              MOV      r1,sp
000066  4650              MOV      r0,r10
000068  940a              STR      r4,[sp,#0x28]
00006a  f7fffffe          BL       DMA_Init
;;;192    
;;;193    		/* Enable DMA1 channel1 */
;;;194    		DMA_Cmd(DMA1_Channel1, ENABLE);
00006e  2101              MOVS     r1,#1
000070  4650              MOV      r0,r10
000072  f7fffffe          BL       DMA_Cmd
;;;195    	}
;;;196    	#endif
;;;197    
;;;198    	/* 配置DMA2_5 用于CH2 */
;;;199    	#if 1
;;;200    	{
;;;201    		DMA_InitTypeDef DMA_InitStructure;
;;;202    
;;;203    		/* Enable DMA1 clock */
;;;204    		RCC_AHBPeriphClockCmd(RCC_AHBPeriph_DMA2, ENABLE);
000076  2101              MOVS     r1,#1
000078  2002              MOVS     r0,#2
00007a  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;205    
;;;206    		DMA_DeInit(DMA2_Channel5);		/* 复位DMA2寄存器到缺省状态 */
00007e  f8dfa13c          LDR      r10,|L10.444|
000082  4650              MOV      r0,r10
000084  f7fffffe          BL       DMA_DeInit
;;;207    		DMA_InitStructure.DMA_PeripheralBaseAddr = ADC3_DR_Address;	/* 选择ADC3的数据寄存器作为源 */
000088  484d              LDR      r0,|L10.448|
;;;208    		DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)&g_DSO->Ch2Buf;	/* 目标地址 */
00008a  9000              STR      r0,[sp,#0]
00008c  6870              LDR      r0,[r6,#4]  ; g_DSO
00008e  a901              ADD      r1,sp,#4
000090  f5006000          ADD      r0,r0,#0x800
000094  e8810031          STM      r1,{r0,r4,r5}
000098  e9cd4804          STRD     r4,r8,[sp,#0x10]
;;;209    		DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;	/* 设置DMA传输方向，外设(ADC)作为源 */
;;;210    		DMA_InitStructure.DMA_BufferSize = SAMPLE_COUNT;	/* 设置缓冲区大小 */
;;;211    		DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	/* 外设地址不自增 */
;;;212    		DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;	/* 存储器地址需要自增 */
;;;213    		DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	/* 选择外设传输单位：16bit */
;;;214    		DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;	/* 选择内存传输单位：16bit */
;;;215    		DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;	/* 无需循环模式   */
;;;216    		DMA_InitStructure.DMA_Priority = DMA_Priority_Medium;	/* 选择DMA优先级 */
00009c  00a8              LSLS     r0,r5,#2
00009e  e9cd4008          STRD     r4,r0,[sp,#0x20]
;;;217    		DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;	/* DMA传输类型，不是内存到内存 */
;;;218    		DMA_Init(DMA2_Channel5, &DMA_InitStructure);
0000a2  e9cd7506          STRD     r7,r5,[sp,#0x18]
0000a6  4669              MOV      r1,sp
0000a8  4650              MOV      r0,r10
0000aa  940a              STR      r4,[sp,#0x28]
0000ac  f7fffffe          BL       DMA_Init
;;;219    
;;;220    		/* Enable DMA2 channel5 */
;;;221    		DMA_Cmd(DMA2_Channel5, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  4650              MOV      r0,r10
0000b4  f7fffffe          BL       DMA_Cmd
;;;222    	}
;;;223    	#endif
;;;224    
;;;225    	/* 配置ADC1  */
;;;226    	
;;;227    	 /* ADCCLK = PCLK2/2 */
;;;228        RCC_ADCCLKConfig(RCC_PCLK2_Div2);     //ADCCLK = PCLK2/4 = 18MHz
0000b8  2000              MOVS     r0,#0
0000ba  f7fffffe          BL       RCC_ADCCLKConfig
;;;229    
;;;230    	#if 1
;;;231    	{
;;;232    		ADC_InitTypeDef	ADC_InitStructure;
;;;233    
;;;234    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
0000be  2101              MOVS     r1,#1
0000c0  0248              LSLS     r0,r1,#9
0000c2  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;235    
;;;236    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
;;;237    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
;;;238    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;		/* 连续转换静止 */
;;;239    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC3;	/* 选择TIM1的CC3做触发 */
0000c6  022d              LSLS     r5,r5,#8
;;;240    		//ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T2_CC2;	/* 选择TIM2的CC2做触发 */
;;;241    
;;;242    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	/* 数据右对齐,高位为0 */
;;;243    		ADC_InitStructure.ADC_NbrOfChannel = 1;	/* 1个通道 */
;;;244    		ADC_Init(ADC1, &ADC_InitStructure);
0000c8  4f3a              LDR      r7,|L10.436|
0000ca  e9cd5402          STRD     r5,r4,[sp,#8]         ;243
0000ce  f88d4004          STRB     r4,[sp,#4]            ;237
0000d2  2601              MOVS     r6,#1                 ;243
0000d4  3f4c              SUBS     r7,r7,#0x4c
0000d6  9400              STR      r4,[sp,#0]            ;237
0000d8  f88d4005          STRB     r4,[sp,#5]            ;238
0000dc  f88d6010          STRB     r6,[sp,#0x10]         ;243
0000e0  4669              MOV      r1,sp
0000e2  4638              MOV      r0,r7
0000e4  f7fffffe          BL       ADC_Init
;;;245    
;;;246    		/* ADC1 regular channels configuration */
;;;247    		ADC_RegularChannelConfig(ADC1, ADC_Channel_10, 1, ADC_SampleTime_1Cycles5);
0000e8  2300              MOVS     r3,#0
0000ea  2201              MOVS     r2,#1
0000ec  210a              MOVS     r1,#0xa
0000ee  4638              MOV      r0,r7
0000f0  f7fffffe          BL       ADC_RegularChannelConfig
;;;248    
;;;249    		/* Enable ADC1 external trigger conversion */
;;;250    		ADC_ExternalTrigConvCmd(ADC1, ENABLE);
0000f4  2101              MOVS     r1,#1
0000f6  4638              MOV      r0,r7
0000f8  f7fffffe          BL       ADC_ExternalTrigConvCmd
;;;251    
;;;252    		/* 使能 ADC1 */
;;;253    		ADC_Cmd(ADC1, ENABLE);
0000fc  2101              MOVS     r1,#1
0000fe  4638              MOV      r0,r7
000100  f7fffffe          BL       ADC_Cmd
;;;254    
;;;255    		/* Enable ADC1 DMA */
;;;256    		ADC_DMACmd(ADC1, ENABLE);
000104  2101              MOVS     r1,#1
000106  4638              MOV      r0,r7
000108  f7fffffe          BL       ADC_DMACmd
;;;257    
;;;258    		/* 使能 ADC1 复位校准寄存器 */
;;;259    		ADC_ResetCalibration(ADC1);
00010c  4638              MOV      r0,r7
00010e  f7fffffe          BL       ADC_ResetCalibration
                  |L10.274|
;;;260    		/* 检测复位校准寄存器 */
;;;261    		while(ADC_GetResetCalibrationStatus(ADC1));
000112  4638              MOV      r0,r7
000114  f7fffffe          BL       ADC_GetResetCalibrationStatus
000118  2800              CMP      r0,#0
00011a  d1fa              BNE      |L10.274|
;;;262    
;;;263    		/* 开始 ADC1 校准 */
;;;264    		ADC_StartCalibration(ADC1);
00011c  4638              MOV      r0,r7
00011e  f7fffffe          BL       ADC_StartCalibration
                  |L10.290|
;;;265    		/* 等待校准结束 */
;;;266    		while(ADC_GetCalibrationStatus(ADC1));
000122  4638              MOV      r0,r7
000124  f7fffffe          BL       ADC_GetCalibrationStatus
000128  2800              CMP      r0,#0
00012a  d1fa              BNE      |L10.290|
;;;267    	}
;;;268    	#endif
;;;269    
;;;270    	/* 配置ADC3  */
;;;271    	#if 1
;;;272    	{
;;;273    		ADC_InitTypeDef	ADC_InitStructure;
;;;274    
;;;275    		RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC3, ENABLE);
00012c  2101              MOVS     r1,#1
00012e  03c8              LSLS     r0,r1,#15
000130  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;276    
;;;277    		ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;
;;;278    		ADC_InitStructure.ADC_ScanConvMode = DISABLE;
;;;279    		ADC_InitStructure.ADC_ContinuousConvMode = DISABLE;		/* 连续转换静止 */
000134  e9cd5402          STRD     r5,r4,[sp,#8]
000138  f88d4004          STRB     r4,[sp,#4]            ;278
00013c  9400              STR      r4,[sp,#0]            ;278
00013e  f88d4005          STRB     r4,[sp,#5]
;;;280    		//ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC1;	/* 选择TIM1的CC1做触发 */
;;;281    		ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_T1_CC3;	/* 选择TIM2的CC2做触发 */
;;;282    		ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;	/* 数据右对齐,高位为0 */
;;;283    		ADC_InitStructure.ADC_NbrOfChannel = 1;	/* 1个通道 */
;;;284    		ADC_Init(ADC3, &ADC_InitStructure);
000142  4c1f              LDR      r4,|L10.448|
000144  f88d6010          STRB     r6,[sp,#0x10]         ;283
000148  3c4c              SUBS     r4,r4,#0x4c
00014a  4669              MOV      r1,sp
00014c  4620              MOV      r0,r4
00014e  f7fffffe          BL       ADC_Init
;;;285    
;;;286    		/* ADC1 regular channels configuration */
;;;287    		ADC_RegularChannelConfig(ADC3, ADC_Channel_11, 1, ADC_SampleTime_1Cycles5);
000152  2300              MOVS     r3,#0
000154  2201              MOVS     r2,#1
000156  210b              MOVS     r1,#0xb
000158  4620              MOV      r0,r4
00015a  f7fffffe          BL       ADC_RegularChannelConfig
;;;288    
;;;289    		/* Enable ADC3 external trigger conversion */
;;;290    		ADC_ExternalTrigConvCmd(ADC3, ENABLE);
00015e  2101              MOVS     r1,#1
000160  4620              MOV      r0,r4
000162  f7fffffe          BL       ADC_ExternalTrigConvCmd
;;;291    
;;;292    		/* 使能 ADC3 */
;;;293    		ADC_Cmd(ADC3, ENABLE);
000166  2101              MOVS     r1,#1
000168  4620              MOV      r0,r4
00016a  f7fffffe          BL       ADC_Cmd
;;;294    
;;;295    		/* Enable ADC3 DMA */
;;;296    		ADC_DMACmd(ADC3, ENABLE);
00016e  2101              MOVS     r1,#1
000170  4620              MOV      r0,r4
000172  f7fffffe          BL       ADC_DMACmd
;;;297    
;;;298    		/* 使能 ADC3 复位校准寄存器 */
;;;299    		ADC_ResetCalibration(ADC3);
000176  4620              MOV      r0,r4
000178  f7fffffe          BL       ADC_ResetCalibration
                  |L10.380|
;;;300    		/* 检测复位校准寄存器 */
;;;301    		while(ADC_GetResetCalibrationStatus(ADC3));
00017c  4620              MOV      r0,r4
00017e  f7fffffe          BL       ADC_GetResetCalibrationStatus
000182  2800              CMP      r0,#0
000184  d1fa              BNE      |L10.380|
;;;302    
;;;303    		/* 开始 ADC3 校准 */
;;;304    		ADC_StartCalibration(ADC3);
000186  4620              MOV      r0,r4
000188  f7fffffe          BL       ADC_StartCalibration
                  |L10.396|
;;;305    		/* 等待校准结束 */
;;;306    		while(ADC_GetCalibrationStatus(ADC3));
00018c  4620              MOV      r0,r4
00018e  f7fffffe          BL       ADC_GetCalibrationStatus
000192  2800              CMP      r0,#0
000194  d1fa              BNE      |L10.396|
;;;307    	}
;;;308    	#endif
;;;309    
;;;310    	/* 配置采样触发定时器，使用TIM1 CC1 */
;;;311    	SetSampRate(g_DSO->SampleFreq);	/* 修改采样频率(启动时100K) */
000196  f8d90004          LDR      r0,[r9,#4]  ; g_DSO
00019a  f5005080          ADD      r0,r0,#0x1000
00019e  6880              LDR      r0,[r0,#8]
0001a0  b00c              ADD      sp,sp,#0x30
0001a2  e8bd47f0          POP      {r4-r10,lr}
0001a6  f7ffbffe          B.W      SetSampRate
;;;312    }
;;;313    
                          ENDP

0001aa  0000              DCW      0x0000
                  |L10.428|
                          DCD      0x40011000
                  |L10.432|
                          DCD      0x40020008
                  |L10.436|
                          DCD      0x4001244c
                  |L10.440|
                          DCD      ||.data||
                  |L10.444|
                          DCD      0x40020458
                  |L10.448|
                          DCD      0x40013c4c

                          AREA ||i.InitDsoParam||, CODE, READONLY, ALIGN=2

                  InitDsoParam PROC
;;;865    */
;;;866    static void InitDsoParam(void)
000000  4815              LDR      r0,|L11.88|
;;;867    {
;;;868    	g_DSO->Ch1Attenuation = 23;	/* 设置缺省衰减系数 */
;;;869    	g_DSO->Ch2Attenuation = 23;	/* 设置缺省衰减系数 */
;;;870    	g_DSO->Ch1VScale = 1000;	/* 缺省是1V */
000002  f44f727a          MOV      r2,#0x3e8
;;;871    	g_DSO->Ch2VScale = 1000;	/* 缺省是1V */
;;;872    
;;;873    	g_DSO->Ch1VOffset = 70; 	/* 通道1 GND线位置 */
;;;874    	g_DSO->Ch2VOffset = 170; /* 通道2 GND线位置 */
;;;875    
;;;876    	g_DSO->ActiveCH = 1;		/* 缺省是CH1 */
;;;877    	g_DSO->AdjustMode = 1;	/* 缺省是调节垂直偏移， 可以切换到2调节幅度 */
;;;878    
;;;879    	g_DSO->HoldEn = 0;
;;;880    
;;;881    	g_DSO->TimeBaseId = 0;									 
;;;882    	g_DSO->TimeBase = 	g_TimeTable[g_DSO->TimeBaseId];
;;;883    	g_DSO->SampleFreq = 25000000 / g_DSO->TimeBase;
;;;884    
;;;885    
;;;886    	g_DSO->Ch1AttId = 2;
000006  2302              MOVS     r3,#2
000008  6841              LDR      r1,[r0,#4]            ;868  ; g_DSO
00000a  f5015080          ADD      r0,r1,#0x1000         ;868
00000e  f5015100          ADD      r1,r1,#0x2000         ;879
000012  83c2              STRH     r2,[r0,#0x1e]         ;871
000014  2246              MOVS     r2,#0x46              ;873
000016  8542              STRH     r2,[r0,#0x2a]         ;873
000018  22aa              MOVS     r2,#0xaa              ;874
00001a  8582              STRH     r2,[r0,#0x2c]         ;874
00001c  2201              MOVS     r2,#1                 ;876
00001e  f880202e          STRB     r2,[r0,#0x2e]         ;876
000022  f880202f          STRB     r2,[r0,#0x2f]         ;877
000026  2200              MOVS     r2,#0                 ;879
000028  f8812391          STRB     r2,[r1,#0x391]        ;879
00002c  490b              LDR      r1,|L11.92|
00002e  6042              STR      r2,[r0,#4]            ;882
000030  4a0b              LDR      r2,|L11.96|
000032  6809              LDR      r1,[r1,#0]            ;882
000034  60c1              STR      r1,[r0,#0xc]          ;883
000036  fbb2f1f1          UDIV     r1,r2,r1              ;883
;;;887    	g_DSO->Ch1Attenuation = g_AttTable[g_DSO->Ch1AttId][0];
00003a  4a08              LDR      r2,|L11.92|
00003c  6081              STR      r1,[r0,#8]            ;886
00003e  323c              ADDS     r2,r2,#0x3c
000040  7403              STRB     r3,[r0,#0x10]         ;886
000042  6911              LDR      r1,[r2,#0x10]
;;;888    	g_DSO->Ch1VScale =  g_AttTable[g_DSO->Ch1AttId][1];
000044  6141              STR      r1,[r0,#0x14]
000046  4611              MOV      r1,r2
000048  8a89              LDRH     r1,[r1,#0x14]
00004a  8381              STRH     r1,[r0,#0x1c]
;;;889    
;;;890    	g_DSO->Ch2AttId = 2;
00004c  7443              STRB     r3,[r0,#0x11]
;;;891    	g_DSO->Ch2Attenuation = g_AttTable[g_DSO->Ch2AttId][0];
00004e  6912              LDR      r2,[r2,#0x10]
;;;892    	g_DSO->Ch2VScale =  g_AttTable[g_DSO->Ch2AttId][1];
000050  6182              STR      r2,[r0,#0x18]
000052  83c1              STRH     r1,[r0,#0x1e]
;;;893    
;;;894    }
000054  4770              BX       lr
;;;895    
                          ENDP

000056  0000              DCW      0x0000
                  |L11.88|
                          DCD      ||.data||
                  |L11.92|
                          DCD      ||.constdata||
                  |L11.96|
                          DCD      0x017d7840

                          AREA ||i.SetSampRate||, CODE, READONLY, ALIGN=2

                  SetSampRate PROC
;;;321    */
;;;322    static void SetSampRate(uint32_t freq)
000000  b530              PUSH     {r4,r5,lr}
;;;323    {
;;;324    	/* 配置定时器2第2通道CC2, CC2作为ADC1的触发源 */
;;;325    	TIM_TimeBaseInitTypeDef  TIM_TimeBaseStructure;
;;;326    	TIM_OCInitTypeDef  TIM_OCInitStructure;
;;;327    	uint16_t Period;
;;;328    
;;;329    	TIM_Cmd(TIM1, DISABLE);
000002  4d1d              LDR      r5,|L12.120|
000004  4604              MOV      r4,r0                 ;323
000006  b087              SUB      sp,sp,#0x1c           ;323
000008  2100              MOVS     r1,#0
00000a  4628              MOV      r0,r5
00000c  f7fffffe          BL       TIM_Cmd
;;;330    
;;;331    //	g_DSO->SampleRate = freq;	/* 将采样频率保存到全部变量中 */
;;;332    
;;;333    	/*
;;;334    	采样频率计算公式 ：
;;;335    		period = 72000000 / freq ;
;;;336    		
;;;337    		1200 == 60KHz 采样频率
;;;338    	*/
;;;339    	Period = 72000000 / freq;		
000010  481a              LDR      r0,|L12.124|
;;;340    
;;;341    	/* Enable TIM1 clock */
;;;342    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM1, ENABLE);
000012  2101              MOVS     r1,#1
000014  fbb0f4f4          UDIV     r4,r0,r4              ;339
000018  02c8              LSLS     r0,r1,#11
00001a  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;343    
;;;344    	TIM_TimeBaseStructInit(&TIM_TimeBaseStructure); 
00001e  4668              MOV      r0,sp
000020  f7fffffe          BL       TIM_TimeBaseStructInit
;;;345    	TIM_TimeBaseStructure.TIM_Period = Period;          
;;;346    	TIM_TimeBaseStructure.TIM_Prescaler = 0;   /* 计数频率 = 72000 000 / 18 = 4000 000	 */
000024  2100              MOVS     r1,#0
000026  f8ad4004          STRH     r4,[sp,#4]            ;345
00002a  f8ad1000          STRH     r1,[sp,#0]
;;;347    	TIM_TimeBaseStructure.TIM_ClockDivision = 0x0;    
00002e  f8ad1006          STRH     r1,[sp,#6]
;;;348    	TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up;  
000032  f8ad1002          STRH     r1,[sp,#2]
;;;349    	TIM_TimeBaseInit(TIM1, &TIM_TimeBaseStructure);
000036  4669              MOV      r1,sp
000038  4628              MOV      r0,r5
00003a  f7fffffe          BL       TIM_TimeBaseInit
;;;350    
;;;351    	/* TIM1 channel1 configuration in PWM mode */
;;;352    	TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM1; 
00003e  2060              MOVS     r0,#0x60
000040  f8ad000c          STRH     r0,[sp,#0xc]
;;;353    	TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable;                
000044  2001              MOVS     r0,#1
000046  f8ad000e          STRH     r0,[sp,#0xe]
;;;354    	TIM_OCInitStructure.TIM_Pulse = TIM_TimeBaseStructure.TIM_Period / 2; 
00004a  f8bd0004          LDRH     r0,[sp,#4]
;;;355    	TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_Low;         
;;;356    	TIM_OC3Init(TIM1, &TIM_OCInitStructure);
00004e  a903              ADD      r1,sp,#0xc
000050  0840              LSRS     r0,r0,#1              ;354
000052  f8ad0012          STRH     r0,[sp,#0x12]         ;354
000056  2002              MOVS     r0,#2                 ;355
000058  f8ad0014          STRH     r0,[sp,#0x14]         ;355
00005c  4628              MOV      r0,r5
00005e  f7fffffe          BL       TIM_OC3Init
;;;357    
;;;358    	/* TIM1 counter enable */
;;;359    	TIM_Cmd(TIM1, ENABLE);
000062  2101              MOVS     r1,#1
000064  4628              MOV      r0,r5
000066  f7fffffe          BL       TIM_Cmd
;;;360    
;;;361    	/* TIM1 main Output Enable */
;;;362    	TIM_CtrlPWMOutputs(TIM1, ENABLE);  
00006a  2101              MOVS     r1,#1
00006c  4628              MOV      r0,r5
00006e  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;363    }
000072  b007              ADD      sp,sp,#0x1c
000074  bd30              POP      {r4,r5,pc}
;;;364    
                          ENDP

000076  0000              DCW      0x0000
                  |L12.120|
                          DCD      0x40012c00
                  |L12.124|
                          DCD      0x044aa200

                          AREA ||i.StartADC||, CODE, READONLY, ALIGN=2

                  StartADC PROC
;;;1078   */
;;;1079   static void StartADC(void)
000000  e92d4ff0          PUSH     {r4-r11,lr}
;;;1080   {
;;;1081   #if 1
;;;1082   	DMA_InitTypeDef DMA_InitStructure;
;;;1083   
;;;1084   	DMA_DeInit(DMA1_Channel1);		/* 复位DMA1寄存器到缺省状态 */
000004  f8dfb08c          LDR      r11,|L13.148|
000008  b08b              SUB      sp,sp,#0x2c           ;1080
00000a  4658              MOV      r0,r11
00000c  f7fffffe          BL       DMA_DeInit
;;;1085   	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC1_DR_Address;	/* 选择ADC1的数据寄存器作为源 */
;;;1086   	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)&g_DSO->Ch1Buf;	/* 目标地址 */
000010  4e22              LDR      r6,|L13.156|
000012  4821              LDR      r0,|L13.152|
000014  9000              STR      r0,[sp,#0]
;;;1087   	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;	/* 设置DMA传输方向，外设(ADC)作为源 */
;;;1088   	DMA_InitStructure.DMA_BufferSize = SAMPLE_COUNT;	/* 设置缓冲区大小 */
000016  a901              ADD      r1,sp,#4
000018  6870              LDR      r0,[r6,#4]  ; g_DSO
00001a  2400              MOVS     r4,#0                 ;1087
00001c  f44f6580          MOV      r5,#0x400
000020  e8810031          STM      r1,{r0,r4,r5}
;;;1089   	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	/* 外设地址不自增 */
;;;1090   	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;	/* 存储器地址需要自增 */
;;;1091   	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	/* 选择外设传输单位：16bit */
000024  a804              ADD      r0,sp,#0x10
000026  2780              MOVS     r7,#0x80              ;1090
000028  f44f7880          MOV      r8,#0x100
00002c  e8800190          STM      r0,{r4,r7,r8}
;;;1092   	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;	/* 选择内存传输单位：16bit */
;;;1093   	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;	/* 无需循环模式   */
;;;1094   	DMA_InitStructure.DMA_Priority = DMA_Priority_High;	/* 选择DMA优先级 */
000030  e9cd5407          STRD     r5,r4,[sp,#0x1c]
000034  f44f5900          MOV      r9,#0x2000
;;;1095   	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;	/* DMA传输类型，不是内存到内存 */
;;;1096   	DMA_Init(DMA1_Channel1, &DMA_InitStructure);
000038  e9cd9409          STRD     r9,r4,[sp,#0x24]
00003c  4669              MOV      r1,sp
00003e  4658              MOV      r0,r11
000040  f7fffffe          BL       DMA_Init
;;;1097   
;;;1098   	DMA_DeInit(DMA2_Channel5);		/* 复位DMA2寄存器到缺省状态 */
000044  f8dfa058          LDR      r10,|L13.160|
000048  4650              MOV      r0,r10
00004a  f7fffffe          BL       DMA_DeInit
;;;1099   	DMA_InitStructure.DMA_PeripheralBaseAddr = ADC3_DR_Address;	/* 选择ADC1的数据寄存器作为源 */
00004e  4815              LDR      r0,|L13.164|
;;;1100   	DMA_InitStructure.DMA_MemoryBaseAddr = (uint32_t)&g_DSO->Ch2Buf;	/* 目标地址 */
000050  9000              STR      r0,[sp,#0]
000052  6870              LDR      r0,[r6,#4]  ; g_DSO
000054  a901              ADD      r1,sp,#4
000056  f5006000          ADD      r0,r0,#0x800
00005a  e8810031          STM      r1,{r0,r4,r5}
00005e  a804              ADD      r0,sp,#0x10
;;;1101   	DMA_InitStructure.DMA_DIR = DMA_DIR_PeripheralSRC;	/* 设置DMA传输方向，外设(ADC)作为源 */
;;;1102   	DMA_InitStructure.DMA_BufferSize = SAMPLE_COUNT;	/* 设置缓冲区大小 */
;;;1103   	DMA_InitStructure.DMA_PeripheralInc = DMA_PeripheralInc_Disable;	/* 外设地址不自增 */
;;;1104   	DMA_InitStructure.DMA_MemoryInc = DMA_MemoryInc_Enable;	/* 存储器地址需要自增 */
;;;1105   	DMA_InitStructure.DMA_PeripheralDataSize = DMA_PeripheralDataSize_HalfWord;	/* 选择外设传输单位：16bit */
;;;1106   	DMA_InitStructure.DMA_MemoryDataSize = DMA_MemoryDataSize_HalfWord;	/* 选择内存传输单位：16bit */
;;;1107   	DMA_InitStructure.DMA_Mode = DMA_Mode_Normal;	/* 无需循环模式   */
;;;1108   	DMA_InitStructure.DMA_Priority = DMA_Priority_High;	/* 选择DMA优先级 */
;;;1109   	DMA_InitStructure.DMA_M2M = DMA_M2M_Disable;	/* DMA传输类型，不是内存到内存 */
;;;1110   	DMA_Init(DMA2_Channel5, &DMA_InitStructure);
000060  4669              MOV      r1,sp
000062  e8800190          STM      r0,{r4,r7,r8}         ;1100
000066  e9cd5407          STRD     r5,r4,[sp,#0x1c]      ;1100
00006a  e9cd9409          STRD     r9,r4,[sp,#0x24]
00006e  4650              MOV      r0,r10
000070  f7fffffe          BL       DMA_Init
;;;1111   #endif
;;;1112   
;;;1113   	/* Enable DMA2 channel5 */
;;;1114   	DMA_Cmd(DMA1_Channel1, ENABLE);
000074  2101              MOVS     r1,#1
000076  4658              MOV      r0,r11
000078  f7fffffe          BL       DMA_Cmd
;;;1115   
;;;1116   	/* Enable DMA2 channel5 */
;;;1117   	DMA_Cmd(DMA2_Channel5, ENABLE);
00007c  2101              MOVS     r1,#1
00007e  4650              MOV      r0,r10
000080  f7fffffe          BL       DMA_Cmd
;;;1118   
;;;1119   	TIM_Cmd(TIM1, ENABLE);
000084  2101              MOVS     r1,#1
000086  4808              LDR      r0,|L13.168|
000088  f7fffffe          BL       TIM_Cmd
;;;1120   }
00008c  b00b              ADD      sp,sp,#0x2c
00008e  e8bd8ff0          POP      {r4-r11,pc}
;;;1121   
                          ENDP

000092  0000              DCW      0x0000
                  |L13.148|
                          DCD      0x40020008
                  |L13.152|
                          DCD      0x4001244c
                  |L13.156|
                          DCD      ||.data||
                  |L13.160|
                          DCD      0x40020458
                  |L13.164|
                          DCD      0x40013c4c
                  |L13.168|
                          DCD      0x40012c00

                          AREA ||i.StopADC||, CODE, READONLY, ALIGN=2

                  StopADC PROC
;;;1059   */
;;;1060   static void StopADC(void)
000000  b510              PUSH     {r4,lr}
;;;1061   {
;;;1062   	TIM_Cmd(TIM1, DISABLE);
000002  2100              MOVS     r1,#0
000004  4806              LDR      r0,|L14.32|
000006  f7fffffe          BL       TIM_Cmd
;;;1063   
;;;1064   	/* Enable DMA1 channel1 */
;;;1065   	DMA_Cmd(DMA1_Channel1, DISABLE);
00000a  2100              MOVS     r1,#0
00000c  4805              LDR      r0,|L14.36|
00000e  f7fffffe          BL       DMA_Cmd
;;;1066   	
;;;1067   	/* Enable DMA2 channel5 */
;;;1068   	DMA_Cmd(DMA2_Channel5, DISABLE);
000012  e8bd4010          POP      {r4,lr}
000016  2100              MOVS     r1,#0
000018  4803              LDR      r0,|L14.40|
00001a  f7ffbffe          B.W      DMA_Cmd
;;;1069   }
;;;1070   
                          ENDP

00001e  0000              DCW      0x0000
                  |L14.32|
                          DCD      0x40012c00
                  |L14.36|
                          DCD      0x40020008
                  |L14.40|
                          DCD      0x40020458

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  g_TimeTable
                          DCD      0x00000014
                          DCD      0x00000032
                          DCD      0x00000064
                          DCD      0x000000c8
                          DCD      0x000001f4
                          DCD      0x000003e8
                          DCD      0x000007d0
                          DCD      0x00001388
                          DCD      0x00002710
                          DCD      0x00004e20
                          DCD      0x0000c350
                          DCD      0x000186a0
                          DCD      0x00030d40
                          DCD      0x0007a120
                          DCD      0x000f4240
                  g_AttTable
                          DCD      0x00000663
                          DCD      0x00001388
                          DCD      0x0000028e
                          DCD      0x000007d0
                          DCD      0x00000147
                          DCD      0x000003e8
                          DCD      0x000000a3
                          DCD      0x000001f4
                          DCD      0x00000041
                          DCD      0x000000c8
                          DCD      0x00000020
                          DCD      0x00000064

                          AREA ||.data||, DATA, ALIGN=2

                  y
000000  0046              DCW      0x0046
                  |symbol_number.46|
000002  00aa              DCW      0x00aa
                  g_DSO
                          DCD      0x00000000
                  FormDSO
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\app\\src\\form_dso.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_form_dso_c_f9ffa0eb____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_form_dso_c_f9ffa0eb____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_form_dso_c_f9ffa0eb____REVSH|
#line 128
|__asm___10_form_dso_c_f9ffa0eb____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
