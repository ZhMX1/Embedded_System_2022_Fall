; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\dm9k_uip.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\dm9k_uip.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\dm9k_uip.crf ..\..\User\uIP\dm9000\dm9k_uip.c]
                          THUMB

                          AREA ||i.DM9K_CtrlLinesConfig||, CODE, READONLY, ALIGN=2

                  DM9K_CtrlLinesConfig PROC
;;;698    */
;;;699    static void DM9K_CtrlLinesConfig(void)
000000  b508              PUSH     {r3,lr}
;;;700    {
;;;701    	GPIO_InitTypeDef GPIO_InitStructure;
;;;702    
;;;703    	/* 使能 FSMC, GPIOD, GPIOE, GPIOF, GPIOG 和 AFIO 时钟 */
;;;704    	RCC_AHBPeriphClockCmd(RCC_AHBPeriph_FSMC, ENABLE);
000002  2101              MOVS     r1,#1
000004  0208              LSLS     r0,r1,#8
000006  f7fffffe          BL       RCC_AHBPeriphClockCmd
;;;705    
;;;706    	RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD | RCC_APB2Periph_GPIOE |
00000a  2101              MOVS     r1,#1
00000c  f24010e1          MOV      r0,#0x1e1
000010  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;707    	                     RCC_APB2Periph_GPIOF | RCC_APB2Periph_GPIOG |
;;;708    	                     RCC_APB2Periph_AFIO, ENABLE);
;;;709    
;;;710    	/* 设置 PD.00(D2), PD.01(D3), PD.04(NOE), PD.05(NWE), PD.08(D13), PD.09(D14),
;;;711    	 PD.10(D15), PD.14(D0), PD.15(D1) 为复用推挽输出 */
;;;712    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0 | GPIO_Pin_1 | GPIO_Pin_4 | GPIO_Pin_5 |
000014  f24c7033          MOV      r0,#0xc733
000018  f8ad0000          STRH     r0,[sp,#0]
;;;713    	                            GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_14 |
;;;714    	                            GPIO_Pin_15; // | GPIO_Pin_7;
;;;715    	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00001c  2003              MOVS     r0,#3
00001e  f88d0002          STRB     r0,[sp,#2]
;;;716    	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000022  2018              MOVS     r0,#0x18
000024  f88d0003          STRB     r0,[sp,#3]
;;;717    	GPIO_Init(GPIOD, &GPIO_InitStructure);
000028  4669              MOV      r1,sp
00002a  480d              LDR      r0,|L1.96|
00002c  f7fffffe          BL       GPIO_Init
;;;718    
;;;719    	/* 设置 PE.07(D4), PE.08(D5), PE.09(D6), PE.10(D7), PE.11(D8), PE.12(D9), PE.13(D10),
;;;720    	 PE.14(D11), PE.15(D12) 为复用推挽输出 */
;;;721    	/* PE3,PE4 用于A19, A20, STM32F103ZE-EK(REV 2.0)必须使能 */
;;;722    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9 | GPIO_Pin_10 |
000030  f64f7098          MOV      r0,#0xff98
000034  f8ad0000          STRH     r0,[sp,#0]
;;;723    	                            GPIO_Pin_11 | GPIO_Pin_12 | GPIO_Pin_13 | GPIO_Pin_14 |
;;;724    	                            GPIO_Pin_15 | GPIO_Pin_3 | GPIO_Pin_4;
;;;725    	GPIO_Init(GPIOE, &GPIO_InitStructure);
000038  4669              MOV      r1,sp
00003a  480a              LDR      r0,|L1.100|
00003c  f7fffffe          BL       GPIO_Init
;;;726    
;;;727    	/* 设置 PF2(A2))  为复用推挽输出 */
;;;728    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_2;
000040  2004              MOVS     r0,#4
000042  f8ad0000          STRH     r0,[sp,#0]
;;;729    	GPIO_Init(GPIOF, &GPIO_InitStructure);
000046  4669              MOV      r1,sp
000048  4807              LDR      r0,|L1.104|
00004a  f7fffffe          BL       GPIO_Init
;;;730    
;;;731    	/* 设置 PG.12(NE4 ) 为复用推挽输出  */
;;;732    	GPIO_InitStructure.GPIO_Pin = GPIO_Pin_12;
00004e  f44f5080          MOV      r0,#0x1000
000052  f8ad0000          STRH     r0,[sp,#0]
;;;733    	//GPIO_InitStructure.GPIO_Pin = GPIO_Pin_9 | GPIO_Pin_10 | GPIO_Pin_12;
;;;734    	GPIO_Init(GPIOG, &GPIO_InitStructure);
000056  4669              MOV      r1,sp
000058  4804              LDR      r0,|L1.108|
00005a  f7fffffe          BL       GPIO_Init
;;;735    }
00005e  bd08              POP      {r3,pc}
;;;736    
                          ENDP

                  |L1.96|
                          DCD      0x40011400
                  |L1.100|
                          DCD      0x40011800
                  |L1.104|
                          DCD      0x40011c00
                  |L1.108|
                          DCD      0x40012000

                          AREA ||i.DM9K_FSMCConfig||, CODE, READONLY, ALIGN=1

                  DM9K_FSMCConfig PROC
;;;742    */
;;;743    static void DM9K_FSMCConfig(void)
000000  b500              PUSH     {lr}
;;;744    {
000002  b097              SUB      sp,sp,#0x5c
;;;745    	FSMC_NORSRAMInitTypeDef  FSMC_NORSRAMInitStructure;
;;;746    	FSMC_NORSRAMTimingInitTypeDef  p;
;;;747    
;;;748    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;749    	/*----------------------- SRAM Bank 3 ----------------------------------------*/
;;;750    	/*-- FSMC Configuration ------------------------------------------------------*/
;;;751    	p.FSMC_AddressSetupTime = 0;		/* 设置为2会出错; 3正常 */
000004  2000              MOVS     r0,#0
;;;752    	p.FSMC_AddressHoldTime = 0;
;;;753    	p.FSMC_DataSetupTime = 4;			/* 设置为1出错，2正常 */
000006  2104              MOVS     r1,#4
000008  e9cd0110          STRD     r0,r1,[sp,#0x40]
00000c  900f              STR      r0,[sp,#0x3c]
;;;754    	p.FSMC_BusTurnAroundDuration = 0;
;;;755    	p.FSMC_CLKDivision = 0;
;;;756    	p.FSMC_DataLatency = 0;
;;;757    	p.FSMC_AccessMode = FSMC_AccessMode_A;
00000e  9014              STR      r0,[sp,#0x50]
;;;758    
;;;759    	FSMC_NORSRAMInitStructure.FSMC_Bank = FSMC_Bank1_NORSRAM4;
000010  2106              MOVS     r1,#6
000012  9015              STR      r0,[sp,#0x54]
000014  e9cd1000          STRD     r1,r0,[sp,#0]
000018  9012              STR      r0,[sp,#0x48]         ;755
;;;760    	FSMC_NORSRAMInitStructure.FSMC_DataAddressMux = FSMC_DataAddressMux_Disable;
;;;761    	FSMC_NORSRAMInitStructure.FSMC_MemoryType = FSMC_MemoryType_SRAM;	// FSMC_MemoryType_PSRAM;
;;;762    	FSMC_NORSRAMInitStructure.FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_16b;
00001a  2110              MOVS     r1,#0x10
00001c  e9cd0102          STRD     r0,r1,[sp,#8]
000020  9013              STR      r0,[sp,#0x4c]         ;756
;;;763    	FSMC_NORSRAMInitStructure.FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
;;;764    	FSMC_NORSRAMInitStructure.FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
000022  9004              STR      r0,[sp,#0x10]
;;;765    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
000024  9005              STR      r0,[sp,#0x14]
;;;766    	FSMC_NORSRAMInitStructure.FSMC_WrapMode = FSMC_WrapMode_Disable;
000026  9006              STR      r0,[sp,#0x18]
;;;767    	FSMC_NORSRAMInitStructure.FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;768    	FSMC_NORSRAMInitStructure.FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000028  0209              LSLS     r1,r1,#8
00002a  9007              STR      r0,[sp,#0x1c]
00002c  e9cd0108          STRD     r0,r1,[sp,#0x20]
;;;769    	FSMC_NORSRAMInitStructure.FSMC_WaitSignal = FSMC_WaitSignal_Disable;
;;;770    	FSMC_NORSRAMInitStructure.FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
000030  900a              STR      r0,[sp,#0x28]
;;;771    	FSMC_NORSRAMInitStructure.FSMC_WriteBurst = FSMC_WriteBurst_Disable;
000032  900b              STR      r0,[sp,#0x2c]
;;;772    	FSMC_NORSRAMInitStructure.FSMC_ReadWriteTimingStruct = &p;
000034  900c              STR      r0,[sp,#0x30]
000036  a80f              ADD      r0,sp,#0x3c
;;;773    	FSMC_NORSRAMInitStructure.FSMC_WriteTimingStruct = &p;
000038  900d              STR      r0,[sp,#0x34]
;;;774    
;;;775    	FSMC_NORSRAMInit(&FSMC_NORSRAMInitStructure);
00003a  900e              STR      r0,[sp,#0x38]
00003c  4668              MOV      r0,sp
00003e  f7fffffe          BL       FSMC_NORSRAMInit
;;;776    
;;;777    	/*!< Enable FSMC Bank1_SRAM3 Bank */
;;;778    	FSMC_NORSRAMCmd(FSMC_Bank1_NORSRAM4, ENABLE);
000042  2101              MOVS     r1,#1
000044  2006              MOVS     r0,#6
000046  f7fffffe          BL       FSMC_NORSRAMCmd
;;;779    }
00004a  b017              ADD      sp,sp,#0x5c
00004c  bd00              POP      {pc}
;;;780    
                          ENDP


                          AREA ||i.dm9k_ReadID||, CODE, READONLY, ALIGN=2

                  dm9k_ReadID PROC
;;;673    */
;;;674    uint32_t dm9k_ReadID(void)
000000  b510              PUSH     {r4,lr}
;;;675    {
;;;676    	uint8_t vid1,vid2,pid1,pid2;
;;;677    
;;;678    	if (s_FSMC_Init_Ok == 0)
000002  4c10              LDR      r4,|L3.68|
000004  7860              LDRB     r0,[r4,#1]  ; s_FSMC_Init_Ok
000006  b928              CBNZ     r0,|L3.20|
;;;679    	{
;;;680    		DM9K_CtrlLinesConfig();
000008  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;681    		DM9K_FSMCConfig();
00000c  f7fffffe          BL       DM9K_FSMCConfig
;;;682    
;;;683    		s_FSMC_Init_Ok = 1;
000010  2001              MOVS     r0,#1
000012  7060              STRB     r0,[r4,#1]
                  |L3.20|
;;;684    	}
;;;685    	vid1 = ior(DM9000_REG_VID_L) & 0xFF;
000014  2028              MOVS     r0,#0x28
000016  f7fffffe          BL       ior
00001a  4602              MOV      r2,r0
;;;686    	vid2 = ior(DM9000_REG_VID_H) & 0xFF;
00001c  2029              MOVS     r0,#0x29
00001e  f7fffffe          BL       ior
000022  4604              MOV      r4,r0
;;;687    	pid1 = ior(DM9000_REG_PID_L) & 0xFF;
000024  202a              MOVS     r0,#0x2a
000026  f7fffffe          BL       ior
00002a  4603              MOV      r3,r0
;;;688    	pid2 = ior(DM9000_REG_PID_H) & 0xFF;
00002c  202b              MOVS     r0,#0x2b
00002e  f7fffffe          BL       ior
000032  4601              MOV      r1,r0
;;;689    
;;;690    	return (vid2 << 24) | (vid1 << 16) | (pid2 << 8) | pid1;
000034  0620              LSLS     r0,r4,#24
000036  ea404002          ORR      r0,r0,r2,LSL #16
00003a  ea402001          ORR      r0,r0,r1,LSL #8
00003e  4318              ORRS     r0,r0,r3
;;;691    }
000040  bd10              POP      {r4,pc}
;;;692    
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      ||.data||

                          AREA ||i.dm9k_debug_test||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                  dm9k_debug_test PROC
;;;437    */
;;;438    void dm9k_debug_test(void)
000000  2700              MOVS     r7,#0
;;;439    {
;;;440    	uint32_t check_device;
;;;441    	uint8_t  check_iomode;
;;;442    	uint8_t  check_reg_fail = 0;
;;;443    	uint8_t  check_fifo_fail = 0;
000002  463d              MOV      r5,r7
;;;444    	uint16_t i;
;;;445    	uint16_t j;
;;;446    
;;;447    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
000004  2103              MOVS     r1,#3
000006  4638              MOV      r0,r7
000008  f7fffffe          BL       iow
;;;448    	dm9k_udelay(10);								/* delay 10us */
00000c  200a              MOVS     r0,#0xa
00000e  f7fffffe          BL       dm9k_udelay
;;;449    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
000012  2103              MOVS     r1,#3
000014  2000              MOVS     r0,#0
000016  f7fffffe          BL       iow
;;;450    	dm9k_udelay(10);								/* delay 10us */
00001a  200a              MOVS     r0,#0xa
00001c  f7fffffe          BL       dm9k_udelay
;;;451    
;;;452    	check_device  = ior(DM9000_REG_VID_L);
000020  2028              MOVS     r0,#0x28
000022  f7fffffe          BL       ior
000026  4602              MOV      r2,r0
;;;453    	check_device |= ior(DM9000_REG_VID_H) << 8;
000028  2029              MOVS     r0,#0x29
00002a  f7fffffe          BL       ior
00002e  ea422200          ORR      r2,r2,r0,LSL #8
;;;454    	check_device |= ior(DM9000_REG_PID_L) << 16;
000032  202a              MOVS     r0,#0x2a
000034  f7fffffe          BL       ior
000038  ea424200          ORR      r2,r2,r0,LSL #16
;;;455    	check_device |= ior(DM9000_REG_PID_H) << 24;
00003c  202b              MOVS     r0,#0x2b
00003e  f7fffffe          BL       ior
;;;456    
;;;457    	if(check_device != 0x90000A46)
000042  497d              LDR      r1,|L4.568|
000044  ea426000          ORR      r0,r2,r0,LSL #24      ;455
000048  4288              CMP      r0,r1
00004a  d003              BEQ      |L4.84|
;;;458    	{
;;;459    		printk("DM9K_DEBUG ==> DEIVCE NOT FOUND, SYSTEM HOLD !!\n");
00004c  a07b              ADR      r0,|L4.572|
00004e  f7fffffe          BL       __2printf
                  |L4.82|
;;;460    		while(1);
000052  e7fe              B        |L4.82|
                  |L4.84|
;;;461    	}
;;;462    	else
;;;463    	{
;;;464    		printk("DM9K_DEBUG ==> DEIVCE FOUND !!\n");
000054  a086              ADR      r0,|L4.624|
000056  f7fffffe          BL       __2printf
;;;465    	}
;;;466    
;;;467    	check_iomode = ior(DM9000_REG_ISR) >> 6;
00005a  20fe              MOVS     r0,#0xfe
00005c  f7fffffe          BL       ior
000060  0980              LSRS     r0,r0,#6
000062  d003              BEQ      |L4.108|
;;;468    	if(check_iomode != DM9000_WORD_MODE)
;;;469    	{
;;;470    		printk("DM9K_DEBUG ==> DEIVCE NOT WORD MODE, SYSTEM HOLD !!\n");
000064  a08a              ADR      r0,|L4.656|
000066  f7fffffe          BL       __2printf
                  |L4.106|
;;;471    		while(1);
00006a  e7fe              B        |L4.106|
                  |L4.108|
;;;472    	}
;;;473    	else
;;;474    	{
;;;475    		printk("DM9K_DEBUG ==> DEIVCE IS WORD MODE !!\n");
00006c  a096              ADR      r0,|L4.712|
00006e  f7fffffe          BL       __2printf
;;;476    	}
;;;477    
;;;478    	printk("DM9K_DEBUG ==> REGISTER R/W TEST !!\n");
000072  a09f              ADR      r0,|L4.752|
000074  f7fffffe          BL       __2printf
;;;479    	NET_REG_ADDR = DM9000_REG_MAR;
000078  4ca7              LDR      r4,|L4.792|
00007a  2016              MOVS     r0,#0x16
00007c  8020              STRH     r0,[r4,#0]
;;;480    	for(i = 0; i < 0x0100; i++)
00007e  2600              MOVS     r6,#0
                  |L4.128|
;;;481    	{
;;;482    		NET_REG_DATA = i;
000080  8126              STRH     r6,[r4,#8]
;;;483    		if(i != (NET_REG_DATA & 0xff))
000082  8920              LDRH     r0,[r4,#8]
000084  b2c0              UXTB     r0,r0
000086  42b0              CMP      r0,r6
000088  d005              BEQ      |L4.150|
;;;484    		{
;;;485    			printk("             > error W %02x , R %02x \n", i , NET_REG_DATA);
00008a  8922              LDRH     r2,[r4,#8]
00008c  4631              MOV      r1,r6
00008e  a0a3              ADR      r0,|L4.796|
000090  f7fffffe          BL       __2printf
;;;486    			check_reg_fail = 1;
000094  2701              MOVS     r7,#1
                  |L4.150|
000096  1c76              ADDS     r6,r6,#1
000098  b2b6              UXTH     r6,r6                 ;480
00009a  2eff              CMP      r6,#0xff              ;480
00009c  d9f0              BLS      |L4.128|
;;;487    		}
;;;488    	}
;;;489    
;;;490    	if(check_reg_fail)
00009e  b11f              CBZ      r7,|L4.168|
;;;491    	{
;;;492    		printk("DM9K_DEBUG ==> REGISTER R/W FAIL, SYSTEM HOLD !!\n");
0000a0  a0a8              ADR      r0,|L4.836|
0000a2  f7fffffe          BL       __2printf
                  |L4.166|
;;;493    		while(1);
0000a6  e7fe              B        |L4.166|
                  |L4.168|
;;;494    	}
;;;495    
;;;496    	printk("DM9K_DEBUG ==> FIFO R/W TEST !!\n");
0000a8  a0b3              ADR      r0,|L4.888|
0000aa  f7fffffe          BL       __2printf
;;;497    	printk("DM9K_DEBUG ==> FIFO WRITE START POINT 0x%02x%02x \n",
0000ae  20fa              MOVS     r0,#0xfa
0000b0  f7fffffe          BL       ior
0000b4  4602              MOV      r2,r0
0000b6  20fb              MOVS     r0,#0xfb
0000b8  f7fffffe          BL       ior
0000bc  4601              MOV      r1,r0
0000be  a0b7              ADR      r0,|L4.924|
0000c0  f7fffffe          BL       __2printf
;;;498    			ior(DM9000_REG_MWRH), ior(DM9000_REG_MWRL));
;;;499    
;;;500    	NET_REG_ADDR = DM9000_REG_MWCMD;
0000c4  26f8              MOVS     r6,#0xf8
0000c6  8026              STRH     r6,[r4,#0]
;;;501    	for(i = 0; i < 0x1000; i++)
0000c8  2000              MOVS     r0,#0
0000ca  f44f5780          MOV      r7,#0x1000
                  |L4.206|
;;;502    		NET_REG_DATA = ((i & 0xff) * 0x0101);
0000ce  b2c1              UXTB     r1,r0
0000d0  eb012101          ADD      r1,r1,r1,LSL #8
0000d4  8121              STRH     r1,[r4,#8]
0000d6  1c40              ADDS     r0,r0,#1
0000d8  b280              UXTH     r0,r0                 ;501
0000da  42b8              CMP      r0,r7                 ;501
0000dc  d3f7              BCC      |L4.206|
;;;503    
;;;504    	printk("DM9K_DEBUG ==> FIFO WRITE END POINT 0x%02x%02x \n",
0000de  20fa              MOVS     r0,#0xfa
0000e0  f7fffffe          BL       ior
0000e4  4602              MOV      r2,r0
0000e6  20fb              MOVS     r0,#0xfb
0000e8  f7fffffe          BL       ior
0000ec  4601              MOV      r1,r0
0000ee  a0b8              ADR      r0,|L4.976|
0000f0  f7fffffe          BL       __2printf
;;;505    			ior(DM9000_REG_MWRH), ior(DM9000_REG_MWRL));
;;;506    
;;;507    	if((ior(DM9000_REG_MWRH) != 0x20) || (ior(DM9000_REG_MWRL) != 0x00))
0000f4  20fb              MOVS     r0,#0xfb
0000f6  f7fffffe          BL       ior
0000fa  2820              CMP      r0,#0x20
0000fc  d103              BNE      |L4.262|
0000fe  20fa              MOVS     r0,#0xfa
000100  f7fffffe          BL       ior
000104  b118              CBZ      r0,|L4.270|
                  |L4.262|
;;;508    	{
;;;509    		printk("DM9K_DEBUG ==> FIFO WRITE FAIL, SYSTEM HOLD !!\n");
000106  a0bf              ADR      r0,|L4.1028|
000108  f7fffffe          BL       __2printf
                  |L4.268|
;;;510    		while(1);
00010c  e7fe              B        |L4.268|
                  |L4.270|
;;;511    	}
;;;512    
;;;513    	ior(DM9000_REG_MRCMDX);
00010e  20f0              MOVS     r0,#0xf0
000110  f7fffffe          BL       ior
;;;514    	printk("DM9K_DEBUG ==> FIFO READ START POINT 0x%02x%02x \n",
000114  20f4              MOVS     r0,#0xf4
000116  f7fffffe          BL       ior
00011a  4602              MOV      r2,r0
00011c  20f5              MOVS     r0,#0xf5
00011e  f7fffffe          BL       ior
000122  4601              MOV      r1,r0
000124  a0c3              ADR      r0,|L4.1076|
000126  f7fffffe          BL       __2printf
;;;515    			ior(DM9000_REG_MRRH), ior(DM9000_REG_MRRL));
;;;516    	ior(DM9000_REG_MRCMDX);
00012a  20f0              MOVS     r0,#0xf0
00012c  f7fffffe          BL       ior
;;;517    
;;;518    	NET_REG_ADDR = DM9000_REG_MRCMD;
000130  20f2              MOVS     r0,#0xf2
000132  8020              STRH     r0,[r4,#0]
;;;519    	for(i = 0; i < 0x1000; i++)
000134  2000              MOVS     r0,#0
                  |L4.310|
;;;520    	{
;;;521    		j = NET_REG_DATA;
000136  8921              LDRH     r1,[r4,#8]
;;;522    
;;;523    		if(((i & 0xff) * 0x0101) != j)
000138  b2c2              UXTB     r2,r0
00013a  eb022202          ADD      r2,r2,r2,LSL #8
00013e  428a              CMP      r2,r1
000140  d000              BEQ      |L4.324|
;;;524    		{
;;;525    			//printk("             > error W %04x , R %04x \n",
;;;526    			//		((i & 0xff) * 0x0101) , j);
;;;527    			check_fifo_fail = 1;
000142  2501              MOVS     r5,#1
                  |L4.324|
000144  1c40              ADDS     r0,r0,#1
000146  b280              UXTH     r0,r0                 ;519
000148  42b8              CMP      r0,r7                 ;519
00014a  d3f4              BCC      |L4.310|
;;;528    		}
;;;529    	}
;;;530    
;;;531    	printk("DM9K_DEBUG ==> FIFO READ END POINT 0x%02x%02x \n",
00014c  20f4              MOVS     r0,#0xf4
00014e  f7fffffe          BL       ior
000152  4602              MOV      r2,r0
000154  20f5              MOVS     r0,#0xf5
000156  f7fffffe          BL       ior
00015a  4601              MOV      r1,r0
00015c  a0c2              ADR      r0,|L4.1128|
00015e  f7fffffe          BL       __2printf
;;;532    			ior(DM9000_REG_MRRH), ior(DM9000_REG_MRRL));
;;;533    
;;;534    	if((ior(DM9000_REG_MRRH) != 0x20) || (ior(DM9000_REG_MRRL) != 0x00))
000162  20f5              MOVS     r0,#0xf5
000164  f7fffffe          BL       ior
000168  2820              CMP      r0,#0x20
00016a  d103              BNE      |L4.372|
00016c  20f4              MOVS     r0,#0xf4
00016e  f7fffffe          BL       ior
000172  b118              CBZ      r0,|L4.380|
                  |L4.372|
;;;535    	{
;;;536    		printk("DM9K_DEBUG ==> FIFO WRITE FAIL, SYSTEM HOLD !!\n");
000174  a0a3              ADR      r0,|L4.1028|
000176  f7fffffe          BL       __2printf
                  |L4.378|
;;;537    		while(1);
00017a  e7fe              B        |L4.378|
                  |L4.380|
;;;538    	}
;;;539    
;;;540    		if(check_fifo_fail)
00017c  b11d              CBZ      r5,|L4.390|
;;;541    	{
;;;542    		printk("DM9K_DEBUG ==> FIFO R/W DATA FAIL, SYSTEM HOLD !!\n");
00017e  a0c6              ADR      r0,|L4.1176|
000180  f7fffffe          BL       __2printf
                  |L4.388|
;;;543    		while(1);
000184  e7fe              B        |L4.388|
                  |L4.390|
;;;544    	}
;;;545    
;;;546    	printk("DM9K_DEBUG ==> PACKET SEND & INT TEST !! \n");
000186  a0d1              ADR      r0,|L4.1228|
000188  f7fffffe          BL       __2printf
;;;547    	iow(DM9000_REG_NCR, DM9000_REG_RESET);
00018c  2103              MOVS     r1,#3
00018e  2000              MOVS     r0,#0
000190  f7fffffe          BL       iow
;;;548    	dm9k_udelay(10);
000194  200a              MOVS     r0,#0xa
000196  f7fffffe          BL       dm9k_udelay
;;;549    	iow(DM9000_REG_NCR, DM9000_REG_RESET);
00019a  2103              MOVS     r1,#3
00019c  2000              MOVS     r0,#0
00019e  f7fffffe          BL       iow
;;;550    	dm9k_udelay(10);
0001a2  200a              MOVS     r0,#0xa
0001a4  f7fffffe          BL       dm9k_udelay
;;;551    
;;;552    	iow(DM9000_REG_IMR, DM9000_IMR_OFF | DM9000_TX_INTR);
0001a8  2182              MOVS     r1,#0x82
0001aa  20ff              MOVS     r0,#0xff
0001ac  f7fffffe          BL       iow
;;;553    
;;;554    	iow(DM9000_REG_TXPLH, 0x01);
0001b0  2101              MOVS     r1,#1
0001b2  20fd              MOVS     r0,#0xfd
0001b4  f7fffffe          BL       iow
;;;555    	iow(DM9000_REG_TXPLL, 0x00);
0001b8  2100              MOVS     r1,#0
0001ba  20fc              MOVS     r0,#0xfc
0001bc  f7fffffe          BL       iow
;;;556    
;;;557    	do
;;;558    	{
;;;559    		iow(DM9000_REG_ISR, DM9000_TX_INTR);
;;;560    		printk("DM9K_DEBUG ==> INT PIN IS OFF\n");
;;;561    
;;;562    		NET_REG_ADDR = DM9000_REG_MWCMD;
;;;563    		for(i = 0; i < (0x0100 / 2); i++)
;;;564    		{
;;;565    			if(i < 3)
;;;566    				NET_REG_DATA = 0xffff;
0001c0  f64f75ff          MOV      r5,#0xffff
                  |L4.452|
0001c4  2102              MOVS     r1,#2                 ;559
0001c6  20fe              MOVS     r0,#0xfe              ;559
0001c8  f7fffffe          BL       iow
0001cc  a0ca              ADR      r0,|L4.1272|
0001ce  f7fffffe          BL       __2printf
0001d2  8026              STRH     r6,[r4,#0]            ;562
0001d4  2000              MOVS     r0,#0                 ;563
0001d6  e001              B        |L4.476|
                  |L4.472|
0001d8  2803              CMP      r0,#3                 ;565
0001da  d201              BCS      |L4.480|
                  |L4.476|
0001dc  8125              STRH     r5,[r4,#8]
0001de  e002              B        |L4.486|
                  |L4.480|
;;;567    			else
;;;568    				NET_REG_DATA = i * 0x0101;
0001e0  eb002100          ADD      r1,r0,r0,LSL #8
0001e4  8121              STRH     r1,[r4,#8]
                  |L4.486|
0001e6  1c40              ADDS     r0,r0,#1
0001e8  b280              UXTH     r0,r0                 ;563
0001ea  2880              CMP      r0,#0x80              ;563
0001ec  d3f4              BCC      |L4.472|
;;;569    		}
;;;570    
;;;571    		printk("DM9K_DEBUG ==> PACKET IS SEND \n");
0001ee  a0ca              ADR      r0,|L4.1304|
0001f0  f7fffffe          BL       __2printf
;;;572    		iow(DM9000_REG_TCR, DM9000_TCR_SET);
0001f4  2101              MOVS     r1,#1
0001f6  2002              MOVS     r0,#2
0001f8  f7fffffe          BL       iow
;;;573    
;;;574    		while(ior(DM9000_REG_TCR) & DM9000_TCR_SET) dm9k_udelay (5);
0001fc  e002              B        |L4.516|
                  |L4.510|
0001fe  2005              MOVS     r0,#5
000200  f7fffffe          BL       dm9k_udelay
                  |L4.516|
000204  2002              MOVS     r0,#2
000206  f7fffffe          BL       ior
00020a  07c0              LSLS     r0,r0,#31
00020c  d1f7              BNE      |L4.510|
;;;575    		if(ior(DM9000_REG_ISR) & DM9000_TX_INTR)
00020e  20fe              MOVS     r0,#0xfe
000210  f7fffffe          BL       ior
000214  0780              LSLS     r0,r0,#30
000216  d501              BPL      |L4.540|
;;;576    			printk("DM9K_DEBUG ==> INT PIN IS ACTIVE \n");
000218  a0c7              ADR      r0,|L4.1336|
00021a  e000              B        |L4.542|
                  |L4.540|
;;;577    		else
;;;578    			printk("DM9K_DEBUG ==> INT PIN IS NOT ACTIVE \n");
00021c  a0cf              ADR      r0,|L4.1372|
                  |L4.542|
00021e  f7fffffe          BL       __2printf
;;;579    
;;;580    		for(i = 0; i < 10; i++)
000222  2300              MOVS     r3,#0
;;;581    			dm9k_udelay(1000);
000224  f44f777a          MOV      r7,#0x3e8
                  |L4.552|
000228  4638              MOV      r0,r7
00022a  f7fffffe          BL       dm9k_udelay
00022e  1c5b              ADDS     r3,r3,#1
000230  b29b              UXTH     r3,r3                 ;580
000232  2b0a              CMP      r3,#0xa               ;580
000234  d3f8              BCC      |L4.552|
000236  e7c5              B        |L4.452|
;;;582    
;;;583    	}while(1);
;;;584    }
;;;585    
                          ENDP

                  |L4.568|
                          DCD      0x90000a46
                  |L4.572|
00023c  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE NOT FOUND, SYSTEM HOLD !!\n",0
000240  5f444542
000244  5547203d
000248  3d3e2044
00024c  45495643
000250  45204e4f
000254  5420464f
000258  554e442c
00025c  20535953
000260  54454d20
000264  484f4c44
000268  2021210a
00026c  00      
00026d  00                DCB      0
00026e  00                DCB      0
00026f  00                DCB      0
                  |L4.624|
000270  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE FOUND !!\n",0
000274  5f444542
000278  5547203d
00027c  3d3e2044
000280  45495643
000284  4520464f
000288  554e4420
00028c  21210a00
                  |L4.656|
000290  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE NOT WORD MODE, SYSTEM HOLD !!\n",0
000294  5f444542
000298  5547203d
00029c  3d3e2044
0002a0  45495643
0002a4  45204e4f
0002a8  5420574f
0002ac  5244204d
0002b0  4f44452c
0002b4  20535953
0002b8  54454d20
0002bc  484f4c44
0002c0  2021210a
0002c4  00      
0002c5  00                DCB      0
0002c6  00                DCB      0
0002c7  00                DCB      0
                  |L4.712|
0002c8  444d394b          DCB      "DM9K_DEBUG ==> DEIVCE IS WORD MODE !!\n",0
0002cc  5f444542
0002d0  5547203d
0002d4  3d3e2044
0002d8  45495643
0002dc  45204953
0002e0  20574f52
0002e4  44204d4f
0002e8  44452021
0002ec  210a00  
0002ef  00                DCB      0
                  |L4.752|
0002f0  444d394b          DCB      "DM9K_DEBUG ==> REGISTER R/W TEST !!\n",0
0002f4  5f444542
0002f8  5547203d
0002fc  3d3e2052
000300  45474953
000304  54455220
000308  522f5720
00030c  54455354
000310  2021210a
000314  00      
000315  00                DCB      0
000316  00                DCB      0
000317  00                DCB      0
                  |L4.792|
                          DCD      0x6c100000
                  |L4.796|
00031c  20202020          DCB      "             > error W %02x , R %02x \n",0
000320  20202020
000324  20202020
000328  203e2065
00032c  72726f72
000330  20572025
000334  30327820
000338  2c205220
00033c  25303278
000340  200a00  
000343  00                DCB      0
                  |L4.836|
000344  444d394b          DCB      "DM9K_DEBUG ==> REGISTER R/W FAIL, SYSTEM HOLD !!\n",0
000348  5f444542
00034c  5547203d
000350  3d3e2052
000354  45474953
000358  54455220
00035c  522f5720
000360  4641494c
000364  2c205359
000368  5354454d
00036c  20484f4c
000370  44202121
000374  0a00    
000376  00                DCB      0
000377  00                DCB      0
                  |L4.888|
000378  444d394b          DCB      "DM9K_DEBUG ==> FIFO R/W TEST !!\n",0
00037c  5f444542
000380  5547203d
000384  3d3e2046
000388  49464f20
00038c  522f5720
000390  54455354
000394  2021210a
000398  00      
000399  00                DCB      0
00039a  00                DCB      0
00039b  00                DCB      0
                  |L4.924|
00039c  444d394b          DCB      "DM9K_DEBUG ==> FIFO WRITE START POINT 0x%02x%02x \n",0
0003a0  5f444542
0003a4  5547203d
0003a8  3d3e2046
0003ac  49464f20
0003b0  57524954
0003b4  45205354
0003b8  41525420
0003bc  504f494e
0003c0  54203078
0003c4  25303278
0003c8  25303278
0003cc  200a00  
0003cf  00                DCB      0
                  |L4.976|
0003d0  444d394b          DCB      "DM9K_DEBUG ==> FIFO WRITE END POINT 0x%02x%02x \n",0
0003d4  5f444542
0003d8  5547203d
0003dc  3d3e2046
0003e0  49464f20
0003e4  57524954
0003e8  4520454e
0003ec  4420504f
0003f0  494e5420
0003f4  30782530
0003f8  32782530
0003fc  3278200a
000400  00      
000401  00                DCB      0
000402  00                DCB      0
000403  00                DCB      0
                  |L4.1028|
000404  444d394b          DCB      "DM9K_DEBUG ==> FIFO WRITE FAIL, SYSTEM HOLD !!\n",0
000408  5f444542
00040c  5547203d
000410  3d3e2046
000414  49464f20
000418  57524954
00041c  45204641
000420  494c2c20
000424  53595354
000428  454d2048
00042c  4f4c4420
000430  21210a00
                  |L4.1076|
000434  444d394b          DCB      "DM9K_DEBUG ==> FIFO READ START POINT 0x%02x%02x \n",0
000438  5f444542
00043c  5547203d
000440  3d3e2046
000444  49464f20
000448  52454144
00044c  20535441
000450  52542050
000454  4f494e54
000458  20307825
00045c  30327825
000460  30327820
000464  0a00    
000466  00                DCB      0
000467  00                DCB      0
                  |L4.1128|
000468  444d394b          DCB      "DM9K_DEBUG ==> FIFO READ END POINT 0x%02x%02x \n",0
00046c  5f444542
000470  5547203d
000474  3d3e2046
000478  49464f20
00047c  52454144
000480  20454e44
000484  20504f49
000488  4e542030
00048c  78253032
000490  78253032
000494  78200a00
                  |L4.1176|
000498  444d394b          DCB      "DM9K_DEBUG ==> FIFO R/W DATA FAIL, SYSTEM HOLD !!\n",0
00049c  5f444542
0004a0  5547203d
0004a4  3d3e2046
0004a8  49464f20
0004ac  522f5720
0004b0  44415441
0004b4  20464149
0004b8  4c2c2053
0004bc  59535445
0004c0  4d20484f
0004c4  4c442021
0004c8  210a00  
0004cb  00                DCB      0
                  |L4.1228|
0004cc  444d394b          DCB      "DM9K_DEBUG ==> PACKET SEND & INT TEST !! \n",0
0004d0  5f444542
0004d4  5547203d
0004d8  3d3e2050
0004dc  41434b45
0004e0  54205345
0004e4  4e442026
0004e8  20494e54
0004ec  20544553
0004f0  54202121
0004f4  200a00  
0004f7  00                DCB      0
                  |L4.1272|
0004f8  444d394b          DCB      "DM9K_DEBUG ==> INT PIN IS OFF\n",0
0004fc  5f444542
000500  5547203d
000504  3d3e2049
000508  4e542050
00050c  494e2049
000510  53204f46
000514  460a00  
000517  00                DCB      0
                  |L4.1304|
000518  444d394b          DCB      "DM9K_DEBUG ==> PACKET IS SEND \n",0
00051c  5f444542
000520  5547203d
000524  3d3e2050
000528  41434b45
00052c  54204953
000530  2053454e
000534  44200a00
                  |L4.1336|
000538  444d394b          DCB      "DM9K_DEBUG ==> INT PIN IS ACTIVE \n",0
00053c  5f444542
000540  5547203d
000544  3d3e2049
000548  4e542050
00054c  494e2049
000550  53204143
000554  54495645
000558  200a00  
00055b  00                DCB      0
                  |L4.1372|
00055c  444d394b          DCB      "DM9K_DEBUG ==> INT PIN IS NOT ACTIVE \n",0
000560  5f444542
000564  5547203d
000568  3d3e2049
00056c  4e542050
000570  494e2049
000574  53204e4f
000578  54204143
00057c  54495645
000580  200a00  
000583  00                DCB      0

                          AREA ||i.dm9k_hash_table||, CODE, READONLY, ALIGN=2

                  dm9k_hash_table PROC
;;;120    */
;;;121    void dm9k_hash_table(void)
000000  b510              PUSH     {r4,lr}
;;;122    {
;;;123    	uint8_t i;
;;;124    
;;;125    	/* 将MAC地址告诉uip */
;;;126    	for (i = 0; i < 6; i++)
;;;127    	{
;;;128    		uip_ethaddr.addr[i] = DEF_MAC_ADDR[i];
000002  4912              LDR      r1,|L5.76|
000004  4c12              LDR      r4,|L5.80|
000006  2000              MOVS     r0,#0                 ;126
                  |L5.8|
000008  5c22              LDRB     r2,[r4,r0]
00000a  540a              STRB     r2,[r1,r0]
00000c  1c40              ADDS     r0,r0,#1
00000e  b2c0              UXTB     r0,r0                 ;126
000010  2806              CMP      r0,#6                 ;126
000012  d3f9              BCC      |L5.8|
;;;129    	}
;;;130    
;;;131    	/* 设置 网卡 MAC 位置，来自於 MyHardware */
;;;132    	for(i = 0; i < 6; i++)
000014  2300              MOVS     r3,#0
                  |L5.22|
;;;133    		iow(DM9000_REG_PAR + i, DEF_MAC_ADDR[i]);
000016  f1030010          ADD      r0,r3,#0x10
00001a  5ce1              LDRB     r1,[r4,r3]
00001c  b2c0              UXTB     r0,r0
00001e  f7fffffe          BL       iow
000022  1c5b              ADDS     r3,r3,#1
000024  b2db              UXTB     r3,r3                 ;132
000026  2b06              CMP      r3,#6                 ;132
000028  d3f5              BCC      |L5.22|
;;;134    
;;;135    	for(i = 0; i < 8; i++) 								/* 清除 网卡多播设置 */
00002a  2300              MOVS     r3,#0
                  |L5.44|
;;;136    		iow(DM9000_REG_MAR + i, 0x00);
00002c  f1030016          ADD      r0,r3,#0x16
000030  b2c0              UXTB     r0,r0
000032  2100              MOVS     r1,#0
000034  f7fffffe          BL       iow
000038  1c5b              ADDS     r3,r3,#1
00003a  b2db              UXTB     r3,r3                 ;135
00003c  2b08              CMP      r3,#8                 ;135
00003e  d3f5              BCC      |L5.44|
;;;137    	iow(DM9000_REG_MAR + 7, 0x80);  					/* 速设置 广播包 设置 */
000040  2180              MOVS     r1,#0x80
000042  e8bd4010          POP      {r4,lr}
000046  201d              MOVS     r0,#0x1d
000048  f7ffbffe          B.W      iow
;;;138    }
;;;139    
                          ENDP

                  |L5.76|
                          DCD      uip_ethaddr
                  |L5.80|
                          DCD      ||.data||+0x2

                          AREA ||i.dm9k_initnic||, CODE, READONLY, ALIGN=1

                  dm9k_initnic PROC
;;;210    */
;;;211    void dm9k_initnic(void)
000000  b500              PUSH     {lr}
;;;212    {
;;;213    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
000002  2103              MOVS     r1,#3
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       iow
;;;214    	dm9k_udelay(10);								/* delay 10us */
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       dm9k_udelay
;;;215    
;;;216    	dm9k_hash_table();								/* 设置 DM9000A MAC 及 多播*/
000010  f7fffffe          BL       dm9k_hash_table
;;;217    
;;;218    	dm9k_reset();									/* 进行 DM9000A 软件设置 */
000014  f7fffffe          BL       dm9k_reset
;;;219    
;;;220    	iow(DM9000_REG_GPR, DM9000_PHY_OFF);			/* 关闭 PHY ，进行 PHY 设置*/
000018  2101              MOVS     r1,#1
00001a  201f              MOVS     r0,#0x1f
00001c  f7fffffe          BL       iow
;;;221    	dm9k_phy_write(0x00, 0x8000);					/* 重置 PHY 的寄存器 */
000020  f44f4100          MOV      r1,#0x8000
000024  2000              MOVS     r0,#0
000026  f7fffffe          BL       dm9k_phy_write
;;;222    #ifdef DM9000A_FLOW_CONTROL
;;;223    	dm9k_phy_write(0x04, 0x01e1 | 0x0400);			/* 设置 自适应模式相容表 */
;;;224    #else
;;;225    	dm9k_phy_write(0x04, 0x01e1);					/* 设置 自适应模式相容表 */
00002a  f24011e1          MOV      r1,#0x1e1
00002e  2004              MOVS     r0,#4
000030  f7fffffe          BL       dm9k_phy_write
;;;226    #endif
;;;227    	//dm9k_phy_write(0x00, 0x1000);					/* 设置 基本连接模式 */
;;;228    	/* 连接模式设置
;;;229    	  0x0000 : 固定10M半双工
;;;230    	  0x0100 : 固定10M全双工
;;;231    	  0x2000 : 固定100M半双工
;;;232    	  0x2100 : 固定100M全双工
;;;233    	  0x1000 : 自适应模式
;;;234    	*/
;;;235    	dm9k_phy_write(0x00, 0x1000);				/* 设置 基本连接模式 */
000034  f44f5180          MOV      r1,#0x1000
000038  2000              MOVS     r0,#0
00003a  f7fffffe          BL       dm9k_phy_write
;;;236    
;;;237    	iow(DM9000_REG_GPR, DM9000_PHY_ON);				/* 结束 PHY 设置, 开启 PHY */
00003e  2100              MOVS     r1,#0
000040  201f              MOVS     r0,#0x1f
000042  f85deb04          POP      {lr}
000046  f7ffbffe          B.W      iow
;;;238    
;;;239    	//dm9k_debug_test();
;;;240    }
;;;241    
                          ENDP


                          AREA ||i.dm9k_interrupt||, CODE, READONLY, ALIGN=1

                  dm9k_interrupt PROC
;;;412    */
;;;413    void  dm9k_interrupt(void)
000000  4770              BX       lr
;;;414    {
;;;415    #if 0  /* armfly */	
;;;416    	uint8_t  save_reg;
;;;417    	uint8_t  isr_status;
;;;418    
;;;419    	save_reg = NET_REG_ADDR;							/* 暂存所使用的位置 */
;;;420    
;;;421    	iow(DM9000_REG_IMR , DM9000_IMR_OFF);				/* 关闭 DM9000A 中断 */
;;;422    	isr_status = ior(DM9000_REG_ISR);					/* 取得中断产生值 */
;;;423    
;;;424    	if(isr_status & DM9000_RX_INTR) 					/* 检查是否为接收中断 */
;;;425    		dm9k_receive_packet();							/* 执行接收处理程序 */
;;;426    
;;;427    	iow(DM9000_REG_IMR , DM9000_IMR_SET);				/* 开启 DM9000A 中断 */
;;;428    	NET_REG_ADDR = save_reg;							/* 回复所使用的位置 */
;;;429    #endif
;;;430    }
;;;431    
                          ENDP


                          AREA ||i.dm9k_phy_write||, CODE, READONLY, ALIGN=1

                  dm9k_phy_write PROC
;;;190    */
;;;191    void dm9k_phy_write(uint8_t phy_reg, uint16_t writedata)
000000  460b              MOV      r3,r1
;;;192    {
000002  b500              PUSH     {lr}
;;;193    	/* 设置写入 PHY 寄存器的位置 */
;;;194    	iow(DM9000_REG_EPAR, phy_reg | DM9000_PHY);
000004  f0400140          ORR      r1,r0,#0x40
000008  200c              MOVS     r0,#0xc
00000a  f7fffffe          BL       iow
;;;195    
;;;196    	/* 设置写入 PHY 寄存器的值 */
;;;197    	iow(DM9000_REG_EPDRH, ( writedata >> 8 ) & 0xff);
00000e  0a19              LSRS     r1,r3,#8
000010  200e              MOVS     r0,#0xe
000012  f7fffffe          BL       iow
;;;198    	iow(DM9000_REG_EPDRL, writedata & 0xff);
000016  b2d9              UXTB     r1,r3
000018  200d              MOVS     r0,#0xd
00001a  f7fffffe          BL       iow
;;;199    
;;;200    	iow(DM9000_REG_EPCR, 0x0a); 						/* 将资料写入 PHY 寄存器 */
00001e  210a              MOVS     r1,#0xa
000020  200b              MOVS     r0,#0xb
000022  f7fffffe          BL       iow
                  |L8.38|
;;;201    	while(ior(DM9000_REG_EPCR) & 0x01);					/* 查寻是否执行结束 */
000026  200b              MOVS     r0,#0xb
000028  f7fffffe          BL       ior
00002c  07c0              LSLS     r0,r0,#31
00002e  d1fa              BNE      |L8.38|
;;;202    	iow(DM9000_REG_EPCR, 0x08); 						/* 清除写入命令 */
000030  2108              MOVS     r1,#8
000032  200b              MOVS     r0,#0xb
000034  f85deb04          POP      {lr}
000038  f7ffbffe          B.W      iow
;;;203    }
;;;204    
                          ENDP


                          AREA ||i.dm9k_receive_packet||, CODE, READONLY, ALIGN=2

                  dm9k_receive_packet PROC
;;;247    */
;;;248    uint16_t dm9k_receive_packet(uint8_t *_uip_buf)
000000  b530              PUSH     {r4,r5,lr}
;;;249    {
;;;250    	uint16_t ReceiveLength;
;;;251    	uint16_t *ReceiveData;
;;;252    	uint8_t  rx_int_count = 0;
;;;253    	uint8_t  rx_checkbyte;
;;;254    	uint16_t rx_status, rx_length;
;;;255    	uint8_t  jump_packet;
;;;256    	uint16_t i;
;;;257    	uint16_t calc_len;
;;;258    	uint16_t calc_MRR;
;;;259    
;;;260    	do
;;;261    	{
;;;262    		ReceiveLength = 0;								/* 清除接收的长度 */
;;;263    		ReceiveData = (uint16_t *)_uip_buf;
;;;264    		jump_packet = 0;								/* 清除跳包动作 */
;;;265    		ior(DM9000_REG_MRCMDX);							/* 读取内存数据，地址不增加 */
;;;266    		/* 计算内存数据位置 */
;;;267    		calc_MRR = (ior(DM9000_REG_MRRH) << 8) + ior(DM9000_REG_MRRL);
;;;268    		rx_checkbyte = ior(DM9000_REG_MRCMDX);			/*  */
;;;269    
;;;270    		if(rx_checkbyte == DM9000_PKT_RDY)				/* 取 */
;;;271    		{
;;;272    			/* 读取封包相关资讯 及 长度 */
;;;273    			NET_REG_ADDR = DM9000_REG_MRCMD;
000002  4c29              LDR      r4,|L9.168|
000004  4605              MOV      r5,r0                 ;249
                  |L9.6|
000006  2200              MOVS     r2,#0                 ;264
000008  20f0              MOVS     r0,#0xf0              ;265
00000a  f7fffffe          BL       ior
00000e  20f4              MOVS     r0,#0xf4              ;267
000010  f7fffffe          BL       ior
000014  4603              MOV      r3,r0                 ;267
000016  20f5              MOVS     r0,#0xf5              ;267
000018  f7fffffe          BL       ior
00001c  eb032000          ADD      r0,r3,r0,LSL #8       ;267
000020  b283              UXTH     r3,r0                 ;267
000022  20f0              MOVS     r0,#0xf0              ;268
000024  f7fffffe          BL       ior
000028  2801              CMP      r0,#1                 ;270
00002a  d004              BEQ      |L9.54|
;;;274    			rx_status = NET_REG_DATA;
;;;275    			rx_length = NET_REG_DATA;
;;;276    
;;;277    			/* 若收到超过系统可承受的封包，此包跳过 */
;;;278    			if(rx_length > Max_Ethernet_Lenth)
;;;279    				jump_packet = 1;
;;;280    
;;;281    #ifdef Broadcast_Jump
;;;282    			/* 若收到的广播或多播包超过特定长度，此包跳过 */
;;;283    			if(rx_status & 0x4000)
;;;284    			{
;;;285    				if(rx_length > Max_Broadcast_Lenth)
;;;286    					jump_packet = 1;
;;;287    			}
;;;288    #endif
;;;289    			/* 计算下一个包的指针位 , 若接收长度为奇数，需加一对齐偶字节。*/
;;;290    			/* 若是超过 0x3fff ，则需回归绕到 0x0c00 起始位置 */
;;;291    			calc_MRR += (rx_length + 4);
;;;292    			if(rx_length & 0x01) calc_MRR++;
;;;293    			if(calc_MRR > 0x3fff) calc_MRR -= 0x3400;
;;;294    
;;;295    			if(jump_packet == 0x01)
;;;296    			{
;;;297    				/* 将指针移到下一个包的包头位置 */
;;;298    				iow (DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;299    				iow (DM9000_REG_MRRL, calc_MRR & 0xff );
;;;300    				continue;
;;;301    			}
;;;302    
;;;303    			/* 开始将内存的资料搬到到系统中，每次移动一个 word */
;;;304    			calc_len = (rx_length + 1) >> 1;
;;;305    			for(i = 0 ; i < calc_len ; i++)
;;;306    				ReceiveData[i] = NET_REG_DATA;
;;;307    
;;;308    			/* 将包长回报给 TCP/IP 上层，并减去最後 4 BYTE 的 CRC-32 检核码 */
;;;309    			ReceiveLength = rx_length - 4;
;;;310    
;;;311    			rx_int_count++;								/* 累计收包次数 */
;;;312    
;;;313    #ifdef FifoPointCheck
;;;314    			if(calc_MRR != ((ior(DM9000_REG_MRRH) << 8) + ior(DM9000_REG_MRRL)))
;;;315    			{
;;;316    #ifdef Point_Error_Reset
;;;317    				dm9k_reset();								/* 若是指针出错，重置 */
;;;318    				return ReceiveLength;
;;;319    #endif
;;;320    				/*若是指针出错，将指针移到下一个包的包头位置  */
;;;321    				iow(DM9000_REG_MRRH, (calc_MRR >> 8) & 0xff);
;;;322    				iow(DM9000_REG_MRRL, calc_MRR & 0xff);
;;;323    			}
;;;324    #endif
;;;325    			return ReceiveLength;
;;;326    		}
;;;327    		else
;;;328    		{
;;;329    			if(rx_checkbyte == DM9000_PKT_NORDY)		/* 未收到包 */
00002c  b3b0              CBZ      r0,|L9.156|
;;;330    			{
;;;331    				iow(DM9000_REG_ISR, 0x3f);				/*  */
;;;332    			}
;;;333    			else
;;;334    			{
;;;335    				dm9k_reset();								/* 接收指针出错，重置 */
00002e  f7fffffe          BL       dm9k_reset
                  |L9.50|
;;;336    			}
;;;337    			return (0);
000032  2000              MOVS     r0,#0
;;;338    		}
;;;339    	}while(rx_int_count < Max_Int_Count);				/* 是否超过最多接收封包计数 */
;;;340    	return 0;
;;;341    }
000034  bd30              POP      {r4,r5,pc}
                  |L9.54|
000036  20f2              MOVS     r0,#0xf2              ;273
000038  8020              STRH     r0,[r4,#0]            ;273
00003a  8920              LDRH     r0,[r4,#8]            ;274
00003c  8921              LDRH     r1,[r4,#8]            ;275
00003e  f5b16fc0          CMP      r1,#0x600             ;278
000042  d900              BLS      |L9.70|
000044  2201              MOVS     r2,#1                 ;279
                  |L9.70|
000046  0440              LSLS     r0,r0,#17             ;283
000048  d503              BPL      |L9.82|
00004a  f5b17ffa          CMP      r1,#0x1f4             ;285
00004e  d900              BLS      |L9.82|
000050  2201              MOVS     r2,#1                 ;286
                  |L9.82|
000052  1858              ADDS     r0,r3,r1              ;291
000054  1d00              ADDS     r0,r0,#4              ;291
000056  b283              UXTH     r3,r0                 ;291
000058  07c8              LSLS     r0,r1,#31             ;292
00005a  d001              BEQ      |L9.96|
00005c  1c5b              ADDS     r3,r3,#1              ;292
00005e  b29b              UXTH     r3,r3                 ;292
                  |L9.96|
000060  f5b34f80          CMP      r3,#0x4000            ;293
000064  d302              BCC      |L9.108|
000066  f5a35350          SUB      r3,r3,#0x3400         ;293
00006a  b29b              UXTH     r3,r3                 ;293
                  |L9.108|
00006c  b142              CBZ      r2,|L9.128|
00006e  0a19              LSRS     r1,r3,#8              ;298
000070  20f5              MOVS     r0,#0xf5              ;298
000072  f7fffffe          BL       iow
000076  b2d9              UXTB     r1,r3                 ;299
000078  20f4              MOVS     r0,#0xf4              ;299
00007a  f7fffffe          BL       iow
00007e  e7c2              B        |L9.6|
                  |L9.128|
000080  1c48              ADDS     r0,r1,#1              ;304
000082  0842              LSRS     r2,r0,#1              ;304
000084  2000              MOVS     r0,#0                 ;305
000086  e004              B        |L9.146|
                  |L9.136|
000088  8923              LDRH     r3,[r4,#8]            ;306
00008a  f8253010          STRH     r3,[r5,r0,LSL #1]     ;306
00008e  1c40              ADDS     r0,r0,#1              ;306
000090  b280              UXTH     r0,r0                 ;305
                  |L9.146|
000092  4290              CMP      r0,r2                 ;305
000094  d3f8              BCC      |L9.136|
000096  1f09              SUBS     r1,r1,#4              ;305
000098  b288              UXTH     r0,r1                 ;309
00009a  bd30              POP      {r4,r5,pc}
                  |L9.156|
00009c  e7ff              B        |L9.158|
                  |L9.158|
00009e  213f              MOVS     r1,#0x3f              ;331
0000a0  20fe              MOVS     r0,#0xfe              ;331
0000a2  f7fffffe          BL       iow
0000a6  e7c4              B        |L9.50|
;;;342    
                          ENDP

                  |L9.168|
                          DCD      0x6c100000

                          AREA ||i.dm9k_reset||, CODE, READONLY, ALIGN=2

                  dm9k_reset PROC
;;;145    */
;;;146    void dm9k_reset(void)
000000  b500              PUSH     {lr}
;;;147    {
;;;148    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
000002  2103              MOVS     r1,#3
000004  2000              MOVS     r0,#0
000006  f7fffffe          BL       iow
;;;149    	dm9k_udelay(10);								/* delay 10us */
00000a  200a              MOVS     r0,#0xa
00000c  f7fffffe          BL       dm9k_udelay
;;;150    	iow(DM9000_REG_NCR, DM9000_REG_RESET);			/* 对 DM9000A 进行软件重置 */
000010  2103              MOVS     r1,#3
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       iow
;;;151    	dm9k_udelay(10);								/* delay 10us */
000018  200a              MOVS     r0,#0xa
00001a  f7fffffe          BL       dm9k_udelay
;;;152    
;;;153    	/* 基本记存器相关设置 */
;;;154    	iow(DM9000_REG_IMR, DM9000_IMR_OFF); 			/* 开启内存自环模式 */
00001e  2180              MOVS     r1,#0x80
000020  20ff              MOVS     r0,#0xff
000022  f7fffffe          BL       iow
;;;155    	iow(DM9000_REG_TCR2, DM9000_TCR2_SET);			/* 设置 LED 显示模式1:全双工亮，半双工灭 */
000026  2180              MOVS     r1,#0x80
000028  202d              MOVS     r0,#0x2d
00002a  f7fffffe          BL       iow
;;;156    
;;;157    	/* 清除多余资讯 */
;;;158    	iow(DM9000_REG_NSR, 0x2c);
00002e  212c              MOVS     r1,#0x2c
000030  2001              MOVS     r0,#1
000032  f7fffffe          BL       iow
;;;159    	iow(DM9000_REG_TCR, 0x00);
000036  2100              MOVS     r1,#0
000038  2002              MOVS     r0,#2
00003a  f7fffffe          BL       iow
;;;160    	iow(DM9000_REG_ISR, 0x3f);
00003e  213f              MOVS     r1,#0x3f
000040  20fe              MOVS     r0,#0xfe
000042  f7fffffe          BL       iow
;;;161    
;;;162    #ifdef DM9000A_FLOW_CONTROL
;;;163    	iow(DM9000_REG_BPTR, DM9000_BPTR_SET);			/* 半双工流控设置 */
;;;164    	iow(DM9000_REG_FCTR, DM9000_FCTR_SET);			/* 全双工流控设置 */
;;;165    	iow(DM9000_REG_FCR, DM9000_FCR_SET);			/* 开启流控设置 */
;;;166    #endif
;;;167    
;;;168    #ifdef DM9000A_UPTO_100M
;;;169    	/* DM9000A无此寄存器 */
;;;170    	iow(DM9000_REG_OTCR, DM9000_OTCR_SET);			/* 工作频率到 100Mhz 设置 */
;;;171    #endif
;;;172    
;;;173    #ifdef  Rx_Int_enable
;;;174    	iow(DM9000_REG_IMR, DM9000_IMR_SET);			/* 开启 中断模式 */
;;;175    #else
;;;176    	iow(DM9000_REG_IMR, DM9000_IMR_OFF);			/* 关闭 中断模式 */
000046  2180              MOVS     r1,#0x80
000048  20ff              MOVS     r0,#0xff
00004a  f7fffffe          BL       iow
;;;177    #endif
;;;178    
;;;179    	iow(DM9000_REG_RCR, DM9000_RCR_SET);			/* 开启 接收工能 */
00004e  2131              MOVS     r1,#0x31
000050  2005              MOVS     r0,#5
000052  f7fffffe          BL       iow
;;;180    
;;;181    	SendPackOk = 0;
000056  4902              LDR      r1,|L10.96|
000058  2000              MOVS     r0,#0
00005a  7008              STRB     r0,[r1,#0]
;;;182    }
00005c  bd00              POP      {pc}
;;;183    
                          ENDP

00005e  0000              DCW      0x0000
                  |L10.96|
                          DCD      ||.data||

                          AREA ||i.dm9k_send_packet||, CODE, READONLY, ALIGN=2

                  dm9k_send_packet PROC
;;;349    */
;;;350    void dm9k_send_packet(uint8_t *p_char, uint16_t length)
000000  b530              PUSH     {r4,r5,lr}
;;;351    {
;;;352    	uint16_t SendLength = length;
;;;353    	uint16_t *SendData = (uint16_t *) p_char;
;;;354    	uint16_t i;
;;;355    	uint16_t calc_len;
;;;356    	__IO uint16_t calc_MWR;
;;;357    
;;;358    	/* 检查 DM9000A 是否还在传送中！若是等待直到传送结束 */
;;;359    	if(SendPackOk == Max_Send_Pack)
000002  4d18              LDR      r5,|L11.100|
000004  4604              MOV      r4,r0                 ;353
000006  460b              MOV      r3,r1                 ;352
000008  7828              LDRB     r0,[r5,#0]  ; SendPackOk
00000a  2802              CMP      r0,#2
00000c  d003              BEQ      |L11.22|
00000e  e008              B        |L11.34|
                  |L11.16|
;;;360    	{
;;;361    		while(ior(DM9000_REG_TCR) & DM9000_TCR_SET)
;;;362    		{
;;;363    			dm9k_udelay (5);
000010  2005              MOVS     r0,#5
000012  f7fffffe          BL       dm9k_udelay
                  |L11.22|
000016  2002              MOVS     r0,#2                 ;361
000018  f7fffffe          BL       ior
00001c  07c0              LSLS     r0,r0,#31             ;361
00001e  d1f7              BNE      |L11.16|
;;;364    		}
;;;365    		SendPackOk = 0;
000020  7028              STRB     r0,[r5,#0]
                  |L11.34|
;;;366    	}
;;;367    
;;;368    	SendPackOk++;										/* 设置传送计数 */
000022  b2c0              UXTB     r0,r0
000024  1c40              ADDS     r0,r0,#1
000026  7028              STRB     r0,[r5,#0]
;;;369    
;;;370    #ifdef FifoPointCheck
;;;371    	/* 计算下一个传送的指针位 , 若接收长度为奇数，需加一对齐偶字节。*/
;;;372    	/* 若是超过 0x0bff ，则需回归绕到 0x0000 起始位置 */
;;;373    	calc_MWR = (ior(DM9000_REG_MWRH) << 8) + ior(DM9000_REG_MWRL);
;;;374    	calc_MWR += SendLength;
;;;375    	if(SendLength & 0x01) calc_MWR++;
;;;376    	if(calc_MWR > 0x0bff) calc_MWR -= 0x0c00;
;;;377    #endif
;;;378    
;;;379    	iow(DM9000_REG_TXPLH, (SendLength >> 8) & 0xff);	/* 设置传送封包的长度 */
000028  0a19              LSRS     r1,r3,#8
00002a  20fd              MOVS     r0,#0xfd
00002c  f7fffffe          BL       iow
;;;380    	iow(DM9000_REG_TXPLL, SendLength & 0xff);
000030  b2d9              UXTB     r1,r3
000032  20fc              MOVS     r0,#0xfc
000034  f7fffffe          BL       iow
;;;381    
;;;382    	/* 开始将系统的资料搬到到内存中，每次移动一个 word */
;;;383    	NET_REG_ADDR = DM9000_REG_MWCMD;
000038  4a0b              LDR      r2,|L11.104|
00003a  20f8              MOVS     r0,#0xf8
00003c  8010              STRH     r0,[r2,#0]
00003e  1c5b              ADDS     r3,r3,#1
;;;384    	calc_len = (SendLength + 1) >> 1;
000040  0858              LSRS     r0,r3,#1
;;;385    	for(i = 0; i < calc_len; i++)
000042  2100              MOVS     r1,#0
000044  e005              B        |L11.82|
;;;386    		NET_REG_DATA = SendData[i];
000046  bf00              NOP      
                  |L11.72|
000048  f8343011          LDRH     r3,[r4,r1,LSL #1]
00004c  8113              STRH     r3,[r2,#8]
00004e  1c49              ADDS     r1,r1,#1
000050  b289              UXTH     r1,r1                 ;385
                  |L11.82|
000052  4281              CMP      r1,r0                 ;385
000054  d3f8              BCC      |L11.72|
;;;387    
;;;388    	iow(DM9000_REG_TCR, DM9000_TCR_SET);				/* 进行传送 */
000056  e8bd4030          POP      {r4,r5,lr}
00005a  2101              MOVS     r1,#1
00005c  2002              MOVS     r0,#2
00005e  f7ffbffe          B.W      iow
;;;389    
;;;390    #ifdef FifoPointCheck
;;;391    	if(calc_MWR != ((ior(DM9000_REG_MWRH) << 8) + ior(DM9000_REG_MWRL)))
;;;392    	{
;;;393    #ifdef Point_Error_Reset
;;;394    		/* 若是指针出错，等待此一封包送完 , 之後进行重置 */
;;;395    		while(ior(DM9000_REG_TCR) & DM9000_TCR_SET) dm9k_udelay (5);
;;;396    		dm9k_reset();
;;;397    		return;
;;;398    #endif
;;;399    		/*若是指针出错，将指针移到下一个传送包的包头位置  */
;;;400    		iow(DM9000_REG_MWRH, (calc_MWR >> 8) & 0xff);
;;;401    		iow(DM9000_REG_MWRL, calc_MWR & 0xff);
;;;402    	}
;;;403    #endif
;;;404    	return;
;;;405    }
;;;406    
                          ENDP

000062  0000              DCW      0x0000
                  |L11.100|
                          DCD      ||.data||
                  |L11.104|
                          DCD      0x6c100000

                          AREA ||i.dm9k_udelay||, CODE, READONLY, ALIGN=1

                  dm9k_udelay PROC
;;;78     */
;;;79     void dm9k_udelay(uint16_t time)
000000  2200              MOVS     r2,#0
;;;80     {
000002  e006              B        |L12.18|
                  |L12.4|
;;;81         uint16_t i,k;
;;;82     
;;;83     	for (i = 0; i < time; i++)
;;;84     	{
;;;85     		for (k = 0; k < 80; k++);
000004  2100              MOVS     r1,#0
                  |L12.6|
000006  1c49              ADDS     r1,r1,#1
000008  b289              UXTH     r1,r1
00000a  2950              CMP      r1,#0x50
00000c  d3fb              BCC      |L12.6|
00000e  1c52              ADDS     r2,r2,#1
000010  b292              UXTH     r2,r2                 ;83
                  |L12.18|
000012  4282              CMP      r2,r0                 ;83
000014  d3f6              BCC      |L12.4|
                  |L12.22|
;;;86     	}
;;;87     	while(time--);
000016  1e40              SUBS     r0,r0,#1
000018  b280              UXTH     r0,r0
00001a  d2fc              BCS      |L12.22|
;;;88     }
00001c  4770              BX       lr
;;;89     
                          ENDP


                          AREA ||i.etherdev_chkmedia||, CODE, READONLY, ALIGN=1

                  etherdev_chkmedia PROC
;;;625    */
;;;626    void etherdev_chkmedia(void)
000000  b500              PUSH     {lr}
;;;627    {
;;;628    //	uint8_t status;
;;;629    
;;;630    	while(!(ior(DM9000_REG_NSR) & DM9000_PHY))
;;;631    	{
;;;632    		dm9k_udelay(2000);
000002  f44f63fa          MOV      r3,#0x7d0
000006  e002              B        |L13.14|
                  |L13.8|
000008  4618              MOV      r0,r3
00000a  f7fffffe          BL       dm9k_udelay
                  |L13.14|
00000e  2001              MOVS     r0,#1                 ;630
000010  f7fffffe          BL       ior
000014  0640              LSLS     r0,r0,#25             ;630
000016  d5f7              BPL      |L13.8|
;;;633    	}
;;;634    }
000018  bd00              POP      {pc}
;;;635    
                          ENDP


                          AREA ||i.etherdev_init||, CODE, READONLY, ALIGN=2

                  etherdev_init PROC
;;;591    */
;;;592    void etherdev_init(void)
000000  b510              PUSH     {r4,lr}
;;;593    {
;;;594    	DM9K_CtrlLinesConfig();
000002  f7fffffe          BL       DM9K_CtrlLinesConfig
;;;595    	DM9K_FSMCConfig();
000006  f7fffffe          BL       DM9K_FSMCConfig
;;;596    
;;;597    	s_FSMC_Init_Ok = 1;
00000a  4903              LDR      r1,|L14.24|
00000c  2001              MOVS     r0,#1
00000e  7048              STRB     r0,[r1,#1]
;;;598    
;;;599    	dm9k_initnic();
000010  e8bd4010          POP      {r4,lr}
000014  f7ffbffe          B.W      dm9k_initnic
;;;600    }
;;;601    
                          ENDP

                  |L14.24|
                          DCD      ||.data||

                          AREA ||i.etherdev_poll||, CODE, READONLY, ALIGN=1

                  etherdev_poll PROC
;;;650    */
;;;651    uint16_t etherdev_poll(void)
000000  2000              MOVS     r0,#0
;;;652    {
;;;653    	uint16_t bytes_read = 0;
;;;654    #if 0
;;;655    
;;;656    	/* tick_count threshold should be 12 for 0.5 sec bail-out
;;;657    		One second (24) worked better for me, but socket recycling
;;;658    		is then slower. I set UIP_TIME_WAIT_TIMEOUT 60 in uipopt.h
;;;659    		to counter this. Retransmission timing etc. is affected also. */
;;;660    	while ((!(bytes_read = etherdev_read())) && (timer0_tick() < 12)) continue;
;;;661    
;;;662    	timer0_reset();
;;;663    
;;;664    #endif
;;;665    	return bytes_read;
;;;666    }
000002  4770              BX       lr
;;;667    
                          ENDP


                          AREA ||i.etherdev_read||, CODE, READONLY, ALIGN=1

                  etherdev_read PROC
;;;613    
;;;614    uint16_t etherdev_read(uint8_t *p_char)
000000  f7ffbffe          B.W      dm9k_receive_packet
;;;615    {
;;;616    	return dm9k_receive_packet(p_char);
;;;617    }
;;;618    
                          ENDP


                          AREA ||i.etherdev_send||, CODE, READONLY, ALIGN=1

                  etherdev_send PROC
;;;608    */
;;;609    void etherdev_send(uint8_t *p_char, uint16_t length)
000000  f7ffbffe          B.W      dm9k_send_packet
;;;610    {
;;;611    	dm9k_send_packet(p_char, length);
;;;612    }
;;;613    
                          ENDP


                          AREA ||i.ior||, CODE, READONLY, ALIGN=2

                  ior PROC
;;;95     */
;;;96     uint8_t ior(uint8_t reg)
000000  4902              LDR      r1,|L18.12|
;;;97     {
;;;98     	NET_REG_ADDR = reg;
000002  8008              STRH     r0,[r1,#0]
;;;99     	return (NET_REG_DATA);
000004  8908              LDRH     r0,[r1,#8]
000006  b2c0              UXTB     r0,r0
;;;100    }
000008  4770              BX       lr
;;;101    
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      0x6c100000

                          AREA ||i.iow||, CODE, READONLY, ALIGN=2

                  iow PROC
;;;108    */
;;;109    void iow(uint8_t reg, uint8_t writedata)
000000  4a01              LDR      r2,|L19.8|
;;;110    {
;;;111    	NET_REG_ADDR = reg;
000002  8010              STRH     r0,[r2,#0]
;;;112    	NET_REG_DATA = writedata;
000004  8111              STRH     r1,[r2,#8]
;;;113    }
000006  4770              BX       lr
;;;114    
                          ENDP

                  |L19.8|
                          DCD      0x6c100000

                          AREA ||.data||, DATA, ALIGN=0

                  SendPackOk
000000  00                DCB      0x00
                  s_FSMC_Init_Ok
000001  00                DCB      0x00
                  DEF_MAC_ADDR
000002  0060              DCB      0x00,0x60
000004  6e9000ae          DCB      0x6e,0x90,0x00,0xae

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\uIP\\dm9000\\dm9k_uip.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___10_dm9k_uip_c_75898a95____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___10_dm9k_uip_c_75898a95____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___10_dm9k_uip_c_75898a95____REVSH|
#line 128
|__asm___10_dm9k_uip_c_75898a95____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
