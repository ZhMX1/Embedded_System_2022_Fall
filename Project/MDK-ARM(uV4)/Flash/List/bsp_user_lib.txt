; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\bsp_user_lib.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\bsp_user_lib.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\bsp_user_lib.crf ..\..\User\bsp\src\bsp_user_lib.c]
                          THUMB

                          AREA ||i.AsciiToUint32||, CODE, READONLY, ALIGN=1

                  AsciiToUint32 PROC
;;;434    */
;;;435    uint32_t AsciiToUint32(char *pAscii)
000000  b570              PUSH     {r4-r6,lr}
;;;436    {
;;;437    	char i;
;;;438    	char bTemp;
;;;439    	char bIsHex;
;;;440    	char bLen;
;;;441    	char bZeroLen;
;;;442    	uint32_t lResult;
;;;443    	uint32_t lBitValue;
;;;444    
;;;445    	/* 判断是否是16进制数 */
;;;446    	bIsHex = 0;
;;;447    	if ((pAscii[0] == '0') && ((pAscii[1] == 'x') || (pAscii[1] == 'X')))
000002  7801              LDRB     r1,[r0,#0]
000004  2930              CMP      r1,#0x30
000006  d104              BNE      |L1.18|
000008  7841              LDRB     r1,[r0,#1]
00000a  2978              CMP      r1,#0x78
00000c  d008              BEQ      |L1.32|
00000e  2958              CMP      r1,#0x58
000010  d006              BEQ      |L1.32|
                  |L1.18|
;;;448    	{
;;;449    		bIsHex=1;
;;;450    	}
;;;451    
;;;452    	lResult=0;
000012  2400              MOVS     r4,#0
;;;453    	// 最大数值为 4294967295, 10位+2字符"0x" //
;;;454    	if (bIsHex == 0)
;;;455    	{ // 十进制 //
;;;456    		// 求长度 //
;;;457    		lBitValue=1;
000014  2301              MOVS     r3,#1
;;;458    
;;;459    		/* 前导去0 */
;;;460    		for (i = 0; i < 8; i++)
000016  4621              MOV      r1,r4
                  |L1.24|
;;;461    		{
;;;462    			bTemp = pAscii[i];
000018  5c42              LDRB     r2,[r0,r1]
;;;463    			if (bTemp != '0')
00001a  2a30              CMP      r2,#0x30
00001c  d108              BNE      |L1.48|
00001e  e003              B        |L1.40|
                  |L1.32|
000020  2400              MOVS     r4,#0                 ;452
;;;464    				break;
;;;465    		}
;;;466    		bZeroLen = i;
;;;467    
;;;468    		for (i = 0; i < 10; i++)
;;;469    		{
;;;470    			if ((pAscii[i] < '0') || (pAscii[i] > '9'))
;;;471    				break;
;;;472    			lBitValue = lBitValue * 10;
;;;473    		}
;;;474    		bLen = i;
;;;475    		lBitValue = lBitValue / 10;
;;;476    		if (lBitValue == 0)
;;;477    			lBitValue=1;
;;;478    		for (i = bZeroLen; i < bLen; i++)
;;;479    		{
;;;480    			lResult += (pAscii[i] - '0') * lBitValue;
;;;481    			lBitValue /= 10;
;;;482    		}
;;;483    	}
;;;484    	else
;;;485    	{	/* 16进制 */
;;;486    		/* 求长度 */
;;;487    		lBitValue=1;
000022  2501              MOVS     r5,#1
;;;488    
;;;489    		/* 前导去0 */
;;;490    		for (i = 0; i < 8; i++)
000024  4621              MOV      r1,r4
000026  e020              B        |L1.106|
                  |L1.40|
000028  1c49              ADDS     r1,r1,#1              ;449
00002a  b2c9              UXTB     r1,r1                 ;460
00002c  2908              CMP      r1,#8                 ;460
00002e  d3f3              BCC      |L1.24|
                  |L1.48|
000030  2200              MOVS     r2,#0                 ;468
                  |L1.50|
000032  5c85              LDRB     r5,[r0,r2]            ;470
000034  3d30              SUBS     r5,r5,#0x30           ;470
000036  2d0a              CMP      r5,#0xa               ;470
000038  d206              BCS      |L1.72|
00003a  eb030383          ADD      r3,r3,r3,LSL #2       ;472
00003e  1c52              ADDS     r2,r2,#1              ;472
000040  005b              LSLS     r3,r3,#1              ;472
000042  b2d2              UXTB     r2,r2                 ;468
000044  2a0a              CMP      r2,#0xa               ;468
000046  d3f4              BCC      |L1.50|
                  |L1.72|
000048  250a              MOVS     r5,#0xa               ;475
00004a  fbb3f3f5          UDIV     r3,r3,r5              ;475
00004e  b94b              CBNZ     r3,|L1.100|
000050  2301              MOVS     r3,#1                 ;477
000052  e007              B        |L1.100|
                  |L1.84|
000054  5c46              LDRB     r6,[r0,r1]            ;480
000056  3e30              SUBS     r6,r6,#0x30           ;480
000058  fb064403          MLA      r4,r6,r3,r4           ;480
00005c  fbb3f3f5          UDIV     r3,r3,r5              ;481
000060  1c49              ADDS     r1,r1,#1              ;481
000062  b2c9              UXTB     r1,r1                 ;478
                  |L1.100|
000064  4291              CMP      r1,r2                 ;478
000066  d3f5              BCC      |L1.84|
000068  e039              B        |L1.222|
                  |L1.106|
;;;491    		{
;;;492    			bTemp = pAscii[i + 2];
00006a  1842              ADDS     r2,r0,r1
00006c  7892              LDRB     r2,[r2,#2]
;;;493    			if(bTemp!='0')
00006e  2a30              CMP      r2,#0x30
000070  d103              BNE      |L1.122|
000072  1c49              ADDS     r1,r1,#1
000074  b2c9              UXTB     r1,r1                 ;490
000076  2908              CMP      r1,#8                 ;490
000078  d3f7              BCC      |L1.106|
                  |L1.122|
;;;494    				break;
;;;495    		}
;;;496    		bZeroLen = i;
00007a  460b              MOV      r3,r1
;;;497    		for (; i < 8; i++)
00007c  e00e              B        |L1.156|
                  |L1.126|
;;;498    		{
;;;499    			bTemp=pAscii[i+2];
00007e  1842              ADDS     r2,r0,r1
000080  7892              LDRB     r2,[r2,#2]
;;;500    			if (((bTemp >= 'A') && (bTemp <= 'F')) ||
000082  f1a20641          SUB      r6,r2,#0x41
000086  2e05              CMP      r6,#5
000088  d905              BLS      |L1.150|
;;;501    				((bTemp>='a')&&(bTemp<='f')) ||
00008a  3e20              SUBS     r6,r6,#0x20
00008c  2e05              CMP      r6,#5
00008e  d902              BLS      |L1.150|
000090  3a30              SUBS     r2,r2,#0x30
;;;502    				((bTemp>='0')&&(bTemp<='9')) )
000092  2a09              CMP      r2,#9
000094  d804              BHI      |L1.160|
                  |L1.150|
;;;503    			{
;;;504    				lBitValue=lBitValue * 16;
000096  012d              LSLS     r5,r5,#4
000098  1c49              ADDS     r1,r1,#1
00009a  b2c9              UXTB     r1,r1                 ;497
                  |L1.156|
00009c  2908              CMP      r1,#8                 ;497
00009e  d3ee              BCC      |L1.126|
                  |L1.160|
;;;505    			}
;;;506    			else
;;;507    			{
;;;508    				break;
;;;509    			}
;;;510    		}
;;;511    		lBitValue = lBitValue / 16;
0000a0  092d              LSRS     r5,r5,#4
;;;512    		if (lBitValue == 0)
0000a2  d11a              BNE      |L1.218|
;;;513    			lBitValue = 1;
0000a4  2501              MOVS     r5,#1
0000a6  e018              B        |L1.218|
                  |L1.168|
;;;514    		bLen = i;
;;;515    		for (i = bZeroLen; i < bLen; i++)
;;;516    		{
;;;517    			bTemp = pAscii[i + 2];
0000a8  18c2              ADDS     r2,r0,r3
0000aa  7892              LDRB     r2,[r2,#2]
;;;518    			if ((bTemp >= 'A') && (bTemp <= 'F'))
0000ac  f1a20641          SUB      r6,r2,#0x41
0000b0  2e05              CMP      r6,#5
0000b2  d801              BHI      |L1.184|
0000b4  3a37              SUBS     r2,r2,#0x37
;;;519    			{
;;;520    				bTemp -= 0x37;
0000b6  e004              B        |L1.194|
                  |L1.184|
;;;521    			}
;;;522    			else if ((bTemp >= 'a') && (bTemp <= 'f'))
0000b8  f1a20661          SUB      r6,r2,#0x61
0000bc  2e05              CMP      r6,#5
0000be  d802              BHI      |L1.198|
0000c0  3a57              SUBS     r2,r2,#0x57
                  |L1.194|
;;;523    			{
;;;524    				bTemp -= 0x57;
0000c2  b2d2              UXTB     r2,r2
0000c4  e004              B        |L1.208|
                  |L1.198|
;;;525    			}
;;;526    			else if ((bTemp >= '0') && (bTemp <= '9'))
0000c6  f1a20630          SUB      r6,r2,#0x30
0000ca  2e09              CMP      r6,#9
0000cc  d800              BHI      |L1.208|
;;;527    			{
;;;528    				bTemp -= '0';
0000ce  b2f2              UXTB     r2,r6
                  |L1.208|
;;;529    			}
;;;530    			lResult += bTemp*lBitValue;
0000d0  fb024405          MLA      r4,r2,r5,r4
;;;531    			lBitValue /= 16;
0000d4  092d              LSRS     r5,r5,#4
0000d6  1c5b              ADDS     r3,r3,#1
0000d8  b2db              UXTB     r3,r3                 ;515
                  |L1.218|
0000da  428b              CMP      r3,r1                 ;515
0000dc  d3e4              BCC      |L1.168|
                  |L1.222|
;;;532    		}
;;;533    	}
;;;534    	return lResult;
0000de  4620              MOV      r0,r4
;;;535    }
0000e0  bd70              POP      {r4-r6,pc}
;;;536    
                          ENDP


                          AREA ||i.BEBufToUint16||, CODE, READONLY, ALIGN=1

                  BEBufToUint16 PROC
;;;283    */
;;;284    uint16_t BEBufToUint16(uint8_t *_pBuf)
000000  8800              LDRH     r0,[r0,#0]
;;;285    {
;;;286        return (((uint16_t)_pBuf[0] << 8) | _pBuf[1]);
000002  ba40              REV16    r0,r0
;;;287    }
000004  4770              BX       lr
;;;288    
                          ENDP


                          AREA ||i.BEBufToUint32||, CODE, READONLY, ALIGN=1

                  BEBufToUint32 PROC
;;;309    */
;;;310    uint32_t BEBufToUint32(uint8_t *_pBuf)
000000  6801              LDR      r1,[r0,#0]
;;;311    {
;;;312        return (((uint32_t)_pBuf[0] << 24) | ((uint32_t)_pBuf[1] << 16) | ((uint32_t)_pBuf[2] << 8) | _pBuf[3]);
000002  78c0              LDRB     r0,[r0,#3]
000004  ba09              REV      r1,r1
000006  f02101ff          BIC      r1,r1,#0xff
00000a  4308              ORRS     r0,r0,r1
;;;313    }
00000c  4770              BX       lr
;;;314    
                          ENDP


                          AREA ||i.BcdToChar||, CODE, READONLY, ALIGN=1

                  BcdToChar PROC
;;;380    */
;;;381    char BcdToChar(uint8_t _bcd)
000000  280a              CMP      r0,#0xa
;;;382    {
000002  d201              BCS      |L4.8|
000004  3030              ADDS     r0,r0,#0x30
;;;383    	if (_bcd < 10)
;;;384    	{
;;;385    		return _bcd + '0';
000006  e002              B        |L4.14|
                  |L4.8|
;;;386    	}
;;;387    	else if (_bcd < 16)
000008  2810              CMP      r0,#0x10
00000a  d202              BCS      |L4.18|
00000c  3041              ADDS     r0,r0,#0x41
                  |L4.14|
;;;388    	{
;;;389    		return _bcd + 'A';
00000e  b2c0              UXTB     r0,r0
;;;390    	}
;;;391    	else
;;;392    	{
;;;393    		return 0;
;;;394    	}
;;;395    }
000010  4770              BX       lr
                  |L4.18|
000012  2000              MOVS     r0,#0                 ;393
000014  4770              BX       lr
;;;396    
                          ENDP


                          AREA ||i.CRC16_Modbus||, CODE, READONLY, ALIGN=2

                  CRC16_Modbus PROC
;;;343    */
;;;344    uint16_t CRC16_Modbus(uint8_t *_pBuf, uint16_t _usLen)
000000  b570              PUSH     {r4-r6,lr}
;;;345    {
;;;346    	uint8_t ucCRCHi = 0xFF; /* 高CRC字节初始化 */
;;;347    	uint8_t ucCRCLo = 0xFF; /* 低CRC 字节初始化 */
;;;348    	uint16_t usIndex;  /* CRC循环中的索引 */
;;;349    
;;;350        while (_usLen--)
;;;351        {
;;;352    		usIndex = ucCRCHi ^ *_pBuf++; /* 计算CRC */
;;;353    		ucCRCHi = ucCRCLo ^ s_CRCHi[usIndex];
000002  4d09              LDR      r5,|L5.40|
000004  22ff              MOVS     r2,#0xff              ;346
000006  4613              MOV      r3,r2                 ;347
;;;354    		ucCRCLo = s_CRCLo[usIndex];
000008  f5057680          ADD      r6,r5,#0x100
00000c  e006              B        |L5.28|
00000e  bf00              NOP                            ;352
                  |L5.16|
000010  f8104b01          LDRB     r4,[r0],#1            ;352
000014  4054              EORS     r4,r4,r2              ;352
000016  5d2a              LDRB     r2,[r5,r4]            ;353
000018  405a              EORS     r2,r2,r3              ;353
00001a  5d33              LDRB     r3,[r6,r4]
                  |L5.28|
00001c  1e49              SUBS     r1,r1,#1              ;350
00001e  b289              UXTH     r1,r1                 ;350
000020  d2f6              BCS      |L5.16|
;;;355        }
;;;356        return ((uint16_t)ucCRCHi << 8 | ucCRCLo);
000022  ea432002          ORR      r0,r3,r2,LSL #8
;;;357    }
000026  bd70              POP      {r4-r6,pc}
;;;358    
                          ENDP

                  |L5.40|
                          DCD      ||.constdata||

                          AREA ||i.CaculTwoPoint||, CODE, READONLY, ALIGN=1

                  CaculTwoPoint PROC
;;;367    */
;;;368    int32_t  CaculTwoPoint(int32_t x1, int32_t y1, int32_t x2, int32_t y2, int32_t x)
000000  b570              PUSH     {r4-r6,lr}
;;;369    {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;370    	return y1 + ((int64_t)(y2 - y1) * (x - x1)) / (x2 - x1);
000006  9804              LDR      r0,[sp,#0x10]
000008  1b19              SUBS     r1,r3,r4
00000a  1b40              SUBS     r0,r0,r5
00000c  fb810100          SMULL    r0,r1,r1,r0
000010  1b52              SUBS     r2,r2,r5
000012  17d3              ASRS     r3,r2,#31
000014  f7fffffe          BL       __aeabi_ldivmod
000018  1900              ADDS     r0,r0,r4
;;;371    }
00001a  bd70              POP      {r4-r6,pc}
;;;372    
                          ENDP


                          AREA ||i.HexToAscll||, CODE, READONLY, ALIGN=1

                  HexToAscll PROC
;;;406    */
;;;407    void HexToAscll(uint8_t * _pHex, char *_pAscii, uint16_t _BinBytes)
000000  b5f0              PUSH     {r4-r7,lr}
;;;408    {
000002  4604              MOV      r4,r0
000004  2600              MOVS     r6,#0
000006  b112              CBZ      r2,|L7.14|
;;;409    	uint16_t i;
;;;410    	
;;;411    	if (_BinBytes == 0)
;;;412    	{
;;;413    		_pAscii[0] = 0;
;;;414    	}
;;;415    	else
;;;416    	{
;;;417    		for (i = 0; i < _BinBytes; i++)
000008  2300              MOVS     r3,#0
;;;418    		{
;;;419    			_pAscii[3 * i] = BcdToChar(_pHex[i] >> 4);
;;;420    			_pAscii[3 * i + 1] = BcdToChar(_pHex[i] & 0x0F);
;;;421    			_pAscii[3 * i + 2] = ' ';
00000a  2720              MOVS     r7,#0x20
00000c  e014              B        |L7.56|
                  |L7.14|
00000e  700e              STRB     r6,[r1,#0]            ;413
;;;422    		}
;;;423    		_pAscii[3 * (i - 1) + 2] = 0;
;;;424    	}
;;;425    }
000010  bdf0              POP      {r4-r7,pc}
                  |L7.18|
000012  5ce0              LDRB     r0,[r4,r3]            ;419
000014  0900              LSRS     r0,r0,#4              ;419
000016  f7fffffe          BL       BcdToChar
00001a  eb030543          ADD      r5,r3,r3,LSL #1       ;419
00001e  5548              STRB     r0,[r1,r5]            ;419
000020  5ce0              LDRB     r0,[r4,r3]            ;420
000022  f000000f          AND      r0,r0,#0xf            ;420
000026  f7fffffe          BL       BcdToChar
00002a  4684              MOV      r12,r0                ;420
00002c  1868              ADDS     r0,r5,r1              ;420
00002e  1c5b              ADDS     r3,r3,#1              ;421
000030  f880c001          STRB     r12,[r0,#1]           ;420
000034  7087              STRB     r7,[r0,#2]            ;421
000036  b29b              UXTH     r3,r3                 ;417
                  |L7.56|
000038  4293              CMP      r3,r2                 ;417
00003a  d3ea              BCC      |L7.18|
00003c  eb030043          ADD      r0,r3,r3,LSL #1       ;423
000040  4408              ADD      r0,r0,r1              ;423
000042  f8006c01          STRB     r6,[r0,#-1]           ;423
000046  bdf0              POP      {r4-r7,pc}
;;;426    
                          ENDP


                          AREA ||i.LEBufToUint16||, CODE, READONLY, ALIGN=1

                  LEBufToUint16 PROC
;;;296    */
;;;297    uint16_t LEBufToUint16(uint8_t *_pBuf)
000000  8800              LDRH     r0,[r0,#0]
;;;298    {
;;;299        return (((uint16_t)_pBuf[1] << 8) | _pBuf[0]);
;;;300    }
000002  4770              BX       lr
;;;301    
                          ENDP


                          AREA ||i.LEBufToUint32||, CODE, READONLY, ALIGN=1

                  LEBufToUint32 PROC
;;;322    */
;;;323    uint32_t LEBufToUint32(uint8_t *_pBuf)
000000  7801              LDRB     r1,[r0,#0]
;;;324    {
;;;325        return (((uint32_t)_pBuf[3] << 24) | ((uint32_t)_pBuf[2] << 16) | ((uint32_t)_pBuf[1] << 8) | _pBuf[0]);
000002  f8d00001          LDR      r0,[r0,#1]
000006  ea412000          ORR      r0,r1,r0,LSL #8
;;;326    }
00000a  4770              BX       lr
;;;327    
                          ENDP


                          AREA ||i.int_to_str||, CODE, READONLY, ALIGN=2

                  int_to_str PROC
;;;180    */
;;;181    void int_to_str(int _iNumber, char *_pBuf, unsigned char _len)
000000  b5f0              PUSH     {r4-r7,lr}
;;;182    {
000002  460d              MOV      r5,r1
000004  4616              MOV      r6,r2
000006  0007              MOVS     r7,r0
000008  d501              BPL      |L10.14|
;;;183    	unsigned char i;
;;;184    	int iTemp;
;;;185    
;;;186    	if (_iNumber < 0)	/* 负数 */
;;;187    	{
;;;188    		iTemp = -_iNumber;	/* 转为正数 */
00000a  427c              RSBS     r4,r7,#0
00000c  e000              B        |L10.16|
                  |L10.14|
;;;189    	}
;;;190    	else
;;;191    	{
;;;192    		iTemp = _iNumber;
00000e  4604              MOV      r4,r0
                  |L10.16|
;;;193    	}
;;;194    
;;;195    	mem_set(_pBuf, ' ',_len);
000010  2120              MOVS     r1,#0x20
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       mem_set
;;;196    
;;;197    	/* 将整数转换为ASCII字符串 */
;;;198    	for (i = 0; i < _len; i++)
000018  2000              MOVS     r0,#0
;;;199    	{
;;;200    		_pBuf[_len - 1 - i] = (iTemp % 10) + '0';
00001a  210a              MOVS     r1,#0xa
00001c  e00e              B        |L10.60|
00001e  bf00              NOP      
                  |L10.32|
000020  fb94f2f1          SDIV     r2,r4,r1
000024  fb014212          MLS      r2,r1,r2,r4
;;;201    		iTemp = iTemp / 10;
000028  fb94f4f1          SDIV     r4,r4,r1
00002c  1a33              SUBS     r3,r6,r0              ;200
00002e  442b              ADD      r3,r3,r5              ;200
000030  3230              ADDS     r2,r2,#0x30           ;200
000032  f8032c01          STRB     r2,[r3,#-1]           ;200
;;;202    		if (iTemp == 0)
000036  b11c              CBZ      r4,|L10.64|
000038  1c40              ADDS     r0,r0,#1
00003a  b2c0              UXTB     r0,r0                 ;198
                  |L10.60|
00003c  42b0              CMP      r0,r6                 ;198
00003e  d3ef              BCC      |L10.32|
                  |L10.64|
;;;203    		{
;;;204    			break;
;;;205    		}
;;;206    	}
;;;207    	_pBuf[_len] = 0;
000040  2000              MOVS     r0,#0
000042  55a8              STRB     r0,[r5,r6]
;;;208    
;;;209    	if (_iNumber < 0)	/* 负数 */
000044  2f00              CMP      r7,#0
000046  da09              BGE      |L10.92|
;;;210    	{
;;;211    		for (i = 0; i < _len; i++)
000048  e00b              B        |L10.98|
                  |L10.74|
;;;212    		{
;;;213    			if ((_pBuf[i] == ' ') && (_pBuf[i + 1] != ' '))
00004a  5c29              LDRB     r1,[r5,r0]
00004c  2920              CMP      r1,#0x20
00004e  d106              BNE      |L10.94|
000050  1829              ADDS     r1,r5,r0
000052  7849              LDRB     r1,[r1,#1]
000054  2920              CMP      r1,#0x20
000056  d002              BEQ      |L10.94|
;;;214    			{
;;;215    				_pBuf[i] = '-';
000058  212d              MOVS     r1,#0x2d
00005a  5429              STRB     r1,[r5,r0]
                  |L10.92|
;;;216    				break;
;;;217    			}
;;;218    		}
;;;219    	}
;;;220    }
00005c  bdf0              POP      {r4-r7,pc}
                  |L10.94|
00005e  1c40              ADDS     r0,r0,#1
000060  b2c0              UXTB     r0,r0                 ;211
                  |L10.98|
000062  42b0              CMP      r0,r6                 ;211
000064  d3f1              BCC      |L10.74|
000066  bdf0              POP      {r4-r7,pc}
;;;221    
                          ENDP


                          AREA ||i.mem_cpy||, CODE, READONLY, ALIGN=2

                  mem_cpy PROC
;;;162    */
;;;163    void mem_cpy(char *_tar, char *_src, int _len)
000000  e004              B        |L11.12|
;;;164    {
;;;165    	while (_len--)
;;;166    	{
;;;167    		*_tar++ = *_src++;
000002  bf00              NOP      
                  |L11.4|
000004  f8113b01          LDRB     r3,[r1],#1
000008  f8003b01          STRB     r3,[r0],#1
                  |L11.12|
00000c  1e52              SUBS     r2,r2,#1
00000e  d2f9              BCS      |L11.4|
;;;168    	}
;;;169    }
000010  4770              BX       lr
;;;170    
                          ENDP


                          AREA ||i.mem_set||, CODE, READONLY, ALIGN=2

                  mem_set PROC
;;;144    */
;;;145    void mem_set(char *_tar, char _data, int _len)
000000  e002              B        |L12.8|
;;;146    {
;;;147    	while (_len--)
;;;148    	{
;;;149    		*_tar++ = _data;
000002  bf00              NOP      
                  |L12.4|
000004  f8001b01          STRB     r1,[r0],#1
                  |L12.8|
000008  1e52              SUBS     r2,r2,#1
00000a  d2fb              BCS      |L12.4|
;;;150    	}
;;;151    }
00000c  4770              BX       lr
;;;152    
                          ENDP


                          AREA ||i.str_cmp||, CODE, READONLY, ALIGN=1

                  str_cmp PROC
;;;124    */
;;;125    int str_cmp(char * s1, char * s2)
000000  e001              B        |L13.6|
                  |L13.2|
;;;126    {
;;;127    	while ((*s1!=0) && (*s2!=0) && (*s1==*s2))
;;;128    	{
;;;129    		s1++;
;;;130    		s2++;
000002  1c40              ADDS     r0,r0,#1
000004  1c49              ADDS     r1,r1,#1
                  |L13.6|
000006  7802              LDRB     r2,[r0,#0]            ;127
000008  b11a              CBZ      r2,|L13.18|
00000a  780b              LDRB     r3,[r1,#0]            ;127
00000c  b10b              CBZ      r3,|L13.18|
00000e  429a              CMP      r2,r3                 ;127
000010  d0f7              BEQ      |L13.2|
                  |L13.18|
;;;131    	}
;;;132    	return *s1 - *s2;
000012  7809              LDRB     r1,[r1,#0]
000014  b2d0              UXTB     r0,r2
000016  1a40              SUBS     r0,r0,r1
;;;133    }
000018  4770              BX       lr
;;;134    
                          ENDP


                          AREA ||i.str_cpy||, CODE, READONLY, ALIGN=1

                  str_cpy PROC
                  |L14.0|
;;;106    */
;;;107    void str_cpy(char *_tar, char *_src)
000000  780a              LDRB     r2,[r1,#0]
;;;108    {
;;;109    	do
;;;110    	{
;;;111    		*_tar++ = *_src;
000002  f8002b01          STRB     r2,[r0],#1
;;;112    	}
;;;113    	while (*_src++);
000006  f8112b01          LDRB     r2,[r1],#1
00000a  2a00              CMP      r2,#0
00000c  d1f8              BNE      |L14.0|
;;;114    }
00000e  4770              BX       lr
;;;115    
                          ENDP


                          AREA ||i.str_len||, CODE, READONLY, ALIGN=1

                  str_len PROC
;;;89     */
;;;90     int str_len(char *_str)
000000  4601              MOV      r1,r0
;;;91     {
;;;92     	int len = 0;
000002  2000              MOVS     r0,#0
000004  e000              B        |L15.8|
                  |L15.6|
000006  1c40              ADDS     r0,r0,#1              ;91
                  |L15.8|
;;;93     
;;;94     	while (*_str++) len++;
000008  f8112b01          LDRB     r2,[r1],#1
00000c  2a00              CMP      r2,#0
00000e  d1fa              BNE      |L15.6|
;;;95     	return len;
;;;96     }
000010  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.str_to_int||, CODE, READONLY, ALIGN=1

                  str_to_int PROC
;;;229    */
;;;230    int str_to_int(char *_pStr)
000000  b530              PUSH     {r4,r5,lr}
;;;231    {
;;;232    	unsigned char flag;
;;;233    	char *p;
;;;234    	int ulInt;
;;;235    	unsigned char  i;
;;;236    	unsigned char  ucTemp;
;;;237    
;;;238    	p = _pStr;
;;;239    	if (*p == '-')
000002  7801              LDRB     r1,[r0,#0]
000004  292d              CMP      r1,#0x2d
000006  d006              BEQ      |L16.22|
;;;240    	{
;;;241    		flag = 1;	/* 负数 */
;;;242    		p++;
;;;243    	}
;;;244    	else
;;;245    	{
;;;246    		flag = 0;
000008  2400              MOVS     r4,#0
                  |L16.10|
;;;247    	}
;;;248    
;;;249    	ulInt = 0;
00000a  2200              MOVS     r2,#0
;;;250    	for (i = 0; i < 15; i++)
00000c  4613              MOV      r3,r2
                  |L16.14|
;;;251    	{
;;;252    		ucTemp = *p;
00000e  7801              LDRB     r1,[r0,#0]
;;;253    		if (ucTemp == '.')	/* 遇到小数点，自动跳过1个字节 */
000010  292e              CMP      r1,#0x2e
000012  d003              BEQ      |L16.28|
000014  e004              B        |L16.32|
                  |L16.22|
000016  2401              MOVS     r4,#1                 ;241
000018  1c40              ADDS     r0,r0,#1              ;241
00001a  e7f6              B        |L16.10|
                  |L16.28|
;;;254    		{
;;;255    			p++;
;;;256    			ucTemp = *p;
00001c  f8101f01          LDRB     r1,[r0,#1]!
                  |L16.32|
;;;257    		}
;;;258    		if ((ucTemp >= '0') && (ucTemp <= '9'))
000020  f1a10530          SUB      r5,r1,#0x30
000024  2d09              CMP      r5,#9
000026  d809              BHI      |L16.60|
;;;259    		{
;;;260    			ulInt = ulInt * 10 + (ucTemp - '0');
000028  eb020282          ADD      r2,r2,r2,LSL #2
00002c  eb010242          ADD      r2,r1,r2,LSL #1
000030  1c5b              ADDS     r3,r3,#1
000032  b2db              UXTB     r3,r3                 ;250
000034  1c40              ADDS     r0,r0,#1              ;250
000036  3a30              SUBS     r2,r2,#0x30           ;250
000038  2b0f              CMP      r3,#0xf               ;250
;;;261    			p++;
00003a  d3e8              BCC      |L16.14|
                  |L16.60|
;;;262    		}
;;;263    		else
;;;264    		{
;;;265    			break;
;;;266    		}
;;;267    	}
;;;268    
;;;269    	if (flag == 1)
00003c  b10c              CBZ      r4,|L16.66|
;;;270    	{
;;;271    		return -ulInt;
00003e  4250              RSBS     r0,r2,#0
;;;272    	}
;;;273    	return ulInt;
;;;274    }
000040  bd30              POP      {r4,r5,pc}
                  |L16.66|
000042  4610              MOV      r0,r2                 ;273
000044  bd30              POP      {r4,r5,pc}
;;;275    
                          ENDP


                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  s_CRCHi
000000  00c18140          DCB      0x00,0xc1,0x81,0x40
000004  01c08041          DCB      0x01,0xc0,0x80,0x41
000008  01c08041          DCB      0x01,0xc0,0x80,0x41
00000c  00c18140          DCB      0x00,0xc1,0x81,0x40
000010  01c08041          DCB      0x01,0xc0,0x80,0x41
000014  00c18140          DCB      0x00,0xc1,0x81,0x40
000018  00c18140          DCB      0x00,0xc1,0x81,0x40
00001c  01c08041          DCB      0x01,0xc0,0x80,0x41
000020  01c08041          DCB      0x01,0xc0,0x80,0x41
000024  00c18140          DCB      0x00,0xc1,0x81,0x40
000028  00c18140          DCB      0x00,0xc1,0x81,0x40
00002c  01c08041          DCB      0x01,0xc0,0x80,0x41
000030  00c18140          DCB      0x00,0xc1,0x81,0x40
000034  01c08041          DCB      0x01,0xc0,0x80,0x41
000038  01c08041          DCB      0x01,0xc0,0x80,0x41
00003c  00c18140          DCB      0x00,0xc1,0x81,0x40
000040  01c08041          DCB      0x01,0xc0,0x80,0x41
000044  00c18140          DCB      0x00,0xc1,0x81,0x40
000048  00c18140          DCB      0x00,0xc1,0x81,0x40
00004c  01c08041          DCB      0x01,0xc0,0x80,0x41
000050  00c18140          DCB      0x00,0xc1,0x81,0x40
000054  01c08041          DCB      0x01,0xc0,0x80,0x41
000058  01c08041          DCB      0x01,0xc0,0x80,0x41
00005c  00c18140          DCB      0x00,0xc1,0x81,0x40
000060  00c18140          DCB      0x00,0xc1,0x81,0x40
000064  01c08041          DCB      0x01,0xc0,0x80,0x41
000068  01c08041          DCB      0x01,0xc0,0x80,0x41
00006c  00c18140          DCB      0x00,0xc1,0x81,0x40
000070  01c08041          DCB      0x01,0xc0,0x80,0x41
000074  00c18140          DCB      0x00,0xc1,0x81,0x40
000078  00c18140          DCB      0x00,0xc1,0x81,0x40
00007c  01c08041          DCB      0x01,0xc0,0x80,0x41
000080  01c08041          DCB      0x01,0xc0,0x80,0x41
000084  00c18140          DCB      0x00,0xc1,0x81,0x40
000088  00c18140          DCB      0x00,0xc1,0x81,0x40
00008c  01c08041          DCB      0x01,0xc0,0x80,0x41
000090  00c18140          DCB      0x00,0xc1,0x81,0x40
000094  01c08041          DCB      0x01,0xc0,0x80,0x41
000098  01c08041          DCB      0x01,0xc0,0x80,0x41
00009c  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000a4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000a8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000ac  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000b4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000b8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000bc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000c4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000c8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000cc  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000d4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000d8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000dc  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e0  01c08041          DCB      0x01,0xc0,0x80,0x41
0000e4  00c18140          DCB      0x00,0xc1,0x81,0x40
0000e8  00c18140          DCB      0x00,0xc1,0x81,0x40
0000ec  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f0  00c18140          DCB      0x00,0xc1,0x81,0x40
0000f4  01c08041          DCB      0x01,0xc0,0x80,0x41
0000f8  01c08041          DCB      0x01,0xc0,0x80,0x41
0000fc  00c18140          DCB      0x00,0xc1,0x81,0x40
                  s_CRCLo
000100  00c0c101          DCB      0x00,0xc0,0xc1,0x01
000104  c30302c2          DCB      0xc3,0x03,0x02,0xc2
000108  c60607c7          DCB      0xc6,0x06,0x07,0xc7
00010c  05c5c404          DCB      0x05,0xc5,0xc4,0x04
000110  cc0c0dcd          DCB      0xcc,0x0c,0x0d,0xcd
000114  0fcfce0e          DCB      0x0f,0xcf,0xce,0x0e
000118  0acacb0b          DCB      0x0a,0xca,0xcb,0x0b
00011c  c90908c8          DCB      0xc9,0x09,0x08,0xc8
000120  d81819d9          DCB      0xd8,0x18,0x19,0xd9
000124  1bdbda1a          DCB      0x1b,0xdb,0xda,0x1a
000128  1ededf1f          DCB      0x1e,0xde,0xdf,0x1f
00012c  dd1d1cdc          DCB      0xdd,0x1d,0x1c,0xdc
000130  14d4d515          DCB      0x14,0xd4,0xd5,0x15
000134  d71716d6          DCB      0xd7,0x17,0x16,0xd6
000138  d21213d3          DCB      0xd2,0x12,0x13,0xd3
00013c  11d1d010          DCB      0x11,0xd1,0xd0,0x10
000140  f03031f1          DCB      0xf0,0x30,0x31,0xf1
000144  33f3f232          DCB      0x33,0xf3,0xf2,0x32
000148  36f6f737          DCB      0x36,0xf6,0xf7,0x37
00014c  f53534f4          DCB      0xf5,0x35,0x34,0xf4
000150  3cfcfd3d          DCB      0x3c,0xfc,0xfd,0x3d
000154  ff3f3efe          DCB      0xff,0x3f,0x3e,0xfe
000158  fa3a3bfb          DCB      0xfa,0x3a,0x3b,0xfb
00015c  39f9f838          DCB      0x39,0xf9,0xf8,0x38
000160  28e8e929          DCB      0x28,0xe8,0xe9,0x29
000164  eb2b2aea          DCB      0xeb,0x2b,0x2a,0xea
000168  ee2e2fef          DCB      0xee,0x2e,0x2f,0xef
00016c  2dedec2c          DCB      0x2d,0xed,0xec,0x2c
000170  e42425e5          DCB      0xe4,0x24,0x25,0xe5
000174  27e7e626          DCB      0x27,0xe7,0xe6,0x26
000178  22e2e323          DCB      0x22,0xe2,0xe3,0x23
00017c  e12120e0          DCB      0xe1,0x21,0x20,0xe0
000180  a06061a1          DCB      0xa0,0x60,0x61,0xa1
000184  63a3a262          DCB      0x63,0xa3,0xa2,0x62
000188  66a6a767          DCB      0x66,0xa6,0xa7,0x67
00018c  a56564a4          DCB      0xa5,0x65,0x64,0xa4
000190  6cacad6d          DCB      0x6c,0xac,0xad,0x6d
000194  af6f6eae          DCB      0xaf,0x6f,0x6e,0xae
000198  aa6a6bab          DCB      0xaa,0x6a,0x6b,0xab
00019c  69a9a868          DCB      0x69,0xa9,0xa8,0x68
0001a0  78b8b979          DCB      0x78,0xb8,0xb9,0x79
0001a4  bb7b7aba          DCB      0xbb,0x7b,0x7a,0xba
0001a8  be7e7fbf          DCB      0xbe,0x7e,0x7f,0xbf
0001ac  7dbdbc7c          DCB      0x7d,0xbd,0xbc,0x7c
0001b0  b47475b5          DCB      0xb4,0x74,0x75,0xb5
0001b4  77b7b676          DCB      0x77,0xb7,0xb6,0x76
0001b8  72b2b373          DCB      0x72,0xb2,0xb3,0x73
0001bc  b17170b0          DCB      0xb1,0x71,0x70,0xb0
0001c0  50909151          DCB      0x50,0x90,0x91,0x51
0001c4  93535292          DCB      0x93,0x53,0x52,0x92
0001c8  96565797          DCB      0x96,0x56,0x57,0x97
0001cc  55959454          DCB      0x55,0x95,0x94,0x54
0001d0  9c5c5d9d          DCB      0x9c,0x5c,0x5d,0x9d
0001d4  5f9f9e5e          DCB      0x5f,0x9f,0x9e,0x5e
0001d8  5a9a9b5b          DCB      0x5a,0x9a,0x9b,0x5b
0001dc  99595898          DCB      0x99,0x59,0x58,0x98
0001e0  88484989          DCB      0x88,0x48,0x49,0x89
0001e4  4b8b8a4a          DCB      0x4b,0x8b,0x8a,0x4a
0001e8  4e8e8f4f          DCB      0x4e,0x8e,0x8f,0x4f
0001ec  8d4d4c8c          DCB      0x8d,0x4d,0x4c,0x8c
0001f0  44848545          DCB      0x44,0x84,0x85,0x45
0001f4  87474686          DCB      0x87,0x47,0x46,0x86
0001f8  82424383          DCB      0x82,0x42,0x43,0x83
0001fc  41818040          DCB      0x41,0x81,0x80,0x40

;*** Start embedded assembler ***

#line 1 "..\\..\\User\\bsp\\src\\bsp_user_lib.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_user_lib_c_s_CRCLo____REV16|
#line 114 "..\\..\\Libraries\\CMSIS\\Include\\core_cmInstr.h"
|__asm___14_bsp_user_lib_c_s_CRCLo____REV16| PROC
#line 115

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___14_bsp_user_lib_c_s_CRCLo____REVSH|
#line 128
|__asm___14_bsp_user_lib_c_s_CRCLo____REVSH| PROC
#line 129

 revsh r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
