; generated by Component: ARM Compiler 5.06 update 4 (build 422) Tool: ArmCC [4d3604]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\flash\obj\psock.o --asm_dir=.\Flash\List\ --list_dir=.\Flash\List\ --depend=.\flash\obj\psock.d --cpu=Cortex-M3 --apcs=interwork -O3 --diag_suppress=9931,870 -I..\..\Libraries\CMSIS\Device\ST\STM32F10x\Include -I..\..\Libraries\STM32F10x_StdPeriph_Driver\inc -I..\..\Libraries\STM32_USB-FS-Device_Driver\inc -I..\..\Libraries\CMSIS\Include -I..\..\User\bsp -I..\..\User\bsp\inc -I..\..\User\app\inc -I..\..\User\fonts -I..\..\User\images -I..\..\User\uIP\uip -I..\..\User\uIP\http -I..\..\User\uIP\dm9000 -I..\..\User\FatFS\src -I..\..\User\usb_mass -I..\..\User\CH376\inc -I.\RTE\_Flash -ID:\Keil\ARM\PACK\ARM\CMSIS\5.0.1\CMSIS\Include -ID:\Keil\ARM\PACK\Keil\STM32F1xx_DFP\2.1.0\Device\Include -D__MICROLIB -D__UVISION_VERSION=523 -D_RTE_ -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER -DSTM32F10X_HD --omf_browse=.\flash\obj\psock.crf ..\..\User\uIP\uip\psock.c]
                          THUMB

                          AREA ||i.buf_bufdata||, CODE, READONLY, ALIGN=1

                  buf_bufdata PROC
;;;82     static u8_t
;;;83     buf_bufdata(struct psock_buf *buf, u16_t len,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;84     	    u8_t **dataptr, u16_t *datalen)
;;;85     {
000004  4616              MOV      r6,r2
000006  461d              MOV      r5,r3
;;;86       if(*datalen < buf->left) {
000008  881a              LDRH     r2,[r3,#0]
00000a  4604              MOV      r4,r0                 ;85
00000c  8883              LDRH     r3,[r0,#4]
00000e  2700              MOVS     r7,#0
;;;87         memcpy(buf->ptr, *dataptr, *datalen);
000010  6800              LDR      r0,[r0,#0]
000012  6831              LDR      r1,[r6,#0]            ;86
000014  429a              CMP      r2,r3                 ;86
000016  d211              BCS      |L1.60|
000018  f7fffffe          BL       __aeabi_memcpy
;;;88         buf->ptr += *datalen;
00001c  8829              LDRH     r1,[r5,#0]
00001e  6820              LDR      r0,[r4,#0]
000020  4408              ADD      r0,r0,r1
;;;89         buf->left -= *datalen;
000022  6020              STR      r0,[r4,#0]
000024  88a0              LDRH     r0,[r4,#4]
000026  8829              LDRH     r1,[r5,#0]
000028  1a40              SUBS     r0,r0,r1
00002a  80a0              STRH     r0,[r4,#4]
;;;90         *dataptr += *datalen;
00002c  8829              LDRH     r1,[r5,#0]
00002e  6830              LDR      r0,[r6,#0]
000030  4408              ADD      r0,r0,r1
;;;91         *datalen = 0;
000032  6030              STR      r0,[r6,#0]
000034  802f              STRH     r7,[r5,#0]
;;;92         return BUF_NOT_FULL;
000036  2000              MOVS     r0,#0
                  |L1.56|
;;;93       } else if(*datalen == buf->left) {
;;;94         memcpy(buf->ptr, *dataptr, *datalen);
;;;95         buf->ptr += *datalen;
;;;96         buf->left = 0;
;;;97         *dataptr += *datalen;
;;;98         *datalen = 0;
;;;99         return BUF_FULL;
;;;100      } else {
;;;101        memcpy(buf->ptr, *dataptr, buf->left);
;;;102        buf->ptr += buf->left;
;;;103        *datalen -= buf->left;
;;;104        *dataptr += buf->left;
;;;105        buf->left = 0;
;;;106        return BUF_FULL;
;;;107      }
;;;108    }
000038  e8bd81f0          POP      {r4-r8,pc}
                  |L1.60|
00003c  d10c              BNE      |L1.88|
00003e  f7fffffe          BL       __aeabi_memcpy
000042  8829              LDRH     r1,[r5,#0]            ;95
000044  6820              LDR      r0,[r4,#0]            ;95
000046  4408              ADD      r0,r0,r1              ;95
000048  6020              STR      r0,[r4,#0]            ;96
00004a  80a7              STRH     r7,[r4,#4]            ;96
00004c  8829              LDRH     r1,[r5,#0]            ;97
00004e  6830              LDR      r0,[r6,#0]            ;97
000050  4408              ADD      r0,r0,r1              ;97
000052  6030              STR      r0,[r6,#0]            ;98
000054  802f              STRH     r7,[r5,#0]            ;98
000056  e00e              B        |L1.118|
                  |L1.88|
000058  461a              MOV      r2,r3                 ;99
00005a  f7fffffe          BL       __aeabi_memcpy
00005e  88a0              LDRH     r0,[r4,#4]            ;102
000060  6821              LDR      r1,[r4,#0]            ;102
000062  4401              ADD      r1,r1,r0              ;102
000064  6021              STR      r1,[r4,#0]            ;103
000066  8829              LDRH     r1,[r5,#0]            ;103
000068  1a08              SUBS     r0,r1,r0              ;103
00006a  8028              STRH     r0,[r5,#0]            ;103
00006c  88a1              LDRH     r1,[r4,#4]            ;104
00006e  6830              LDR      r0,[r6,#0]            ;104
000070  4408              ADD      r0,r0,r1              ;104
000072  6030              STR      r0,[r6,#0]            ;105
000074  80a7              STRH     r7,[r4,#4]            ;105
                  |L1.118|
000076  2001              MOVS     r0,#1                 ;106
000078  e7de              B        |L1.56|
;;;109    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.buf_bufto||, CODE, READONLY, ALIGN=1

                  buf_bufto PROC
;;;110    static u8_t
;;;111    buf_bufto(register struct psock_buf *buf, u8_t endmarker,
000000  b530              PUSH     {r4,r5,lr}
;;;112    	  register u8_t **dataptr, register u16_t *datalen)
;;;113    {
;;;114      u8_t c;
;;;115      while(buf->left > 0 && *datalen > 0) {
;;;116        c = *buf->ptr = **dataptr;
;;;117        ++*dataptr;
;;;118        ++buf->ptr;
;;;119        --*datalen;
;;;120        --buf->left;
;;;121    
;;;122        if(c == endmarker) {
;;;123          return BUF_FOUND;
000002  e013              B        |L2.44|
                  |L2.4|
000004  6814              LDR      r4,[r2,#0]            ;116
000006  6805              LDR      r5,[r0,#0]            ;116
000008  7824              LDRB     r4,[r4,#0]            ;116
00000a  702c              STRB     r4,[r5,#0]            ;116
00000c  6815              LDR      r5,[r2,#0]            ;117
00000e  1c6d              ADDS     r5,r5,#1              ;117
000010  6015              STR      r5,[r2,#0]            ;118
000012  6805              LDR      r5,[r0,#0]            ;118
000014  1c6d              ADDS     r5,r5,#1              ;118
000016  6005              STR      r5,[r0,#0]            ;119
000018  881d              LDRH     r5,[r3,#0]            ;119
00001a  1e6d              SUBS     r5,r5,#1              ;119
00001c  801d              STRH     r5,[r3,#0]            ;119
00001e  8885              LDRH     r5,[r0,#4]            ;120
000020  1e6d              SUBS     r5,r5,#1              ;120
000022  8085              STRH     r5,[r0,#4]            ;120
000024  428c              CMP      r4,r1                 ;122
000026  d101              BNE      |L2.44|
000028  2002              MOVS     r0,#2
;;;124        }
;;;125      }
;;;126    
;;;127      if(*datalen == 0) {
;;;128        return BUF_NOT_FOUND;
;;;129      }
;;;130    
;;;131      while(*datalen > 0) {
;;;132        c = **dataptr;
;;;133        --*datalen;
;;;134        ++*dataptr;
;;;135    
;;;136        if(c == endmarker) {
;;;137          return BUF_FOUND | BUF_FULL;
;;;138        }
;;;139      }
;;;140    
;;;141      return BUF_FULL;
;;;142    }
00002a  bd30              POP      {r4,r5,pc}
                  |L2.44|
00002c  8884              LDRH     r4,[r0,#4]            ;115
00002e  b11c              CBZ      r4,|L2.56|
000030  881c              LDRH     r4,[r3,#0]            ;115
000032  2c00              CMP      r4,#0                 ;115
000034  d1e6              BNE      |L2.4|
000036  e001              B        |L2.60|
                  |L2.56|
000038  8818              LDRH     r0,[r3,#0]            ;127
00003a  b908              CBNZ     r0,|L2.64|
                  |L2.60|
00003c  2000              MOVS     r0,#0                 ;128
00003e  bd30              POP      {r4,r5,pc}
                  |L2.64|
000040  6810              LDR      r0,[r2,#0]            ;132
000042  881c              LDRH     r4,[r3,#0]            ;133
000044  7800              LDRB     r0,[r0,#0]            ;132
000046  1e64              SUBS     r4,r4,#1              ;133
000048  801c              STRH     r4,[r3,#0]            ;133
00004a  6814              LDR      r4,[r2,#0]            ;134
00004c  1c64              ADDS     r4,r4,#1              ;134
00004e  6014              STR      r4,[r2,#0]            ;136
000050  4288              CMP      r0,r1                 ;136
000052  d101              BNE      |L2.88|
000054  2003              MOVS     r0,#3                 ;137
000056  bd30              POP      {r4,r5,pc}
                  |L2.88|
000058  8818              LDRH     r0,[r3,#0]            ;131
00005a  2800              CMP      r0,#0                 ;131
00005c  d1f0              BNE      |L2.64|
00005e  2001              MOVS     r0,#1                 ;141
000060  bd30              POP      {r4,r5,pc}
;;;143    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.data_acked||, CODE, READONLY, ALIGN=2

                  data_acked PROC
;;;159    static char
;;;160    data_acked(register struct psock *s)
000000  f8901020          LDRB     r1,[r0,#0x20]
;;;161    {
;;;162      if(s->state == STATE_DATA_SENT && uip_acked()) {
000004  2906              CMP      r1,#6
000006  d11a              BNE      |L3.62|
000008  490e              LDR      r1,|L3.68|
00000a  7809              LDRB     r1,[r1,#0]  ; uip_flags
00000c  07c9              LSLS     r1,r1,#31
00000e  d016              BEQ      |L3.62|
;;;163        if(s->sendlen > uip_mss()) {
000010  4a0d              LDR      r2,|L3.72|
000012  8a01              LDRH     r1,[r0,#0x10]
000014  6813              LDR      r3,[r2,#0]  ; uip_conn
000016  8a5a              LDRH     r2,[r3,#0x12]
000018  4291              CMP      r1,r2
00001a  d906              BLS      |L3.42|
;;;164          s->sendlen -= uip_mss();
00001c  1a89              SUBS     r1,r1,r2
00001e  8201              STRH     r1,[r0,#0x10]
;;;165          s->sendptr += uip_mss();
000020  8a5a              LDRH     r2,[r3,#0x12]
000022  6841              LDR      r1,[r0,#4]
000024  4411              ADD      r1,r1,r2
000026  6041              STR      r1,[r0,#4]
000028  e004              B        |L3.52|
                  |L3.42|
;;;166        } else {
;;;167          s->sendptr += s->sendlen;
00002a  6842              LDR      r2,[r0,#4]
00002c  4411              ADD      r1,r1,r2
;;;168          s->sendlen = 0;
00002e  6041              STR      r1,[r0,#4]
000030  2100              MOVS     r1,#0
000032  8201              STRH     r1,[r0,#0x10]
                  |L3.52|
;;;169        }
;;;170        s->state = STATE_ACKED;
000034  2101              MOVS     r1,#1
000036  f8801020          STRB     r1,[r0,#0x20]
;;;171        return 1;
00003a  4608              MOV      r0,r1
;;;172      }
;;;173      return 0;
;;;174    }
00003c  4770              BX       lr
                  |L3.62|
00003e  2000              MOVS     r0,#0                 ;173
000040  4770              BX       lr
;;;175    /*---------------------------------------------------------------------------*/
                          ENDP

000042  0000              DCW      0x0000
                  |L3.68|
                          DCD      uip_flags
                  |L3.72|
                          DCD      uip_conn

                          AREA ||i.psock_datalen||, CODE, READONLY, ALIGN=1

                  psock_datalen PROC
;;;246    u16_t
;;;247    psock_datalen(struct psock *psock)
000000  8b81              LDRH     r1,[r0,#0x1c]
;;;248    {
;;;249      return psock->bufsize - psock->buf.left;
000002  8b00              LDRH     r0,[r0,#0x18]
000004  1a08              SUBS     r0,r1,r0
000006  b280              UXTH     r0,r0
;;;250    }
000008  4770              BX       lr
;;;251    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.psock_generator_send||, CODE, READONLY, ALIGN=2

                  psock_generator_send PROC
;;;214    /*---------------------------------------------------------------------------*/
;;;215    PT_THREAD(psock_generator_send(register struct psock *s,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;216    			       unsigned short (*generate)(void *), void *arg))
;;;217    {
000004  4604              MOV      r4,r0
;;;218      PT_BEGIN(&s->psockpt);
000006  8840              LDRH     r0,[r0,#2]
000008  460d              MOV      r5,r1                 ;217
00000a  4690              MOV      r8,r2                 ;217
00000c  2600              MOVS     r6,#0
00000e  b110              CBZ      r0,|L5.22|
000010  28ee              CMP      r0,#0xee
000012  d122              BNE      |L5.90|
000014  e010              B        |L5.56|
                  |L5.22|
;;;219    
;;;220      /* Ensure that there is a generator function to call. */
;;;221      if(generate == NULL) {
000016  b31d              CBZ      r5,|L5.96|
;;;222        PT_EXIT(&s->psockpt);
;;;223      }
;;;224    
;;;225      /* Call the generator function to generate the data in the
;;;226         uip_appdata buffer. */
;;;227      s->sendlen = generate(arg);
000018  4610              MOV      r0,r2
00001a  47a8              BLX      r5
00001c  8220              STRH     r0,[r4,#0x10]
;;;228      s->sendptr = uip_appdata;
00001e  4811              LDR      r0,|L5.100|
000020  6800              LDR      r0,[r0,#0]  ; uip_appdata
;;;229    
;;;230      s->state = STATE_NONE;
000022  6060              STR      r0,[r4,#4]
000024  f8846020          STRB     r6,[r4,#0x20]
                  |L5.40|
;;;231      do {
;;;232        /* Call the generator function again if we are called to perform a
;;;233           retransmission. */
;;;234        if(uip_rexmit()) {
000028  480f              LDR      r0,|L5.104|
00002a  7800              LDRB     r0,[r0,#0]  ; uip_flags
00002c  0740              LSLS     r0,r0,#29
00002e  d501              BPL      |L5.52|
;;;235          generate(arg);
000030  4640              MOV      r0,r8
000032  47a8              BLX      r5
                  |L5.52|
;;;236        }
;;;237        /* Wait until all data is sent and acknowledged. */
;;;238        PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
000034  20ee              MOVS     r0,#0xee
000036  8060              STRH     r0,[r4,#2]
                  |L5.56|
000038  4620              MOV      r0,r4
00003a  f7fffffe          BL       data_acked
00003e  4607              MOV      r7,r0
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       send_data
000046  4207              TST      r7,r0
000048  d102              BNE      |L5.80|
00004a  2000              MOVS     r0,#0
                  |L5.76|
;;;239      } while(s->sendlen > 0);
;;;240    
;;;241      s->state = STATE_NONE;
;;;242    
;;;243      PT_END(&s->psockpt);
;;;244    }
00004c  e8bd81f0          POP      {r4-r8,pc}
                  |L5.80|
000050  8a20              LDRH     r0,[r4,#0x10]         ;239
000052  2800              CMP      r0,#0                 ;239
000054  d1e8              BNE      |L5.40|
000056  f8846020          STRB     r6,[r4,#0x20]         ;241
                  |L5.90|
00005a  8066              STRH     r6,[r4,#2]            ;243
00005c  2002              MOVS     r0,#2                 ;243
00005e  e7f5              B        |L5.76|
                  |L5.96|
000060  2001              MOVS     r0,#1                 ;222
000062  e7f3              B        |L5.76|
;;;245    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L5.100|
                          DCD      uip_appdata
                  |L5.104|
                          DCD      uip_flags

                          AREA ||i.psock_init||, CODE, READONLY, ALIGN=1

                  psock_init PROC
;;;327    void
;;;328    psock_init(register struct psock *psock, char *buffer, unsigned int buffersize)
000000  b510              PUSH     {r4,lr}
;;;329    {
;;;330      psock->state = STATE_NONE;
000002  2400              MOVS     r4,#0
000004  f8804020          STRB     r4,[r0,#0x20]
;;;331      psock->readlen = 0;
000008  8244              STRH     r4,[r0,#0x12]
00000a  60c1              STR      r1,[r0,#0xc]
00000c  61c2              STR      r2,[r0,#0x1c]
00000e  6141              STR      r1,[r0,#0x14]
000010  8302              STRH     r2,[r0,#0x18]
;;;332      psock->bufptr = buffer;
;;;333      psock->bufsize = buffersize;
;;;334      buf_setup(&psock->buf, buffer, buffersize);
;;;335      PT_INIT(&psock->pt);
000012  8004              STRH     r4,[r0,#0]
;;;336      PT_INIT(&psock->psockpt);
000014  8044              STRH     r4,[r0,#2]
;;;337    }
000016  bd10              POP      {r4,pc}
;;;338    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.psock_newdata||, CODE, READONLY, ALIGN=2

                  psock_newdata PROC
;;;252    char
;;;253    psock_newdata(struct psock *s)
000000  8a41              LDRH     r1,[r0,#0x12]
;;;254    {
000002  b939              CBNZ     r1,|L7.20|
;;;255      if(s->readlen > 0) {
;;;256        /* There is data in the uip_appdata buffer that has not yet been
;;;257           read with the PSOCK_READ functions. */
;;;258        return 1;
;;;259      } else if(s->state == STATE_READ) {
000004  f8901020          LDRB     r1,[r0,#0x20]
000008  2902              CMP      r1,#2
00000a  d005              BEQ      |L7.24|
;;;260        /* All data in uip_appdata buffer already consumed. */
;;;261        s->state = STATE_BLOCKED_NEWDATA;
;;;262        return 0;
;;;263      } else if(uip_newdata()) {
00000c  4805              LDR      r0,|L7.36|
00000e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000010  0780              LSLS     r0,r0,#30
000012  d504              BPL      |L7.30|
                  |L7.20|
;;;264        /* There is new data that has not been consumed. */
;;;265        return 1;
000014  2001              MOVS     r0,#1
;;;266      } else {
;;;267        /* There is no new data. */
;;;268        return 0;
;;;269      }
;;;270    }
000016  4770              BX       lr
                  |L7.24|
000018  2103              MOVS     r1,#3                 ;261
00001a  f8801020          STRB     r1,[r0,#0x20]         ;261
                  |L7.30|
00001e  2000              MOVS     r0,#0                 ;268
000020  4770              BX       lr
;;;271    /*---------------------------------------------------------------------------*/
                          ENDP

000022  0000              DCW      0x0000
                  |L7.36|
                          DCD      uip_flags

                          AREA ||i.psock_readbuf||, CODE, READONLY, ALIGN=2

                  psock_readbuf PROC
;;;298    /*---------------------------------------------------------------------------*/
;;;299    PT_THREAD(psock_readbuf(register struct psock *psock))
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;300    {
000004  4604              MOV      r4,r0
;;;301      PT_BEGIN(&psock->psockpt);
000006  8840              LDRH     r0,[r0,#2]
000008  2600              MOVS     r6,#0
00000a  f44f779b          MOV      r7,#0x136
;;;302    
;;;303      buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
00000e  f1040514          ADD      r5,r4,#0x14
000012  b110              CBZ      r0,|L8.26|
000014  42b8              CMP      r0,r7                 ;301
000016  d129              BNE      |L8.108|
000018  e006              B        |L8.40|
                  |L8.26|
00001a  8ba0              LDRH     r0,[r4,#0x1c]
00001c  68e1              LDR      r1,[r4,#0xc]
00001e  6029              STR      r1,[r5,#0]
000020  80a8              STRH     r0,[r5,#4]
                  |L8.34|
;;;304    
;;;305      /* XXX: Should add buf_checkmarker() before do{} loop, if
;;;306         incoming data has been handled while waiting for a write. */
;;;307    
;;;308      do {
;;;309        if(psock->readlen == 0) {
000022  8a60              LDRH     r0,[r4,#0x12]
000024  b988              CBNZ     r0,|L8.74|
;;;310          PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
000026  8067              STRH     r7,[r4,#2]
                  |L8.40|
000028  4620              MOV      r0,r4
00002a  f7fffffe          BL       psock_newdata
00002e  2800              CMP      r0,#0
000030  d01e              BEQ      |L8.112|
;;;311          printf("Waited for newdata\n");
000032  a013              ADR      r0,|L8.128|
000034  f7fffffe          BL       __2printf
;;;312          psock->state = STATE_READ;
000038  2002              MOVS     r0,#2
00003a  f8840020          STRB     r0,[r4,#0x20]
;;;313          psock->readptr = (u8_t *)uip_appdata;
00003e  4815              LDR      r0,|L8.148|
000040  6800              LDR      r0,[r0,#0]  ; uip_appdata
;;;314          psock->readlen = uip_datalen();
000042  60a0              STR      r0,[r4,#8]
000044  4814              LDR      r0,|L8.152|
000046  8800              LDRH     r0,[r0,#0]  ; uip_len
000048  8260              STRH     r0,[r4,#0x12]
                  |L8.74|
;;;315        }
;;;316      } while(buf_bufdata(&psock->buf, psock->bufsize,
00004a  8ba0              LDRH     r0,[r4,#0x1c]
00004c  f1040312          ADD      r3,r4,#0x12
000050  b281              UXTH     r1,r0
000052  f1040208          ADD      r2,r4,#8
000056  4628              MOV      r0,r5
000058  f7fffffe          BL       buf_bufdata
00005c  2801              CMP      r0,#1
00005e  d1e0              BNE      |L8.34|
;;;317    			 &psock->readptr,
;;;318    			 &psock->readlen) != BUF_FULL);
;;;319    
;;;320      if(psock_datalen(psock) == 0) {
000060  8ba0              LDRH     r0,[r4,#0x1c]
000062  8b21              LDRH     r1,[r4,#0x18]
000064  1a40              SUBS     r0,r0,r1
000066  0400              LSLS     r0,r0,#16
000068  0c00              LSRS     r0,r0,#16
00006a  d003              BEQ      |L8.116|
                  |L8.108|
;;;321        psock->state = STATE_NONE;
;;;322        PT_RESTART(&psock->psockpt);
;;;323      }
;;;324      PT_END(&psock->psockpt);
00006c  8066              STRH     r6,[r4,#2]
00006e  2002              MOVS     r0,#2
                  |L8.112|
;;;325    }
000070  e8bd81f0          POP      {r4-r8,pc}
                  |L8.116|
000074  f8846020          STRB     r6,[r4,#0x20]         ;321
000078  8066              STRH     r6,[r4,#2]            ;322
00007a  2000              MOVS     r0,#0                 ;322
00007c  e7f8              B        |L8.112|
;;;326    /*---------------------------------------------------------------------------*/
                          ENDP

00007e  0000              DCW      0x0000
                  |L8.128|
000080  57616974          DCB      "Waited for newdata\n",0
000084  65642066
000088  6f72206e
00008c  65776461
000090  74610a00
                  |L8.148|
                          DCD      uip_appdata
                  |L8.152|
                          DCD      uip_len

                          AREA ||i.psock_readto||, CODE, READONLY, ALIGN=2

                  psock_readto PROC
;;;271    /*---------------------------------------------------------------------------*/
;;;272    PT_THREAD(psock_readto(register struct psock *psock, unsigned char c))
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;273    {
000004  4604              MOV      r4,r0
;;;274      PT_BEGIN(&psock->psockpt);
000006  8840              LDRH     r0,[r0,#2]
000008  460f              MOV      r7,r1                 ;273
00000a  2600              MOVS     r6,#0
;;;275    
;;;276      buf_setup(&psock->buf, psock->bufptr, psock->bufsize);
00000c  f1040514          ADD      r5,r4,#0x14
000010  b120              CBZ      r0,|L9.28|
000012  f5a07080          SUB      r0,r0,#0x100          ;273
000016  381b              SUBS     r0,r0,#0x1b           ;273
000018  d127              BNE      |L9.106|
00001a  e008              B        |L9.46|
                  |L9.28|
00001c  8ba0              LDRH     r0,[r4,#0x1c]
00001e  68e1              LDR      r1,[r4,#0xc]
000020  6029              STR      r1,[r5,#0]
000022  80a8              STRH     r0,[r5,#4]
                  |L9.36|
;;;277    
;;;278      /* XXX: Should add buf_checkmarker() before do{} loop, if
;;;279         incoming data has been handled while waiting for a write. */
;;;280    
;;;281      do {
;;;282        if(psock->readlen == 0) {
000024  8a60              LDRH     r0,[r4,#0x12]
000026  b980              CBNZ     r0,|L9.74|
;;;283          PT_WAIT_UNTIL(&psock->psockpt, psock_newdata(psock));
000028  f240101b          MOV      r0,#0x11b
00002c  8060              STRH     r0,[r4,#2]
                  |L9.46|
00002e  4620              MOV      r0,r4
000030  f7fffffe          BL       psock_newdata
000034  2800              CMP      r0,#0
000036  d01a              BEQ      |L9.110|
;;;284          psock->state = STATE_READ;
000038  2002              MOVS     r0,#2
00003a  f8840020          STRB     r0,[r4,#0x20]
;;;285          psock->readptr = (u8_t *)uip_appdata;
00003e  480f              LDR      r0,|L9.124|
000040  6800              LDR      r0,[r0,#0]  ; uip_appdata
;;;286          psock->readlen = uip_datalen();
000042  60a0              STR      r0,[r4,#8]
000044  480e              LDR      r0,|L9.128|
000046  8800              LDRH     r0,[r0,#0]  ; uip_len
000048  8260              STRH     r0,[r4,#0x12]
                  |L9.74|
;;;287        }
;;;288      } while((buf_bufto(&psock->buf, c,
00004a  f1040312          ADD      r3,r4,#0x12
00004e  f1040208          ADD      r2,r4,#8
000052  4639              MOV      r1,r7
000054  4628              MOV      r0,r5
000056  f7fffffe          BL       buf_bufto
00005a  0780              LSLS     r0,r0,#30
00005c  d5e2              BPL      |L9.36|
;;;289    		     &psock->readptr,
;;;290    		     &psock->readlen) & BUF_FOUND) == 0);
;;;291    
;;;292      if(psock_datalen(psock) == 0) {
00005e  8ba0              LDRH     r0,[r4,#0x1c]
000060  8b21              LDRH     r1,[r4,#0x18]
000062  1a40              SUBS     r0,r0,r1
000064  0400              LSLS     r0,r0,#16
000066  0c00              LSRS     r0,r0,#16
000068  d003              BEQ      |L9.114|
                  |L9.106|
;;;293        psock->state = STATE_NONE;
;;;294        PT_RESTART(&psock->psockpt);
;;;295      }
;;;296      PT_END(&psock->psockpt);
00006a  8066              STRH     r6,[r4,#2]
00006c  2002              MOVS     r0,#2
                  |L9.110|
;;;297    }
00006e  e8bd81f0          POP      {r4-r8,pc}
                  |L9.114|
000072  f8846020          STRB     r6,[r4,#0x20]         ;293
000076  8066              STRH     r6,[r4,#2]            ;294
000078  2000              MOVS     r0,#0                 ;294
00007a  e7f8              B        |L9.110|
;;;298    /*---------------------------------------------------------------------------*/
                          ENDP

                  |L9.124|
                          DCD      uip_appdata
                  |L9.128|
                          DCD      uip_len

                          AREA ||i.psock_send||, CODE, READONLY, ALIGN=1

                  psock_send PROC
;;;175    /*---------------------------------------------------------------------------*/
;;;176    PT_THREAD(psock_send(register struct psock *s, const char *buf,
000000  b570              PUSH     {r4-r6,lr}
;;;177    		     unsigned int len))
;;;178    {
000002  4604              MOV      r4,r0
;;;179      PT_BEGIN(&s->psockpt);
000004  8840              LDRH     r0,[r0,#2]
000006  2500              MOVS     r5,#0
000008  b110              CBZ      r0,|L10.16|
00000a  28cf              CMP      r0,#0xcf
00000c  d11a              BNE      |L10.68|
00000e  e009              B        |L10.36|
                  |L10.16|
;;;180    
;;;181      /* If there is no data to send, we exit immediately. */
;;;182      if(len == 0) {
000010  b122              CBZ      r2,|L10.28|
;;;183        PT_EXIT(&s->psockpt);
;;;184      }
;;;185    
;;;186      /* Save the length of and a pointer to the data that is to be
;;;187         sent. */
;;;188      s->sendptr = buf;
;;;189      s->sendlen = len;
000012  6061              STR      r1,[r4,#4]
000014  8222              STRH     r2,[r4,#0x10]
;;;190    
;;;191      s->state = STATE_NONE;
000016  f8845020          STRB     r5,[r4,#0x20]
;;;192    
;;;193      /* We loop here until all data is sent. The s->sendlen variable is
;;;194         updated by the data_sent() function. */
;;;195      while(s->sendlen > 0) {
00001a  e00e              B        |L10.58|
                  |L10.28|
00001c  2001              MOVS     r0,#1                 ;183
;;;196    
;;;197        /*
;;;198         * The condition for this PT_WAIT_UNTIL is a little tricky: the
;;;199         * protothread will wait here until all data has been acknowledged
;;;200         * (data_acked() returns true) and until all data has been sent
;;;201         * (send_data() returns true). The two functions data_acked() and
;;;202         * send_data() must be called in succession to ensure that all
;;;203         * data is sent. Therefore the & operator is used instead of the
;;;204         * && operator, which would cause only the data_acked() function
;;;205         * to be called when it returns false.
;;;206         */
;;;207        PT_WAIT_UNTIL(&s->psockpt, data_acked(s) & send_data(s));
;;;208      }
;;;209    
;;;210      s->state = STATE_NONE;
;;;211    
;;;212      PT_END(&s->psockpt);
;;;213    }
00001e  bd70              POP      {r4-r6,pc}
                  |L10.32|
000020  20cf              MOVS     r0,#0xcf              ;207
000022  8060              STRH     r0,[r4,#2]            ;207
                  |L10.36|
000024  4620              MOV      r0,r4                 ;207
000026  f7fffffe          BL       data_acked
00002a  4606              MOV      r6,r0                 ;207
00002c  4620              MOV      r0,r4                 ;207
00002e  f7fffffe          BL       send_data
000032  4206              TST      r6,r0                 ;207
000034  d101              BNE      |L10.58|
000036  2000              MOVS     r0,#0                 ;207
000038  bd70              POP      {r4-r6,pc}
                  |L10.58|
00003a  8a20              LDRH     r0,[r4,#0x10]         ;195
00003c  2800              CMP      r0,#0                 ;195
00003e  d1ef              BNE      |L10.32|
000040  f8845020          STRB     r5,[r4,#0x20]         ;210
                  |L10.68|
000044  8065              STRH     r5,[r4,#2]            ;212
000046  2002              MOVS     r0,#2                 ;212
000048  bd70              POP      {r4-r6,pc}
;;;214    /*---------------------------------------------------------------------------*/
                          ENDP


                          AREA ||i.send_data||, CODE, READONLY, ALIGN=2

                  send_data PROC
;;;144    static char
;;;145    send_data(register struct psock *s)
000000  b510              PUSH     {r4,lr}
;;;146    {
000002  4604              MOV      r4,r0
;;;147      if(s->state != STATE_DATA_SENT || uip_rexmit()) {
000004  f8900020          LDRB     r0,[r0,#0x20]
000008  2806              CMP      r0,#6
00000a  d103              BNE      |L11.20|
00000c  480a              LDR      r0,|L11.56|
00000e  7800              LDRB     r0,[r0,#0]  ; uip_flags
000010  0740              LSLS     r0,r0,#29
000012  d50e              BPL      |L11.50|
                  |L11.20|
;;;148        if(s->sendlen > uip_mss()) {
000014  4809              LDR      r0,|L11.60|
000016  8a22              LDRH     r2,[r4,#0x10]
000018  6800              LDR      r0,[r0,#0]  ; uip_conn
00001a  8a41              LDRH     r1,[r0,#0x12]
00001c  6860              LDR      r0,[r4,#4]
00001e  428a              CMP      r2,r1
000020  d800              BHI      |L11.36|
000022  4611              MOV      r1,r2
                  |L11.36|
;;;149          uip_send(s->sendptr, uip_mss());
;;;150        } else {
;;;151          uip_send(s->sendptr, s->sendlen);
000024  f7fffffe          BL       uip_send
;;;152        }
;;;153        s->state = STATE_DATA_SENT;
000028  2006              MOVS     r0,#6
00002a  f8840020          STRB     r0,[r4,#0x20]
;;;154        return 1;
00002e  2001              MOVS     r0,#1
;;;155      }
;;;156      return 0;
;;;157    }
000030  bd10              POP      {r4,pc}
                  |L11.50|
000032  2000              MOVS     r0,#0                 ;156
000034  bd10              POP      {r4,pc}
;;;158    /*---------------------------------------------------------------------------*/
                          ENDP

000036  0000              DCW      0x0000
                  |L11.56|
                          DCD      uip_flags
                  |L11.60|
                          DCD      uip_conn
